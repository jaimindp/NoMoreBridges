"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenFactory = void 0;
const networks_1 = require("@injectivelabs/networks");
const exceptions_1 = require("@injectivelabs/exceptions");
const utils_1 = require("@injectivelabs/utils");
const TokenMetaUtils_1 = require("./TokenMetaUtils");
const network_1 = require("./tokens/network");
const tokens_1 = __importDefault(require("./tokens/tokens"));
const token_1 = require("./utils/token");
const helpers_1 = require("./utils/helpers");
class TokenFactory {
    constructor(tokenMetaUtils) {
        this.tokenMetaUtils = tokenMetaUtils;
    }
    static make(network = networks_1.Network.Mainnet, registry = {}) {
        if ((0, networks_1.isTestnet)(network)) {
            return new TokenFactory(new TokenMetaUtils_1.TokenMetaUtils(Object.assign(Object.assign({}, (0, network_1.getTokensBySymbolForTestnet)()), registry)));
        }
        if (network === networks_1.Network.Devnet) {
            return new TokenFactory(new TokenMetaUtils_1.TokenMetaUtils(Object.assign(Object.assign({}, (0, network_1.getTokensBySymbolForDevnet)()), registry)));
        }
        if (network === networks_1.Network.Devnet1) {
            return new TokenFactory(new TokenMetaUtils_1.TokenMetaUtils(Object.assign(Object.assign({}, (0, network_1.getTokensBySymbolForDevnet1)()), registry)));
        }
        if (network === networks_1.Network.Devnet2) {
            return new TokenFactory(new TokenMetaUtils_1.TokenMetaUtils(Object.assign(Object.assign({}, (0, network_1.getTokensBySymbolForDevnet2)()), registry)));
        }
        return new TokenFactory(new TokenMetaUtils_1.TokenMetaUtils(Object.assign(Object.assign({}, tokens_1.default), registry)));
    }
    toToken(denom) {
        const isDenom = denom.startsWith('ibc/') ||
            denom.startsWith('peggy') ||
            denom.startsWith('factory/');
        if (denom === utils_1.INJ_DENOM) {
            return (0, token_1.getTokenFromMeta)(this.tokenMetaUtils.getMetaBySymbol(denom), denom);
        }
        try {
            if (!isDenom) {
                const bySymbol = this.tokenMetaUtils.getMetaBySymbol(denom);
                if (bySymbol) {
                    return (0, token_1.getTokenFromMetaIncludingIbcBaseDenoms)(bySymbol, denom);
                }
                const byAddress = this.tokenMetaUtils.getMetaByAddress(denom);
                if (byAddress) {
                    return (0, token_1.getTokenFromMeta)(byAddress, denom);
                }
                return;
            }
            if (denom.startsWith('ibc/')) {
                const meta = this.getIbcDenomTokenMeta(denom);
                return meta ? (0, token_1.getTokenFromMeta)(meta, denom) : undefined;
            }
            if (denom.startsWith('factory/')) {
                const meta = this.getFactoryDenomTokenMeta(denom);
                return meta ? (0, token_1.getTokenFromMeta)(meta, denom) : undefined;
            }
            if (denom.startsWith('peggy')) {
                const meta = this.getPeggyDenomTokenMeta(denom);
                return meta ? (0, token_1.getTokenFromMeta)(meta, denom) : undefined;
            }
            const meta = this.getCw20DenomTokenMeta(denom);
            return meta ? (0, token_1.getTokenFromMeta)(meta, denom) : undefined;
        }
        catch (e) {
            return undefined;
        }
    }
    getPeggyDenomTokenMeta(denom) {
        const address = denom.startsWith('peggy')
            ? denom.replace('peggy', '')
            : denom;
        if (!address.startsWith('0x')) {
            throw new exceptions_1.GeneralException(new Error(`The address ${address} is not a valid ERC20 address`));
        }
        if (address.length !== 42) {
            throw new exceptions_1.GeneralException(new Error(`The address ${address} is not a valid ERC20 address`));
        }
        return this.tokenMetaUtils.getMetaByAddress(address);
    }
    getCw20DenomTokenMeta(address) {
        if (!(0, helpers_1.isCw20ContractAddress)(address)) {
            throw new exceptions_1.GeneralException(new Error(`The address ${address} is not a valid CW20 address`));
        }
        return this.tokenMetaUtils.getMetaByAddress(address);
    }
    getIbcDenomTokenMeta(hash) {
        return this.tokenMetaUtils.getMetaByHash(hash);
    }
    getFactoryDenomTokenMeta(denom) {
        const [address] = denom.split('/').reverse();
        if (!address) {
            throw new exceptions_1.GeneralException(new Error(`The address ${address} is not a valid CW20 address`));
        }
        return (0, helpers_1.isCw20ContractAddress)(address)
            ? this.tokenMetaUtils.getMetaByAddress(address)
            : this.tokenMetaUtils.getMetaByFactory(denom);
    }
}
exports.TokenFactory = TokenFactory;
//# sourceMappingURL=TokenFactory.js.map