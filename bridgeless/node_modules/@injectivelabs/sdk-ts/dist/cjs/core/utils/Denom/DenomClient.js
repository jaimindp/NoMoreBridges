"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DenomClient = void 0;
const token_metadata_1 = require("@injectivelabs/token-metadata");
const exceptions_1 = require("@injectivelabs/exceptions");
const utf8_1 = require("../../../utils/utf8");
const crypto_1 = require("../../../utils/crypto");
const networks_1 = require("@injectivelabs/networks");
const ChainGrpcIbcApi_1 = require("../../../client/chain/grpc/ChainGrpcIbcApi");
/**
 * This client can be used to fetch token
 * denoms including API calls as well
 *
 * Special Case:
 * If IBC denom is not within the hardcoded
 * IBC hashes we should query the denom traces API
 * to find the token meta for the denom
 *
 * @category Utility Classes
 */
class DenomClient {
    constructor(network = networks_1.Network.Mainnet, options) {
        this.cachedDenomTraces = {};
        this.tokenFactory = token_metadata_1.TokenFactory.make(network);
        this.tokenMetaUtils = token_metadata_1.TokenMetaUtilsFactory.make(network);
        this.ibcApi = new ChainGrpcIbcApi_1.ChainGrpcIbcApi(options && options.endpoints
            ? options.endpoints.grpc
            : (0, networks_1.getNetworkEndpoints)(network).grpc);
    }
    getDenomTokenInfo(denom) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = this.tokenFactory.toTokenInfo(denom);
            if (token) {
                return token;
            }
            if (denom.startsWith('ibc')) {
                const token = yield this.getIbcDenomToken(denom);
                return token ? token_metadata_1.TokenInfo.fromToken(token) : undefined;
            }
            return;
        });
    }
    getDenomToken(denom) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = this.tokenFactory.toToken(denom);
            if (token) {
                return token;
            }
            if (denom.startsWith('ibc')) {
                return yield this.getIbcDenomToken(denom);
            }
            return;
        });
    }
    getTokenMetaDataBySymbol(symbol) {
        return this.tokenMetaUtils.getMetaBySymbol(symbol);
    }
    getTokenMetaDataByAddress(address) {
        return this.tokenMetaUtils.getMetaByAddress(address);
    }
    getTokenMetaDataByName(name) {
        return this.tokenMetaUtils.getMetaByName(name);
    }
    getCoinGeckoId(denom) {
        return this.tokenMetaUtils.getCoinGeckoIdFromSymbol(denom);
    }
    /**
     * Find token based on the hash and the base denom
     * from the denom trace of the particular hash
     */
    getIbcDenomToken(denom) {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = denom.replace('ibc/', '');
            if (Object.keys(this.cachedDenomTraces).length === 0) {
                yield this.fetchAndCacheDenomTraces();
            }
            const cachedDenomTrace = this.cachedDenomTraces[hash];
            if (cachedDenomTrace) {
                const token = this.tokenFactory.toToken(cachedDenomTrace.baseDenom);
                if (!token) {
                    return undefined;
                }
                return Object.assign(Object.assign({}, token), { ibc: (0, token_metadata_1.getIbcTokenMetaFromDenomTrace)(Object.assign(Object.assign({}, cachedDenomTrace), { decimals: token.decimals, hash })), denom });
            }
            try {
                const denomTrace = yield this.ibcApi.fetchDenomTrace(hash);
                const token = this.tokenFactory.toToken(denomTrace.baseDenom);
                if (!token) {
                    return undefined;
                }
                return Object.assign(Object.assign({}, token), { ibc: (0, token_metadata_1.getIbcTokenMetaFromDenomTrace)(Object.assign(Object.assign({}, denomTrace), { decimals: token.decimals, hash })), denom });
            }
            catch (e) {
                throw new exceptions_1.GeneralException(new Error(`Denom trace not found for ${denom}`), {
                    type: exceptions_1.ErrorType.NotFoundError,
                });
            }
        });
    }
    fetchAndCacheDenomTraces() {
        return __awaiter(this, void 0, void 0, function* () {
            const denomTraces = yield this.ibcApi.fetchDenomsTrace();
            const denomHashes = denomTraces.map((trace) => {
                return {
                    trace: trace,
                    hash: Buffer.from((0, crypto_1.sha256)((0, utf8_1.fromUtf8)(`${trace.path}/${trace.baseDenom}`))).toString('hex'),
                };
            });
            this.cachedDenomTraces = denomHashes.reduce((denomTraces, denomTrace) => (Object.assign(Object.assign({}, denomTraces), { [denomTrace.hash.toUpperCase()]: denomTrace.trace })), {});
        });
    }
}
exports.DenomClient = DenomClient;
//# sourceMappingURL=DenomClient.js.map