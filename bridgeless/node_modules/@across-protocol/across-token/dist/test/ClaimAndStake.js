"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const AcceleratingDistributor_Fixture_1 = require("./AcceleratingDistributor.Fixture");
const common_1 = require("@uma/common");
const merkle_distributor_1 = require("@uma/merkle-distributor");
const constants_1 = require("./constants");
let acrossToken, distributor, lpToken1, claimer;
let merkleDistributor, contractCreator, lpToken2, claimAndStake;
const createLeaf = (recipient) => {
    (0, utils_1.expect)(Object.keys(recipient).every((val) => ["account", "amount", "accountIndex"].includes(val))).to.be.true;
    return Buffer.from(utils_1.ethers.utils
        .solidityKeccak256(["address", "uint256", "uint256"], [recipient.account, recipient.amount, recipient.accountIndex])
        .slice(2), "hex");
};
const window1RewardAmount = (0, utils_1.toBN)((0, utils_1.toWei)("100"));
const window2RewardAmount = (0, utils_1.toBN)((0, utils_1.toWei)("300"));
const totalBatchRewards = window1RewardAmount.add(window2RewardAmount);
let batchedClaims;
describe("ClaimAndStake: Atomic Claim and Stake", async function () {
    beforeEach(async function () {
        [contractCreator, claimer] = await utils_1.ethers.getSigners();
        ({ distributor, acrossToken, lpToken1, lpToken2, merkleDistributor, claimAndStake } =
            await (0, AcceleratingDistributor_Fixture_1.acceleratingDistributorFixture)());
        // Enable reward token for staking.
        await (0, AcceleratingDistributor_Fixture_1.enableTokenForStaking)(distributor, lpToken1, acrossToken);
        // Seed MerkleDistributor with reward tokens.
        await lpToken1.connect(contractCreator).mint(contractCreator.address, common_1.MAX_UINT_VAL);
        await lpToken1.connect(contractCreator).approve(merkleDistributor.address, common_1.MAX_UINT_VAL);
        // Set two windows with trivial one leaf trees.
        const reward1Recipients = [
            {
                account: claimer.address,
                amount: window1RewardAmount.toString(),
                accountIndex: 0,
            },
        ];
        const reward2Recipients = [
            {
                account: claimer.address,
                amount: window2RewardAmount.toString(),
                accountIndex: 0,
            },
        ];
        const merkleTree1 = new merkle_distributor_1.MerkleTree(reward1Recipients.map((item) => createLeaf(item)));
        await merkleDistributor
            .connect(contractCreator)
            .setWindow(window1RewardAmount, lpToken1.address, merkleTree1.getRoot(), "");
        const merkleTree2 = new merkle_distributor_1.MerkleTree(reward2Recipients.map((item) => createLeaf(item)));
        await merkleDistributor
            .connect(contractCreator)
            .setWindow(window2RewardAmount, lpToken1.address, merkleTree2.getRoot(), "");
        // Construct claims for all trees assuming that each tree index is equal to its window index.
        batchedClaims = [
            {
                windowIndex: 0,
                account: reward1Recipients[0].account,
                accountIndex: reward1Recipients[0].accountIndex,
                amount: reward1Recipients[0].amount,
                merkleProof: merkleTree1.getProof(createLeaf(reward1Recipients[0])),
            },
            {
                windowIndex: 1,
                account: reward2Recipients[0].account,
                accountIndex: reward2Recipients[0].accountIndex,
                amount: reward2Recipients[0].amount,
                merkleProof: merkleTree2.getProof(createLeaf(reward2Recipients[0])),
            },
        ];
        (0, utils_1.expect)(await lpToken1.balanceOf(claimer.address)).to.equal((0, utils_1.toBN)(0));
        // Tests require staker to have approved contract
        await lpToken1.connect(claimer).approve(distributor.address, common_1.MAX_UINT_VAL);
    });
    it("Happy path", async function () {
        const time = await distributor.getCurrentTime();
        await (0, utils_1.expect)(claimAndStake.connect(claimer).claimAndStake(batchedClaims[0]))
            .to.emit(distributor, "Stake")
            .withArgs(lpToken1.address, claimer.address, window1RewardAmount, time, window1RewardAmount, window1RewardAmount);
        (0, utils_1.expect)((await distributor.getUserStake(lpToken1.address, claimer.address)).cumulativeBalance).to.equal(window1RewardAmount);
        (0, utils_1.expect)((await distributor.getUserStake(lpToken1.address, claimAndStake.address)).cumulativeBalance).to.equal((0, utils_1.toBN)(0));
        (0, utils_1.expect)(await lpToken1.balanceOf(merkleDistributor.address)).to.equal(window2RewardAmount);
        (0, utils_1.expect)(await lpToken1.balanceOf(claimer.address)).to.equal((0, utils_1.toBN)(0));
    });
    it("Multicall", async function () {
        const callData1 = claimAndStake.interface.encodeFunctionData("claimAndStake", [batchedClaims[0]]);
        const callData2 = claimAndStake.interface.encodeFunctionData("claimAndStake", [batchedClaims[1]]);
        await claimAndStake.connect(claimer).multicall([callData1, callData2]);
        (0, utils_1.expect)((await distributor.getUserStake(lpToken1.address, claimer.address)).cumulativeBalance).to.equal(totalBatchRewards);
        (0, utils_1.expect)((await distributor.getUserStake(lpToken1.address, claimAndStake.address)).cumulativeBalance).to.equal((0, utils_1.toBN)(0));
        (0, utils_1.expect)(await lpToken1.balanceOf(merkleDistributor.address)).to.equal((0, utils_1.toBN)(0));
        (0, utils_1.expect)(await lpToken1.balanceOf(claimer.address)).to.equal((0, utils_1.toBN)(0));
    });
    it("Fails if ClaimAndStake contract is not whitelisted claimer on MerkleDistributor", async function () {
        await merkleDistributor.whitelistClaimer(claimAndStake.address, false);
        await (0, utils_1.expect)(claimAndStake.connect(claimer).claimAndStake(batchedClaims[0])).to.be.revertedWith("unwhitelisted claimer");
    });
    it("Claim account is not caller", async function () {
        // Claiming with account that isn't receiving the claims causes revert
        await (0, utils_1.expect)(claimAndStake.connect(contractCreator).claimAndStake(batchedClaims[0])).to.be.revertedWith("claim account not caller");
    });
    it("Claimed token is not eligible for staking", async function () {
        // Disable staking token
        await distributor.configureStakingToken(lpToken1.address, false, constants_1.baseEmissionRate, constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier);
        await (0, utils_1.expect)(claimAndStake.connect(claimer).claimAndStake(batchedClaims[0])).to.be.revertedWith("stakedToken not enabled");
    });
});
