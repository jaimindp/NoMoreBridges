"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const AcceleratingDistributor_Fixture_1 = require("./AcceleratingDistributor.Fixture");
const constants_1 = require("./constants");
let timer, acrossToken, distributor, lpToken1, depositor1;
describe("AcceleratingDistributor: Reward Token Flow", async function () {
    beforeEach(async function () {
        [, depositor1] = await utils_1.ethers.getSigners();
        ({ timer, distributor, acrossToken, lpToken1 } = await (0, AcceleratingDistributor_Fixture_1.acceleratingDistributorFixture)());
        await (0, AcceleratingDistributor_Fixture_1.enableTokenForStaking)(distributor, lpToken1, acrossToken);
        await (0, utils_1.seedAndApproveWallet)(depositor1, [lpToken1], distributor);
    });
    it("Get rewards token flow", async function () {
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        // Advance time 200 seconds. Expected rewards are 200 * 0.01 * (1 + 200 / 1000 * (5 - 1)) = 3.6.
        await (0, utils_1.advanceTime)(timer, 200);
        await (0, utils_1.expect)(() => distributor.connect(depositor1).withdrawReward(lpToken1.address))
            // Get the rewards. Check the cash flows are as expected. The distributor should send 3.6 to the depositor.
            .to.changeTokenBalances(acrossToken, [distributor, depositor1], [(0, utils_1.toWei)(-3.6), (0, utils_1.toWei)(3.6)]);
        // After claiming the rewards the users multiplier should be reset to 1.
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1));
        // Advance time 500 seconds. Expected rewards are 500 * 0.01 * (1 + 500 / 1000 * (5 - 1)) = 15.
        await (0, utils_1.advanceTime)(timer, 500);
        await (0, utils_1.expect)(() => distributor.connect(depositor1).withdrawReward(lpToken1.address))
            // Get the rewards. Check the cash flows are as expected. The distributor should send 15 to the depositor.
            .to.changeTokenBalances(acrossToken, [distributor, depositor1], [(0, utils_1.toWei)(-15), (0, utils_1.toWei)(15)]);
    });
    it("Unstake token flow", async function () {
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        // Advance time 200 seconds. Expected rewards are 200 * 0.01 * (1 + 200 / 1000 * (5 - 1)) = 3.6.
        await (0, utils_1.advanceTime)(timer, 200);
        (0, utils_1.expect)(await distributor.getOutstandingRewards(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(3.6));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1.8));
        // User unstakes. This should send back their LP tokens but seeing they did not claim any rewards their rewards
        // should remain the same. Their multiplier, however, should have rest as they unstaked everything.
        await (0, utils_1.expect)(() => distributor.connect(depositor1).unstake(lpToken1.address, constants_1.stakeAmount))
            // Get the LP tokens back. Check the cash flows are as expected. The distributor should send stakedAmount.
            .to.changeTokenBalances(lpToken1, [distributor, depositor1], [constants_1.stakeAmount.mul(-1), constants_1.stakeAmount]);
        (0, utils_1.expect)(await distributor.getOutstandingRewards(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(3.6));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1));
        // If we advance time their accumulated rewards should NOT increase as they have nothing staked.
        await (0, utils_1.advanceTime)(timer, 200);
        (0, utils_1.expect)(await distributor.getOutstandingRewards(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(3.6));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1));
        // User re-stakes. As they unstaked before they've forced their multiplier back to 1. They should start accumulating
        // rewards again and their new accumulation should add to the previous one.
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        (0, utils_1.expect)(await distributor.getOutstandingRewards(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(3.6));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1));
        // Advance time by 300 seconds. Expected Multiplier is 1 + 300 / 1000 * (5 - 1) = 2.2. Expected rewards are
        // 3.6 + 300 * 0.01 * 2.2 = 10.2 (i.e previous rewards + the new batch with no carry over multiplier due to reset).
        await (0, utils_1.advanceTime)(timer, 300);
        (0, utils_1.expect)(await distributor.getOutstandingRewards(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(10.2));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(2.2));
        // This time unstake then claim rewards. multiplier and outstanding rewards should reset.
        await (0, utils_1.expect)(() => distributor.connect(depositor1).unstake(lpToken1.address, constants_1.stakeAmount))
            // Get the rewards. Check the cash flows are as expected. The distributor should send 0.9 to the depositor1.
            .to.changeTokenBalances(lpToken1, [distributor, depositor1], [constants_1.stakeAmount.mul(-1), constants_1.stakeAmount]);
        await (0, utils_1.expect)(() => distributor.connect(depositor1).withdrawReward(lpToken1.address))
            // Get the rewards. Check the cash flows are as expected. The distributor should send 10.2 to the depositor1.
            .to.changeTokenBalances(acrossToken, [distributor, depositor1], [(0, utils_1.toWei)(10.2).mul(-1), (0, utils_1.toWei)(10.2)]);
        (0, utils_1.expect)(await distributor.getOutstandingRewards(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(0));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1));
        // Re-stake and advance time. There should be no memory of the previous stakes and rewards should accumulate from scratch.
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        (0, utils_1.expect)(await distributor.getOutstandingRewards(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(0));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1));
        await (0, utils_1.advanceTime)(timer, 200);
        (0, utils_1.expect)(await distributor.getOutstandingRewards(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(3.6));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1.8));
    });
    it("Exit token flow", async function () {
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        // Advance time 200 seconds. Expected rewards are 200 * 0.01 * (1 + 200 / 1000 * (5 - 1)) = 3.6.
        // Exit should pull out all rewards and unstake all LP tokens. Check balances directly as there was 2 token actions.
        await (0, utils_1.advanceTime)(timer, 200);
        await distributor.connect(depositor1).exit(lpToken1.address);
        (0, utils_1.expect)(await lpToken1.balanceOf(distributor.address)).to.equal((0, utils_1.toBN)(0));
        (0, utils_1.expect)(await lpToken1.balanceOf(depositor1.address)).to.equal((0, utils_1.toBN)(constants_1.seedWalletAmount));
        const expectedRewards = (0, utils_1.toWei)(3.6);
        (0, utils_1.expect)(await acrossToken.balanceOf(distributor.address)).to.equal(constants_1.seedDistributorAmount.sub(expectedRewards));
        (0, utils_1.expect)(await acrossToken.balanceOf(depositor1.address)).to.equal(expectedRewards);
    });
});
