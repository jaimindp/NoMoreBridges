"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const utils_2 = require("./utils");
const AcceleratingDistributor_Fixture_1 = require("./AcceleratingDistributor.Fixture");
const constants_1 = require("./constants");
let timer, acrossToken, distributor, lpToken1, depositor1;
let owner, rando;
describe("AcceleratingDistributor: Events", async function () {
    beforeEach(async function () {
        [owner, depositor1, rando] = await utils_1.ethers.getSigners();
        ({ timer, distributor, acrossToken, lpToken1 } = await (0, AcceleratingDistributor_Fixture_1.acceleratingDistributorFixture)());
        await (0, AcceleratingDistributor_Fixture_1.enableTokenForStaking)(distributor, lpToken1, acrossToken);
        await (0, utils_2.seedAndApproveWallet)(depositor1, [lpToken1], distributor);
    });
    it("configureStakingToken", async function () {
        const currentTime = await distributor.getCurrentTime();
        await (0, utils_1.expect)(distributor.configureStakingToken(lpToken1.address, true, constants_1.baseEmissionRate, constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier))
            .to.emit(distributor, "TokenConfiguredForStaking")
            .withArgs(lpToken1.address, true, constants_1.baseEmissionRate, constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier, currentTime);
    });
    it("RecoverToken", async function () {
        const randomToken = await (await (0, utils_2.getContractFactory)("TestToken", owner)).deploy("RANDO", "RANDO");
        const amount = (0, utils_2.toWei)(420);
        await randomToken.mint(distributor.address, amount);
        await (0, utils_1.expect)(distributor.recoverToken(randomToken.address))
            .to.emit(distributor, "RecoverToken")
            .withArgs(randomToken.address, amount);
    });
    it("Stake", async function () {
        const time1 = await distributor.getCurrentTime();
        await (0, utils_1.expect)(distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount))
            .to.emit(distributor, "Stake")
            .withArgs(lpToken1.address, depositor1.address, constants_1.stakeAmount, time1, constants_1.stakeAmount, constants_1.stakeAmount);
        // Subsequent stakes emit expected event. Advance time 420 seconds and stake 2x the amount.
        await (0, utils_2.advanceTime)(timer, 420);
        const time2 = await distributor.getCurrentTime();
        const avgDepositTime = time1.add(constants_1.stakeAmount.mul(2).mul((0, utils_2.toWei)(1)).div(constants_1.stakeAmount.mul(3)).mul(time2.sub(time1)).div((0, utils_2.toWei)(1)));
        await (0, utils_1.expect)(distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount.mul(2)))
            .to.emit(distributor, "Stake")
            .withArgs(lpToken1.address, depositor1.address, constants_1.stakeAmount.mul(2), avgDepositTime, constants_1.stakeAmount.mul(3), constants_1.stakeAmount.mul(3));
    });
    it("StakeFor", async function () {
        const time1 = await distributor.getCurrentTime();
        await (0, utils_1.expect)(distributor.connect(depositor1).stakeFor(lpToken1.address, constants_1.stakeAmount, rando.address))
            .to.emit(distributor, "Stake")
            .withArgs(lpToken1.address, rando.address, constants_1.stakeAmount, time1, constants_1.stakeAmount, constants_1.stakeAmount);
        // Subsequent stakes emit expected event. Advance time 420 seconds and stake 2x the amount.
        await (0, utils_2.advanceTime)(timer, 420);
        const time2 = await distributor.getCurrentTime();
        const avgDepositTime = time1.add(constants_1.stakeAmount.mul(2).mul((0, utils_2.toWei)(1)).div(constants_1.stakeAmount.mul(3)).mul(time2.sub(time1)).div((0, utils_2.toWei)(1)));
        await (0, utils_1.expect)(distributor.connect(depositor1).stakeFor(lpToken1.address, constants_1.stakeAmount.mul(2), rando.address))
            .to.emit(distributor, "Stake")
            .withArgs(lpToken1.address, rando.address, constants_1.stakeAmount.mul(2), avgDepositTime, constants_1.stakeAmount.mul(3), constants_1.stakeAmount.mul(3));
    });
    it("Unstake", async function () {
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        // Unstake 1/3. Should see associated event.
        await (0, utils_1.expect)(distributor.connect(depositor1).unstake(lpToken1.address, constants_1.stakeAmount.div(3)))
            .to.emit(distributor, "Unstake")
            .withArgs(lpToken1.address, depositor1.address, constants_1.stakeAmount.div(3), constants_1.stakeAmount.mul(2).div(3).add(1), constants_1.stakeAmount.mul(2).div(3).add(1)); // Add 1 to deal with rounding.
        // Unstake the remaining should emit the rest.
        await (0, utils_1.expect)(distributor.connect(depositor1).unstake(lpToken1.address, constants_1.stakeAmount.mul(2).div(3).add(1)))
            .to.emit(distributor, "Unstake")
            .withArgs(lpToken1.address, depositor1.address, constants_1.stakeAmount.mul(2).div(3).add(1), 0, 0);
    });
    it("GetRewards", async function () {
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        // Advance 200. should be entitled to 200 * 0.01 * (1 + 200 / 1000 * (5 - 1)) = 3.6.
        // Reward paid per token should be 200 * 0.01 or 0.2.
        await (0, utils_2.advanceTime)(timer, 200);
        const currentTime = await distributor.getCurrentTime();
        await (0, utils_1.expect)(distributor.connect(depositor1).withdrawReward(lpToken1.address))
            .to.emit(distributor, "RewardsWithdrawn")
            .withArgs(lpToken1.address, depositor1.address, (0, utils_2.toWei)(3.6), currentTime, (0, utils_2.toWei)(0.2), 0, (0, utils_2.toWei)(0.2));
    });
    it("Exit", async function () {
        // Exit calls unstake and getRewards. We've tested these events already so nothing needed on those. Just test Exit.
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        await (0, utils_2.advanceTime)(timer, 200);
        await (0, utils_1.expect)(distributor.connect(depositor1).exit(lpToken1.address))
            .to.emit(distributor, "Exit")
            .withArgs(lpToken1.address, depositor1.address, 0);
    });
});
