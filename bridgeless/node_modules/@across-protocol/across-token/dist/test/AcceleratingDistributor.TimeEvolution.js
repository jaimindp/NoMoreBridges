"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const AcceleratingDistributor_Fixture_1 = require("./AcceleratingDistributor.Fixture");
const constants_1 = require("./constants");
let timer, acrossToken, distributor, lpToken1;
let owner, depositor1, depositor2;
describe("AcceleratingDistributor: Time Evolution", async function () {
    beforeEach(async function () {
        [owner, depositor1] = await utils_1.ethers.getSigners();
        ({ timer, distributor, acrossToken, lpToken1 } = await (0, AcceleratingDistributor_Fixture_1.acceleratingDistributorFixture)());
        await (0, AcceleratingDistributor_Fixture_1.enableTokenForStaking)(distributor, lpToken1, acrossToken);
        await (0, utils_1.seedAndApproveWallet)(depositor1, [lpToken1], distributor);
    });
    it("Users average deposit time should update as expected", async function () {
        const time1 = await distributor.getCurrentTime();
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        // Advance 420 seconds and stake again at the same size. As the two deposits are of equal size we should expect to
        // see the users averageDeposit time be time1 + 210 seconds (half way between the two deposits).
        await (0, utils_1.advanceTime)(timer, 420);
        const time2 = await distributor.getCurrentTime();
        (0, utils_1.expect)(await distributor.getTimeSinceAverageDeposit(lpToken1.address, depositor1.address)).to.equal(420);
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        const averageDepositTime1 = time1.add(210);
        (0, utils_1.expect)(time2).to.equal(time1.add(420));
        (0, utils_1.expect)((await distributor.getUserStake(lpToken1.address, depositor1.address)).averageDepositTime).to.equal(averageDepositTime1);
        // Advance another 69 seconds and this time stake 10x the deposit amount. This should result in the average time
        // being closer to the current time than the previous stake time. Use the appropriate equation to compute avg time.
        await (0, utils_1.advanceTime)(timer, 69);
        const time3 = await distributor.getCurrentTime();
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount.mul(10));
        const averageDepositTime2 = averageDepositTime1.add(constants_1.stakeAmount.mul(10).mul((0, utils_1.toWei)(1)).div(constants_1.stakeAmount.mul(12)).mul(time3.sub(averageDepositTime1)).div((0, utils_1.toWei)(1)));
        (0, utils_1.expect)((await distributor.getUserStake(lpToken1.address, depositor1.address)).averageDepositTime).to.equal(averageDepositTime2);
    });
    it("Time advance should update user multiplier as expected", async function () {
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        await (0, utils_1.advanceTime)(timer, 200);
        // Depositor should have the multiplier of 1 + 200 / 1000 * (5 - 1) = 1.8.
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1.8));
        // Advance another 69 seconds. Multiplier should now be 1 + 269 / 1000 * (5 - 1) = 2.076
        await (0, utils_1.advanceTime)(timer, 69);
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(2.076));
        // Advance time to the max secondsToMaxMultiplier (at least 731 seconds). Multiplier should equal the max multiplier.
        await (0, utils_1.advanceTime)(timer, 731);
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal(constants_1.maxMultiplier);
        //  Advancing time past now should not increase the multiplier any further.
        await (0, utils_1.advanceTime)(timer, 1000);
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal(constants_1.maxMultiplier);
    });
    it("Partial unstake behaves as expected with reward multiplier", async function () {
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        await (0, utils_1.advanceTime)(timer, 200);
        // Depositor should have the multiplier of 1 + 200 / 1000 * (5 - 1) = 1.8.
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1.8));
        // Unstake half of the LP tokens. Should not change the multiplier.
        await distributor.connect(depositor1).unstake(lpToken1.address, constants_1.stakeAmount.div(2));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1.8));
        // Multiplier should continue increasing after unstake in the same fashion. Another 200 seconds gives a multiplier
        // of 1 + 400 / 1000 * (5 - 1) = 2.6.
        await (0, utils_1.advanceTime)(timer, 200);
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(2.6));
        // Now, remove the rest of the LP tokens. This should reset the multiplier to 1.
        await distributor.connect(depositor1).unstake(lpToken1.address, constants_1.stakeAmount.sub(constants_1.stakeAmount.div(2)));
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1));
        // If the user re-stakes the LP tokens, the multiplier should be 1 with no memory of the previous stake.
        await distributor.connect(depositor1).stake(lpToken1.address, constants_1.stakeAmount);
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1));
        // Multiplier should now increase as per usual.
        await (0, utils_1.advanceTime)(timer, 200);
        (0, utils_1.expect)(await distributor.getUserRewardMultiplier(lpToken1.address, depositor1.address)).to.equal((0, utils_1.toWei)(1.8));
    });
});
