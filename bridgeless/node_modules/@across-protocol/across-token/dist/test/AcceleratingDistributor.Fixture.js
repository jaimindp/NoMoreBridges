"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableTokenForStaking = exports.acceleratingDistributorFixture = void 0;
const utils_1 = require("./utils");
const constants_1 = require("./constants");
exports.acceleratingDistributorFixture = utils_1.hre.deployments.createFixture(async ({ ethers }) => {
    const [deployerWallet] = await ethers.getSigners();
    const timer = await (await (0, utils_1.getContractFactory)("Timer", deployerWallet)).deploy();
    const acrossToken = await (await (0, utils_1.getContractFactory)("AcrossToken", deployerWallet)).deploy();
    const distributor = await (await (0, utils_1.getContractFactory)("AcceleratingDistributor_Testable", deployerWallet)).deploy(acrossToken.address, timer.address);
    const lpToken1 = await (await (0, utils_1.getContractFactory)("TestToken", deployerWallet)).deploy("LP1", "LP Token 1");
    const lpToken2 = await (await (0, utils_1.getContractFactory)("TestToken", deployerWallet)).deploy("LP2", "LP Token 2");
    const merkleDistributor = await (await (0, utils_1.getContractFactory)("MerkleDistributorTest", deployerWallet)).deploy();
    const claimAndStake = await (await (0, utils_1.getContractFactory)("ClaimAndStake", deployerWallet)).deploy(merkleDistributor.address, distributor.address);
    await merkleDistributor.whitelistClaimer(claimAndStake.address, true);
    return { timer, acrossToken, distributor, lpToken1, lpToken2, merkleDistributor, claimAndStake };
});
async function enableTokenForStaking(distributor, lpToken, acrossToken) {
    // Enable the LpToken for staking and deposit some across tokens into the distributor.
    await distributor.configureStakingToken(lpToken.address, true, constants_1.baseEmissionRate, constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier);
    await acrossToken.mint(distributor.address, constants_1.seedDistributorAmount);
}
exports.enableTokenForStaking = enableTokenForStaking;
