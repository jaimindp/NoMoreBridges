"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const AcceleratingDistributor_Fixture_1 = require("./AcceleratingDistributor.Fixture");
const constants_1 = require("./constants");
let timer, acrossToken, distributor, lpToken1;
let owner, rando;
describe("AcceleratingDistributor: Admin Functions", async function () {
    beforeEach(async function () {
        [owner, rando] = await utils_1.ethers.getSigners();
        ({ timer, distributor, acrossToken, lpToken1 } = await (0, AcceleratingDistributor_Fixture_1.acceleratingDistributorFixture)());
    });
    it("Enable token for staking", async function () {
        (0, utils_1.expect)((await distributor.stakingTokens(lpToken1.address)).enabled).to.be.false;
        await distributor.configureStakingToken(lpToken1.address, true, constants_1.baseEmissionRate, constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier);
        (0, utils_1.expect)((await distributor.stakingTokens(lpToken1.address)).enabled).to.be.true;
        (0, utils_1.expect)((await distributor.stakingTokens(lpToken1.address)).baseEmissionRate).to.equal(constants_1.baseEmissionRate);
        (0, utils_1.expect)((await distributor.stakingTokens(lpToken1.address)).maxMultiplier).to.equal(constants_1.maxMultiplier);
        (0, utils_1.expect)((await distributor.stakingTokens(lpToken1.address)).secondsToMaxMultiplier).to.equal(constants_1.secondsToMaxMultiplier);
        (0, utils_1.expect)((await distributor.stakingTokens(lpToken1.address)).lastUpdateTime).to.equal(await timer.getCurrentTime());
        // Update settings.
        const newMultiplier = constants_1.maxMultiplier.add((0, utils_1.toWei)(1));
        await distributor.configureStakingToken(lpToken1.address, true, constants_1.baseEmissionRate, newMultiplier, constants_1.secondsToMaxMultiplier);
        (0, utils_1.expect)((await distributor.stakingTokens(lpToken1.address)).maxMultiplier).to.equal(newMultiplier);
        //Disable token for staking.
        await distributor.configureStakingToken(lpToken1.address, false, constants_1.baseEmissionRate, newMultiplier, constants_1.secondsToMaxMultiplier);
        (0, utils_1.expect)((await distributor.stakingTokens(lpToken1.address)).enabled).to.be.false;
    });
    it("Can only recover excess staked tokens", async function () {
        await distributor.configureStakingToken(lpToken1.address, true, constants_1.baseEmissionRate, constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier);
        // Drop tokens directly onto the contract. The owner should be able to fully recover these.
        await lpToken1.mint(distributor.address, (0, utils_1.toWei)(420));
        await (0, utils_1.expect)(() => distributor.recoverToken(lpToken1.address)).to.changeTokenBalances(lpToken1, [distributor, owner], [(0, utils_1.toWei)(420).mul(-1), (0, utils_1.toWei)(420)]);
        // Stake tokens. Should not be able to recover as no excess above what that contract thinks it should have.
        await lpToken1.mint(rando.address, (0, utils_1.toWei)(69));
        await lpToken1.connect(rando).approve(distributor.address, (0, utils_1.toWei)(69));
        await distributor.connect(rando).stake(lpToken1.address, (0, utils_1.toWei)(69));
        await (0, utils_1.expect)(distributor.recoverToken(lpToken1.address)).to.be.revertedWith("Can't recover 0 tokens");
        // Mint additional tokens to the contract to simulate someone dropping them accidentally. This should be recoverable.
        await lpToken1.mint(distributor.address, (0, utils_1.toWei)(696));
        await (0, utils_1.expect)(() => distributor.recoverToken(lpToken1.address)).to.changeTokenBalances(lpToken1, [distributor, owner], [(0, utils_1.toWei)(696).mul(-1), (0, utils_1.toWei)(696)]);
        // The contract should be left with the original stake amount in it as this was not recoverable.
        (0, utils_1.expect)(await lpToken1.balanceOf(distributor.address)).to.equal((0, utils_1.toWei)(69));
        await (0, utils_1.expect)(distributor.recoverToken(lpToken1.address)).to.be.revertedWith("Can't recover 0 tokens");
    });
    it("Can skim any amount of a random token", async function () {
        const randomToken = await (await (0, utils_1.getContractFactory)("TestToken", owner)).deploy("RANDO", "RANDO");
        const amount = (0, utils_1.toWei)(420);
        await randomToken.mint(distributor.address, amount);
        await distributor.recoverToken(randomToken.address);
        (0, utils_1.expect)(await randomToken.balanceOf(distributor.address)).to.equal((0, utils_1.toWei)(0));
        await (0, utils_1.expect)(distributor.recoverToken(randomToken.address)).to.be.revertedWith("Can't recover 0 tokens");
    });
    it("Owner can at any time recover reward token", async function () {
        await acrossToken.mint(distributor.address, (0, utils_1.toWei)(420));
        // Owner can recover tokens at any point in time.
        await (0, utils_1.expect)(() => distributor.recoverToken(acrossToken.address)).to.changeTokenBalances(acrossToken, [distributor, owner], [(0, utils_1.toWei)(420).mul(-1), (0, utils_1.toWei)(420)]);
    });
    it("Cannot set staking token to reward token", async function () {
        await (0, utils_1.expect)(distributor.configureStakingToken(acrossToken.address, true, constants_1.baseEmissionRate, constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier)).to.be.revertedWith("Staked token is reward token");
    });
    it("Cannot set bad staking configs", async function () {
        await (0, utils_1.expect)(distributor.configureStakingToken(lpToken1.address, true, constants_1.baseEmissionRate, (0, utils_1.toWei)((0, utils_1.toWei)(1)), constants_1.secondsToMaxMultiplier)).to.be.revertedWith("maxMultiplier can not be set too large");
        await (0, utils_1.expect)(distributor.configureStakingToken(lpToken1.address, true, constants_1.baseEmissionRate, constants_1.maxMultiplier, 0)).to.be.revertedWith("secondsToMaxMultiplier must be greater than 0");
        await (0, utils_1.expect)(distributor.configureStakingToken(lpToken1.address, true, (0, utils_1.toWei)(10000000000), constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier)).to.be.revertedWith("baseEmissionRate can not be set too large");
    });
    it("Non owner cant execute admin functions", async function () {
        await (0, utils_1.expect)(distributor.connect(rando).configureStakingToken(lpToken1.address, true, 4, 2, 0)).to.be.revertedWith("Ownable: caller is not the owner");
    });
    it("Permissioning on staking-related methods", async function () {
        await (0, utils_1.expect)(distributor.connect(owner).stake(lpToken1.address, 0)).to.be.revertedWith("stakedToken not enabled");
        await (0, utils_1.expect)(distributor.connect(owner).unstake(lpToken1.address, 0)).to.be.revertedWith("stakedToken not initialized");
        await (0, utils_1.expect)(distributor.connect(owner).withdrawReward(lpToken1.address)).to.be.revertedWith("stakedToken not initialized");
        await (0, utils_1.expect)(distributor.connect(owner).exit(lpToken1.address)).to.be.revertedWith("stakedToken not initialized");
        await distributor.configureStakingToken(lpToken1.address, true, constants_1.baseEmissionRate, constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier);
        await (0, utils_1.expect)(distributor.connect(owner).stake(lpToken1.address, 0)).to.not.be.reverted;
        await (0, utils_1.expect)(distributor.connect(owner).unstake(lpToken1.address, 0)).to.not.be.reverted;
        await (0, utils_1.expect)(distributor.connect(owner).withdrawReward(lpToken1.address)).to.not.be.reverted;
        await (0, utils_1.expect)(distributor.connect(owner).exit(lpToken1.address)).to.not.be.reverted;
        await distributor.configureStakingToken(lpToken1.address, false, constants_1.baseEmissionRate, constants_1.maxMultiplier, constants_1.secondsToMaxMultiplier);
        await (0, utils_1.expect)(distributor.connect(owner).stake(lpToken1.address, 0)).to.be.revertedWith("stakedToken not enabled");
        await (0, utils_1.expect)(distributor.connect(owner).unstake(lpToken1.address, 0)).to.not.be.reverted;
        await (0, utils_1.expect)(distributor.connect(owner).withdrawReward(lpToken1.address)).to.not.be.reverted;
        await (0, utils_1.expect)(distributor.connect(owner).exit(lpToken1.address)).to.not.be.reverted;
    });
});
