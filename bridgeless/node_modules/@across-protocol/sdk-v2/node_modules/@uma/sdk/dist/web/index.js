import { RegistryEthers__factory, getRegistryAddress, ExpiringMultiPartyEthers__factory, ERC20Ethers__factory, MulticallEthers__factory, Multicall2Ethers__factory, LongShortPairCreatorEthers__factory, getLongShortPairCreatorAddress, getLongShortPairCreatorAbi, LongShortPairEthers__factory, BridgeDepositBoxEthers__factory, BridgePoolEthers__factory, RateModelStoreEthers__factory, getRateModelStoreAddress, getOptimisticOracleInterfaceAbi, OptimisticOracleInterfaceEthers__factory, getSkinnyOptimisticOracleAbi, SkinnyOptimisticOracleEthers__factory, getOptimisticOracleV2InterfaceAbi, OptimisticOracleV2InterfaceEthers__factory, OptimismL1StandardBridgeEthers__factory, BobaAddressManagerEthers__factory } from '@uma/contracts-frontend';
import assert from 'assert';
import { BigNumber, utils as utils$3, ethers as ethers$1, Contract } from 'ethers';
import zip from 'lodash-es/zip';
import { set, sortedIndex, sortedLastIndex, get as get$1 } from 'lodash-es';
import axios from 'axios';
import get from 'lodash-es/get';
import highland from 'highland';
import Decimal from 'decimal.js';
import sortedIndexBy from 'lodash-es/sortedIndexBy';
import clamp from 'lodash-es/clamp';
import { Provider, JsonRpcSigner, JsonRpcProvider, Web3Provider, FallbackProvider } from '@ethersproject/providers';
import set$1 from 'lodash-es/set';
import has from 'lodash-es/has';
import { getContractInterface, predeploys } from '@eth-optimism/contracts';
import { Watcher } from '@eth-optimism/core-utils';
import sortedLastIndexBy from 'lodash-es/sortedLastIndexBy';
import filter from 'lodash-es/filter';
import produce from 'immer';
import bluebird from 'bluebird';
import uid from 'lodash-es/uniqueId';
import sortedIndex$1 from 'lodash-es/sortedIndex';
import sortedLastIndex$1 from 'lodash-es/sortedLastIndex';

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var Factory = RegistryEthers__factory;
function connect(address, provider) {
  return Factory.connect(address, provider);
}
// experimenting with a generalized way of handling events and returning state, inspired from react style reducers
function reduceEvents(state, event) {
  if (state === void 0) {
    state = {};
  }
  switch (event.event) {
    case "NewContractRegistered":
      {
        var _state, _extends2;
        var typedEvent = event;
        var contractAddress = typedEvent.args.contractAddress;
        var contracts = ((_state = state) == null ? void 0 : _state.contracts) || {};
        return _extends({}, state, {
          contracts: _extends({}, contracts, (_extends2 = {}, _extends2[contractAddress] = typedEvent, _extends2))
        });
      }
  }
  return state;
}
function getEventState(events) {
  return events.reduce(reduceEvents, {});
}



var index = {
  __proto__: null,
  getAddress: getRegistryAddress,
  getAbi: getRegistryAddress,
  connect: connect,
  reduceEvents: reduceEvents,
  getEventState: getEventState
};

// check if a value is not null or undefined, useful for numbers which could be 0.
// "is" syntax: https://stackoverflow.com/questions/40081332/what-does-the-is-keyword-do-in-typescript
/* eslint-disable-next-line @typescript-eslint/ban-types */
function exists(value) {
  return value !== null && value !== undefined;
}
function Balances(balances) {
  if (balances === void 0) {
    balances = {};
  }
  function create(id, amount) {
    if (amount === void 0) {
      amount = "0";
    }
    assert(!has(id), "balance already exists");
    return set(id, amount);
  }
  function has(id) {
    return exists(balances[id]);
  }
  function set(id, amount) {
    balances[id] = amount;
    return amount;
  }
  function add(id, amount) {
    return set(id, BigNumber.from(amount).add(getOrCreate(id)).toString());
  }
  function sub(id, amount) {
    return set(id, BigNumber.from(getOrCreate(id)).sub(amount).toString());
  }
  function get(id) {
    assert(has(id), "balance does not exist");
    return balances[id];
  }
  function getOrCreate(id) {
    if (has(id)) return get(id);
    return create(id);
  }
  return {
    create: create,
    add: add,
    sub: sub,
    get: get,
    balances: balances,
    set: set,
    has: has,
    getOrCreate: getOrCreate
  };
}
// Copied from common, but modified for ethers Bignumber
var ConvertDecimals = function ConvertDecimals(fromDecimals, toDecimals) {
  assert(fromDecimals >= 0, "requires fromDecimals as an integer >= 0");
  assert(toDecimals >= 0, "requires toDecimals as an integer >= 0");
  // amount: string, BN, number - integer amount in fromDecimals smallest unit that want to convert toDecimals
  // returns: string with toDecimals in smallest unit
  return function (amount) {
    assert(exists(amount), "must provide an amount to convert");
    amount = BigNumber.from(amount);
    if (amount.isZero()) return amount.toString();
    var diff = fromDecimals - toDecimals;
    if (diff == 0) return amount.toString();
    if (diff > 0) return amount.div(BigNumber.from("10").pow(diff)).toString();
    return amount.mul(BigNumber.from("10").pow(-1 * diff)).toString();
  };
};
// async sleep
var sleep = function sleep(delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return new Promise(function (res) {
    return setTimeout(res, delay);
  });
};
// Loop forever but wait until execution is finished before starting next timer. Throw an error to break this
// or add another utlity function if you need it to end on condition.
function loop(_x, _x2) {
  return _loop.apply(this, arguments);
}
function _loop() {
  _loop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fn, delay) {
    var _len,
      args,
      _key,
      _args2 = arguments;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          for (_len = _args2.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = _args2[_key];
          }
        case 1:
          _context2.next = 3;
          return fn.apply(void 0, args);
        case 3:
          _context2.next = 5;
          return sleep(delay);
        case 5:
          {
            _context2.next = 1;
            break;
          }
        case 6:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _loop.apply(this, arguments);
}
var BatchReadWithErrors = function BatchReadWithErrors(multicall2) {
  return function (contract) {
    return /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(calls) {
        var results;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return multicall2.batch(contract, calls.map(function (_ref2) {
                var method = _ref2[0],
                  args = _ref2.slice(1);
                return {
                  method: method,
                  args: args
                };
              })).readWithErrors();
            case 2:
              results = _context.sent;
              return _context.abrupt("return", Object.fromEntries(zip(calls, results).map(function (_ref3) {
                var call = _ref3[0],
                  result = _ref3[1];
                if (call == null) return [];
                var method = call[0];
                if (!(result != null && result.result)) return [method, undefined];
                return [method, result.result[0] || result.result];
              })));
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x3) {
        return _ref.apply(this, arguments);
      };
    }();
  };
};
/**
 * @notice Return average block-time for a period.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function averageBlockTimeSeconds(_x4) {
  return _averageBlockTimeSeconds.apply(this, arguments);
}
function _averageBlockTimeSeconds() {
  _averageBlockTimeSeconds = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(chainId) {
    var defaultBlockTimeSeconds;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          // TODO: Call an external API to get this data. Currently this value is a hard-coded estimate
          // based on the data from https://etherscan.io/chart/blocktime. ~13.5 seconds has been the average
          // since April 2016, although this value seems to spike periodically for a relatively short period of time.
          defaultBlockTimeSeconds = 12;
          if (defaultBlockTimeSeconds) {
            _context3.next = 3;
            break;
          }
          throw "Missing default block time value";
        case 3:
          _context3.t0 = chainId;
          _context3.next = _context3.t0 === 10 ? 6 : _context3.t0 === 42161 ? 7 : _context3.t0 === 288 ? 8 : _context3.t0 === 137 ? 9 : _context3.t0 === 1 ? 10 : 11;
          break;
        case 6:
          return _context3.abrupt("return", 0.5);
        case 7:
          return _context3.abrupt("return", 0.5);
        case 8:
          return _context3.abrupt("return", 150);
        case 9:
          return _context3.abrupt("return", 2.5);
        case 10:
          return _context3.abrupt("return", defaultBlockTimeSeconds);
        case 11:
          return _context3.abrupt("return", defaultBlockTimeSeconds);
        case 12:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _averageBlockTimeSeconds.apply(this, arguments);
}
function estimateBlocksElapsed(_x5, _x6, _x7) {
  return _estimateBlocksElapsed.apply(this, arguments);
}
function _estimateBlocksElapsed() {
  _estimateBlocksElapsed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(seconds, cushionPercentage, chainId) {
    var cushionMultiplier, averageBlockTime;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          if (cushionPercentage === void 0) {
            cushionPercentage = 0.0;
          }
          cushionMultiplier = cushionPercentage + 1.0;
          _context4.next = 4;
          return averageBlockTimeSeconds(chainId);
        case 4:
          averageBlockTime = _context4.sent;
          return _context4.abrupt("return", Math.floor(seconds * cushionMultiplier / averageBlockTime));
        case 6:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _estimateBlocksElapsed.apply(this, arguments);
}

var utils = {
  __proto__: null,
  exists: exists,
  Balances: Balances,
  ConvertDecimals: ConvertDecimals,
  sleep: sleep,
  loop: loop,
  BatchReadWithErrors: BatchReadWithErrors,
  averageBlockTimeSeconds: averageBlockTimeSeconds,
  estimateBlocksElapsed: estimateBlocksElapsed
};

var Factory$1 = ExpiringMultiPartyEthers__factory;
function connect$1(address, provider) {
  return Factory$1.connect(address, provider);
}
// experimenting with a generalized way of handling events and returning state, inspired from react style reducers
function reduceEvents$1(state, event) {
  if (state === void 0) {
    state = {};
  }
  switch (event.event) {
    case "RequestTransferPositionExecuted":
      {
        var typedEvent = event;
        var _typedEvent$args = typedEvent.args,
          oldSponsor = _typedEvent$args.oldSponsor,
          newSponsor = _typedEvent$args.newSponsor;
        var tokens = Balances(state.tokens || {});
        var collateral = Balances(state.collateral || {});
        var collateralBalance = collateral.get(oldSponsor);
        collateral.set(oldSponsor, "0");
        collateral.set(newSponsor, collateralBalance);
        var tokenBalance = tokens.get(oldSponsor);
        tokens.set(oldSponsor, "0");
        tokens.set(newSponsor, tokenBalance.toString());
        return _extends({}, state, {
          collateral: collateral.balances,
          tokens: tokens.balances
        });
      }
    case "PositionCreated":
      {
        var _typedEvent = event;
        var _typedEvent$args2 = _typedEvent.args,
          sponsor = _typedEvent$args2.sponsor,
          collateralAmount = _typedEvent$args2.collateralAmount,
          tokenAmount = _typedEvent$args2.tokenAmount;
        var _tokens = Balances(state.tokens || {});
        var _collateral = Balances(state.collateral || {});
        _collateral.add(sponsor, collateralAmount.toString());
        _tokens.add(sponsor, tokenAmount.toString());
        return _extends({}, state, {
          collateral: _collateral.balances,
          tokens: _tokens.balances
        });
      }
    case "NewSponsor":
      {
        var _typedEvent2 = event;
        var _sponsor = _typedEvent2.args.sponsor;
        var sponsors = new Set(state.sponsors || []);
        sponsors.add(_sponsor);
        return _extends({}, state, {
          sponsors: Array.from(sponsors.values())
        });
      }
    case "SettleExpiredPosition":
      {
        var _typedEvent3 = event;
        var _typedEvent3$args = _typedEvent3.args,
          caller = _typedEvent3$args.caller,
          collateralReturned = _typedEvent3$args.collateralReturned,
          tokensBurned = _typedEvent3$args.tokensBurned;
        var _tokens2 = Balances(state.tokens || {});
        var _collateral2 = Balances(state.collateral || {});
        _collateral2.sub(caller, collateralReturned.toString());
        _tokens2.sub(caller, tokensBurned.toString());
        return _extends({}, state, {
          expired: true,
          collateral: _collateral2.balances,
          tokens: _tokens2.balances
        });
      }
    case "Redeem":
      {
        var _typedEvent4 = event;
        var _typedEvent4$args = _typedEvent4.args,
          _sponsor2 = _typedEvent4$args.sponsor,
          _collateralAmount = _typedEvent4$args.collateralAmount,
          _tokenAmount = _typedEvent4$args.tokenAmount;
        var _tokens3 = Balances(state.tokens || {});
        var _collateral3 = Balances(state.collateral || {});
        _collateral3.sub(_sponsor2, _collateralAmount.toString());
        _tokens3.sub(_sponsor2, _tokenAmount.toString());
        return _extends({}, state, {
          collateral: _collateral3.balances,
          tokens: _tokens3.balances
        });
      }
    case "LiquidationCreated":
      {
        var _typedEvent5 = event;
        var _typedEvent5$args = _typedEvent5.args,
          _sponsor3 = _typedEvent5$args.sponsor,
          tokensOutstanding = _typedEvent5$args.tokensOutstanding,
          liquidatedCollateral = _typedEvent5$args.liquidatedCollateral;
        var _tokens4 = Balances(state.tokens || {});
        var _collateral4 = Balances(state.collateral || {});
        _collateral4.sub(_sponsor3, liquidatedCollateral.toString());
        _tokens4.sub(_sponsor3, tokensOutstanding.toString());
        return _extends({}, state, {
          collateral: _collateral4.balances,
          tokens: _tokens4.balances
        });
      }
    // these 2 are the same
    case "Withdrawal":
    case "RequestWithdrawalExecuted":
      {
        var _typedEvent6 = event;
        var _typedEvent6$args = _typedEvent6.args,
          _sponsor4 = _typedEvent6$args.sponsor,
          _collateralAmount2 = _typedEvent6$args.collateralAmount;
        var _collateral5 = Balances(state.collateral || {});
        _collateral5.sub(_sponsor4, _collateralAmount2.toString());
        return _extends({}, state, {
          collateral: _collateral5.balances
        });
      }
    case "ContractExpired":
      {
        return _extends({}, state, {
          expired: true
        });
      }
  }
  return state;
}
function getEventState$1(events, initialState) {
  if (initialState === void 0) {
    initialState = {};
  }
  return events.reduce(reduceEvents$1, initialState);
}



var index$1 = {
  __proto__: null,
  connect: connect$1,
  reduceEvents: reduceEvents$1,
  getEventState: getEventState$1
};

var Factory$2 = ERC20Ethers__factory;
function connect$2(address, provider) {
  return Factory$2.connect(address, provider);
}
// takes all events and returns user balances and approvals
function reduceEvents$2(state, event) {
  if (state === void 0) {
    state = {};
  }
  switch (event.event) {
    case "Transfer":
      {
        var typedEvent = event;
        var _typedEvent$args = typedEvent.args,
          from = _typedEvent$args.from,
          to = _typedEvent$args.to,
          value = _typedEvent$args.value;
        var balances = Balances(state.balances || {});
        balances.sub(from, value);
        balances.add(to, value);
        return _extends({}, state, {
          balances: balances.balances
        });
      }
    case "Approval":
      {
        var _typedEvent = event;
        var _typedEvent$args2 = _typedEvent.args,
          owner = _typedEvent$args2.owner,
          spender = _typedEvent$args2.spender,
          _value = _typedEvent$args2.value;
        set(state, ["approvalsByOwner", owner, spender], _value.toString());
        set(state, ["approvalsBySpender", spender, owner], _value.toString());
        return _extends({}, state);
      }
  }
  return state;
}
function getEventState$2(events, initialState) {
  if (initialState === void 0) {
    initialState = {};
  }
  return events.reduce(reduceEvents$2, initialState);
}



var index$2 = {
  __proto__: null,
  connect: connect$2,
  reduceEvents: reduceEvents$2,
  getEventState: getEventState$2
};

var Factory$3 = MulticallEthers__factory;
function connect$3(address, provider) {
  return Factory$3.connect(address, provider);
}



var index$3 = {
  __proto__: null,
  connect: connect$3
};

var Factory$4 = Multicall2Ethers__factory;
function connect$4(address, provider) {
  return Factory$4.connect(address, provider);
}



var index$4 = {
  __proto__: null,
  connect: connect$4
};

var Factory$5 = LongShortPairCreatorEthers__factory;
function connect$5(address, provider) {
  return Factory$5.connect(address, provider);
}
function reduceEvents$3(state, event) {
  switch (event.event) {
    case "CreatedLongShortPair":
      {
        var _extends2;
        var typedEvent = event;
        var contracts = (state == null ? void 0 : state.contracts) || {};
        return _extends({}, state, {
          contracts: _extends({}, contracts, (_extends2 = {}, _extends2[typedEvent.args.longShortPair] = typedEvent, _extends2))
        });
      }
  }
  return state;
}
function getEventState$3(events, eventState) {
  if (eventState === void 0) {
    eventState = {};
  }
  return events.reduce(reduceEvents$3, eventState);
}



var index$5 = {
  __proto__: null,
  getAddress: getLongShortPairCreatorAddress,
  getAbi: getLongShortPairCreatorAbi,
  connect: connect$5,
  reduceEvents: reduceEvents$3,
  getEventState: getEventState$3
};

var Factory$6 = LongShortPairEthers__factory;
function connect$6(address, provider) {
  return Factory$6.connect(address, provider);
}
function reduceEvents$4(state, event) {
  switch (event.event) {
    case "TokensCreated":
      {
        var typedEvent = event;
        var _typedEvent$args = typedEvent.args,
          sponsor = _typedEvent$args.sponsor,
          collateralUsed = _typedEvent$args.collateralUsed,
          tokensMinted = _typedEvent$args.tokensMinted;
        var sponsors = new Set(state.sponsors || []);
        var longs = Balances(state.longs || {});
        var shorts = Balances(state.shorts || {});
        var collateral = Balances(state.collateral || {});
        sponsors.add(sponsor);
        longs.add(sponsor, tokensMinted);
        shorts.add(sponsor, tokensMinted);
        collateral.add(sponsor, collateralUsed);
        return _extends({}, state, {
          collateral: collateral.balances,
          shorts: shorts.balances,
          longs: longs.balances,
          sponsors: Array.from(sponsors.values())
        });
      }
    case "TokensRedeemed":
      {
        var _typedEvent = event;
        var _typedEvent$args2 = _typedEvent.args,
          _sponsor = _typedEvent$args2.sponsor,
          collateralReturned = _typedEvent$args2.collateralReturned,
          tokensRedeemed = _typedEvent$args2.tokensRedeemed;
        var _longs = Balances(state.longs || {});
        var _shorts = Balances(state.shorts || {});
        var _collateral = Balances(state.collateral || {});
        _longs.sub(_sponsor, tokensRedeemed);
        _shorts.sub(_sponsor, tokensRedeemed);
        _collateral.sub(_sponsor, collateralReturned);
        return _extends({}, state, {
          collateral: _collateral.balances,
          shorts: _shorts.balances,
          longs: _longs.balances
        });
      }
    case "ContractExpired":
      {
        var _typedEvent2 = event;
        var caller = _typedEvent2.args.caller;
        return _extends({}, state, {
          expired: true,
          expiredBy: caller
        });
      }
    case "PositionSettled":
      {
        var _typedEvent3 = event;
        var _typedEvent3$args = _typedEvent3.args,
          _sponsor2 = _typedEvent3$args.sponsor,
          _collateralReturned = _typedEvent3$args.collateralReturned,
          longTokens = _typedEvent3$args.longTokens,
          shortTokens = _typedEvent3$args.shortTokens;
        var _longs2 = Balances(state.longs || {});
        var _shorts2 = Balances(state.shorts || {});
        var _collateral2 = Balances(state.collateral || {});
        _longs2.sub(_sponsor2, longTokens);
        _shorts2.sub(_sponsor2, shortTokens);
        _collateral2.sub(_sponsor2, _collateralReturned);
        return _extends({}, state, {
          collateral: _collateral2.balances,
          shorts: _shorts2.balances,
          longs: _longs2.balances
        });
      }
  }
  return state;
}
function getEventState$4(events, eventState) {
  if (eventState === void 0) {
    eventState = {};
  }
  return events.reduce(reduceEvents$4, eventState);
}



var index$6 = {
  __proto__: null,
  connect: connect$6,
  reduceEvents: reduceEvents$4,
  getEventState: getEventState$4
};

var Factory$7 = BridgeDepositBoxEthers__factory;
function connect$7(address, provider) {
  return Factory$7.connect(address, provider);
}
function reduceEvents$5(state, event) {
  switch (event.event) {
    case "SetMinimumBridgingDelay":
      {
        var typedEvent = event;
        var newMinimumBridgingDelay = typedEvent.args.newMinimumBridgingDelay;
        return _extends({}, state, {
          minimumBridgingDelay: newMinimumBridgingDelay.toString()
        });
      }
    case "WhitelistToken":
      {
        var _extends2;
        var _typedEvent = event;
        var _typedEvent$args = _typedEvent.args,
          l1Token = _typedEvent$args.l1Token,
          l2Token = _typedEvent$args.l2Token,
          lastBridgeTime = _typedEvent$args.lastBridgeTime,
          bridgePool = _typedEvent$args.bridgePool;
        return _extends({}, state, {
          whitelistedTokens: _extends({}, state.whitelistedTokens, (_extends2 = {}, _extends2[l2Token] = {
            l1Token: l1Token,
            l2Token: l2Token,
            lastBridgeTime: lastBridgeTime,
            bridgePool: bridgePool
          }, _extends2))
        });
      }
    case "DepositsEnabled":
      {
        var _extends3;
        var _typedEvent2 = event;
        var _typedEvent2$args = _typedEvent2.args,
          _l2Token = _typedEvent2$args.l2Token,
          depositsEnabled = _typedEvent2$args.depositsEnabled;
        return _extends({}, state, {
          depositsEnabled: _extends({}, state.depositsEnabled, (_extends3 = {}, _extends3[_l2Token] = depositsEnabled, _extends3))
        });
      }
    case "FundsDeposited":
      {
        var _extends4;
        var _typedEvent3 = event;
        var _typedEvent3$args = _typedEvent3.args,
          chainId = _typedEvent3$args.chainId,
          depositId = _typedEvent3$args.depositId,
          l1Recipient = _typedEvent3$args.l1Recipient,
          l2Sender = _typedEvent3$args.l2Sender,
          _l1Token = _typedEvent3$args.l1Token,
          amount = _typedEvent3$args.amount,
          slowRelayFeePct = _typedEvent3$args.slowRelayFeePct,
          instantRelayFeePct = _typedEvent3$args.instantRelayFeePct,
          quoteTimestamp = _typedEvent3$args.quoteTimestamp;
        return _extends({}, state, {
          deposits: _extends({}, state.deposits, (_extends4 = {}, _extends4[depositId.toString()] = {
            chainId: chainId,
            depositId: depositId,
            l1Recipient: l1Recipient,
            l2Sender: l2Sender,
            l1Token: _l1Token,
            amount: amount,
            slowRelayFeePct: slowRelayFeePct,
            instantRelayFeePct: instantRelayFeePct,
            quoteTimestamp: quoteTimestamp
          }, _extends4))
        });
      }
  }
  return state;
}
function getEventState$5(events, eventState) {
  if (eventState === void 0) {
    eventState = {};
  }
  return events.reduce(reduceEvents$5, eventState);
}



var index$7 = {
  __proto__: null,
  connect: connect$7,
  reduceEvents: reduceEvents$5,
  getEventState: getEventState$5
};

var Factory$8 = BridgePoolEthers__factory;
function connect$8(address, provider) {
  return Factory$8.connect(address, provider);
}
function attach(address) {
  return new Factory$8().attach(address);
}
function eventStateDefaults() {
  return {
    tokens: {},
    lpTokens: {},
    deposits: {},
    relays: {},
    instantRelays: {}
  };
}
function reduceEvents$6(state, event) {
  switch (event.event) {
    // event LiquidityAdded(address indexed token, uint256 amount, uint256 lpTokensMinted, address liquidityProvider);
    case "LiquidityAdded":
      {
        var typedEvent = event;
        var _typedEvent$args = typedEvent.args,
          amount = _typedEvent$args.amount,
          lpTokensMinted = _typedEvent$args.lpTokensMinted,
          liquidityProvider = _typedEvent$args.liquidityProvider;
        var tokens = Balances(state.tokens || {});
        var lpTokens = Balances(state.lpTokens || {});
        tokens.add(liquidityProvider, amount.toString());
        lpTokens.add(liquidityProvider, lpTokensMinted.toString());
        return _extends({}, state, {
          tokens: _extends({}, tokens.balances),
          lpTokens: _extends({}, lpTokens.balances)
        });
      }
    // event LiquidityRemoved(address indexed token, uint256 amount, uint256 lpTokensBurnt, address liquidityProvider);
    case "LiquidityRemoved":
      {
        var _typedEvent = event;
        var _typedEvent$args2 = _typedEvent.args,
          _amount = _typedEvent$args2.amount,
          lpTokensBurnt = _typedEvent$args2.lpTokensBurnt,
          _liquidityProvider = _typedEvent$args2.liquidityProvider;
        var _tokens = Balances(state.tokens || {});
        var _lpTokens = Balances(state.lpTokens || {});
        _tokens.sub(_liquidityProvider, _amount.toString());
        _lpTokens.sub(_liquidityProvider, lpTokensBurnt.toString());
        return _extends({}, state, {
          tokens: _extends({}, _tokens.balances),
          lpTokens: _extends({}, _lpTokens.balances)
        });
      }
    // event DepositRelayed( bytes32 indexed depositHash, DepositData depositData, address l1Token, RelayData relay, bytes32 relayAncillaryDataHash);
    case "DepositRelayed":
      {
        var _extends2, _extends3;
        var _typedEvent2 = event;
        var _typedEvent2$args = _typedEvent2.args,
          depositHash = _typedEvent2$args.depositHash,
          depositData = _typedEvent2$args.depositData,
          relay = _typedEvent2$args.relay,
          relayAncillaryDataHash = _typedEvent2$args.relayAncillaryDataHash;
        return _extends({}, state, {
          relays: _extends({}, state.relays, (_extends2 = {}, _extends2[relayAncillaryDataHash] = relay, _extends2)),
          deposits: _extends({}, state.deposits, (_extends3 = {}, _extends3[depositHash] = depositData, _extends3))
        });
      }
    // event RelaySpedUp(bytes32 indexed depositHash, address indexed instantRelayer, RelayData relay);
    case "RelaySpedUp":
      {
        var _extends4;
        var _typedEvent3 = event;
        var _typedEvent3$args = _typedEvent3.args,
          _depositHash = _typedEvent3$args.depositHash,
          instantRelayer = _typedEvent3$args.instantRelayer;
        return _extends({}, state, {
          instantRelays: _extends({}, state.instantRelays || {}, (_extends4 = {}, _extends4[_depositHash] = instantRelayer, _extends4))
        });
      }
    // event RelayDisputed(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);
    case "RelayDisputed":
      {
        // TODO: finish implementation
        // const typedEvent = event as RelayDisputed;
        // const { depositHash, relayHash, disputer } = typedEvent.args;
        return state;
      }
    // event RelayCanceled(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);
    case "RelayCanceled":
      {
        // TODO: finish implementation
        // const typedEvent = event as RelayCanceled;
        // const { depositHash, relayHash, disputer } = typedEvent.args;
        return state;
      }
    // event RelaySettled(bytes32 indexed depositHash, address indexed caller, RelayData relay);
    case "RelaySettled":
      {
        // TODO: finish implementation
        // const typedEvent = event as RelaySettled;
        // const { depositHash, caller, relay } = typedEvent.args;
        return state;
      }
    // event BridgePoolAdminTransferred(address oldAdmin, address newAdmin);
    case "BridgePoolAdminTransferred":
      {
        var _typedEvent4 = event;
        var _typedEvent4$args = _typedEvent4.args,
          oldAdmin = _typedEvent4$args.oldAdmin,
          newAdmin = _typedEvent4$args.newAdmin;
        return _extends({}, state, {
          oldAdmin: oldAdmin,
          newAdmin: newAdmin
        });
      }
  }
  return state;
}
function getEventState$6(events, eventState) {
  if (eventState === void 0) {
    eventState = eventStateDefaults();
  }
  return events.reduce(reduceEvents$6, eventState);
}



var index$8 = {
  __proto__: null,
  Factory: Factory$8,
  connect: connect$8,
  attach: attach,
  eventStateDefaults: eventStateDefaults,
  reduceEvents: reduceEvents$6,
  getEventState: getEventState$6
};

var Etherchain = /*#__PURE__*/function () {
  function Etherchain(url) {
    if (url === void 0) {
      url = "https://www.etherchain.org/api";
    }
    this.url = url;
  }
  var _proto = Etherchain.prototype;
  _proto.getGasPrice = /*#__PURE__*/function () {
    var _getGasPrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var endpoint, result, msg;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            endpoint = this.url + "/gasPriceOracle";
            _context.next = 4;
            return axios.get(endpoint);
          case 4:
            result = _context.sent;
            return _context.abrupt("return", result.data);
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            msg = get(_context.t0, "response.data.error", get(_context.t0, "response.statusText", "Unknown Coingecko Error"));
            throw new Error(msg);
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[0, 8]]);
    }));
    function getGasPrice() {
      return _getGasPrice.apply(this, arguments);
    }
    return getGasPrice;
  }();
  return Etherchain;
}();



var index$9 = {
  __proto__: null,
  Etherchain: Etherchain
};

var Factory$9 = RateModelStoreEthers__factory;
function connect$9(address, provider) {
  return Factory$9.connect(address, provider);
}
function attach$1(address) {
  return new Factory$9().attach(address);
}



var rateModelStore = {
  __proto__: null,
  Factory: Factory$9,
  getAddress: getRateModelStoreAddress,
  connect: connect$9,
  attach: attach$1
};

var Factory$a = OptimisticOracleInterfaceEthers__factory;
function connect$a(address, provider) {
  return Factory$a.connect(address, provider);
}
var contractInterface = /*#__PURE__*/new utils$3.Interface( /*#__PURE__*/getOptimisticOracleInterfaceAbi());
var RequestState;
(function (RequestState) {
  RequestState[RequestState["Invalid"] = 0] = "Invalid";
  RequestState[RequestState["Requested"] = 1] = "Requested";
  RequestState[RequestState["Proposed"] = 2] = "Proposed";
  RequestState[RequestState["Expired"] = 3] = "Expired";
  RequestState[RequestState["Disputed"] = 4] = "Disputed";
  RequestState[RequestState["Resolved"] = 5] = "Resolved";
  RequestState[RequestState["Settled"] = 6] = "Settled";
})(RequestState || (RequestState = {}));
function requestId(request) {
  // if enabling sorting, put timestamp first
  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join("!");
}
function reduceEvents$7(state, event) {
  switch (event.event) {
    case "RequestPrice":
      {
        var typedEvent = event;
        var _typedEvent$args = typedEvent.args,
          requester = _typedEvent$args.requester,
          identifier = _typedEvent$args.identifier,
          timestamp = _typedEvent$args.timestamp,
          ancillaryData = _typedEvent$args.ancillaryData,
          currency = _typedEvent$args.currency,
          reward = _typedEvent$args.reward,
          finalFee = _typedEvent$args.finalFee;
        var id = requestId(typedEvent.args);
        if (!state.requests) state.requests = {};
        var request = state.requests[id] || {
          requester: requester,
          identifier: identifier,
          timestamp: timestamp,
          ancillaryData: ancillaryData
        };
        state.requests[id] = _extends({}, request, {
          currency: currency,
          reward: reward,
          finalFee: finalFee,
          state: RequestState.Requested,
          requestTx: event.transactionHash,
          requestBlockNumber: event.blockNumber,
          requestLogIndex: event.logIndex
        });
        break;
      }
    case "ProposePrice":
      {
        var _typedEvent = event;
        var _typedEvent$args2 = _typedEvent.args,
          _requester = _typedEvent$args2.requester,
          _identifier = _typedEvent$args2.identifier,
          _timestamp = _typedEvent$args2.timestamp,
          _ancillaryData = _typedEvent$args2.ancillaryData,
          proposer = _typedEvent$args2.proposer,
          proposedPrice = _typedEvent$args2.proposedPrice,
          expirationTimestamp = _typedEvent$args2.expirationTimestamp,
          _currency = _typedEvent$args2.currency;
        var _id = requestId(_typedEvent.args);
        if (!state.requests) state.requests = {};
        var _request = state.requests[_id] || {
          requester: _requester,
          identifier: _identifier,
          timestamp: _timestamp,
          ancillaryData: _ancillaryData
        };
        state.requests[_id] = _extends({}, _request, {
          currency: _currency,
          proposer: proposer,
          proposedPrice: proposedPrice,
          expirationTime: expirationTimestamp,
          state: RequestState.Proposed,
          proposeTx: event.transactionHash,
          proposeBlockNumber: event.blockNumber,
          proposeLogIndex: event.logIndex
        });
        break;
      }
    case "DisputePrice":
      {
        var _typedEvent2 = event;
        var _typedEvent2$args = _typedEvent2.args,
          _requester2 = _typedEvent2$args.requester,
          _identifier2 = _typedEvent2$args.identifier,
          _timestamp2 = _typedEvent2$args.timestamp,
          _ancillaryData2 = _typedEvent2$args.ancillaryData,
          _proposer = _typedEvent2$args.proposer,
          disputer = _typedEvent2$args.disputer,
          _proposedPrice = _typedEvent2$args.proposedPrice;
        var _id2 = requestId(_typedEvent2.args);
        if (!state.requests) state.requests = {};
        var _request2 = state.requests[_id2] || {
          requester: _requester2,
          identifier: _identifier2,
          timestamp: _timestamp2,
          ancillaryData: _ancillaryData2
        };
        state.requests[_id2] = _extends({}, _request2, {
          proposer: _proposer,
          disputer: disputer,
          proposedPrice: _proposedPrice,
          state: RequestState.Disputed,
          disputeTx: event.transactionHash,
          disputeBlockNumber: event.blockNumber,
          disputeLogIndex: event.logIndex
        });
        break;
      }
    case "Settle":
      {
        var _typedEvent3 = event;
        var _typedEvent3$args = _typedEvent3.args,
          _requester3 = _typedEvent3$args.requester,
          _identifier3 = _typedEvent3$args.identifier,
          _timestamp3 = _typedEvent3$args.timestamp,
          _ancillaryData3 = _typedEvent3$args.ancillaryData,
          _proposer2 = _typedEvent3$args.proposer,
          _disputer = _typedEvent3$args.disputer,
          price = _typedEvent3$args.price,
          payout = _typedEvent3$args.payout;
        var _id3 = requestId(_typedEvent3.args);
        if (!state.requests) state.requests = {};
        var _request3 = state.requests[_id3] || {
          requester: _requester3,
          identifier: _identifier3,
          timestamp: _timestamp3,
          ancillaryData: _ancillaryData3
        };
        state.requests[_id3] = _extends({}, _request3, {
          requester: _requester3,
          proposer: _proposer2,
          disputer: _disputer,
          price: price,
          payout: payout,
          state: RequestState.Settled,
          settleTx: event.transactionHash,
          settleBlockNumber: event.blockNumber,
          settleLogIndex: event.logIndex
        });
        break;
      }
  }
  return state;
}
function getEventState$7(events, eventState) {
  if (eventState === void 0) {
    eventState = {};
  }
  return events.reduce(reduceEvents$7, eventState);
}



var index$a = {
  __proto__: null,
  connect: connect$a,
  contractInterface: contractInterface,
  get RequestState () { return RequestState; },
  requestId: requestId,
  reduceEvents: reduceEvents$7,
  getEventState: getEventState$7
};

var Factory$b = SkinnyOptimisticOracleEthers__factory;
function connect$b(address, provider) {
  return Factory$b.connect(address, provider);
}
var contractInterface$1 = /*#__PURE__*/new utils$3.Interface( /*#__PURE__*/getSkinnyOptimisticOracleAbi());
var RequestState$1;
(function (RequestState) {
  RequestState[RequestState["Invalid"] = 0] = "Invalid";
  RequestState[RequestState["Requested"] = 1] = "Requested";
  RequestState[RequestState["Proposed"] = 2] = "Proposed";
  RequestState[RequestState["Expired"] = 3] = "Expired";
  RequestState[RequestState["Disputed"] = 4] = "Disputed";
  RequestState[RequestState["Resolved"] = 5] = "Resolved";
  RequestState[RequestState["Settled"] = 6] = "Settled";
})(RequestState$1 || (RequestState$1 = {}));
function requestId$1(request) {
  // if enabling sorting, put timestamp first
  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join("!");
}
function reduceEvents$8(state, event) {
  switch (event.event) {
    case "RequestPrice":
      {
        var typedEvent = event;
        var _typedEvent$args = typedEvent.args,
          requester = _typedEvent$args.requester,
          identifier = _typedEvent$args.identifier,
          timestamp = _typedEvent$args.timestamp,
          ancillaryData = _typedEvent$args.ancillaryData,
          request = _typedEvent$args.request;
        var id = requestId$1(typedEvent.args);
        if (!state.requests) state.requests = {};
        state.requests[id] = _extends({}, state.requests[id], request, {
          requester: requester,
          identifier: identifier,
          timestamp: timestamp,
          ancillaryData: ancillaryData,
          state: RequestState$1.Requested,
          requestTx: event.transactionHash,
          requestBlockNumber: event.blockNumber,
          requestLogIndex: event.logIndex
        });
        break;
      }
    case "ProposePrice":
      {
        var _typedEvent = event;
        var _typedEvent$args2 = _typedEvent.args,
          _requester = _typedEvent$args2.requester,
          _identifier = _typedEvent$args2.identifier,
          _timestamp = _typedEvent$args2.timestamp,
          _ancillaryData = _typedEvent$args2.ancillaryData,
          _request = _typedEvent$args2.request;
        var _id = requestId$1(_typedEvent.args);
        if (!state.requests) state.requests = {};
        state.requests[_id] = _extends({}, state.requests[_id], _request, {
          requester: _requester,
          identifier: _identifier,
          timestamp: _timestamp,
          ancillaryData: _ancillaryData,
          state: RequestState$1.Proposed,
          proposeTx: event.transactionHash,
          proposeBlockNumber: event.blockNumber,
          proposeLogIndex: event.logIndex
        });
        break;
      }
    case "DisputePrice":
      {
        var _typedEvent2 = event;
        var _typedEvent2$args = _typedEvent2.args,
          _requester2 = _typedEvent2$args.requester,
          _identifier2 = _typedEvent2$args.identifier,
          _timestamp2 = _typedEvent2$args.timestamp,
          _ancillaryData2 = _typedEvent2$args.ancillaryData,
          _request2 = _typedEvent2$args.request;
        var _id2 = requestId$1(_typedEvent2.args);
        if (!state.requests) state.requests = {};
        state.requests[_id2] = _extends({}, state.requests[_id2], _request2, {
          requester: _requester2,
          identifier: _identifier2,
          timestamp: _timestamp2,
          ancillaryData: _ancillaryData2,
          state: RequestState$1.Disputed,
          disputeTx: event.transactionHash,
          disputeBlockNumber: event.blockNumber,
          disputeLogIndex: event.logIndex
        });
        break;
      }
    case "Settle":
      {
        var _typedEvent3 = event;
        var _typedEvent3$args = _typedEvent3.args,
          _requester3 = _typedEvent3$args.requester,
          _identifier3 = _typedEvent3$args.identifier,
          _timestamp3 = _typedEvent3$args.timestamp,
          _ancillaryData3 = _typedEvent3$args.ancillaryData,
          _request3 = _typedEvent3$args.request;
        var _id3 = requestId$1(_typedEvent3.args);
        if (!state.requests) state.requests = {};
        state.requests[_id3] = _extends({}, state.requests[_id3], _request3, {
          requester: _requester3,
          identifier: _identifier3,
          timestamp: _timestamp3,
          ancillaryData: _ancillaryData3,
          state: RequestState$1.Settled,
          settleTx: event.transactionHash,
          settleBlockNumber: event.blockNumber,
          settleLogIndex: event.logIndex
        });
        break;
      }
  }
  return state;
}
function getEventState$8(events, eventState) {
  if (eventState === void 0) {
    eventState = {};
  }
  return events.reduce(reduceEvents$8, eventState);
}



var index$b = {
  __proto__: null,
  connect: connect$b,
  contractInterface: contractInterface$1,
  get RequestState () { return RequestState$1; },
  requestId: requestId$1,
  reduceEvents: reduceEvents$8,
  getEventState: getEventState$8
};

var Factory$c = OptimisticOracleV2InterfaceEthers__factory;
function connect$c(address, provider) {
  return Factory$c.connect(address, provider);
}
var contractInterface$2 = /*#__PURE__*/new utils$3.Interface( /*#__PURE__*/getOptimisticOracleV2InterfaceAbi());
var RequestState$2;
(function (RequestState) {
  RequestState[RequestState["Invalid"] = 0] = "Invalid";
  RequestState[RequestState["Requested"] = 1] = "Requested";
  RequestState[RequestState["Proposed"] = 2] = "Proposed";
  RequestState[RequestState["Expired"] = 3] = "Expired";
  RequestState[RequestState["Disputed"] = 4] = "Disputed";
  RequestState[RequestState["Resolved"] = 5] = "Resolved";
  RequestState[RequestState["Settled"] = 6] = "Settled";
})(RequestState$2 || (RequestState$2 = {}));
function requestId$2(request) {
  // if enabling sorting, put timestamp first
  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join("!");
}
function reduceEvents$9(state, event) {
  switch (event.event) {
    case "RequestPrice":
      {
        var typedEvent = event;
        var _typedEvent$args = typedEvent.args,
          requester = _typedEvent$args.requester,
          identifier = _typedEvent$args.identifier,
          timestamp = _typedEvent$args.timestamp,
          ancillaryData = _typedEvent$args.ancillaryData,
          currency = _typedEvent$args.currency,
          reward = _typedEvent$args.reward,
          finalFee = _typedEvent$args.finalFee;
        var id = requestId$2(typedEvent.args);
        if (!state.requests) state.requests = {};
        var request = state.requests[id] || {
          requester: requester,
          identifier: identifier,
          timestamp: timestamp,
          ancillaryData: ancillaryData
        };
        state.requests[id] = _extends({}, request, {
          currency: currency,
          reward: reward,
          finalFee: finalFee,
          state: RequestState$2.Requested,
          requestTx: event.transactionHash,
          requestBlockNumber: event.blockNumber,
          requestLogIndex: event.logIndex
        });
        break;
      }
    case "ProposePrice":
      {
        var _typedEvent = event;
        var _typedEvent$args2 = _typedEvent.args,
          _requester = _typedEvent$args2.requester,
          _identifier = _typedEvent$args2.identifier,
          _timestamp = _typedEvent$args2.timestamp,
          _ancillaryData = _typedEvent$args2.ancillaryData,
          proposer = _typedEvent$args2.proposer,
          proposedPrice = _typedEvent$args2.proposedPrice,
          expirationTimestamp = _typedEvent$args2.expirationTimestamp,
          _currency = _typedEvent$args2.currency;
        var _id = requestId$2(_typedEvent.args);
        if (!state.requests) state.requests = {};
        var _request = state.requests[_id] || {
          requester: _requester,
          identifier: _identifier,
          timestamp: _timestamp,
          ancillaryData: _ancillaryData
        };
        state.requests[_id] = _extends({}, _request, {
          currency: _currency,
          proposer: proposer,
          proposedPrice: proposedPrice,
          expirationTime: expirationTimestamp,
          state: RequestState$2.Proposed,
          proposeTx: event.transactionHash,
          proposeBlockNumber: event.blockNumber,
          proposeLogIndex: event.logIndex
        });
        break;
      }
    case "DisputePrice":
      {
        var _typedEvent2 = event;
        var _typedEvent2$args = _typedEvent2.args,
          _requester2 = _typedEvent2$args.requester,
          _identifier2 = _typedEvent2$args.identifier,
          _timestamp2 = _typedEvent2$args.timestamp,
          _ancillaryData2 = _typedEvent2$args.ancillaryData,
          _proposer = _typedEvent2$args.proposer,
          disputer = _typedEvent2$args.disputer,
          _proposedPrice = _typedEvent2$args.proposedPrice;
        var _id2 = requestId$2(_typedEvent2.args);
        if (!state.requests) state.requests = {};
        var _request2 = state.requests[_id2] || {
          requester: _requester2,
          identifier: _identifier2,
          timestamp: _timestamp2,
          ancillaryData: _ancillaryData2
        };
        state.requests[_id2] = _extends({}, _request2, {
          proposer: _proposer,
          disputer: disputer,
          proposedPrice: _proposedPrice,
          state: RequestState$2.Disputed,
          disputeTx: event.transactionHash,
          disputeBlockNumber: event.blockNumber,
          disputeLogIndex: event.logIndex
        });
        break;
      }
    case "Settle":
      {
        var _typedEvent3 = event;
        var _typedEvent3$args = _typedEvent3.args,
          _requester3 = _typedEvent3$args.requester,
          _identifier3 = _typedEvent3$args.identifier,
          _timestamp3 = _typedEvent3$args.timestamp,
          _ancillaryData3 = _typedEvent3$args.ancillaryData,
          _proposer2 = _typedEvent3$args.proposer,
          _disputer = _typedEvent3$args.disputer,
          price = _typedEvent3$args.price,
          payout = _typedEvent3$args.payout;
        var _id3 = requestId$2(_typedEvent3.args);
        if (!state.requests) state.requests = {};
        var _request3 = state.requests[_id3] || {
          requester: _requester3,
          identifier: _identifier3,
          timestamp: _timestamp3,
          ancillaryData: _ancillaryData3
        };
        state.requests[_id3] = _extends({}, _request3, {
          requester: _requester3,
          proposer: _proposer2,
          disputer: _disputer,
          price: price,
          payout: payout,
          state: RequestState$2.Settled,
          settleTx: event.transactionHash,
          settleBlockNumber: event.blockNumber,
          settleLogIndex: event.logIndex
        });
        break;
      }
  }
  return state;
}
function getEventState$9(events, eventState) {
  if (eventState === void 0) {
    eventState = {};
  }
  return events.reduce(reduceEvents$9, eventState);
}



var index$c = {
  __proto__: null,
  connect: connect$c,
  contractInterface: contractInterface$2,
  get RequestState () { return RequestState$2; },
  requestId: requestId$2,
  reduceEvents: reduceEvents$9,
  getEventState: getEventState$9
};



var index$d = {
  __proto__: null,
  registry: index,
  emp: index$1,
  erc20: index$2,
  multicall: index$3,
  multicall2: index$4,
  lspCreator: index$5,
  lsp: index$6,
  bridgeDepositBox: index$7,
  bridgePool: index$8,
  etherchain: index$9,
  rateModelStore: rateModelStore,
  optimisticOracle: index$a,
  skinnyOptimisticOracle: index$b,
  optimisticOracleV2: index$c
};

function JsMap (map) {
  if (map === void 0) {
    map = new Map();
  }
  function get(_x) {
    return _get.apply(this, arguments);
  }
  function _get() {
    _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(id) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", map.get(id));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _get.apply(this, arguments);
  }
  function set(_x2, _x3) {
    return _set.apply(this, arguments);
  }
  function _set() {
    _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id, data) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            map.set(id, data);
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _set.apply(this, arguments);
  }
  function has(_x4) {
    return _has.apply(this, arguments);
  }
  function _has() {
    _has = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", map.has(id));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _has.apply(this, arguments);
  }
  function del(_x5) {
    return _del.apply(this, arguments);
  }
  function _del() {
    _del = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            map["delete"](id);
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return _del.apply(this, arguments);
  }
  function entries() {
    return _entries.apply(this, arguments);
  }
  function _entries() {
    _entries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            return _context5.abrupt("return", Array.from(map.entries()));
          case 1:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    return _entries.apply(this, arguments);
  }
  function values() {
    return _values.apply(this, arguments);
  }
  function _values() {
    _values = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.abrupt("return", Array.from(map.values()));
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    return _values.apply(this, arguments);
  }
  function keys() {
    return _keys.apply(this, arguments);
  }
  function _keys() {
    _keys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            return _context7.abrupt("return", Array.from(map.keys()));
          case 1:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    return _keys.apply(this, arguments);
  }
  function size() {
    return _size.apply(this, arguments);
  }
  function _size() {
    _size = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            return _context8.abrupt("return", map.size);
          case 1:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    return _size.apply(this, arguments);
  }
  function clear() {
    return _clear.apply(this, arguments);
  }
  function _clear() {
    _clear = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            map.clear();
          case 1:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }));
    return _clear.apply(this, arguments);
  }
  return {
    get: get,
    set: set,
    has: has,
    "delete": del,
    entries: entries,
    values: values,
    keys: keys,
    size: size,
    clear: clear
  };
}

// this class will basically give you similar functionality to a sorted key value store this is really useful for
// time series data, and JS does not have a native way to do this, but comes for free with most NoSql databases.
function SortedJsMap () {
  var ids = [];
  var map = new Map();
  function getStart(id, inclusive) {
    if (inclusive === void 0) {
      inclusive = true;
    }
    if (inclusive) {
      return sortedIndex(ids, id);
    } else {
      return sortedLastIndex(ids, id);
    }
  }
  function getEnd(id, inclusive) {
    if (inclusive === void 0) {
      inclusive = false;
    }
    return getStart(id, !inclusive);
  }
  function del(id) {
    var index = sortedIndex(ids, id);
    ids.splice(index, 1);
    var result = map.get(id);
    map["delete"](id);
    return result;
  }
  // keeps typescript from complaining that return values may be undefined
  function getSafe(id) {
    var result = map.get(id);
    if (exists(result)) return result;
    throw new Error("Missing data for index: " + id);
  }
  return {
    has: function has(id) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", map.has(id));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    },
    set: function set(id, data) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var index;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (map.has(id)) {
                map.set(id, data);
              } else {
                index = sortedIndex(ids, id);
                ids.splice(index, 0, id);
                map.set(id, data);
              }
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    },
    get: function get(id) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", map.get(id));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    },
    values: function values() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", ids.map(getSafe));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }))();
    },
    entries: function entries() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", ids.map(function (id) {
                return [id, getSafe(id)];
              }));
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }))();
    },
    keys: function keys() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", [].concat(ids));
            case 1:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }))();
    },
    clear: function clear() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              map.clear();
              ids.length = 0;
            case 2:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }))();
    },
    size: function size() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              return _context8.abrupt("return", ids.length);
            case 1:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }))();
    },
    "delete": function _delete(id) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (map.has(id)) {
                _context9.next = 2;
                break;
              }
              return _context9.abrupt("return");
            case 2:
              del(id);
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }))();
    },
    // assume [a,b)
    between: function between(a, b) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var start, end;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              start = getStart(a);
              end = getEnd(b);
              return _context10.abrupt("return", ids.slice(start, end).map(getSafe));
            case 3:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }))();
    },
    slice: function slice(id, length) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var start;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              start = getStart(id);
              return _context11.abrupt("return", ids.slice(start, start + length).map(getSafe));
            case 2:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }))();
    }
  };
}

//-
// Use an array, `excludeFromIndexes`, to exclude properties from indexing.
// This will allow storing string values larger than 1500 bytes.
// Example:
// [
//   'description',
//   'embeddedEntity.description',
//   'arrayValue[]',
//   'arrayValue[].description'
// ]
//-
function store (kind, store, excludeFromIndexes) {
  if (excludeFromIndexes === void 0) {
    excludeFromIndexes = [];
  }
  function makeKey(id) {
    return store.key([kind, id]);
  }
  // return value or undefined if it doesnt exist
  function get(_x) {
    return _get.apply(this, arguments);
  }
  function _get() {
    _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(id) {
      var _yield$store$get, result;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return store.get(makeKey(id));
          case 3:
            _yield$store$get = _context.sent;
            result = _yield$store$get[0];
            return _context.abrupt("return", result);
          case 8:
            _context.prev = 8;
            _context.t0 = _context["catch"](0);
            return _context.abrupt("return");
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 8]]);
    }));
    return _get.apply(this, arguments);
  }
  function set(_x2, _x3) {
    return _set.apply(this, arguments);
  }
  function _set() {
    _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id, data) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return store.save({
              key: makeKey(id),
              data: data,
              excludeFromIndexes: excludeFromIndexes
            });
          case 2:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _set.apply(this, arguments);
  }
  function has(_x4) {
    return _has.apply(this, arguments);
  }
  function _has() {
    _has = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.t0 = exists;
            _context3.next = 3;
            return get(id);
          case 3:
            _context3.t1 = _context3.sent;
            return _context3.abrupt("return", (0, _context3.t0)(_context3.t1));
          case 5:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _has.apply(this, arguments);
  }
  function del(_x5) {
    return _del.apply(this, arguments);
  }
  function _del() {
    _del = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return store["delete"](makeKey(id));
          case 2:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return _del.apply(this, arguments);
  }
  function entries() {
    return _entries.apply(this, arguments);
  }
  function _entries() {
    _entries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var _yield$store$createQu, results;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return store.createQuery(kind).run();
          case 2:
            _yield$store$createQu = _context5.sent;
            results = _yield$store$createQu[0];
            return _context5.abrupt("return", results.map(function (result) {
              return [result[store.KEY].name, result];
            }));
          case 5:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    return _entries.apply(this, arguments);
  }
  function values() {
    return _values.apply(this, arguments);
  } // all this does is map over full entries to return the id of the entry. have not found a better way to query this.
  function _values() {
    _values = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var _yield$store$createQu2, results;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return store.createQuery(kind).run();
          case 2:
            _yield$store$createQu2 = _context6.sent;
            results = _yield$store$createQu2[0];
            return _context6.abrupt("return", results);
          case 5:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    return _values.apply(this, arguments);
  }
  function keys() {
    return _keys.apply(this, arguments);
  } // theres no way to really do built into the store client. Google recommends managing a size entry yourself.
  function _keys() {
    _keys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var _yield$store$createQu3, results;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return store.createQuery(kind).select("__key__").run();
          case 2:
            _yield$store$createQu3 = _context7.sent;
            results = _yield$store$createQu3[0];
            return _context7.abrupt("return", results.map(function (result) {
              return result[store.KEY].name;
            }));
          case 5:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    return _keys.apply(this, arguments);
  }
  function size() {
    return _size.apply(this, arguments);
  } // this actually queries all values, then batches them to delete N at a time. This is a horrible way
  // to do this, but I could not find a better way to "drop" all kinds from the table.
  function _size() {
    _size = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            throw new Error("size not supported in google store");
          case 1:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    return _size.apply(this, arguments);
  }
  function clear() {
    return _clear.apply(this, arguments);
  }
  function _clear() {
    _clear = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return highland(store.createQuery(kind).runStream()).map(function (val) {
              return val[store.KEY];
            }).batch(500).map( /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(keys) {
                return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                  while (1) switch (_context9.prev = _context9.next) {
                    case 0:
                      return _context9.abrupt("return", store["delete"](keys));
                    case 1:
                    case "end":
                      return _context9.stop();
                  }
                }, _callee9);
              }));
              return function (_x10) {
                return _ref.apply(this, arguments);
              };
            }()).flatMap(highland).collect().toPromise(Promise);
          case 2:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    return _clear.apply(this, arguments);
  }
  function slice(_x6, _x7) {
    return _slice.apply(this, arguments);
  }
  function _slice() {
    _slice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(id, length) {
      var _yield$store$createQu4, result;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            _context11.next = 2;
            return store.createQuery(kind).filter("__key__", ">=", makeKey(id)).limit(length).run();
          case 2:
            _yield$store$createQu4 = _context11.sent;
            result = _yield$store$createQu4[0];
            return _context11.abrupt("return", result);
          case 5:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    }));
    return _slice.apply(this, arguments);
  }
  function between(_x8, _x9) {
    return _between.apply(this, arguments);
  }
  function _between() {
    _between = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(a, b) {
      var _yield$store$createQu5, result;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return store.createQuery(kind).filter("__key__", ">=", makeKey(a)).filter("__key__", "<", makeKey(b)).run();
          case 2:
            _yield$store$createQu5 = _context12.sent;
            result = _yield$store$createQu5[0];
            return _context12.abrupt("return", result);
          case 5:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    }));
    return _between.apply(this, arguments);
  }
  return {
    get: get,
    set: set,
    has: has,
    "delete": del,
    entries: entries,
    values: values,
    keys: keys,
    size: size,
    clear: clear,
    between: between,
    slice: slice
  };
}



var index$e = {
  __proto__: null,
  JsMap: JsMap,
  SortedJsMap: SortedJsMap,
  GoogleDatastore: store
};

function Table(config, store) {
  var makeId = config.makeId,
    type = config.type;
  function create(_x) {
    return _create.apply(this, arguments);
  }
  function _create() {
    _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {
      var id;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            id = exists(data.id) ? data.id : makeId(data);
            _context.t0 = assert;
            _context.next = 4;
            return has(id);
          case 4:
            _context.t1 = !_context.sent;
            _context.t2 = type + " exists: " + id;
            (0, _context.t0)(_context.t1, _context.t2);
            return _context.abrupt("return", set(_extends({
              id: id
            }, data)));
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _create.apply(this, arguments);
  }
  function set(_x2) {
    return _set.apply(this, arguments);
  }
  function _set() {
    _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return store.set(data.id, _extends({}, data));
          case 2:
            return _context2.abrupt("return", data);
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _set.apply(this, arguments);
  }
  function get(_x3) {
    return _get.apply(this, arguments);
  }
  function _get() {
    _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(id) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.t0 = assert;
            _context3.next = 3;
            return store.has(id);
          case 3:
            _context3.t1 = _context3.sent;
            _context3.t2 = type + " does not exist";
            (0, _context3.t0)(_context3.t1, _context3.t2);
            _context3.next = 8;
            return store.get(id);
          case 8:
            return _context3.abrupt("return", _context3.sent);
          case 9:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _get.apply(this, arguments);
  }
  function has(_x4) {
    return _has.apply(this, arguments);
  }
  function _has() {
    _has = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", store.has(id));
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return _has.apply(this, arguments);
  }
  function update(_x5, _x6) {
    return _update.apply(this, arguments);
  }
  function _update() {
    _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(id, data) {
      var got;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return get(id);
          case 2:
            got = _context5.sent;
            return _context5.abrupt("return", set(_extends({}, got, data)));
          case 4:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    return _update.apply(this, arguments);
  }
  return _extends({}, store, {
    create: create,
    set: set,
    get: get,
    has: has,
    update: update,
    makeId: makeId,
    type: type
  });
}

function makeId(data) {
  return data.number;
}

// personally dont like to have this as a named export, but cannot export both function and type as default
var Table$1 = function Table$1(type, store) {
  if (type === void 0) {
    type = "Block";
  }
  if (store === void 0) {
    store = JsMap();
  }
  var table = Table({
    type: type,
    makeId: makeId
  }, store);
  // delete blocks older than timestamp
  function prune(_x) {
    return _prune.apply(this, arguments);
  }
  function _prune() {
    _prune = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(timestamp) {
      var blocks, deleted, _iterator, _step, block, _block$id;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return table.values();
          case 2:
            blocks = _context.sent;
            deleted = []; // normally would use a map or filter, but dont want to include bluebird as a dependency
            _iterator = _createForOfIteratorHelperLoose(blocks);
          case 5:
            if ((_step = _iterator()).done) {
              _context.next = 13;
              break;
            }
            block = _step.value;
            if (!(block.timestamp < timestamp)) {
              _context.next = 11;
              break;
            }
            _context.next = 10;
            return table["delete"]((_block$id = block.id) != null ? _block$id : block.number);
          case 10:
            deleted.push(block);
          case 11:
            _context.next = 5;
            break;
          case 13:
            return _context.abrupt("return", deleted);
          case 14:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _prune.apply(this, arguments);
  }
  return _extends({}, table, {
    prune: prune
  });
};



var index$f = {
  __proto__: null,
  Table: Table$1,
  makeId: makeId
};

function makeId$1(data) {
  return data.address;
}

var Table$2 = function Table$1(type, store) {
  if (type === void 0) {
    type = "Emp";
  }
  if (store === void 0) {
    store = JsMap();
  }
  var table = Table({
    type: type,
    makeId: makeId$1
  }, store);
  function addSponsors(_x, _x2) {
    return _addSponsors.apply(this, arguments);
  }
  function _addSponsors() {
    _addSponsors = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(id, sponsors) {
      var data, set;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return table.get(id);
          case 2:
            data = _context.sent;
            // keep sponsors unique
            set = new Set([].concat(data.sponsors || [], sponsors));
            return _context.abrupt("return", table.update(id, {
              sponsors: Array.from(set.values())
            }));
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _addSponsors.apply(this, arguments);
  }
  function setCreatedTimestamp(_x3, _x4) {
    return _setCreatedTimestamp.apply(this, arguments);
  }
  function _setCreatedTimestamp() {
    _setCreatedTimestamp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id, timestamp) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", table.update(id, {
              createdTimestamp: timestamp
            }));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _setCreatedTimestamp.apply(this, arguments);
  }
  return _extends({}, table, {
    addSponsors: addSponsors,
    setCreatedTimestamp: setCreatedTimestamp
  });
};



var index$g = {
  __proto__: null,
  Table: Table$2,
  makeId: makeId$1
};

function makeId$2(data) {
  return data.timestamp.toString().padStart(24, "0");
}

var Table$3 = function Table$1(type, store) {
  if (type === void 0) {
    type = "Historical Price";
  }
  if (store === void 0) {
    store = SortedJsMap();
  }
  var table = Table({
    type: type,
    makeId: makeId$2
  }, store);
  function betweenByTimestamp(a, b) {
    return table.between(makeId$2({
      timestamp: a
    }), makeId$2({
      timestamp: b
    }));
  }
  function sliceByTimestamp(timestamp, length) {
    return table.slice(makeId$2({
      timestamp: timestamp
    }), length);
  }
  function hasByTimestamp(timestamp) {
    return table.has(makeId$2({
      timestamp: timestamp
    }));
  }
  function getByTimestamp(timestamp) {
    return table.get(makeId$2({
      timestamp: timestamp
    }));
  }
  return _extends({}, table, {
    betweenByTimestamp: betweenByTimestamp,
    sliceByTimestamp: sliceByTimestamp,
    hasByTimestamp: hasByTimestamp,
    getByTimestamp: getByTimestamp
  });
};



var index$h = {
  __proto__: null,
  Table: Table$3,
  makeId: makeId$2
};

function makeId$3(data) {
  return data.address;
}

var Table$4 = function Table$1(type, store) {
  if (type === void 0) {
    type = "Token";
  }
  if (store === void 0) {
    store = JsMap();
  }
  var table = Table({
    type: type,
    makeId: makeId$3
  }, store);
  function getOrCreate(_x) {
    return _getOrCreate.apply(this, arguments);
  }
  function _getOrCreate() {
    _getOrCreate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(address) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return table.has(makeId$3({
              address: address
            }));
          case 2:
            if (_context.sent) {
              _context.next = 4;
              break;
            }
            return _context.abrupt("return", table.create({
              address: address
            }));
          case 4:
            return _context.abrupt("return", table.get(makeId$3({
              address: address
            })));
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _getOrCreate.apply(this, arguments);
  }
  function upsert(_x2, _x3) {
    return _upsert.apply(this, arguments);
  }
  function _upsert() {
    _upsert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(address, data) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getOrCreate(address);
          case 2:
            return _context2.abrupt("return", table.update(address, data));
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _upsert.apply(this, arguments);
  }
  return _extends({}, table, {
    getOrCreate: getOrCreate,
    upsert: upsert
  });
};



var index$i = {
  __proto__: null,
  Table: Table$4,
  makeId: makeId$3
};



var index$j = {
  __proto__: null,
  blocks: index$f,
  emps: index$g,
  historicalPrices: index$h,
  erc20s: index$i,
  base: Table
};

/**
 * toBN.
 *
 * @param {BigNumberish} num
 * @returns {BN}
 */
var toBN = function toBN(num) {
  return BigNumber.from(num.toString());
};
/**
 * toBNWei.
 *
 * @param {BigNumberish} num
 * @param {number} decimals
 * @returns {BN}
 */
var toBNWei = function toBNWei(num, decimals) {
  return ethers$1.utils.parseUnits(num.toString(), decimals);
};
/**
 * toWei.
 *
 * @param {BigNumberish} num
 * @param {number} decimals
 * @returns {string}
 */
var toWei = function toWei(num, decimals) {
  return toBNWei(num, decimals).toString();
};
/**
 * fromWei.
 *
 * @param {BigNumberish} num
 * @param {number} decimals
 * @returns {string}
 */
var fromWei = function fromWei(num, decimals) {
  return ethers$1.utils.formatUnits(num.toString(), decimals);
};
/**
 * min.
 *
 * @param {BigNumberish} a
 * @param {BigNumberish} b
 * @returns {BN}
 */
function min(a, b) {
  var bna = toBN(a);
  var bnb = toBN(b);
  return bna.lte(bnb) ? bna : bnb;
}
/**
 * max.
 *
 * @param {BigNumberish} a
 * @param {BigNumberish} b
 * @returns {BN}
 */
function max(a, b) {
  var bna = toBN(a);
  var bnb = toBN(b);
  return bna.gte(bnb) ? bna : bnb;
}
var fixedPointAdjustment = /*#__PURE__*/toBNWei("1");
/**
 * Convert an amount of eth into a token given price and token decimals.
 *
 * @param {BigNumberish} fromAmount - Amount of eth to convert.
 * @param {string | number} [ price=1 ] - The price as eth per token, ie how much eth can 1 token buy.
 * @param {} [ toDecimals=18 ] - Number of decimals for the token currency.
 * @returns {string} The number of tokens denominated in token decimals in the smallest unit (wei).
 */
function ethToToken(fromAmount, price, toDecimals) {
  if (price === void 0) {
    price = 1;
  }
  if (toDecimals === void 0) {
    toDecimals = 18;
  }
  var priceWei = toBNWei(price);
  var toAmount = toBNWei(fromAmount).div(priceWei);
  return ConvertDecimals(18, toDecimals)(toAmount);
}
/**
 * Convert a gas amount and gas price to wei.
 *
 * @param {number} gas - gas amount.
 * @param {BigNumberish} gasPrice - gas price in gwei.
 * @returns {BigNumber} - total fees in wei.
 */
var gasToEth = function gasToEth(gas, gasPrice) {
  return BigNumber.from(gas).mul(gasPrice);
};
/**
 * getGasFees. Low level pure function call to calculate gas fees.
 *
 * @param {number} gas - The gast cost for transfer, use constants defined in file.
 * @param {BigNumberish} gasPrice - Estimated gas price in wei.
 * @param {string | number} [price = 1] - The price of the token in eth, how much eth can 1 token buy.
 * @param {number} [decimals=18] - Number of decimals of token.
 * @returns {string} - The value of fees native to the token/eth provided, in its smallest unit.
 */
function calculateGasFees(gas, gasPrice, price, decimals) {
  if (price === void 0) {
    price = 1;
  }
  if (decimals === void 0) {
    decimals = 18;
  }
  var amountEth = gasToEth(gas, gasPrice);
  return ethToToken(amountEth, price, decimals);
}
/**
 * percent.
 *
 * @param {BigNumberish} numerator
 * @param {BigNumberish} denominator
 * @returns {BN}
 */
function percent(numerator, denominator) {
  return fixedPointAdjustment.mul(numerator).div(denominator);
}
/**
 * calcContinuousCompoundInterest. From https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=0&t=1&given_data_last=find_r&action=solve
 * Returns a yearly interest rate if start/end amount had been continuously compounded over the period elapsed. Multiply result by 100 for a %.
 *
 * @param {string} startAmount
 * @param {string} endAmount
 * @param {string} periodsElapsed
 * @param {string} periodsPerYear
 */
var calcContinuousCompoundInterest = function calcContinuousCompoundInterest(startAmount, endAmount, periodsElapsed, periodsPerYear) {
  var years = new Decimal(periodsPerYear).div(periodsElapsed);
  return new Decimal(endAmount).div(startAmount).ln().div(years).toString();
};
/**
 * calcPeriodicCompoundInterest. Taken from https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=365&t=1&given_data_last=find_r&action=solve
 * This will return a periodically compounded interest rate for 1 year. Multiply result by 100 for a %.
 *
 * @param {string} startAmount - Starting amount or price
 * @param {string} endAmount - Ending amount or price
 * @param {string} periodsElapsed - How many periods elapsed for the start and end amount.
 * @param {string} periodsPerYear - How many periods in 1 year.
 */
var calcPeriodicCompoundInterest = function calcPeriodicCompoundInterest(startAmount, endAmount, periodsElapsed, periodsPerYear) {
  var n = new Decimal(periodsPerYear);
  var A = new Decimal(endAmount);
  var P = new Decimal(startAmount);
  var t = new Decimal(periodsPerYear).div(periodsElapsed);
  var one = new Decimal(1);
  return n.mul(A.div(P).pow(one.div(n.div(t))).sub(one)).toString();
};
/**
 * calcApr. Simple apr calculation based on extrapolating the difference for a short period over a year.
 *
 * @param {Decimalish} startAmount - Starting amount or price
 * @param {Decimalish} endAmount - Ending amount or price
 * @param {Decimalish} periodsElapsed - periods elapsed from start to end
 * @param {Decimalish} periodsPerYear - periods per year
 */
var calcApr = function calcApr(startAmount, endAmount, periodsElapsed, periodsPerYear) {
  return new Decimal(endAmount).sub(startAmount).div(startAmount).mul(periodsPerYear).div(periodsElapsed).toString();
};

var utils$1 = {
  __proto__: null,
  toBN: toBN,
  toBNWei: toBNWei,
  toWei: toWei,
  fromWei: fromWei,
  min: min,
  max: max,
  fixedPointAdjustment: fixedPointAdjustment,
  ethToToken: ethToToken,
  gasToEth: gasToEth,
  calculateGasFees: calculateGasFees,
  percent: percent,
  calcContinuousCompoundInterest: calcContinuousCompoundInterest,
  calcPeriodicCompoundInterest: calcPeriodicCompoundInterest,
  calcApr: calcApr
};

// This Util calculates the across realized LP fees. See https://gist.github.com/chrismaree/a713725e4fe96c531c42ed7b629d4a85
// Calculate the rate for a 0 sized deposit (infinitesimally small).
function calculateInstantaneousRate(rateModel, utilization) {
  var beforeKink = min(utilization, rateModel.UBar).mul(rateModel.R1).div(rateModel.UBar);
  var afterKink = max(toBN("0"), toBN(utilization).sub(rateModel.UBar)).mul(rateModel.R2).div(toBNWei("1").sub(rateModel.UBar));
  return toBN(rateModel.R0).add(beforeKink).add(afterKink);
}
//  Compute area under curve of the piece-wise linear rate model.
function calculateAreaUnderRateCurve(rateModel, utilization) {
  // Area under first piecewise component
  var utilizationBeforeKink = min(utilization, rateModel.UBar);
  var rectangle1Area = utilizationBeforeKink.mul(rateModel.R0).div(fixedPointAdjustment);
  var triangle1Area = toBNWei("0.5").mul(calculateInstantaneousRate(rateModel, utilizationBeforeKink).sub(rateModel.R0)).mul(utilizationBeforeKink).div(fixedPointAdjustment).div(fixedPointAdjustment);
  // Area under second piecewise component
  var utilizationAfter = max(toBN("0"), utilization.sub(rateModel.UBar));
  var rectangle2Area = utilizationAfter.mul(toBN(rateModel.R0).add(rateModel.R1)).div(fixedPointAdjustment);
  var triangle2Area = toBNWei("0.5").mul(calculateInstantaneousRate(rateModel, utilization).sub(toBN(rateModel.R0).add(rateModel.R1))).mul(utilizationAfter).div(fixedPointAdjustment).div(fixedPointAdjustment);
  return rectangle1Area.add(triangle1Area).add(rectangle2Area).add(triangle2Area);
}
// converts an APY rate to a one week rate. Uses the Decimal library to take a fractional exponent
function convertApyToWeeklyFee(apy) {
  // R_week = (1 + apy)^(1/52) - 1
  var weeklyFeePct = Decimal.pow(new Decimal("1").plus(fromWei(apy)), new Decimal("1").dividedBy(new Decimal("52"))).minus(new Decimal("1"));
  // Convert from decimal back to BN, scaled by 1e18.
  return toBN(weeklyFeePct.times(fixedPointAdjustment.toString()).floor().toString());
}
// Calculate the realized yearly LP Fee APY Percent for a given rate model, utilization before and after the deposit.
function calculateApyFromUtilization(rateModel, utilizationBeforeDeposit, utilizationAfterDeposit) {
  if (utilizationBeforeDeposit.eq(utilizationAfterDeposit)) throw new Error("Deposit cant have zero size");
  // Get the area of [0, utilizationBeforeDeposit] and [0, utilizationAfterDeposit]
  var areaBeforeDeposit = calculateAreaUnderRateCurve(rateModel, utilizationBeforeDeposit);
  var areaAfterDeposit = calculateAreaUnderRateCurve(rateModel, utilizationAfterDeposit);
  var numerator = areaAfterDeposit.sub(areaBeforeDeposit);
  var denominator = utilizationAfterDeposit.sub(utilizationBeforeDeposit);
  return numerator.mul(fixedPointAdjustment).div(denominator);
}
function calculateRealizedLpFeePct(rateModel, utilizationBeforeDeposit, utilizationAfterDeposit) {
  var apy = calculateApyFromUtilization(rateModel, toBN(utilizationBeforeDeposit), toBN(utilizationAfterDeposit));
  return convertApyToWeeklyFee(apy);
}

var feeCalculator = {
  __proto__: null,
  calculateInstantaneousRate: calculateInstantaneousRate,
  calculateApyFromUtilization: calculateApyFromUtilization,
  calculateRealizedLpFeePct: calculateRealizedLpFeePct
};

// these gas costs are estimations, its possible to provide better estimations yourself when invoking getGasFees.
var SLOW_ETH_GAS = 243177;
var SLOW_ERC_GAS = 250939;
var SLOW_UMA_GAS = 273955;
// fast costs are slightly higher and include the slow cost
var FAST_ETH_GAS = 273519;
var FAST_ERC_GAS = 281242;
var FAST_UMA_GAS = 305572;
var SPEED_UP_ETH_GAS = 195288;
var SPEED_UP_ERC_GAS = 203011;
var SPEED_UP_UMA_GAS = 227341;
// Bots incur lower than expected costs due to batching mulitple transactions, this roughly estimates the savings
var DEFAULT_GAS_DISCOUNT = 25;
var expectedRateModelKeys = ["UBar", "R0", "R1", "R2"];
// Amount of blocks to wait following a `TokensBridged` L2 event until we check the L1 state commitment contracts. This
// offset provides a buffer to allow for any time delay between L2 state changing and L1 state updating. For example,
// Optimism has a several hour delay.
var L2_STATE_COMMITMENT_DELAY_BLOCKS = 25000;
var AddressZero = ethers$1.constants.AddressZero;
// mainnet addresses, hard coded here for convenience, but theres probably a better pattern for this
var ADDRESSES = {
  ETH: AddressZero,
  UMA: "0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828",
  WETH: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  USDC: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  RateModel: "0xd18fFeb5fdd1F2e122251eA7Bf357D8Af0B60B50"
};
var SECONDS_PER_YEAR = 31557600; // based on 365.25 days per year
var DEFAULT_BLOCK_DELTA = 10; // look exchange rate up based on 10 block difference by default

var constants = {
  __proto__: null,
  SLOW_ETH_GAS: SLOW_ETH_GAS,
  SLOW_ERC_GAS: SLOW_ERC_GAS,
  SLOW_UMA_GAS: SLOW_UMA_GAS,
  FAST_ETH_GAS: FAST_ETH_GAS,
  FAST_ERC_GAS: FAST_ERC_GAS,
  FAST_UMA_GAS: FAST_UMA_GAS,
  SPEED_UP_ETH_GAS: SPEED_UP_ETH_GAS,
  SPEED_UP_ERC_GAS: SPEED_UP_ERC_GAS,
  SPEED_UP_UMA_GAS: SPEED_UP_UMA_GAS,
  DEFAULT_GAS_DISCOUNT: DEFAULT_GAS_DISCOUNT,
  expectedRateModelKeys: expectedRateModelKeys,
  L2_STATE_COMMITMENT_DELAY_BLOCKS: L2_STATE_COMMITMENT_DELAY_BLOCKS,
  AddressZero: AddressZero,
  ADDRESSES: ADDRESSES,
  SECONDS_PER_YEAR: SECONDS_PER_YEAR,
  DEFAULT_BLOCK_DELTA: DEFAULT_BLOCK_DELTA
};

var RateModelDictionary = /*#__PURE__*/function () {
  function RateModelDictionary() {
    this.rateModelDictionary = {};
  }
  var _proto = RateModelDictionary.prototype;
  _proto._throwIfNotInitialized = function _throwIfNotInitialized() {
    if (Object.keys(this.rateModelDictionary).length == 0) throw new Error("RateModelUtility method called before updating rate model dictionary!");
  };
  _proto.updateWithEvents = function updateWithEvents(rateModelEvents) {
    this.rateModelDictionary = createRateModelEventDictionary(rateModelEvents);
  }
  /**
   * Return the rate model for L1 token set at the block height.
   * @param l1Token L1 token address to get rate model for.
   * @param blockNumber Block height to get rate model for.
   * @returns Rate model object.
   */;
  _proto.getRateModelForBlockNumber = function getRateModelForBlockNumber(l1Token, blockNumber) {
    this._throwIfNotInitialized();
    var l1TokenNormalized = ethers$1.utils.getAddress(l1Token);
    if (!this.rateModelDictionary[l1TokenNormalized] || this.rateModelDictionary[l1TokenNormalized].length === 0) throw new Error("No updated rate model events for L1 token: " + l1TokenNormalized);
    if (!blockNumber) {
      // If block number is undefined, use latest updated rate model.
      return parseAndReturnRateModelFromString(this.rateModelDictionary[l1TokenNormalized].slice(-1)[0].rateModel);
    } else {
      var firstEventBlockNumber = this.rateModelDictionary[l1TokenNormalized][0].blockNumber;
      if (blockNumber < firstEventBlockNumber) {
        throw new Error("Block number #" + blockNumber + " is before first UpdatedRateModel event block " + firstEventBlockNumber);
      }
      // We're looking for the latest rate model update that occurred at or before the block number.
      // Rate model events are inserted into the array from oldest at index 0 to newest at index length-1, so we'll
      // reverse the array so it goes from newest at index 0 to oldest at index length-1, and then find the first event
      // who's block number is less than or equal to the target block number.
      var rateModel = this.rateModelDictionary[l1TokenNormalized].slice().reverse() // reverse() modifies memory in place so create a copy first.
      .find(function (event) {
        return event.blockNumber <= blockNumber;
      });
      if (!rateModel) throw new Error("No updated rate model events before block #" + blockNumber + " for L1 token: " + l1TokenNormalized);
      return parseAndReturnRateModelFromString(rateModel == null ? void 0 : rateModel.rateModel);
    }
  }
  /**
   * @notice Return all L1 tokens that had a rate model associated with it at the block number.
   * @param blockNumber Returns l1 tokens that were mapped to a rate model at this block height. If undefined,
   * this function will return all L1 tokens that have a block number as of the latest block height.
   * @returns array of L1 token addresses.
   */;
  _proto.getL1TokensFromRateModel = function getL1TokensFromRateModel(blockNumber) {
    var _this = this;
    if (blockNumber === void 0) {
      blockNumber = undefined;
    }
    this._throwIfNotInitialized();
    return Object.keys(this.rateModelDictionary).map(function (l1Token) {
      var l1TokenNormalized = ethers$1.utils.getAddress(l1Token);
      // Check that there is at least one UpdatedRateModel event before the provided block number, otherwise
      // this L1 token didn't exist in the RateModel at the block height and we shouldn't include it in the returned
      // array.
      if (!blockNumber || _this.rateModelDictionary[l1TokenNormalized].find(function (event) {
        return event.blockNumber <= blockNumber;
      })) return ethers$1.utils.getAddress(l1Token);else return null;
    }).filter(exists);
  };
  return RateModelDictionary;
}();
/**
 * Helper method that returns parsed rate model from string, or throws.
 * @param rateModelString Stringified rate model to parse.
 * @returns Rate model object. Must conform to `expectedRateModelKeys` format.
 */
var parseAndReturnRateModelFromString = function parseAndReturnRateModelFromString(rateModelString) {
  var rateModelFromEvent = JSON.parse(rateModelString);
  // Rate model must contain the exact same keys in `expectedRateModelKeys`.
  for (var _iterator = _createForOfIteratorHelperLoose(expectedRateModelKeys), _step; !(_step = _iterator()).done;) {
    var _key = _step.value;
    if (!Object.keys(rateModelFromEvent).includes(_key)) {
      throw new Error("Rate model does not contain all expected keys. Expected keys: [" + expectedRateModelKeys + "], actual keys: [" + Object.keys(rateModelFromEvent) + "]");
    }
  }
  for (var _i = 0, _Object$keys = Object.keys(rateModelFromEvent); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (!expectedRateModelKeys.includes(key)) {
      throw new Error("Rate model contains unexpected keys. Expected keys: [" + expectedRateModelKeys + "], actual keys: [" + Object.keys(rateModelFromEvent) + "]");
    }
  }
  return {
    UBar: rateModelFromEvent.UBar,
    R0: rateModelFromEvent.R0,
    R1: rateModelFromEvent.R1,
    R2: rateModelFromEvent.R2
  };
};
/**
 * Given an unsorted array of updated rate model events, return a dictionary mapping token addresses to sorted
 * rate model events. This method is used internally to enforce chronological sorting of events and mapping rate models
 * to token addresses.
 * @param rateModelEvents Unsorted updated rate model events, each of which contains a token address, the stringified
 * rate model for that token, and the block height of the update.
 * @returns Dictionary mapping token addresses to chronologically sorted rate model updates.
 */
var createRateModelEventDictionary = function createRateModelEventDictionary(rateModelEvents) {
  var updatedRateModelEventsForToken = {};
  // Sort events in-place from oldest to newest:
  rateModelEvents.sort(function (a, b) {
    if (a.blockNumber !== b.blockNumber) {
      return a.blockNumber - b.blockNumber;
    }
    if (a.transactionIndex !== b.transactionIndex) {
      return a.transactionIndex - b.transactionIndex;
    }
    return a.logIndex - b.logIndex;
  });
  for (var _iterator2 = _createForOfIteratorHelperLoose(rateModelEvents), _step2; !(_step2 = _iterator2()).done;) {
    var updatedRateModelEvent = _step2.value;
    // The contract enforces that all rate models are mapped to addresses, therefore we do not need to check that
    // `l1Token` is a valid address.
    var l1TokenNormalized = ethers$1.utils.getAddress(updatedRateModelEvent.l1Token);
    if (!updatedRateModelEventsForToken[l1TokenNormalized]) updatedRateModelEventsForToken[l1TokenNormalized] = [];
    // We assume that events are returned from oldest to newest, so we can simply push events into the array and
    // and maintain their time order.
    updatedRateModelEventsForToken[l1TokenNormalized].push({
      blockNumber: updatedRateModelEvent.blockNumber,
      rateModel: updatedRateModelEvent.rateModel
    });
  }
  return updatedRateModelEventsForToken;
};

var rateModel = {
  __proto__: null,
  RateModelDictionary: RateModelDictionary,
  parseAndReturnRateModelFromString: parseAndReturnRateModelFromString
};

var BlockFinder = /*#__PURE__*/function () {
  function BlockFinder(requestBlock, blocks, chainId) {
    if (blocks === void 0) {
      blocks = [];
    }
    if (chainId === void 0) {
      chainId = 1;
    }
    this.requestBlock = requestBlock;
    this.blocks = blocks;
    this.chainId = chainId;
    assert(requestBlock, "requestBlock function must be provided");
  }
  /**
   * @notice Gets the latest block whose timestamp is <= the provided timestamp.
   * @param {number} timestamp timestamp to search.
   */
  var _proto = BlockFinder.prototype;
  _proto.getBlockForTimestamp =
  /*#__PURE__*/
  function () {
    var _getBlockForTimestamp = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(timestamp) {
      var block, initialBlock, cushion, incrementDistance, multiplier, distance, blockNumber, _block, index;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            timestamp = Number(timestamp);
            assert(timestamp !== undefined && timestamp !== null, "timestamp must be provided");
            // If the last block we have stored is too early, grab the latest block.
            if (!(this.blocks.length === 0 || this.blocks[this.blocks.length - 1].timestamp < timestamp)) {
              _context.next = 8;
              break;
            }
            _context.next = 5;
            return this.getLatestBlock();
          case 5:
            block = _context.sent;
            if (!(timestamp >= block.timestamp)) {
              _context.next = 8;
              break;
            }
            return _context.abrupt("return", block);
          case 8:
            if (!(this.blocks[0].timestamp > timestamp)) {
              _context.next = 28;
              break;
            }
            initialBlock = this.blocks[0]; // We use a 2x cushion to reduce the number of iterations in the following loop and increase the chance
            // that the first block we find sets a floor for the target timestamp. The loop converges on the correct block
            // slower than the following incremental search performed by `findBlock`, so we want to minimize the number of
            // loop iterations in favor of searching more blocks over the `findBlock` search.
            cushion = 1;
            _context.t0 = Math;
            _context.next = 14;
            return estimateBlocksElapsed(initialBlock.timestamp - timestamp, cushion, this.chainId);
          case 14:
            _context.t1 = _context.sent;
            incrementDistance = _context.t0.max.call(_context.t0, _context.t1, 1);
            multiplier = 1;
          case 17:
            distance = multiplier * incrementDistance;
            blockNumber = Math.max(0, initialBlock.number - distance);
            _context.next = 21;
            return this.getBlock(blockNumber);
          case 21:
            _block = _context.sent;
            if (!(_block.timestamp <= timestamp)) {
              _context.next = 24;
              break;
            }
            return _context.abrupt("break", 28);
          case 24:
            // Found an earlier block.
            assert(blockNumber > 0, "timestamp is before block 0"); // Block 0 was not earlier than this timestamp. The row.
          case 25:
            multiplier++;
            _context.next = 17;
            break;
          case 28:
            // Find the index where the block would be inserted and use that as the end block (since it is >= the timestamp).
            index = sortedIndexBy(this.blocks, {
              timestamp: timestamp
            }, "timestamp");
            return _context.abrupt("return", this.findBlock(this.blocks[index - 1], this.blocks[index], timestamp));
          case 30:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getBlockForTimestamp(_x) {
      return _getBlockForTimestamp.apply(this, arguments);
    }
    return getBlockForTimestamp;
  }() // Grabs the most recent block and caches it.
  ;
  _proto.getLatestBlock =
  /*#__PURE__*/
  function () {
    var _getLatestBlock = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var _this$blocks$index;
      var block, index;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return this.requestBlock("latest");
          case 2:
            block = _context2.sent;
            index = sortedIndexBy(this.blocks, block, "number");
            if (((_this$blocks$index = this.blocks[index]) == null ? void 0 : _this$blocks$index.number) !== block.number) this.blocks.splice(index, 0, block);
            return _context2.abrupt("return", this.blocks[index]);
          case 6:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function getLatestBlock() {
      return _getLatestBlock.apply(this, arguments);
    }
    return getLatestBlock;
  }() // Grabs the block for a particular number and caches it.
  ;
  _proto.getBlock =
  /*#__PURE__*/
  function () {
    var _getBlock = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(number) {
      var _this$blocks$index2, _this$blocks$index3;
      var index, block;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            index = sortedIndexBy(this.blocks, {
              number: number
            }, "number");
            if (!(((_this$blocks$index2 = this.blocks[index]) == null ? void 0 : _this$blocks$index2.number) === number)) {
              _context3.next = 3;
              break;
            }
            return _context3.abrupt("return", this.blocks[index]);
          case 3:
            _context3.next = 5;
            return this.requestBlock(number);
          case 5:
            block = _context3.sent;
            // Recompute the index after the async call since the state of this.blocks could have changed!
            index = sortedIndexBy(this.blocks, {
              number: number
            }, "number");
            // Rerun this check to avoid duplicate insertion.
            if (!(((_this$blocks$index3 = this.blocks[index]) == null ? void 0 : _this$blocks$index3.number) === number)) {
              _context3.next = 9;
              break;
            }
            return _context3.abrupt("return", this.blocks[index]);
          case 9:
            this.blocks.splice(index, 0, block); // A simple insert at index.
            return _context3.abrupt("return", block);
          case 11:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function getBlock(_x2) {
      return _getBlock.apply(this, arguments);
    }
    return getBlock;
  }() // Return the latest block, between startBlock and endBlock, whose timestamp is <= timestamp.
  // Effectively, this is an interpolation search algorithm to minimize block requests.
  // Note: startBlock and endBlock _must_ be different blocks.
  ;
  _proto.findBlock =
  /*#__PURE__*/
  function () {
    var _findBlock = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_startBlock, _endBlock, timestamp) {
      var startBlock, endBlock, totalTimeDifference, totalBlockDistance, blockPercentile, estimatedBlock, newBlock;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            startBlock = _startBlock, endBlock = _endBlock; // In the case of equality, the endBlock is expected to be passed as the one whose timestamp === the requested
            // timestamp.
            if (!(endBlock.timestamp === timestamp)) {
              _context4.next = 3;
              break;
            }
            return _context4.abrupt("return", endBlock);
          case 3:
            if (!(endBlock.number === startBlock.number + 1)) {
              _context4.next = 5;
              break;
            }
            return _context4.abrupt("return", startBlock);
          case 5:
            assert(endBlock.number !== startBlock.number, "startBlock cannot equal endBlock");
            assert(timestamp < endBlock.timestamp && timestamp > startBlock.timestamp, "timestamp not in between start and end blocks");
            // Interpolating the timestamp we're searching for to block numbers.
            totalTimeDifference = endBlock.timestamp - startBlock.timestamp;
            totalBlockDistance = endBlock.number - startBlock.number;
            blockPercentile = (timestamp - startBlock.timestamp) / totalTimeDifference;
            estimatedBlock = startBlock.number + Math.round(blockPercentile * totalBlockDistance); // Clamp ensures the estimated block is strictly greater than the start block and strictly less than the end block.
            _context4.next = 13;
            return this.getBlock(clamp(estimatedBlock, startBlock.number + 1, endBlock.number - 1));
          case 13:
            newBlock = _context4.sent;
            if (!(newBlock.timestamp < timestamp)) {
              _context4.next = 18;
              break;
            }
            return _context4.abrupt("return", this.findBlock(newBlock, endBlock, timestamp));
          case 18:
            return _context4.abrupt("return", this.findBlock(startBlock, newBlock, timestamp));
          case 19:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function findBlock(_x3, _x4, _x5) {
      return _findBlock.apply(this, arguments);
    }
    return findBlock;
  }();
  return BlockFinder;
}();

var LpFeeCalculator = /*#__PURE__*/function () {
  function LpFeeCalculator(provider) {
    this.provider = provider;
    this.blockFinder = new BlockFinder(provider.getBlock.bind(provider));
  }
  var _proto = LpFeeCalculator.prototype;
  _proto.getLpFeePct = /*#__PURE__*/function () {
    var _getLpFeePct = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenAddress, bridgePoolAddress, amount, timestamp) {
      var blockFinder, provider, bridgePoolInstance, rateModelStoreAddress, rateModelStoreInstance, targetBlock, blockTag, _yield$Promise$all, currentUt, nextUt, rateModelForBlockHeight, rateModel;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            amount = BigNumber.from(amount);
            assert(amount.gt(0), "Amount must be greater than 0");
            blockFinder = this.blockFinder, provider = this.provider;
            bridgePoolInstance = connect$8(bridgePoolAddress, provider);
            _context.t0 = rateModelStore;
            _context.next = 7;
            return this.provider.getNetwork();
          case 7:
            _context.next = 9;
            return _context.sent.chainId;
          case 9:
            _context.t1 = _context.sent;
            _context.next = 12;
            return _context.t0.getAddress.call(_context.t0, _context.t1);
          case 12:
            rateModelStoreAddress = _context.sent;
            rateModelStoreInstance = connect$9(rateModelStoreAddress, provider);
            if (!exists(timestamp)) {
              _context.next = 20;
              break;
            }
            _context.next = 17;
            return blockFinder.getBlockForTimestamp(timestamp);
          case 17:
            _context.t2 = _context.sent;
            _context.next = 23;
            break;
          case 20:
            _context.next = 22;
            return provider.getBlock("latest");
          case 22:
            _context.t2 = _context.sent;
          case 23:
            targetBlock = _context.t2;
            assert(exists(targetBlock), "Unable to find target block for timestamp: " + timestamp || "latest");
            blockTag = targetBlock.number;
            _context.next = 28;
            return Promise.all([bridgePoolInstance.callStatic.liquidityUtilizationCurrent({
              blockTag: blockTag
            }), bridgePoolInstance.callStatic.liquidityUtilizationPostRelay(amount, {
              blockTag: blockTag
            }), rateModelStoreInstance.callStatic.l1TokenRateModels(tokenAddress, {
              blockTag: blockTag
            })]);
          case 28:
            _yield$Promise$all = _context.sent;
            currentUt = _yield$Promise$all[0];
            nextUt = _yield$Promise$all[1];
            rateModelForBlockHeight = _yield$Promise$all[2];
            // Parsing stringified rate model will error if the rate model doesn't contain exactly the expected keys or isn't
            // a JSON object.
            rateModel = parseAndReturnRateModelFromString(rateModelForBlockHeight);
            return _context.abrupt("return", calculateRealizedLpFeePct(rateModel, currentUt, nextUt));
          case 34:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getLpFeePct(_x, _x2, _x3, _x4) {
      return _getLpFeePct.apply(this, arguments);
    }
    return getLpFeePct;
  }();
  return LpFeeCalculator;
}();

var Coingecko = /*#__PURE__*/function () {
  function Coingecko(host) {
    if (host === void 0) {
      host = "https://api.coingecko.com/api/v3";
    }
    this.host = host;
  }
  // Fetch historic prices for a `contract` denominated in `currency` between timestamp `from` and `to`. Note timestamps
  // are assumed to be js timestamps and are converted to unixtimestamps by dividing by 1000.
  var _proto = Coingecko.prototype;
  _proto.getHistoricContractPrices =
  /*#__PURE__*/
  function () {
    var _getHistoricContractPrices = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(contract, from, to, currency) {
      var result;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (currency === void 0) {
              currency = "usd";
            }
            assert(contract, "requires contract address");
            assert(currency, "requires currency symbol");
            assert(from, "requires from timestamp");
            assert(to, "requires to timestamp");
            from = Math.floor(from / 1000);
            to = Math.floor(to / 1000);
            _context.next = 9;
            return this.call("coins/ethereum/contract/" + contract.toLowerCase() + "/market_chart/range/?vs_currency=" + currency + "&from=" + from + "&to=" + to);
          case 9:
            result = _context.sent;
            if (!result.prices) {
              _context.next = 12;
              break;
            }
            return _context.abrupt("return", result.prices);
          case 12:
            throw new Error("Something went wrong fetching coingecko prices!");
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getHistoricContractPrices(_x, _x2, _x3, _x4) {
      return _getHistoricContractPrices.apply(this, arguments);
    }
    return getHistoricContractPrices;
  }();
  _proto.getContractDetails = /*#__PURE__*/function () {
    var _getContractDetails = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(contract_address, platform_id) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (platform_id === void 0) {
              platform_id = "ethereum";
            }
            return _context2.abrupt("return", this.call("coins/" + platform_id + "/contract/" + contract_address.toLowerCase()));
          case 2:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function getContractDetails(_x5, _x6) {
      return _getContractDetails.apply(this, arguments);
    }
    return getContractDetails;
  }();
  _proto.getCurrentPriceByContract = /*#__PURE__*/function () {
    var _getCurrentPriceByContract = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(contract_address, currency, platform_id) {
      var result, price;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (currency === void 0) {
              currency = "usd";
            }
            if (platform_id === void 0) {
              platform_id = "ethereum";
            }
            _context3.next = 4;
            return this.getContractDetails(contract_address, platform_id);
          case 4:
            result = _context3.sent;
            price = get$1(result, ["market_data", "current_price", currency], null);
            assert(price !== null, "No current price available for: " + contract_address);
            return _context3.abrupt("return", [result.last_updated, price]);
          case 8:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function getCurrentPriceByContract(_x7, _x8, _x9) {
      return _getCurrentPriceByContract.apply(this, arguments);
    }
    return getCurrentPriceByContract;
  }() // Return an array of spot prices for an array of collateral addresses in one async call. Note we might in future
  // This was adapted from packages/merkle-distributor/kpi-options-helpers/calculate-uma-tvl.ts
  ;
  _proto.getContractPrices =
  /*#__PURE__*/
  function () {
    var _getContractPrices = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(addresses, currency, platform_id) {
      var contract_addresses, lookup, result;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            if (currency === void 0) {
              currency = "usd";
            }
            if (platform_id === void 0) {
              platform_id = "ethereum";
            }
            // Generate a unique set with no repeated. join the set with the required coingecko delimiter.
            contract_addresses = Array.from(new Set(addresses.filter(function (n) {
              return n;
            }).values()));
            assert(contract_addresses.length > 0, "Must supply at least 1 contract address");
            // coingecko returns lowercase addresses, so if you expect checksummed addresses, this lookup table will convert them back without having to add ethers as a dependency
            lookup = Object.fromEntries(contract_addresses.map(function (address) {
              return [address.toLowerCase(), address];
            }));
            _context4.next = 7;
            return this.call("simple/token_price/" + platform_id + "?contract_addresses=" + contract_addresses.join("%2C") + "&vs_currencies=" + currency + "&include_last_updated_at=true");
          case 7:
            result = _context4.sent;
            return _context4.abrupt("return", Object.entries(result).map(function (_ref) {
              var key = _ref[0],
                value = _ref[1];
              return {
                address: lookup[key],
                timestamp: value.last_updated_at,
                price: value[currency]
              };
            }));
          case 9:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function getContractPrices(_x10, _x11, _x12) {
      return _getContractPrices.apply(this, arguments);
    }
    return getContractPrices;
  }();
  _proto.getPlatforms = /*#__PURE__*/function () {
    var _getPlatforms = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            return _context5.abrupt("return", this.call("asset_platforms"));
          case 1:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function getPlatforms() {
      return _getPlatforms.apply(this, arguments);
    }
    return getPlatforms;
  }();
  _proto.call = /*#__PURE__*/function () {
    var _call = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(path) {
      var host, url, result, msg;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.prev = 0;
            host = this.host;
            url = host + "/" + path;
            _context6.next = 5;
            return axios(url);
          case 5:
            result = _context6.sent;
            return _context6.abrupt("return", result.data);
          case 9:
            _context6.prev = 9;
            _context6.t0 = _context6["catch"](0);
            msg = get$1(_context6.t0, "response.data.error", get$1(_context6.t0, "response.statusText", "Unknown Coingecko Error"));
            throw new Error(msg);
          case 13:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this, [[0, 9]]);
    }));
    function call(_x13) {
      return _call.apply(this, arguments);
    }
    return call;
  }();
  return Coingecko;
}();

/**
 * Function to estimate gas fees based on coingecko token price and ethers gasPrice. You must still
 * provide a gas amount estimation based on the usage pattern. See constants for current estimations. Returns
 * an amount of gas estimated in the token provided in wei.
 *
 * @param {Provider} ethers Provider
 * @param {BigNumberish} Total amount to be relayed, specified in smallest unit of currency.
 * @param {number} gas - The gas cost for transfer, use constants defined in constants file.
 * @param {string} [tokenAddress = constants.ADDRESSES.ETH] - Token address, for ETH, constants.ADDRESSES.ETH
 */
function getGasFee(_x, _x2, _x3) {
  return _getGasFee.apply(this, arguments);
}
// These tables are hard coded to mainnet
function _getGasFee() {
  _getGasFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ethersProvider, gas, tokenAddress) {
    var _yield$ethersProvider, baseFeePerGas, gasPrice, priorityFeePerGas, priorityFeePerGasWei, coingecko, _yield$coingecko$getC, tokenPrice, erc20Client, decimals;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (tokenAddress === void 0) {
            tokenAddress = ADDRESSES.ETH;
          }
          _context.next = 3;
          return ethersProvider.getBlock("latest");
        case 3:
          _yield$ethersProvider = _context.sent;
          baseFeePerGas = _yield$ethersProvider.baseFeePerGas;
          if (!baseFeePerGas) {
            _context.next = 13;
            break;
          }
          _context.next = 8;
          return new Etherchain().getGasPrice();
        case 8:
          priorityFeePerGas = _context.sent.fastest;
          // transform priority fee from gwei (eg 4.1) to wei
          priorityFeePerGasWei = toWei(priorityFeePerGas, 9);
          gasPrice = baseFeePerGas.add(priorityFeePerGasWei);
          _context.next = 16;
          break;
        case 13:
          _context.next = 15;
          return ethersProvider.getGasPrice();
        case 15:
          gasPrice = _context.sent;
        case 16:
          if (!(tokenAddress === ADDRESSES.ETH)) {
            _context.next = 18;
            break;
          }
          return _context.abrupt("return", calculateGasFees(gas, gasPrice));
        case 18:
          coingecko = new Coingecko();
          _context.next = 21;
          return coingecko.getCurrentPriceByContract(tokenAddress, "eth");
        case 21:
          _yield$coingecko$getC = _context.sent;
          tokenPrice = _yield$coingecko$getC[1];
          erc20Client = connect$2(tokenAddress, ethersProvider);
          _context.next = 26;
          return erc20Client.decimals();
        case 26:
          decimals = _context.sent;
          return _context.abrupt("return", calculateGasFees(gas, gasPrice, tokenPrice, decimals));
        case 28:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _getGasFee.apply(this, arguments);
}
function makeSlowGasTable() {
  var _ref;
  return _ref = {}, _ref[ADDRESSES.UMA] = SLOW_UMA_GAS, _ref[ADDRESSES.ETH] = SLOW_ETH_GAS, _ref[ADDRESSES.WETH] = SLOW_ETH_GAS, _ref.DEFAULT = SLOW_ERC_GAS, _ref;
}
// instant gas is the amount of gas above slow gas
function makeInstantGasTable() {
  var _ref2;
  return _ref2 = {}, _ref2[ADDRESSES.UMA] = FAST_UMA_GAS - SLOW_UMA_GAS, _ref2[ADDRESSES.ETH] = FAST_ETH_GAS - SLOW_ETH_GAS, _ref2[ADDRESSES.WETH] = FAST_ETH_GAS - SLOW_ETH_GAS, _ref2.DEFAULT = FAST_ERC_GAS - SLOW_ERC_GAS, _ref2;
}
var GetGasByAddress = function GetGasByAddress(gasTable) {
  return function (tokenAddress) {
    if (exists(gasTable[tokenAddress])) return gasTable[tokenAddress];
    return gasTable.DEFAULT;
  };
};
var getInstantGasByAddress = /*#__PURE__*/GetGasByAddress( /*#__PURE__*/makeInstantGasTable());
var getSlowGasByAddress = /*#__PURE__*/GetGasByAddress( /*#__PURE__*/makeSlowGasTable());
/**
 * getDepositFees. Returns to you appropriate values for calling the relay deposit function. Returns the slow gas fee
 * and the instant gas fee which is the amount additional to the slow fee as percentages in wei.
 *
 * @param {Provider} ethersProvider - Read provider on mainnet
 * @param {BigNumberish} amountToRelay - Amount in wei of token to relay
 * @param {string} tokenAddress = 0 - Mainnet address of token to relay. Defaults to ETH which is constants.ADDRESSES.ETH.
 * @param {string} discountPercent = DEFAULT_GAS_DISCOUNT- Percent as a value 0-100 of gas fee discount. 0 means no discount. Typically 25 for a 25% gas fee reduction.
 * No need to override this as the values are hardcoded in the sdk.
 * @returns {Promise<DepositFees>} - Returns the fee parameters to the deposit function on the deposit box contract.
 * These are percentages in wei. For example 50% is represented as 0.5 * 1e18.
 */
function getDepositFees(_x4, _x5, _x6, _x7) {
  return _getDepositFees.apply(this, arguments);
}
/**
 * getDepositFeesDetails. Same as deposit fees, but returns more information, useful for a frontend display.
 *
 * @param {Provider} ethersProvider - Read provider on mainnet
 * @param {BigNumberish} amountToRelay - Amount in wei of token to relay
 * @param {string} tokenAddress = 0 - Mainnet address of token to relay, for ETH specify constants.ADDRESSES.ETH
 * @param {number} feeLimitPercent? - Optional, percent as a value 0-100 of how much to limit fees as a percentage of the total relayed. Typically 25 or 25% of fees are acceptable out of the total relay amount.
 * For instance 25 means fees can be up to 25% of the total amount to send, fees above this will cause isAmountTooLow to be true.
 * @param {string} discountPercent = DEFAULT_GAS_DISCOUNT - Percent as a value 0-100 of gas fee discount. 0 means no discount. Typically 25 for a 25% gas fee reduction.
 * No need to override this as the values are hardcoded in the sdk.
 * @returns {DepositFeeDetails}
 */
function _getDepositFees() {
  _getDepositFees = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(ethersProvider, amountToRelay, tokenAddress, discountPercent) {
    var slowGas, slowGasDiscounted, slowGasFee, instantGas, instantGasDiscounted, instantGasFee;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (tokenAddress === void 0) {
            tokenAddress = ADDRESSES.ETH;
          }
          if (discountPercent === void 0) {
            discountPercent = DEFAULT_GAS_DISCOUNT;
          }
          assert(discountPercent >= 0 && discountPercent <= 100, "discountPercent must be between 0 and 100 percent");
          slowGas = getSlowGasByAddress(tokenAddress);
          slowGasDiscounted = Math.floor((1 - discountPercent / 100) * slowGas);
          _context2.next = 7;
          return getGasFee(ethersProvider, slowGasDiscounted, tokenAddress);
        case 7:
          slowGasFee = _context2.sent;
          instantGas = getInstantGasByAddress(tokenAddress);
          instantGasDiscounted = Math.floor((1 - discountPercent / 100) * instantGas);
          _context2.next = 12;
          return getGasFee(ethersProvider, instantGasDiscounted, tokenAddress);
        case 12:
          instantGasFee = _context2.sent;
          return _context2.abrupt("return", {
            slowPct: percent(slowGasFee, amountToRelay).toString(),
            instantPct: percent(instantGasFee, amountToRelay).toString()
          });
        case 14:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _getDepositFees.apply(this, arguments);
}
function getDepositFeesDetails(_x8, _x9, _x10, _x11, _x12) {
  return _getDepositFeesDetails.apply(this, arguments);
}
function _getDepositFeesDetails() {
  _getDepositFeesDetails = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(ethersProvider, amountToRelay, tokenAddress, feeLimitPercent, discountPercent) {
    var _yield$getDepositFees, slowPct, instantPct, slowTotal, instantTotal, isAmountTooLow;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          if (tokenAddress === void 0) {
            tokenAddress = ADDRESSES.ETH;
          }
          if (discountPercent === void 0) {
            discountPercent = DEFAULT_GAS_DISCOUNT;
          }
          _context3.next = 4;
          return getDepositFees(ethersProvider, amountToRelay, tokenAddress, discountPercent);
        case 4:
          _yield$getDepositFees = _context3.sent;
          slowPct = _yield$getDepositFees.slowPct;
          instantPct = _yield$getDepositFees.instantPct;
          slowTotal = BigNumber.from(slowPct).mul(amountToRelay).div(fixedPointAdjustment).toString();
          instantTotal = BigNumber.from(instantPct).mul(amountToRelay).div(fixedPointAdjustment).toString();
          isAmountTooLow = false;
          if (feeLimitPercent) {
            assert(feeLimitPercent >= 0 && feeLimitPercent <= 100, "feeLimitPercent must be between 0 and 100 percent");
            isAmountTooLow = BigNumber.from(slowPct).add(instantPct).gt(toBNWei(feeLimitPercent / 100));
          }
          return _context3.abrupt("return", {
            amountToRelay: amountToRelay.toString(),
            discountPercent: discountPercent,
            feeLimitPercent: feeLimitPercent,
            tokenAddress: tokenAddress,
            instant: {
              pct: instantPct,
              total: instantTotal
            },
            slow: {
              pct: slowPct,
              total: slowTotal
            },
            isAmountTooLow: isAmountTooLow
          });
        case 12:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _getDepositFeesDetails.apply(this, arguments);
}

var gasFeeCalculator = {
  __proto__: null,
  getGasFee: getGasFee,
  getInstantGasByAddress: getInstantGasByAddress,
  getSlowGasByAddress: getSlowGasByAddress,
  getDepositFees: getDepositFees,
  getDepositFeesDetails: getDepositFeesDetails
};

// Multicall class that exposes public functions to the user and recursively chains itself.  Acts immutable
// if you store reference to the parent intsance. Children will contain mutated state.
var Multicall = /*#__PURE__*/function () {
  function Multicall(state) {
    // make a copy of this so we dont mutate the original
    this.requests = [].concat(state.requests);
    this.multicallClient = state.multicallClient;
  }
  // internally add requests to queue. Only called by parent for chaining.
  var _proto = Multicall.prototype;
  _proto.push = function push(contractInstance, call) {
    this.requests.push({
      contractInstance: contractInstance,
      call: call
    });
  }
  // encode requests to multicall contract
  ;
  _proto.encodeRequest = function encodeRequest(request) {
    var contractInstance = request.contractInstance,
      call = request.call;
    return {
      target: contractInstance.address,
      callData: contractInstance["interface"].encodeFunctionData(call.method, call.args)
    };
  }
  // decode response from multicall contract
  ;
  _proto.decodeResponse = function decodeResponse(request, response) {
    var contractInstance = request.contractInstance,
      call = request.call;
    return contractInstance["interface"].decodeFunctionResult(call.method, response);
  }
  // adds a new request to the queue, to be executed when read is called. Returns an instance of this class so you can chain.
  ;
  _proto.add = function add(contractInstance, call) {
    var child = new Multicall(this);
    child.push(contractInstance, call);
    return child;
  }
  // adds a list of requests to the queue, to be executed when read is called. Returns an instance of this class so you can chain.
  ;
  _proto.batch = function batch(contractInstance, calls) {
    var child = new Multicall(this);
    calls.forEach(function (call) {
      child.push(contractInstance, call);
    });
    return child;
  }
  // reads from the contract, returns the read results in order that requests were queued.
  ;
  _proto.read =
  /*#__PURE__*/
  function () {
    var _read = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_requests) {
      var _this = this;
      var encodedRequests, _yield$this$multicall, returnData, zipped;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (_requests === void 0) {
              _requests = this.requests;
            }
            encodedRequests = _requests.map(function (request) {
              return _this.encodeRequest(request);
            });
            _context.next = 4;
            return this.multicallClient.callStatic.aggregate(encodedRequests);
          case 4:
            _yield$this$multicall = _context.sent;
            returnData = _yield$this$multicall.returnData;
            zipped = zip(_requests, returnData);
            return _context.abrupt("return", zipped.map(function (_ref) {
              var request = _ref[0],
                response = _ref[1];
              if (request && response) return _this.decodeResponse(request, response);
              throw new Error("Unable to decode contract response");
            }));
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function read(_x) {
      return _read.apply(this, arguments);
    }
    return read;
  }();
  return Multicall;
}();
// Factory that alters construction of multicall to be more friendly for end user
var Factory$d = /*#__PURE__*/function (_Multicall) {
  _inheritsLoose(Factory, _Multicall);
  function Factory(address, provider) {
    var multicallClient = connect$3(address, provider);
    return _Multicall.call(this, {
      multicallClient: multicallClient,
      requests: []
    }) || this;
  }
  return Factory;
}(Multicall);

var Multicall2 = /*#__PURE__*/function (_Multicall) {
  _inheritsLoose(Multicall2, _Multicall);
  function Multicall2(state) {
    return _Multicall.call(this, state) || this;
  }
  // reads from the contract, returns the read and error results in order that requests were queued.
  var _proto = Multicall2.prototype;
  _proto.readWithErrors =
  /*#__PURE__*/
  function () {
    var _readWithErrors = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_requests) {
      var _this = this;
      var encodedRequests, _yield$this$multicall, returnData, zipped;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (_requests === void 0) {
              _requests = this.requests;
            }
            encodedRequests = _requests.map(function (request) {
              return _this.encodeRequest(request);
            });
            _context.next = 4;
            return this.multicallClient.callStatic.tryBlockAndAggregate(false, encodedRequests);
          case 4:
            _yield$this$multicall = _context.sent;
            returnData = _yield$this$multicall[2];
            zipped = zip(_requests, returnData);
            return _context.abrupt("return", zipped.map(function (_ref) {
              var request = _ref[0],
                response = _ref[1];
              if (request && response) {
                return {
                  success: response.success,
                  result: response.success ? _this.decodeResponse(request, response.returnData) : undefined
                };
              }
              throw new Error("Unable to decode contract response");
            }));
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function readWithErrors(_x) {
      return _readWithErrors.apply(this, arguments);
    }
    return readWithErrors;
  }() // adds a new request to the queue, to be executed when read is called. Returns an instance of this class so you can chain.
  ;
  _proto.add = function add(contractInstance, call) {
    return new Multicall2(_Multicall.prototype.add.call(this, contractInstance, call));
  }
  // adds a list of requests to the queue, to be executed when read is called. Returns an instance of this class so you can chain.
  ;
  _proto.batch = function batch(contractInstance, calls) {
    return new Multicall2(_Multicall.prototype.batch.call(this, contractInstance, calls));
  };
  return Multicall2;
}(Multicall); // Factory that alters construction of multicall2 to be more friendly for end user
var Multicall2Factory = /*#__PURE__*/function (_Multicall2) {
  _inheritsLoose(Multicall2Factory, _Multicall2);
  function Multicall2Factory(address, provider) {
    var multicallClient = connect$4(address, provider);
    return _Multicall2.call(this, {
      multicallClient: multicallClient,
      requests: []
    }) || this;
  }
  return Multicall2Factory;
}(Multicall2);

function makeKey(tx) {
  return JSON.stringify(Object.entries(tx).map(function (_ref) {
    var key = _ref[0],
      value = _ref[1];
    return [key, (value || "").toString()];
  }));
}
var TransactionManager = (function (config, signer, emit) {
  if (emit === void 0) {
    emit = function emit() {
      return null;
    };
  }
  assert(signer.provider, "signer requires a provider, use signer.connect(provider)");
  var _config$confirmations = config.confirmations,
    confirmations = _config$confirmations === void 0 ? 3 : _config$confirmations;
  var requests = new Map();
  var submissions = new Map();
  var mined = new Map();
  function request(unsignedTx) {
    // this no longer calls signer.populateTransaction, to allow metamask to fill in missing details instead
    // use overrides if you want to manually fill in other tx details, including the overrides.customData field.
    var populated = unsignedTx;
    var key = makeKey(populated);
    assert(!requests.has(key), "Transaction already in progress");
    requests.set(key, populated);
    return key;
  }
  function processRequest(_x) {
    return _processRequest.apply(this, arguments);
  }
  function _processRequest() {
    _processRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key) {
      var request, sent;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            request = requests.get(key);
            assert(request, "invalid request");
            // always delete request, it should only be submitted once
            requests["delete"](key);
            _context.prev = 3;
            _context.next = 6;
            return signer.sendTransaction(request);
          case 6:
            sent = _context.sent;
            submissions.set(key, sent.hash);
            emit("submitted", key, sent.hash);
            _context.next = 14;
            break;
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](3);
            emit("error", key, _context.t0);
          case 14:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[3, 11]]);
    }));
    return _processRequest.apply(this, arguments);
  }
  function processSubmission(_x2) {
    return _processSubmission.apply(this, arguments);
  }
  function _processSubmission() {
    _processSubmission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {
      var hash, receipt;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            hash = submissions.get(key);
            assert(hash, "invalid submission");
            assert(signer.provider, "signer requires a provider, use signer.connect(provider)");
            // we look for this transaction, but it may never find it if its sped up
            _context2.next = 5;
            return signer.provider.getTransactionReceipt(hash)["catch"](function () {
              return undefined;
            });
          case 5:
            receipt = _context2.sent;
            if (!(receipt == null)) {
              _context2.next = 8;
              break;
            }
            return _context2.abrupt("return");
          case 8:
            if (!(receipt.confirmations < confirmations)) {
              _context2.next = 10;
              break;
            }
            return _context2.abrupt("return");
          case 10:
            submissions["delete"](key);
            mined.set(key, receipt);
            emit("mined", key, receipt);
          case 13:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _processSubmission.apply(this, arguments);
  }
  function isMined(_x3) {
    return _isMined.apply(this, arguments);
  }
  function _isMined() {
    _isMined = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", mined.get(key));
          case 1:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _isMined.apply(this, arguments);
  }
  function update() {
    return _update.apply(this, arguments);
  }
  function _update() {
    _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var _iterator, _step, key, _iterator2, _step2, _key;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _iterator = _createForOfIteratorHelperLoose(requests.keys());
          case 1:
            if ((_step = _iterator()).done) {
              _context4.next = 7;
              break;
            }
            key = _step.value;
            _context4.next = 5;
            return processRequest(key);
          case 5:
            _context4.next = 1;
            break;
          case 7:
            _iterator2 = _createForOfIteratorHelperLoose(submissions.keys());
          case 8:
            if ((_step2 = _iterator2()).done) {
              _context4.next = 14;
              break;
            }
            _key = _step2.value;
            _context4.next = 12;
            return processSubmission(_key);
          case 12:
            _context4.next = 8;
            break;
          case 14:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return _update.apply(this, arguments);
  }
  return {
    request: request,
    isMined: isMined,
    update: update
  };
});

var PoolState = /*#__PURE__*/function () {
  function PoolState(batchRead, contract, address) {
    this.batchRead = batchRead;
    this.contract = contract;
    this.address = address;
    this.l1Token = undefined;
  }
  var _proto = PoolState.prototype;
  _proto.read = /*#__PURE__*/function () {
    var _read = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(latestBlock, previousBlock) {
      var exchangeRatePrevious;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(this.l1Token === undefined)) {
              _context.next = 4;
              break;
            }
            _context.next = 3;
            return this.contract.l1Token();
          case 3:
            this.l1Token = _context.sent;
          case 4:
            _context.next = 6;
            return this.contract.callStatic.exchangeRateCurrent({
              blockTag: previousBlock || latestBlock - 1
            });
          case 6:
            exchangeRatePrevious = _context.sent;
            _context.t0 = _extends;
            _context.t1 = {
              address: this.address,
              l1Token: this.l1Token,
              exchangeRatePrevious: exchangeRatePrevious
            };
            _context.next = 11;
            return this.batchRead([
            // its important exchangeRateCurrent is called first, as it calls _sync under the hood which updates the contract
            // and gives more accurate values for the following properties.
            ["exchangeRateCurrent"], ["liquidityUtilizationCurrent"], ["liquidReserves"], ["pendingReserves"], ["utilizedReserves"]]);
          case 11:
            _context.t2 = _context.sent;
            return _context.abrupt("return", (0, _context.t0)(_context.t1, _context.t2));
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function read(_x, _x2) {
      return _read.apply(this, arguments);
    }
    return read;
  }();
  return PoolState;
}();
var PoolEventState = /*#__PURE__*/function () {
  function PoolEventState(contract, startBlock, state) {
    var _this = this;
    if (startBlock === void 0) {
      startBlock = 0;
    }
    if (state === void 0) {
      state = eventStateDefaults();
    }
    this.contract = contract;
    this.startBlock = startBlock;
    this.state = state;
    this.seen = new Set();
    this.filterSeen = function (params) {
      var seen = _this.hasEvent(params);
      if (!seen) _this.addEvent(params);
      return !seen;
    };
    this.iface = new ethers$1.utils.Interface(Factory$8.abi);
  }
  var _proto2 = PoolEventState.prototype;
  _proto2.makeId = function makeId(params) {
    return [params.blockNumber, params.transactionIndex, params.logIndex].join("!");
  };
  _proto2.hasEvent = function hasEvent(params) {
    return this.seen.has(this.makeId(params));
  };
  _proto2.addEvent = function addEvent(params) {
    return this.seen.add(this.makeId(params));
  };
  _proto2.read = /*#__PURE__*/function () {
    var _read2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(endBlock, userAddress) {
      var events;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (!(endBlock <= this.startBlock)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return", this.state);
          case 2:
            _context2.t0 = Promise;
            _context2.t1 = [];
            _context2.next = 6;
            return this.contract.queryFilter(this.contract.filters.LiquidityAdded(undefined, undefined, userAddress), this.startBlock, endBlock);
          case 6:
            _context2.t2 = _context2.sent;
            _context2.next = 9;
            return this.contract.queryFilter(this.contract.filters.LiquidityRemoved(undefined, undefined, userAddress), this.startBlock, endBlock);
          case 9:
            _context2.t3 = _context2.sent;
            _context2.t4 = _context2.t1.concat.call(_context2.t1, _context2.t2, _context2.t3);
            _context2.next = 13;
            return _context2.t0.all.call(_context2.t0, _context2.t4);
          case 13:
            events = _context2.sent.filter(this.filterSeen).sort(function (a, b) {
              if (a.blockNumber !== b.blockNumber) return a.blockNumber - b.blockNumber;
              if (a.transactionIndex !== b.transactionIndex) return a.transactionIndex - b.transactionIndex;
              // if everything is the same, return a, ie maintain order of array
              return -1;
            });
            // ethers queries are inclusive [start,end] unless start === end, then exclusive (start,end). we increment to make sure we dont see same event twice
            this.startBlock = endBlock + 1;
            this.state = getEventState$6(events, this.state);
            return _context2.abrupt("return", this.state);
          case 17:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function read(_x3, _x4) {
      return _read2.apply(this, arguments);
    }
    return read;
  }();
  _proto2.makeEventFromLog = function makeEventFromLog(log) {
    var description = this.iface.parseLog(log);
    return _extends({}, log, description, {
      event: description.name,
      eventSignature: description.signature
    });
  };
  _proto2.readTxReceipt = function readTxReceipt(receipt) {
    var _this2 = this;
    var events = receipt.logs.map(function (log) {
      try {
        return _this2.makeEventFromLog(log);
      } catch (err) {
        // return nothing, this throws a lot because logs from other contracts are included in receipt
        return;
      }
    })
    // filter out undefined
    .filter(exists).filter(this.filterSeen);
    this.state = getEventState$6(events, this.state);
    return this.state;
  };
  return PoolEventState;
}();
var UserState = /*#__PURE__*/function () {
  function UserState(contract) {
    this.contract = contract;
  }
  var _proto3 = UserState.prototype;
  _proto3.read = /*#__PURE__*/function () {
    var _read3 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(user) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.t0 = user;
            _context3.next = 3;
            return this.contract.balanceOf(user);
          case 3:
            _context3.t1 = _context3.sent;
            return _context3.abrupt("return", {
              address: _context3.t0,
              balanceOf: _context3.t1
            });
          case 5:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function read(_x5) {
      return _read3.apply(this, arguments);
    }
    return read;
  }();
  return UserState;
}();
function calculateRemoval(amountWei, percentWei) {
  var receive = amountWei.mul(percentWei).div(fixedPointAdjustment);
  var remain = amountWei.sub(receive);
  return {
    recieve: receive.toString(),
    remain: remain.toString()
  };
}
// params here mimic the user object type
function previewRemoval(values, percentFloat) {
  var percentWei = toBNWei(percentFloat);
  return {
    position: _extends({}, calculateRemoval(BigNumber.from(values.totalDeposited), percentWei)),
    fees: _extends({}, calculateRemoval(BigNumber.from(values.feesEarned), percentWei)),
    total: _extends({}, calculateRemoval(BigNumber.from(values.positionValue), percentWei))
  };
}
function joinUserState(poolState, eventState, userState) {
  var positionValue = BigNumber.from(poolState.exchangeRateCurrent).mul(userState.balanceOf).div(fixedPointAdjustment);
  var totalDeposited = BigNumber.from(eventState.tokens[userState.address] || "0");
  var feesEarned = positionValue.sub(totalDeposited);
  return {
    address: userState.address,
    poolAddress: poolState.address,
    lpTokens: userState.balanceOf.toString(),
    positionValue: positionValue.toString(),
    totalDeposited: totalDeposited.toString(),
    feesEarned: feesEarned.toString()
  };
}
function joinPoolState(poolState, latestBlock, previousBlock, rateModel) {
  var totalPoolSize = poolState.liquidReserves.add(poolState.utilizedReserves);
  var secondsElapsed = latestBlock.timestamp - previousBlock.timestamp;
  var blocksElapsed = latestBlock.number - previousBlock.number;
  var exchangeRatePrevious = poolState.exchangeRatePrevious.toString();
  var exchangeRateCurrent = poolState.exchangeRateCurrent.toString();
  var estimatedApy = calcPeriodicCompoundInterest(exchangeRatePrevious, exchangeRateCurrent, secondsElapsed, SECONDS_PER_YEAR);
  var estimatedApr = calcApr(exchangeRatePrevious, exchangeRateCurrent, secondsElapsed, SECONDS_PER_YEAR);
  var projectedApr = "";
  if (rateModel) {
    projectedApr = fromWei(calculateInstantaneousRate(rateModel, poolState.liquidityUtilizationCurrent).mul(poolState.liquidityUtilizationCurrent).div(fixedPointAdjustment));
  }
  return {
    address: poolState.address,
    totalPoolSize: totalPoolSize.toString(),
    l1Token: poolState.l1Token,
    liquidReserves: poolState.liquidReserves.toString(),
    pendingReserves: poolState.pendingReserves.toString(),
    exchangeRateCurrent: poolState.exchangeRateCurrent.toString(),
    exchangeRatePrevious: poolState.exchangeRatePrevious.toString(),
    estimatedApy: estimatedApy,
    estimatedApr: estimatedApr,
    blocksElapsed: blocksElapsed,
    secondsElapsed: secondsElapsed,
    liquidityUtilizationCurrent: poolState.liquidityUtilizationCurrent.toString(),
    projectedApr: projectedApr,
    utilizedReserves: poolState.utilizedReserves.toString()
  };
}
var ReadPoolClient = /*#__PURE__*/function () {
  function ReadPoolClient(address, provider, multicallAddress) {
    this.address = address;
    this.provider = provider;
    this.multicallAddress = multicallAddress;
    this.multicall = new Multicall2Factory(multicallAddress, provider);
    this.contract = connect$8(address, provider);
    this.batchRead = BatchReadWithErrors(this.multicall)(this.contract);
    this.poolState = new PoolState(this.batchRead, this.contract, address);
  }
  var _proto4 = ReadPoolClient.prototype;
  _proto4.read = /*#__PURE__*/function () {
    var _read4 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(latestBlock) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", this.poolState.read(latestBlock));
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function read(_x6) {
      return _read4.apply(this, arguments);
    }
    return read;
  }();
  return ReadPoolClient;
}();
function _validateWithdraw(pool, user, lpTokenAmount) {
  var l1TokensToReturn = BigNumber.from(lpTokenAmount).mul(pool.exchangeRateCurrent).div(fixedPointAdjustment);
  assert(BigNumber.from(l1TokensToReturn).gt("0"), "Must withdraw amount greater than 0");
  assert(BigNumber.from(pool.liquidReserves).gte(l1TokensToReturn.add(pool.pendingReserves)), "Utilization too high to remove that amount, try lowering withdraw amount");
  assert(BigNumber.from(lpTokenAmount).lte(user.lpTokens), "You cannot withdraw more than you have");
  return {
    lpTokenAmount: lpTokenAmount,
    l1TokensToReturn: l1TokensToReturn.toString()
  };
}
var Client = /*#__PURE__*/function () {
  function Client(config, deps, emit) {
    this.config = config;
    this.deps = deps;
    this.emit = emit;
    this.poolContracts = {};
    this.transactionManagers = {};
    this.state = {
      pools: {},
      users: {},
      transactions: {}
    };
    this.poolEvents = {};
    this.intervalStarted = false;
    this.multicall = new Multicall2Factory(config.multicall2Address, deps.provider);
    this.batchRead = BatchReadWithErrors(this.multicall);
    this.rateModelInstance = connect$9(config.rateModelStoreAddress || ADDRESSES.RateModel, deps.provider);
  }
  var _proto5 = Client.prototype;
  _proto5.getOrCreatePoolContract = function getOrCreatePoolContract(address) {
    if (this.poolContracts[address]) return this.poolContracts[address];
    var contract = connect$8(address, this.deps.provider);
    this.poolContracts[address] = contract;
    return contract;
  };
  _proto5.getOrCreatePoolEvents = function getOrCreatePoolEvents(poolAddress) {
    if (this.poolEvents[poolAddress]) return this.poolEvents[poolAddress];
    this.poolEvents[poolAddress] = new PoolEventState(this.getOrCreatePoolContract(poolAddress));
    return this.poolEvents[poolAddress];
  };
  _proto5.getOrCreateTransactionManager = function getOrCreateTransactionManager(signer, address) {
    var _this3 = this;
    if (this.transactionManagers[address]) return this.transactionManagers[address];
    var txman = TransactionManager({
      confirmations: this.config.confirmations
    }, signer, function (event, id, data) {
      if (event === "submitted") {
        _this3.state.transactions[id].state = event;
        _this3.state.transactions[id].hash = data;
        _this3.emit(["transactions", id], _extends({}, _this3.state.transactions[id]));
      }
      if (event === "mined") {
        var txReceipt = data;
        _this3.state.transactions[id].state = event;
        _this3.state.transactions[id].receipt = txReceipt;
        _this3.emit(["transactions", id], _extends({}, _this3.state.transactions[id]));
        // trigger pool and user update for a known mined transaction
        var tx = _this3.state.transactions[id];
        _this3.updatePool(tx.toAddress).then(function () {
          return _this3.updateUserWithTransaction(tx.fromAddress, tx.toAddress, txReceipt);
        })["catch"](function (err) {
          _this3.emit(["error"], err);
        });
      }
      if (event === "error") {
        _this3.state.transactions[id].state = event;
        _this3.state.transactions[id].error = data;
        _this3.emit(["transactions", id], _extends({}, _this3.state.transactions[id]));
      }
    });
    this.transactionManagers[address] = txman;
    return txman;
  };
  _proto5.addEthLiquidity = /*#__PURE__*/function () {
    var _addEthLiquidity = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(signer, pool, l1TokenAmount, overrides) {
      var userAddress, contract, txman, request, id;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            if (overrides === void 0) {
              overrides = {};
            }
            _context5.next = 3;
            return signer.getAddress();
          case 3:
            userAddress = _context5.sent;
            contract = this.getOrCreatePoolContract(pool);
            txman = this.getOrCreateTransactionManager(signer, userAddress); // dont allow override value here
            _context5.next = 8;
            return contract.populateTransaction.addLiquidity(l1TokenAmount, _extends({}, overrides, {
              value: l1TokenAmount
            }));
          case 8:
            request = _context5.sent;
            _context5.next = 11;
            return txman.request(request);
          case 11:
            id = _context5.sent;
            this.state.transactions[id] = {
              id: id,
              state: "requested",
              toAddress: pool,
              fromAddress: userAddress,
              type: "Add Liquidity",
              description: "Adding ETH to pool",
              request: request
            };
            this.emit(["transactions", id], _extends({}, this.state.transactions[id]));
            _context5.next = 16;
            return txman.update();
          case 16:
            return _context5.abrupt("return", id);
          case 17:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function addEthLiquidity(_x7, _x8, _x9, _x10) {
      return _addEthLiquidity.apply(this, arguments);
    }
    return addEthLiquidity;
  }();
  _proto5.addTokenLiquidity = /*#__PURE__*/function () {
    var _addTokenLiquidity = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(signer, pool, l1TokenAmount, overrides) {
      var userAddress, contract, txman, request, id;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            if (overrides === void 0) {
              overrides = {};
            }
            _context6.next = 3;
            return signer.getAddress();
          case 3:
            userAddress = _context6.sent;
            contract = this.getOrCreatePoolContract(pool);
            txman = this.getOrCreateTransactionManager(signer, userAddress);
            _context6.next = 8;
            return contract.populateTransaction.addLiquidity(l1TokenAmount, overrides);
          case 8:
            request = _context6.sent;
            _context6.next = 11;
            return txman.request(request);
          case 11:
            id = _context6.sent;
            this.state.transactions[id] = {
              id: id,
              state: "requested",
              toAddress: pool,
              fromAddress: userAddress,
              type: "Add Liquidity",
              description: "Adding Tokens to pool",
              request: request
            };
            this.emit(["transactions", id], _extends({}, this.state.transactions[id]));
            _context6.next = 16;
            return txman.update();
          case 16:
            return _context6.abrupt("return", id);
          case 17:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function addTokenLiquidity(_x11, _x12, _x13, _x14) {
      return _addTokenLiquidity.apply(this, arguments);
    }
    return addTokenLiquidity;
  }();
  _proto5.validateWithdraw = /*#__PURE__*/function () {
    var _validateWithdraw2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(poolAddress, userAddress, lpAmount) {
      var poolState, userState;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            if (this.hasPool(poolAddress)) {
              _context7.next = 3;
              break;
            }
            _context7.next = 3;
            return this.updatePool(poolAddress);
          case 3:
            poolState = this.getPool(poolAddress);
            if (this.hasUser(poolAddress, userAddress)) {
              _context7.next = 7;
              break;
            }
            _context7.next = 7;
            return this.updateUser(poolAddress, userAddress);
          case 7:
            userState = this.getUser(poolAddress, userAddress);
            return _context7.abrupt("return", _validateWithdraw(poolState, userState, lpAmount));
          case 9:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function validateWithdraw(_x15, _x16, _x17) {
      return _validateWithdraw2.apply(this, arguments);
    }
    return validateWithdraw;
  }();
  _proto5.removeTokenLiquidity = /*#__PURE__*/function () {
    var _removeTokenLiquidity = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(signer, pool, lpTokenAmount, overrides) {
      var userAddress, contract, txman, request, id;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            if (overrides === void 0) {
              overrides = {};
            }
            _context8.next = 3;
            return signer.getAddress();
          case 3:
            userAddress = _context8.sent;
            _context8.next = 6;
            return this.validateWithdraw(pool, userAddress, lpTokenAmount);
          case 6:
            contract = this.getOrCreatePoolContract(pool);
            txman = this.getOrCreateTransactionManager(signer, userAddress);
            _context8.next = 10;
            return contract.populateTransaction.removeLiquidity(lpTokenAmount, false, overrides);
          case 10:
            request = _context8.sent;
            _context8.next = 13;
            return txman.request(request);
          case 13:
            id = _context8.sent;
            this.state.transactions[id] = {
              id: id,
              state: "requested",
              toAddress: pool,
              fromAddress: userAddress,
              type: "Remove Liquidity",
              description: "Withdrawing Tokens from pool",
              request: request
            };
            this.emit(["transactions", id], _extends({}, this.state.transactions[id]));
            _context8.next = 18;
            return txman.update();
          case 18:
            return _context8.abrupt("return", id);
          case 19:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function removeTokenLiquidity(_x18, _x19, _x20, _x21) {
      return _removeTokenLiquidity.apply(this, arguments);
    }
    return removeTokenLiquidity;
  }();
  _proto5.removeEthliquidity = /*#__PURE__*/function () {
    var _removeEthliquidity = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(signer, pool, lpTokenAmount, overrides) {
      var userAddress, contract, txman, request, id;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            if (overrides === void 0) {
              overrides = {};
            }
            _context9.next = 3;
            return signer.getAddress();
          case 3:
            userAddress = _context9.sent;
            _context9.next = 6;
            return this.validateWithdraw(pool, userAddress, lpTokenAmount);
          case 6:
            contract = this.getOrCreatePoolContract(pool);
            txman = this.getOrCreateTransactionManager(signer, userAddress);
            _context9.next = 10;
            return contract.populateTransaction.removeLiquidity(lpTokenAmount, true, overrides);
          case 10:
            request = _context9.sent;
            _context9.next = 13;
            return txman.request(request);
          case 13:
            id = _context9.sent;
            this.state.transactions[id] = {
              id: id,
              state: "requested",
              toAddress: pool,
              fromAddress: userAddress,
              type: "Remove Liquidity",
              description: "Withdrawing Eth from pool",
              request: request
            };
            this.emit(["transactions", id], _extends({}, this.state.transactions[id]));
            _context9.next = 18;
            return txman.update();
          case 18:
            return _context9.abrupt("return", id);
          case 19:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function removeEthliquidity(_x22, _x23, _x24, _x25) {
      return _removeEthliquidity.apply(this, arguments);
    }
    return removeEthliquidity;
  }();
  _proto5.getPool = function getPool(poolAddress) {
    return this.state.pools[poolAddress];
  };
  _proto5.hasPool = function hasPool(poolAddress) {
    return Boolean(this.state.pools[poolAddress]);
  };
  _proto5.getUser = function getUser(poolAddress, userAddress) {
    return get(this.state, ["users", userAddress, poolAddress]);
  };
  _proto5.hasUser = function hasUser(poolAddress, userAddress) {
    return has(this.state, ["users", userAddress, poolAddress]);
  };
  _proto5.hasTx = function hasTx(id) {
    return has(this.state, ["transactions", id]);
  };
  _proto5.getTx = function getTx(id) {
    return get(this.state, ["transactions", id]);
  };
  _proto5.updateUserWithTransaction = /*#__PURE__*/function () {
    var _updateUserWithTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(userAddress, poolAddress, txReceipt) {
      var contract, poolState, getUserState, getPoolEventState, userState, eventState;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            contract = this.getOrCreatePoolContract(poolAddress);
            if (this.hasPool(poolAddress)) {
              _context10.next = 4;
              break;
            }
            _context10.next = 4;
            return this.updatePool(poolAddress);
          case 4:
            poolState = this.getPool(poolAddress);
            getUserState = new UserState(contract);
            getPoolEventState = this.getOrCreatePoolEvents(poolAddress);
            _context10.next = 9;
            return getUserState.read(userAddress);
          case 9:
            userState = _context10.sent;
            _context10.next = 12;
            return getPoolEventState.readTxReceipt(txReceipt);
          case 12:
            eventState = _context10.sent;
            set$1(this.state, ["users", userAddress, poolAddress], joinUserState(poolState, eventState, userState));
            this.emit(["users", userAddress, poolAddress], this.state.users[userAddress][poolAddress]);
          case 15:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this);
    }));
    function updateUserWithTransaction(_x26, _x27, _x28) {
      return _updateUserWithTransaction.apply(this, arguments);
    }
    return updateUserWithTransaction;
  }();
  _proto5.updateUser = /*#__PURE__*/function () {
    var _updateUser = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(userAddress, poolAddress) {
      var contract, poolState, latestBlock, getUserState, getPoolEventState, userState, eventState;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            contract = this.getOrCreatePoolContract(poolAddress);
            if (this.hasPool(poolAddress)) {
              _context11.next = 4;
              break;
            }
            _context11.next = 4;
            return this.updatePool(poolAddress);
          case 4:
            poolState = this.getPool(poolAddress);
            _context11.next = 7;
            return this.deps.provider.getBlock("latest");
          case 7:
            latestBlock = _context11.sent.number;
            getUserState = new UserState(contract);
            getPoolEventState = this.getOrCreatePoolEvents(poolAddress);
            _context11.next = 12;
            return getUserState.read(userAddress);
          case 12:
            userState = _context11.sent;
            _context11.next = 15;
            return getPoolEventState.read(latestBlock, userAddress);
          case 15:
            eventState = _context11.sent;
            set$1(this.state, ["users", userAddress, poolAddress], joinUserState(poolState, eventState, userState));
            this.emit(["users", userAddress, poolAddress], this.state.users[userAddress][poolAddress]);
          case 18:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this);
    }));
    function updateUser(_x29, _x30) {
      return _updateUser.apply(this, arguments);
    }
    return updateUser;
  }();
  _proto5.updatePool = /*#__PURE__*/function () {
    var _updatePool = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(poolAddress) {
      var _this$config$blockDel, blockDelta, contract, pool, latestBlock, previousBlock, state, rateModel, rateModelRaw;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            // default to 100 block delta unless specified otherwise in config
            _this$config$blockDel = this.config.blockDelta, blockDelta = _this$config$blockDel === void 0 ? DEFAULT_BLOCK_DELTA : _this$config$blockDel;
            contract = this.getOrCreatePoolContract(poolAddress);
            pool = new PoolState(this.batchRead(contract), contract, poolAddress);
            _context12.next = 5;
            return this.deps.provider.getBlock("latest");
          case 5:
            latestBlock = _context12.sent;
            _context12.next = 8;
            return this.deps.provider.getBlock(latestBlock.number - blockDelta);
          case 8:
            previousBlock = _context12.sent;
            _context12.next = 11;
            return pool.read(latestBlock.number, previousBlock.number);
          case 11:
            state = _context12.sent;
            rateModel = undefined;
            _context12.prev = 13;
            _context12.next = 16;
            return this.rateModelInstance.callStatic.l1TokenRateModels(state.l1Token);
          case 16:
            rateModelRaw = _context12.sent;
            rateModel = parseAndReturnRateModelFromString(rateModelRaw);
            _context12.next = 23;
            break;
          case 20:
            _context12.prev = 20;
            _context12.t0 = _context12["catch"](13);
            // we could swallow this error or just log it since getting the rate model is optional,
            // but we will just emit it to the caller and let them decide what to do with it.
            this.emit(["error"], _context12.t0);
          case 23:
            this.state.pools[poolAddress] = joinPoolState(state, latestBlock, previousBlock, rateModel);
            this.emit(["pools", poolAddress], this.state.pools[poolAddress]);
          case 25:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this, [[13, 20]]);
    }));
    function updatePool(_x31) {
      return _updatePool.apply(this, arguments);
    }
    return updatePool;
  }();
  _proto5.updateTransactions = /*#__PURE__*/function () {
    var _updateTransactions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
      var _i, _Object$values, txMan;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            _i = 0, _Object$values = Object.values(this.transactionManagers);
          case 1:
            if (!(_i < _Object$values.length)) {
              _context13.next = 14;
              break;
            }
            txMan = _Object$values[_i];
            _context13.prev = 3;
            _context13.next = 6;
            return txMan.update();
          case 6:
            _context13.next = 11;
            break;
          case 8:
            _context13.prev = 8;
            _context13.t0 = _context13["catch"](3);
            this.emit(["error"], _context13.t0);
          case 11:
            _i++;
            _context13.next = 1;
            break;
          case 14:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this, [[3, 8]]);
    }));
    function updateTransactions() {
      return _updateTransactions.apply(this, arguments);
    }
    return updateTransactions;
  }() // starts transaction checking intervals, defaults to 30 seconds
  ;
  _proto5.startInterval =
  /*#__PURE__*/
  function () {
    var _startInterval = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(delayMs) {
      var _this4 = this;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            if (delayMs === void 0) {
              delayMs = 30000;
            }
            assert(!this.intervalStarted, "Interval already started, try stopping first");
            this.intervalStarted = true;
            loop( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
              return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                while (1) switch (_context14.prev = _context14.next) {
                  case 0:
                    assert(_this4.intervalStarted, "Bridgepool Interval Stopped");
                    _context14.next = 3;
                    return _this4.updateTransactions();
                  case 3:
                  case "end":
                    return _context14.stop();
                }
              }, _callee14);
            })), delayMs)["catch"](function (err) {
              _this4.emit(["error"], err);
            });
          case 4:
          case "end":
            return _context15.stop();
        }
      }, _callee15, this);
    }));
    function startInterval(_x32) {
      return _startInterval.apply(this, arguments);
    }
    return startInterval;
  }() // starts transaction checking intervals
  ;
  _proto5.stopInterval =
  /*#__PURE__*/
  function () {
    var _stopInterval = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            this.intervalStarted = false;
          case 1:
          case "end":
            return _context16.stop();
        }
      }, _callee16, this);
    }));
    function stopInterval() {
      return _stopInterval.apply(this, arguments);
    }
    return stopInterval;
  }();
  return Client;
}();

var bridgePool = {
  __proto__: null,
  PoolEventState: PoolEventState,
  calculateRemoval: calculateRemoval,
  previewRemoval: previewRemoval,
  ReadPoolClient: ReadPoolClient,
  validateWithdraw: _validateWithdraw,
  Client: Client
};

var l1Contracts = {
  Proxy__OVM_L1StandardBridge: {
    1: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1",
    42: "0x22F24361D548e5FaAfb36d1437839f080363982B"
  }
};
var OptimismBridgeClient = /*#__PURE__*/function () {
  function OptimismBridgeClient() {
    // Gas limit for the L2 transaction initiated by the Sequencer
    this.L2_DEPOSIT_GAS_LIMIT = 2000000;
  }
  var _proto = OptimismBridgeClient.prototype;
  _proto.getL1BridgeAddress = function getL1BridgeAddress(chainId) {
    var l1StandardBridgeAddress = l1Contracts.Proxy__OVM_L1StandardBridge[chainId];
    assert(typeof l1StandardBridgeAddress === "string", "Chain not supported");
    return l1StandardBridgeAddress;
  }
  /**
   * Create a transaction to deposit ERC20 tokens to Optimism
   * @param l1Signer The L1 wallet provider (signer)
   * @param l1Erc20Address The L1 token address
   * @param l2Erc20Address The L2 token address
   * @param amount The amount to be deposited in wei
   * @returns The submitted transaction
   */;
  _proto.depositERC20 =
  /*#__PURE__*/
  function () {
    var _depositERC = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(l1Signer, l1Erc20Address, l2Erc20Address, amount) {
      var chainId, l1StandardBridgeAddress, l1StandardBridge, l1_ERC20;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return l1Signer.getChainId();
          case 2:
            chainId = _context.sent;
            l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);
            l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);
            l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
            return _context.abrupt("return", l1StandardBridge.depositERC20(l1_ERC20.address, l2Erc20Address, amount, this.L2_DEPOSIT_GAS_LIMIT, "0x"));
          case 7:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function depositERC20(_x, _x2, _x3, _x4) {
      return _depositERC.apply(this, arguments);
    }
    return depositERC20;
  }()
  /**
   * Create transaction to deposit ETH to Optimism
   * @param l1Signer The L1 wallet provider (signer)
   * @param amount The amount to be deposited in wei
   * @returns The submitted transaction
   */
  ;
  _proto.depositEth =
  /*#__PURE__*/
  function () {
    var _depositEth = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(l1Signer, amount) {
      var chainId, l1StandardBridgeAddress, l1StandardBridge;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return l1Signer.getChainId();
          case 2:
            chainId = _context2.sent;
            l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);
            l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);
            return _context2.abrupt("return", l1StandardBridge.depositETH(this.L2_DEPOSIT_GAS_LIMIT, "0x", {
              value: amount
            }));
          case 6:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function depositEth(_x5, _x6) {
      return _depositEth.apply(this, arguments);
    }
    return depositEth;
  }()
  /**
   * Wait a L1 transaction to be relayed by the L1 Cross Domain Messenger
   * @param tx The L1 -> L2 transaction
   * @param l1RpcProvider Layer 1 RPC provider
   * @param l2RpcProvider Layer 2 RPC provider
   * @returns The transaction receipt
   */
  ;
  _proto.waitRelayToL2 =
  /*#__PURE__*/
  function () {
    var _waitRelayToL = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tx, l1RpcProvider, l2RpcProvider) {
      var l2Messenger, l1Messenger, watcher, _yield$watcher$getMes, msgHash1;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            l2Messenger = new Contract(predeploys.L2CrossDomainMessenger, getContractInterface("L2CrossDomainMessenger"), l2RpcProvider);
            _context3.t0 = Contract;
            _context3.next = 4;
            return l2Messenger.l1CrossDomainMessenger();
          case 4:
            _context3.t1 = _context3.sent;
            _context3.t2 = getContractInterface("L1CrossDomainMessenger");
            _context3.t3 = l1RpcProvider;
            l1Messenger = new _context3.t0(_context3.t1, _context3.t2, _context3.t3);
            // Watch for messages to be relayed between L1 and L2.
            watcher = new Watcher({
              l1: {
                provider: l1RpcProvider,
                messengerAddress: l1Messenger.address
              },
              l2: {
                provider: l2RpcProvider,
                messengerAddress: l2Messenger.address
              }
            }); // Wait for the message to be relayed to L2
            _context3.next = 11;
            return watcher.getMessageHashesFromL1Tx(tx.hash);
          case 11:
            _yield$watcher$getMes = _context3.sent;
            msgHash1 = _yield$watcher$getMes[0];
            return _context3.abrupt("return", watcher.getL2TransactionReceipt(msgHash1, true));
          case 14:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    function waitRelayToL2(_x7, _x8, _x9) {
      return _waitRelayToL.apply(this, arguments);
    }
    return waitRelayToL2;
  }();
  _proto.checkAllowance = /*#__PURE__*/function () {
    var _checkAllowance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(l1Signer, l1Erc20Address) {
      var chainId, l1StandardBridgeAddress, l1_ERC20;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return l1Signer.getChainId();
          case 2:
            chainId = _context4.sent;
            l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);
            l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
            _context4.t0 = l1_ERC20;
            _context4.next = 8;
            return l1Signer.getAddress();
          case 8:
            _context4.t1 = _context4.sent;
            _context4.t2 = l1StandardBridgeAddress;
            return _context4.abrupt("return", _context4.t0.allowance.call(_context4.t0, _context4.t1, _context4.t2));
          case 11:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function checkAllowance(_x10, _x11) {
      return _checkAllowance.apply(this, arguments);
    }
    return checkAllowance;
  }();
  _proto.approve = /*#__PURE__*/function () {
    var _approve = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(l1Signer, l1Erc20Address, amount) {
      var chainId, l1StandardBridgeAddress, l1_ERC20;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return l1Signer.getChainId();
          case 2:
            chainId = _context5.sent;
            l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);
            l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
            return _context5.abrupt("return", l1_ERC20.approve(l1StandardBridgeAddress, amount));
          case 6:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function approve(_x12, _x13, _x14) {
      return _approve.apply(this, arguments);
    }
    return approve;
  }();
  return OptimismBridgeClient;
}();

var optimismBridge = {
  __proto__: null,
  l1Contracts: l1Contracts,
  OptimismBridgeClient: OptimismBridgeClient
};

var l1Contracts$1 = {
  ADDRESS_MANAGER_ADDRESS: {
    // mainnet
    1: "0x8376ac6C3f73a25Dd994E0b0669ca7ee0C02F089",
    // rinkeby
    4: "0x93A96D6A5beb1F661cf052722A1424CDDA3e9418"
  }
};
var BobaBridgeClient = /*#__PURE__*/function () {
  function BobaBridgeClient() {
    // Gas limit for the L2 transaction initiated by the Sequencer
    this.L2_DEPOSIT_GAS_LIMIT = 1300000;
  }
  var _proto = BobaBridgeClient.prototype;
  _proto.getL1BridgeAddress = /*#__PURE__*/function () {
    var _getL1BridgeAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(chainId, l1Provider) {
      var addressManagerAddress, addressManager, l1StandardBridgeAddress;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            addressManagerAddress = l1Contracts$1.ADDRESS_MANAGER_ADDRESS[chainId];
            assert(typeof addressManagerAddress === "string", "Chain not supported");
            addressManager = BobaAddressManagerEthers__factory.connect(addressManagerAddress, l1Provider);
            _context.next = 5;
            return addressManager.getAddress("Proxy__OVM_L1StandardBridge");
          case 5:
            l1StandardBridgeAddress = _context.sent;
            return _context.abrupt("return", l1StandardBridgeAddress);
          case 7:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    function getL1BridgeAddress(_x, _x2) {
      return _getL1BridgeAddress.apply(this, arguments);
    }
    return getL1BridgeAddress;
  }()
  /**
   * Create a transaction to deposit ERC20 tokens to Boba. Mainnet and Rinkeby are currently supported
   * @param l1Signer The L1 wallet provider (signer)
   * @param l1Erc20Address The L1 token address
   * @param l2Erc20Address The L2 token address
   * @param amount The amount to be deposited in wei
   * @returns The submitted transaction
   */
  ;
  _proto.depositERC20 =
  /*#__PURE__*/
  function () {
    var _depositERC = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(l1Signer, l1Erc20Address, l2Erc20Address, amount) {
      var chainId, l1StandardBridgeAddress, l1StandardBridge, l1_ERC20;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return l1Signer.getChainId();
          case 2:
            chainId = _context2.sent;
            _context2.next = 5;
            return this.getL1BridgeAddress(chainId, l1Signer);
          case 5:
            l1StandardBridgeAddress = _context2.sent;
            l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);
            l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
            return _context2.abrupt("return", l1StandardBridge.depositERC20(l1_ERC20.address, l2Erc20Address, amount, this.L2_DEPOSIT_GAS_LIMIT, ethers$1.utils.formatBytes32String(new Date().getTime().toString())));
          case 9:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function depositERC20(_x3, _x4, _x5, _x6) {
      return _depositERC.apply(this, arguments);
    }
    return depositERC20;
  }()
  /**
   * Create transaction to deposit ETH to Boba
   * @param l1Signer The L1 wallet provider (signer)
   * @param amount The amount to be deposited in wei
   * @returns The submitted transaction
   */
  ;
  _proto.depositEth =
  /*#__PURE__*/
  function () {
    var _depositEth = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(l1Signer, amount) {
      var chainId, l1StandardBridgeAddress, l1StandardBridge;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return l1Signer.getChainId();
          case 2:
            chainId = _context3.sent;
            _context3.next = 5;
            return this.getL1BridgeAddress(chainId, l1Signer);
          case 5:
            l1StandardBridgeAddress = _context3.sent;
            l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);
            return _context3.abrupt("return", l1StandardBridge.depositETH(this.L2_DEPOSIT_GAS_LIMIT, ethers$1.utils.formatBytes32String(new Date().getTime().toString()), {
              value: amount
            }));
          case 8:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function depositEth(_x7, _x8) {
      return _depositEth.apply(this, arguments);
    }
    return depositEth;
  }()
  /**
   * Wait a L1 transaction to be relayed by the L1 Cross Domain Messenger
   * @param tx The L1 -> L2 transaction
   * @param l1RpcProvider Layer 1 RPC provider
   * @param l2RpcProvider Layer 2 RPC provider
   * @returns The transaction receipt
   */
  ;
  _proto.waitRelayToL2 =
  /*#__PURE__*/
  function () {
    var _waitRelayToL = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tx, l1RpcProvider, l2RpcProvider) {
      var chainId, addressManagerAddress, addressManager, proxyL1CrossDomainMessengerAddress, l2CrossDomainMessenger, watcher, _yield$watcher$getMes, msgHash;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return l1RpcProvider.getNetwork();
          case 2:
            chainId = _context4.sent.chainId;
            addressManagerAddress = l1Contracts$1.ADDRESS_MANAGER_ADDRESS[chainId];
            assert(typeof addressManagerAddress === "string", "Chain not supported");
            addressManager = BobaAddressManagerEthers__factory.connect(addressManagerAddress, l1RpcProvider);
            _context4.next = 8;
            return addressManager.getAddress("Proxy__L1CrossDomainMessenger");
          case 8:
            proxyL1CrossDomainMessengerAddress = _context4.sent;
            _context4.next = 11;
            return addressManager.getAddress("L2CrossDomainMessenger");
          case 11:
            l2CrossDomainMessenger = _context4.sent;
            // Watch for messages to be relayed between L1 and L2.
            watcher = new Watcher({
              l1: {
                provider: l1RpcProvider,
                messengerAddress: proxyL1CrossDomainMessengerAddress
              },
              l2: {
                provider: l2RpcProvider,
                messengerAddress: l2CrossDomainMessenger
              }
            }); // Wait for the message to be relayed to L2
            _context4.next = 15;
            return watcher.getMessageHashesFromL1Tx(tx.hash);
          case 15:
            _yield$watcher$getMes = _context4.sent;
            msgHash = _yield$watcher$getMes[0];
            return _context4.abrupt("return", watcher.getL2TransactionReceipt(msgHash, true));
          case 18:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    function waitRelayToL2(_x9, _x10, _x11) {
      return _waitRelayToL.apply(this, arguments);
    }
    return waitRelayToL2;
  }();
  _proto.checkAllowance = /*#__PURE__*/function () {
    var _checkAllowance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(l1Signer, l1Erc20Address) {
      var chainId, l1StandardBridgeAddress, l1_ERC20;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return l1Signer.getChainId();
          case 2:
            chainId = _context5.sent;
            _context5.next = 5;
            return this.getL1BridgeAddress(chainId, l1Signer);
          case 5:
            l1StandardBridgeAddress = _context5.sent;
            l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
            _context5.t0 = l1_ERC20;
            _context5.next = 10;
            return l1Signer.getAddress();
          case 10:
            _context5.t1 = _context5.sent;
            _context5.t2 = l1StandardBridgeAddress;
            return _context5.abrupt("return", _context5.t0.allowance.call(_context5.t0, _context5.t1, _context5.t2));
          case 13:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function checkAllowance(_x12, _x13) {
      return _checkAllowance.apply(this, arguments);
    }
    return checkAllowance;
  }();
  _proto.approve = /*#__PURE__*/function () {
    var _approve = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(l1Signer, l1Erc20Address, amount) {
      var chainId, l1StandardBridgeAddress, l1_ERC20;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return l1Signer.getChainId();
          case 2:
            chainId = _context6.sent;
            _context6.next = 5;
            return this.getL1BridgeAddress(chainId, l1Signer);
          case 5:
            l1StandardBridgeAddress = _context6.sent;
            l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
            return _context6.abrupt("return", l1_ERC20.approve(l1StandardBridgeAddress, amount));
          case 8:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function approve(_x14, _x15, _x16) {
      return _approve.apply(this, arguments);
    }
    return approve;
  }();
  return BobaBridgeClient;
}();

var bobaBridge = {
  __proto__: null,
  l1Contracts: l1Contracts$1,
  BobaBridgeClient: BobaBridgeClient
};



var index$k = {
  __proto__: null,
  bridgePool: bridgePool,
  optimismBridge: optimismBridge,
  bobaBridge: bobaBridge
};



var index$l = {
  __proto__: null,
  feeCalculator: feeCalculator,
  rateModel: rateModel,
  gasFeeCalculator: gasFeeCalculator,
  utils: utils$1,
  constants: constants,
  clients: index$k,
  LpFeeCalculator: LpFeeCalculator,
  TransactionManager: TransactionManager
};

// This error should be thrown if an expected value does not exist
var ExistenceError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(ExistenceError, _Error);
  function ExistenceError(message) {
    var _this;
    if (message === void 0) {
      message = "";
    }
    _this = _Error.call(this, message) || this;
    _this.name = "ExistenceError";
    // if this isnt included, we cannot use instanceof to check the type
    Object.setPrototypeOf(_assertThisInitialized(_this), ExistenceError.prototype);
    return _this;
  }
  return ExistenceError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
// Special assert which checks for existence and throw existence error
function assertExists(condition, message) {
  if (message === void 0) {
    message = "";
  }
  if (!exists(condition)) throw new ExistenceError(message);
}
// Ignore only existence errors. If thrown properly this can be used to convert a non existent value to undefined.
function ignoreExistenceError(call) {
  try {
    return call();
  } catch (err) {
    if (err instanceof ExistenceError) return undefined;
    throw err;
  }
}
// same function but for async calls
function ignoreExistenceErrorAsync(_x) {
  return _ignoreExistenceErrorAsync.apply(this, arguments);
}
function _ignoreExistenceErrorAsync() {
  _ignoreExistenceErrorAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(call) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 3;
          return call();
        case 3:
          return _context.abrupt("return", _context.sent);
        case 6:
          _context.prev = 6;
          _context.t0 = _context["catch"](0);
          if (!(_context.t0 instanceof ExistenceError)) {
            _context.next = 10;
            break;
          }
          return _context.abrupt("return", undefined);
        case 10:
          throw _context.t0;
        case 11:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[0, 6]]);
  }));
  return _ignoreExistenceErrorAsync.apply(this, arguments);
}

var errors = {
  __proto__: null,
  ExistenceError: ExistenceError,
  assertExists: assertExists,
  ignoreExistenceError: ignoreExistenceError,
  ignoreExistenceErrorAsync: ignoreExistenceErrorAsync
};

var OracleType;
(function (OracleType) {
  OracleType["Optimistic"] = "Optimistic";
  OracleType["Skinny"] = "Skinny";
  OracleType["OptimisticV2"] = "OptimisticV2";
})(OracleType || (OracleType = {}));
var Flag;
(function (Flag) {
  Flag["MissingRequest"] = "MissingRequest";
  Flag["MissingUser"] = "MissingUser";
  Flag["WrongChain"] = "WrongChain";
  Flag["CanPropose"] = "CanPropose";
  Flag["CanDispute"] = "CanDispute";
  Flag["CanSettle"] = "CanSettle";
  Flag["InDvmVote"] = "InDvmVote";
  Flag["RequestSettled"] = "RequestSettled";
  Flag["InsufficientBalance"] = "InsufficientBalance";
  Flag["InsufficientApproval"] = "InsufficientApproval";
  Flag["ChainChangeInProgress"] = "ChainChangeInProgress";
  Flag["ProposalTxInProgress"] = "ProposalTxInProgress";
  Flag["ApprovalTxInProgress"] = "ApprovalTxInProgress";
  Flag["DisputeTxInProgress"] = "DisputeTxInProgress";
})(Flag || (Flag = {}));

var state = {
  __proto__: null,
  get OracleType () { return OracleType; },
  get Flag () { return Flag; },
  get RequestState () { return RequestState; }
};

var ContextType;
(function (ContextType) {
  ContextType["setUser"] = "setUser";
  ContextType["setActiveRequest"] = "setActiveRequest";
  ContextType["approve"] = "approve";
  ContextType["clearUser"] = "clearUser";
  ContextType["disputePrice"] = "disputePrice";
  ContextType["proposePrice"] = "proposePrice";
  ContextType["switchOrAddChain"] = "switchOrAddChain";
  ContextType["pollActiveRequest"] = "pollActiveRequest";
  ContextType["pollActiveUser"] = "pollActiveUser";
  ContextType["fetchPastEvents"] = "fetchPastEvents";
  ContextType["pollNewEvents"] = "pollNewEvents";
  ContextType["setActiveRequestByTransaction"] = "setActiveRequestByTransaction";
  ContextType["settle"] = "settle";
  ContextType["updateActiveRequest"] = "updateActiveRequest";
  ContextType["fetchEventBased"] = "fetchEventBased";
})(ContextType || (ContextType = {}));

var statemachine = {
  __proto__: null,
  get ContextType () { return ContextType; }
};

var _excluded = ["checkTxIntervalSec", "multicall2Address", "optimisticOracleAddress", "earliestBlockNumber", "maxEventRangeQuery"];
var getAddress = ethers$1.utils.getAddress;
var hexValue = ethers$1.utils.hexValue;
function initFlags() {
  var _ref;
  return _ref = {}, _ref[Flag.MissingRequest] = false, _ref[Flag.MissingUser] = false, _ref[Flag.WrongChain] = false, _ref[Flag.CanPropose] = false, _ref[Flag.CanDispute] = false, _ref[Flag.CanSettle] = false, _ref[Flag.InDvmVote] = false, _ref[Flag.RequestSettled] = false, _ref[Flag.InsufficientBalance] = false, _ref[Flag.InsufficientApproval] = false, _ref[Flag.ProposalTxInProgress] = false, _ref[Flag.ApprovalTxInProgress] = false, _ref[Flag.DisputeTxInProgress] = false, _ref[Flag.ChainChangeInProgress] = false, _ref;
}
var nowS = function nowS(now) {
  if (now === void 0) {
    now = Date.now();
  }
  return Math.floor(now / 1000);
};
// reduce global state into important UI boolean states. this should never throw errors.
function getFlags(state) {
  var read = new Read(state);
  var flags = initFlags();
  var signer = ignoreExistenceError(read.signer);
  flags[Flag.MissingUser] = signer ? false : true;
  var inputRequest = ignoreExistenceError(read.inputRequest);
  flags[Flag.MissingRequest] = inputRequest ? false : true;
  var userChainId = ignoreExistenceError(read.userChainId);
  var requestChainId = ignoreExistenceError(read.requestChainId);
  flags[Flag.WrongChain] = userChainId && requestChainId ? userChainId !== requestChainId : false;
  var request = ignoreExistenceError(read.request);
  // these are a bit redundant with request state, but just an alternate way to see current request state
  flags[Flag.CanPropose] = (request == null ? void 0 : request.state) === RequestState.Requested;
  flags[Flag.CanDispute] = (request == null ? void 0 : request.state) === RequestState.Proposed;
  flags[Flag.CanSettle] = (request == null ? void 0 : request.state) === RequestState.Resolved || (request == null ? void 0 : request.state) === RequestState.Expired;
  flags[Flag.InDvmVote] = (request == null ? void 0 : request.state) === RequestState.Disputed;
  flags[Flag.RequestSettled] = (request == null ? void 0 : request.state) === RequestState.Settled;
  if (request && request.bond && request.finalFee) {
    var totalBond = request.bond.add(request.finalFee);
    var userCollateralBalance = ignoreExistenceError(read.userCollateralBalance);
    var userCollateralAllowance = ignoreExistenceError(read.userCollateralAllowance);
    flags[Flag.InsufficientBalance] = userCollateralBalance ? userCollateralBalance.lt(totalBond) : false;
    flags[Flag.InsufficientApproval] = userCollateralAllowance ? userCollateralAllowance.lt(totalBond) : false;
  }
  var userAddress = ignoreExistenceError(read.userAddress);
  var commands = ignoreExistenceError(function () {
    return read.filterCommands({
      done: false,
      user: userAddress
    });
  });
  if (userAddress && commands) {
    commands.forEach(function (command) {
      if (!flags[Flag.ProposalTxInProgress] && command.type === ContextType.proposePrice) {
        flags[Flag.ProposalTxInProgress] = true;
      }
      if (!flags[Flag.DisputeTxInProgress] && command.type === ContextType.disputePrice) {
        flags[Flag.DisputeTxInProgress] = true;
      }
      if (!flags[Flag.ApprovalTxInProgress] && command.type === ContextType.approve) {
        flags[Flag.ApprovalTxInProgress] = true;
      }
      if (!flags[Flag.ChainChangeInProgress] && command.type === ContextType.switchOrAddChain) {
        flags[Flag.ChainChangeInProgress] = true;
      }
    });
  }
  return flags;
}
function getMulticall2Address(chainId) {
  switch (chainId.toString()) {
    case "1":
      return getAddress("0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696");
    case "4":
      return getAddress("0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696");
    case "5":
      return getAddress("0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696");
    case "42":
      return getAddress("0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696");
    default:
      throw new Error("No address found for deployment Multicall2 on chainId " + chainId);
  }
}
var DefaultChainConfig = function DefaultChainConfig(_ref2) {
  var getMulticall2Address = _ref2.getMulticall2Address;
  return function (chainId, chainConfig) {
    var multicall2Address = chainConfig.multicall2Address;
    try {
      multicall2Address = multicall2Address || getMulticall2Address(chainId);
    } catch (err) {
      // ignore, multicall optional
    }
    var checkTxIntervalSec = chainConfig.checkTxIntervalSec || 5;
    return _extends({}, chainConfig, {
      chainId: chainId,
      multicall2Address: multicall2Address,
      checkTxIntervalSec: checkTxIntervalSec
    });
  };
};
var DefaultConfig = function DefaultConfig(getters) {
  return function (config, oracleType) {
    return Object.entries(config.chains).reduce(function (config, _ref3) {
      var chainId = _ref3[0],
        chainConfig = _ref3[1];
      config.chains[Number(chainId)] = DefaultChainConfig(getters)(Number(chainId), chainConfig);
      return config;
    }, _extends({}, config, {
      chains: {},
      oracleType: oracleType
    }));
  };
};
var TransactionConfirmer = /*#__PURE__*/function () {
  function TransactionConfirmer(provider) {
    this.provider = provider;
  }
  var _proto = TransactionConfirmer.prototype;
  _proto.getReceipt = /*#__PURE__*/function () {
    var _getReceipt = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hash) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", this.provider.getTransactionReceipt(hash));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function getReceipt(_x) {
      return _getReceipt.apply(this, arguments);
    }
    return getReceipt;
  }();
  _proto.isConfirmed = /*#__PURE__*/function () {
    var _isConfirmed = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(hash, confirmations) {
      var receipt;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (confirmations === void 0) {
              confirmations = 1;
            }
            _context2.prev = 1;
            _context2.next = 4;
            return this.getReceipt(hash);
          case 4:
            receipt = _context2.sent;
            if (!(receipt.confirmations >= confirmations)) {
              _context2.next = 7;
              break;
            }
            return _context2.abrupt("return", receipt);
          case 7:
            _context2.next = 11;
            break;
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](1);
          case 11:
            return _context2.abrupt("return", false);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[1, 9]]);
    }));
    function isConfirmed(_x2, _x3) {
      return _isConfirmed.apply(this, arguments);
    }
    return isConfirmed;
  }();
  return TransactionConfirmer;
}();
function chainConfigToChainMetadata(config) {
  var chainMetadata = _objectWithoutPropertiesLoose(config, _excluded);
  return chainMetadata;
}
/**
 * rangeStart. This starts a new range query and sets defaults for state.  Use this as the first call before starting your queries
 *
 * @param {Pick} state
 * @returns {RangeState}
 */
function rangeStart(state) {
  var startBlock = state.startBlock,
    endBlock = state.endBlock,
    _state$multiplier = state.multiplier,
    multiplier = _state$multiplier === void 0 ? 2 : _state$multiplier;
  if (state.maxRange && state.maxRange > 0) {
    var range = endBlock - startBlock;
    assert(range > 0, "End block must be higher than start block");
    var currentRange = Math.min(state.maxRange, range);
    var currentStart = endBlock - currentRange;
    var currentEnd = endBlock;
    return {
      done: false,
      startBlock: startBlock,
      endBlock: endBlock,
      maxRange: state.maxRange,
      currentRange: currentRange,
      currentStart: currentStart,
      currentEnd: currentEnd,
      multiplier: multiplier
    };
  } else {
    // the largest range we can have, since this is the users query for start and end
    var maxRange = endBlock - startBlock;
    assert(maxRange > 0, "End block must be higher than start block");
    var _currentStart = startBlock;
    var _currentEnd = endBlock;
    var _currentRange = maxRange;
    return {
      done: false,
      startBlock: startBlock,
      endBlock: endBlock,
      maxRange: maxRange,
      currentRange: _currentRange,
      currentStart: _currentStart,
      currentEnd: _currentEnd,
      multiplier: multiplier
    };
  }
}
/**
 * rangeSuccessDescending. We have 2 ways of querying events, from oldest to newest, or newest to oldest. Typically we want them in order, from
 * oldest to newest, but for this particular case we want them newest to oldest, ie descending ( larger timestamp to smaller timestamp).
 * This function will increase the range between start/end block and return a new start/end to use since by calling this you are signalling
 * that the last range ended in a successful query.
 *
 * @param {RangeState} state
 * @returns {RangeState}
 */
function rangeSuccessDescending(state) {
  var startBlock = state.startBlock,
    currentStart = state.currentStart,
    maxRange = state.maxRange,
    currentRange = state.currentRange,
    _state$multiplier2 = state.multiplier,
    multiplier = _state$multiplier2 === void 0 ? 2 : _state$multiplier2;
  // we are done if we succeeded querying where the currentStart matches are initial start block
  var done = currentStart <= startBlock;
  // increase range up to max range for every successful query
  var nextRange = Math.min(Math.ceil(currentRange * multiplier), maxRange);
  // move our end point to the previously successful start, ie moving from newest to oldest
  var nextEnd = currentStart;
  // move our start block to the next range down
  var nextStart = Math.max(nextEnd - nextRange, startBlock);
  return _extends({}, state, {
    currentStart: nextStart,
    currentEnd: nextEnd,
    currentRange: nextRange,
    done: done
  });
}
/**
 * rangeFailureDescending. Like the previous function, this will decrease the range between start/end for your query, because you are signalling
 * that the last query failed. It will also keep the end of your range the same, while moving the start range up. This is why
 * its considered descending, it will attempt to move from end to start, rather than start to end.
 *
 * @param {RangeState} state
 * @returns {RangeState}
 */
function rangeFailureDescending(state) {
  var startBlock = state.startBlock,
    currentEnd = state.currentEnd,
    currentRange = state.currentRange,
    _state$multiplier3 = state.multiplier,
    multiplier = _state$multiplier3 === void 0 ? 2 : _state$multiplier3;
  var nextRange = Math.floor(currentRange / multiplier);
  // this will eventually throw an error if you keep calling this function, which protects us against re-querying a broken api in a loop
  assert(nextRange > 0, "Range must be above 0");
  // we stay at the same end block
  var nextEnd = currentEnd;
  // move our start block closer to the end block, shrinking the range
  var nextStart = Math.max(nextEnd - nextRange, startBlock);
  return _extends({}, state, {
    currentStart: nextStart,
    currentEnd: nextEnd,
    currentRange: nextRange
  });
}
/**
 * eventKey. Make a unique and sortable identifier string for an event
 *
 * @param {Event} event
 * @returns {string} - the unique id
 */
function eventKey(event) {
  var _event$logIndex;
  return [
  // we pad these because numbers of varying lengths will not sort correctly, ie "10" will incorrectly sort before "9", but "09" will be correct.
  event.blockNumber.toString().padStart(16, "0"), event.transactionIndex.toString().padStart(16, "0"), (_event$logIndex = event.logIndex) == null ? void 0 : _event$logIndex.toString().padStart(16, "0")].join("~");
}
/**
 * insertOrdered. Inserts items in an array maintaining sorted order, in this case lowest to highest. Does not check duplicates.
 * Mainly used for caching all known events, in order of oldest to newest.
 *
 * @param {T[]} array
 * @param {T} element
 * @param {Function} orderBy
 */
function insertOrderedAscending(array, element, orderBy) {
  var index = sortedLastIndexBy(array, element, orderBy);
  array.splice(index, 0, element);
  return array;
}
function isUnique(array, element, id) {
  var elementId = id(element);
  var found = array.find(function (next) {
    return id(next) === elementId;
  });
  return found === undefined;
}
function isSupportedOracleType(oracleType) {
  return oracleType in OracleType;
}

var utils$2 = {
  __proto__: null,
  getAddress: getAddress,
  hexValue: hexValue,
  initFlags: initFlags,
  nowS: nowS,
  getFlags: getFlags,
  getMulticall2Address: getMulticall2Address,
  DefaultChainConfig: DefaultChainConfig,
  DefaultConfig: DefaultConfig,
  TransactionConfirmer: TransactionConfirmer,
  chainConfigToChainMetadata: chainConfigToChainMetadata,
  rangeStart: rangeStart,
  rangeSuccessDescending: rangeSuccessDescending,
  rangeFailureDescending: rangeFailureDescending,
  eventKey: eventKey,
  insertOrderedAscending: insertOrderedAscending,
  isUnique: isUnique,
  isSupportedOracleType: isSupportedOracleType,
  requestId: requestId
};

var batchProps = [["symbol"], ["name"], ["decimals"], ["totalSupply"]];
var Erc20 = /*#__PURE__*/function () {
  function Erc20(provider, address) {
    this.provider = provider;
    this.address = address;
    this.contract = connect$2(address, provider);
  }
  var _proto = Erc20.prototype;
  _proto.approve = /*#__PURE__*/function () {
    var _approve = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(signer, spender, amount) {
      var contract;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            contract = connect$2(this.address, signer);
            return _context.abrupt("return", contract.approve(spender, amount));
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function approve(_x, _x2, _x3) {
      return _approve.apply(this, arguments);
    }
    return approve;
  }();
  _proto.getProps = /*#__PURE__*/function () {
    var _getProps = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var contract;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            contract = this.contract;
            _context2.t0 = this.address;
            _context2.next = 4;
            return contract.callStatic.symbol();
          case 4:
            _context2.t1 = _context2.sent;
            _context2.next = 7;
            return contract.callStatic.name();
          case 7:
            _context2.t2 = _context2.sent;
            _context2.next = 10;
            return contract.callStatic.decimals();
          case 10:
            _context2.t3 = _context2.sent;
            _context2.next = 13;
            return contract.callStatic.totalSupply();
          case 13:
            _context2.t4 = _context2.sent;
            return _context2.abrupt("return", {
              address: _context2.t0,
              symbol: _context2.t1,
              name: _context2.t2,
              decimals: _context2.t3,
              totalSupply: _context2.t4
            });
          case 15:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function getProps() {
      return _getProps.apply(this, arguments);
    }
    return getProps;
  }();
  return Erc20;
}();
var Erc20Multicall = /*#__PURE__*/function (_Erc) {
  _inheritsLoose(Erc20Multicall, _Erc);
  function Erc20Multicall(provider, address, multicall2) {
    var _this;
    _this = _Erc.call(this, provider, address) || this;
    _this.multicall2 = multicall2;
    _this.batchRead = BatchReadWithErrors(multicall2)(_this.contract);
    return _this;
  }
  var _proto2 = Erc20Multicall.prototype;
  _proto2.getProps = /*#__PURE__*/function () {
    var _getProps2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.t0 = _extends;
            _context3.t1 = {};
            _context3.next = 4;
            return this.batchRead(batchProps);
          case 4:
            _context3.t2 = _context3.sent;
            _context3.t3 = {
              address: this.address
            };
            return _context3.abrupt("return", (0, _context3.t0)(_context3.t1, _context3.t2, _context3.t3));
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function getProps() {
      return _getProps2.apply(this, arguments);
    }
    return getProps;
  }();
  return Erc20Multicall;
}(Erc20);
function factory(provider, address, multicall2) {
  if (!multicall2) return new Erc20(provider, address);
  return new Erc20Multicall(provider, address, multicall2);
}

var erc20 = {
  __proto__: null,
  Erc20: Erc20,
  Erc20Multicall: Erc20Multicall,
  factory: factory
};

// This file contains composable and type safe state writers which mirror the state in types/state.
// Each component takes in 1 parameters, state and you can include any number of functions to operate on the state.
// Some things to consider:
// 1. State can be nested, but it should strictly one direction, each class should ideally only operate on its direct state object.
// 2. The parent can return new components, but its responsible for initializing the state for the child.
// 3. You can modify this.state in the component thanks to immer, but you cannot set this.state to a new object, only its properties.
var User = /*#__PURE__*/function () {
  function User(state) {
    this.state = state;
  }
  var _proto = User.prototype;
  _proto.set = function set(data) {
    // note that this is done because we cannot replace this.state = data or immer loses visibility to the change.
    if (data.chainId) this.chainId(data.chainId);
    if (data.address) this.address(data.address);
    if (data.signer) this.signer(data.signer);
    if (data.provider) this.provider(data.provider);
  };
  _proto.clear = function clear() {
    delete this.state.chainId;
    delete this.state.address;
    delete this.state.signer;
    delete this.state.provider;
  };
  _proto.chainId = function chainId(_chainId) {
    this.state.chainId = _chainId;
  };
  _proto.address = function address(_address) {
    this.state.address = _address;
  };
  _proto.signer = function signer(_signer) {
    this.state.signer = _signer;
  };
  _proto.provider = function provider(_provider) {
    this.state.provider = _provider;
  };
  return User;
}();
var Balances$1 = /*#__PURE__*/function () {
  function Balances(state) {
    this.state = state;
  }
  var _proto2 = Balances.prototype;
  _proto2.set = function set(address, amount) {
    this.state[address] = amount;
  };
  return Balances;
}();
var Erc20$1 = /*#__PURE__*/function () {
  function Erc20(state) {
    this.state = state;
  }
  var _proto3 = Erc20.prototype;
  _proto3.props = function props(data) {
    this.state.props = data;
  };
  _proto3.balance = function balance(account, amount) {
    if (!this.state.balances) this.state.balances = {};
    new Balances$1(this.state.balances).set(account, amount);
  };
  _proto3.allowance = function allowance(account, spender, amount) {
    if (!this.state.allowances) this.state.allowances = {};
    if (!this.state.allowances[spender]) this.state.allowances[spender] = {};
    new Balances$1(this.state.allowances[spender]).set(account, amount);
  };
  return Erc20;
}();
var OptimisticOracle = /*#__PURE__*/function () {
  function OptimisticOracle(state) {
    this.state = state;
  }
  var _proto4 = OptimisticOracle.prototype;
  _proto4.address = function address(_address2) {
    this.state.address = _address2;
  };
  _proto4.request = function request(_request) {
    var id = requestId(_request);
    if (!this.state.requests) this.state.requests = {};
    // merge data in rather than replace
    this.state.requests[id] = _extends({}, this.state.requests[id], _request);
  };
  _proto4.defaultLiveness = function defaultLiveness(_defaultLiveness) {
    this.state.defaultLiveness = _defaultLiveness;
  };
  return OptimisticOracle;
}();
var Chain = /*#__PURE__*/function () {
  function Chain(state) {
    this.state = state;
  }
  var _proto5 = Chain.prototype;
  _proto5.erc20s = function erc20s(address) {
    var _this$state, _this$state$erc20s;
    if (!((_this$state = this.state) != null && _this$state.erc20s)) this.state.erc20s = {};
    if (!((_this$state$erc20s = this.state.erc20s) != null && _this$state$erc20s[address])) this.state.erc20s[address] = {};
    return new Erc20$1(this.state.erc20s[address]);
  };
  _proto5.optimisticOracle = function optimisticOracle() {
    var _this$state2;
    if (!((_this$state2 = this.state) != null && _this$state2.optimisticOracle)) this.state.optimisticOracle = {};
    return new OptimisticOracle(this.state.optimisticOracle);
  };
  _proto5.currentTime = function currentTime(_currentTime) {
    this.state.currentTime = _currentTime;
  };
  return Chain;
}();
var Inputs = /*#__PURE__*/function () {
  function Inputs(state) {
    this.state = state;
  }
  var _proto6 = Inputs.prototype;
  _proto6.request = function request(params) {
    this.state.request = params;
  };
  _proto6.user = function user() {
    if (!this.state.user) this.state.user = {};
    return new User(this.state.user);
  };
  return Inputs;
}();
var Services = /*#__PURE__*/function () {
  function Services(state) {
    this.state = state;
  }
  var _proto7 = Services.prototype;
  _proto7.provider = function provider(_provider2) {
    this.state.provider = _provider2;
  };
  _proto7.erc20s = function erc20s(address) {
    var _this$state3, _this$state4, _this$state5;
    if (!((_this$state3 = this.state) != null && _this$state3.provider)) return;
    if (!((_this$state4 = this.state) != null && _this$state4.erc20s)) this.state.erc20s = {};
    // only add this once
    if ((_this$state5 = this.state) != null && _this$state5.erc20s[address]) return;
    this.state.erc20s[address] = factory(this.state.provider, address, this.state.multicall2);
  };
  _proto7.optimisticOracle = function optimisticOracle(_optimisticOracle) {
    if (this.state.optimisticOracle) return;
    this.state.optimisticOracle = _optimisticOracle;
  };
  _proto7.multicall2 = function multicall2(multicall2Address) {
    if (!multicall2Address) return;
    if (this.state.multicall2) return;
    if (!this.state.provider) return;
    this.state.multicall2 = new Multicall2Factory(multicall2Address, this.state.provider);
  };
  return Services;
}();
/**
 * Write. The main writer class for this applications global state object. Composes classes that initialize, validate
 * and simplify changes to the global state. This class modifies state directly, and really is only useful in combination with immer.
 */
var Write = /*#__PURE__*/function () {
  function Write(state) {
    this.state = state;
  }
  var _proto8 = Write.prototype;
  _proto8.chains = function chains(chainId) {
    var _this$state6, _this$state7, _this$state7$chains;
    if (!((_this$state6 = this.state) != null && _this$state6.chains)) this.state.chains = {};
    if (!((_this$state7 = this.state) != null && (_this$state7$chains = _this$state7.chains) != null && _this$state7$chains[chainId])) this.state.chains[chainId] = {};
    return new Chain(this.state.chains[chainId]);
  };
  _proto8.inputs = function inputs() {
    if (!this.state.inputs) this.state.inputs = {};
    return new Inputs(this.state.inputs);
  };
  _proto8.config = function config(_config) {
    this.state.config = _config;
  };
  _proto8.services = function services(chainId) {
    if (!this.state.services) this.state.services = {};
    if (!this.state.services.chains) this.state.services.chains = {};
    if (!this.state.services.chains[chainId]) this.state.services.chains[chainId] = {};
    return new Services(this.state.services.chains[chainId]);
  };
  _proto8.error = function error(_error) {
    this.state.error = _error;
  };
  _proto8.command = function command(context) {
    if (!this.state.commands) this.state.commands = {};
    this.state.commands[context.id] = context;
  };
  _proto8.sortedRequestsService = function sortedRequestsService(sortedRequests) {
    var _this$state8, _this$state8$services;
    if ((_this$state8 = this.state) != null && (_this$state8$services = _this$state8.services) != null && _this$state8$services.sortedRequests) return;
    // only want to add this once
    this.state.services = {
      sortedRequests: sortedRequests
    };
  };
  _proto8.descendingRequests = function descendingRequests(sortedRequests) {
    this.state.descendingRequests = sortedRequests;
  };
  return Write;
}();

// This is a typescript compatible way of pulling out values from the global state object, essentially
// forming a basic API. Most calls are parameterless, requiring first setting state which determines, the
// user/chain, etc of the query.
var Read = function Read(state) {
  var _this = this;
  this.state = state;
  this.chainConfig = function (optionalChainId) {
    var _this$state, _this$state$config, _this$state$config$ch;
    var chainId = optionalChainId || _this.requestChainId();
    var config = (_this$state = _this.state) == null ? void 0 : (_this$state$config = _this$state.config) == null ? void 0 : (_this$state$config$ch = _this$state$config.chains) == null ? void 0 : _this$state$config$ch[chainId];
    assertExists(config, "No config set for chain: " + chainId);
    return config;
  };
  this.oracleType = function () {
    var _this$state2, _this$state2$config;
    var source = (_this$state2 = _this.state) == null ? void 0 : (_this$state2$config = _this$state2.config) == null ? void 0 : _this$state2$config.oracleType;
    assertExists(source, "No oracle name set on config");
    return source;
  };
  this.requestChainId = function () {
    var _this$state3, _this$state3$inputs, _this$state3$inputs$r;
    var chainId = (_this$state3 = _this.state) == null ? void 0 : (_this$state3$inputs = _this$state3.inputs) == null ? void 0 : (_this$state3$inputs$r = _this$state3$inputs.request) == null ? void 0 : _this$state3$inputs$r.chainId;
    assertExists(chainId, "ChainId is not set on request");
    return chainId;
  };
  this.user = function () {
    var _this$state4, _this$state4$inputs;
    var result = (_this$state4 = _this.state) == null ? void 0 : (_this$state4$inputs = _this$state4.inputs) == null ? void 0 : _this$state4$inputs.user;
    assertExists(result, "user not set");
    return result;
  };
  this.userChainId = function () {
    var _this$state5, _this$state5$inputs, _this$state5$inputs$u;
    var chainId = (_this$state5 = _this.state) == null ? void 0 : (_this$state5$inputs = _this$state5.inputs) == null ? void 0 : (_this$state5$inputs$u = _this$state5$inputs.user) == null ? void 0 : _this$state5$inputs$u.chainId;
    assertExists(chainId, "ChainId is not set");
    return chainId;
  };
  this.requestChain = function (optionalChainId) {
    var _this$state6, _this$state6$chains;
    var chainId = optionalChainId || _this.requestChainId();
    var chain = (_this$state6 = _this.state) == null ? void 0 : (_this$state6$chains = _this$state6.chains) == null ? void 0 : _this$state6$chains[chainId];
    assertExists(chain, "Chain not set");
    return chain;
  };
  this.userAddress = function () {
    var _this$state7, _this$state7$inputs, _this$state7$inputs$u;
    var address = (_this$state7 = _this.state) == null ? void 0 : (_this$state7$inputs = _this$state7.inputs) == null ? void 0 : (_this$state7$inputs$u = _this$state7$inputs.user) == null ? void 0 : _this$state7$inputs$u.address;
    assertExists(address, "User address is not set");
    return address;
  };
  this.oracleAddress = function (optionalChainId) {
    var _chain$optimisticOrac;
    var chain = _this.requestChain(optionalChainId);
    var address = chain == null ? void 0 : (_chain$optimisticOrac = chain.optimisticOracle) == null ? void 0 : _chain$optimisticOrac.address;
    assertExists(address, "Optimistic oracle address not set");
    return address;
  };
  this.signer = function () {
    var _this$state8, _this$state8$inputs, _this$state8$inputs$u;
    var signer = (_this$state8 = _this.state) == null ? void 0 : (_this$state8$inputs = _this$state8.inputs) == null ? void 0 : (_this$state8$inputs$u = _this$state8$inputs.user) == null ? void 0 : _this$state8$inputs$u.signer;
    assertExists(signer, "Signer is not set");
    return signer;
  };
  this.inputRequest = function () {
    var _this$state9, _this$state9$inputs;
    var input = (_this$state9 = _this.state) == null ? void 0 : (_this$state9$inputs = _this$state9.inputs) == null ? void 0 : _this$state9$inputs.request;
    assertExists(input, "Input request is not set");
    return input;
  };
  this.defaultLiveness = function () {
    var _chain$optimisticOrac2;
    var chain = _this.requestChain();
    var liveness = chain == null ? void 0 : (_chain$optimisticOrac2 = chain.optimisticOracle) == null ? void 0 : _chain$optimisticOrac2.defaultLiveness;
    assertExists(liveness, "Optimistic oracle defaultLiveness set");
    return liveness;
  };
  this.request = function () {
    var _chain$optimisticOrac3, _chain$optimisticOrac4;
    var chain = _this.requestChain();
    var input = _this.inputRequest();
    var id = requestId(input);
    var request = chain == null ? void 0 : (_chain$optimisticOrac3 = chain.optimisticOracle) == null ? void 0 : (_chain$optimisticOrac4 = _chain$optimisticOrac3.requests) == null ? void 0 : _chain$optimisticOrac4[id];
    assertExists(request, "Request has not been fetched");
    return request;
  };
  this.collateralProps = function () {
    var _chain$erc20s, _chain$erc20s$request;
    var request = _this.request();
    assertExists(request.currency, "Request currency not set");
    var chain = _this.requestChain();
    var props = (_chain$erc20s = chain.erc20s) == null ? void 0 : (_chain$erc20s$request = _chain$erc20s[request.currency]) == null ? void 0 : _chain$erc20s$request.props;
    assertExists(props, "Props not set on collateral token");
    return props;
  };
  this.userCollateralBalance = function () {
    var _chain$erc20s2, _chain$erc20s2$reques, _chain$erc20s2$reques2;
    var request = _this.request();
    assertExists(request.currency, "Request currency not set");
    var chain = _this.requestChain();
    var user = _this.userAddress();
    var balance = chain == null ? void 0 : (_chain$erc20s2 = chain.erc20s) == null ? void 0 : (_chain$erc20s2$reques = _chain$erc20s2[request.currency]) == null ? void 0 : (_chain$erc20s2$reques2 = _chain$erc20s2$reques.balances) == null ? void 0 : _chain$erc20s2$reques2[user];
    assertExists(balance, "Balance not set on collateral token for user");
    return balance;
  };
  this.userCollateralAllowance = function () {
    var _chain$erc20s3, _chain$erc20s3$reques, _chain$erc20s3$reques2, _chain$erc20s3$reques3;
    var request = _this.request();
    assertExists(request.currency, "Request currency not set");
    var chain = _this.requestChain();
    var user = _this.userAddress();
    var oracle = _this.oracleAddress();
    var allowance = chain == null ? void 0 : (_chain$erc20s3 = chain.erc20s) == null ? void 0 : (_chain$erc20s3$reques = _chain$erc20s3[request.currency]) == null ? void 0 : (_chain$erc20s3$reques2 = _chain$erc20s3$reques.allowances) == null ? void 0 : (_chain$erc20s3$reques3 = _chain$erc20s3$reques2[oracle]) == null ? void 0 : _chain$erc20s3$reques3[user];
    assertExists(allowance, "Allowance not set on user on collateral token for oracle");
    return allowance;
  };
  this.oracleService = function (optionalChainId) {
    var _this$state10, _this$state10$service, _this$state10$service2, _this$state10$service3;
    var chainId = optionalChainId || _this.requestChainId();
    var result = (_this$state10 = _this.state) == null ? void 0 : (_this$state10$service = _this$state10.services) == null ? void 0 : (_this$state10$service2 = _this$state10$service.chains) == null ? void 0 : (_this$state10$service3 = _this$state10$service2[chainId]) == null ? void 0 : _this$state10$service3.optimisticOracle;
    assertExists(result, "Optimistic Oracle Not found on chain " + chainId);
    return result;
  };
  this.collateralService = function () {
    var _this$state11, _this$state11$service, _this$state11$service2, _this$state11$service3, _this$state11$service4;
    var chainId = _this.requestChainId();
    var request = _this.request();
    assertExists(request.currency, "Request currency not set");
    var result = (_this$state11 = _this.state) == null ? void 0 : (_this$state11$service = _this$state11.services) == null ? void 0 : (_this$state11$service2 = _this$state11$service.chains) == null ? void 0 : (_this$state11$service3 = _this$state11$service2[chainId]) == null ? void 0 : (_this$state11$service4 = _this$state11$service3.erc20s) == null ? void 0 : _this$state11$service4[request.currency];
    assertExists(result, "Token not supported on chain " + chainId);
    return result;
  };
  this.command = function (id) {
    var _this$state12, _this$state12$command;
    var result = (_this$state12 = _this.state) == null ? void 0 : (_this$state12$command = _this$state12.commands) == null ? void 0 : _this$state12$command[id];
    assertExists(result, "Unable to find command " + id);
    return result;
  };
  this.tokenService = function (chainId, address) {
    var _this$state13, _this$state13$service, _this$state13$service2, _this$state13$service3, _this$state13$service4;
    var result = (_this$state13 = _this.state) == null ? void 0 : (_this$state13$service = _this$state13.services) == null ? void 0 : (_this$state13$service2 = _this$state13$service.chains) == null ? void 0 : (_this$state13$service3 = _this$state13$service2[chainId]) == null ? void 0 : (_this$state13$service4 = _this$state13$service3.erc20s) == null ? void 0 : _this$state13$service4[address];
    assertExists(result, "Token service not found: " + [chainId, address].join("."));
    return result;
  };
  this.provider = function (chainId) {
    var _this$state14, _this$state14$service, _this$state14$service2, _this$state14$service3;
    var result = (_this$state14 = _this.state) == null ? void 0 : (_this$state14$service = _this$state14.services) == null ? void 0 : (_this$state14$service2 = _this$state14$service.chains) == null ? void 0 : (_this$state14$service3 = _this$state14$service2[chainId]) == null ? void 0 : _this$state14$service3.provider;
    assertExists(result, "Provider not found on chainid: " + chainId);
    return result;
  };
  this.transactionService = function (chainId) {
    var provider = _this.provider(chainId);
    return new TransactionConfirmer(provider);
  };
  this.listCommands = function () {
    var _this$state15;
    return Object.values(((_this$state15 = _this.state) == null ? void 0 : _this$state15.commands) || []);
  };
  this.filterCommands = function (search) {
    return filter(_this.listCommands(), search);
  };
  this.chain = function (optionalChainId) {
    var _this$state16, _this$state16$chains;
    var chainId = optionalChainId || _this.requestChainId();
    var chain = (_this$state16 = _this.state) == null ? void 0 : (_this$state16$chains = _this$state16.chains) == null ? void 0 : _this$state16$chains[chainId];
    assertExists(chain, "No chain for chainId: " + chainId);
    return chain;
  };
  this.currentTime = function (optionalChainId) {
    var chainId = optionalChainId || _this.requestChainId();
    var chain = _this.chain(chainId);
    var time = chain == null ? void 0 : chain.currentTime;
    assertExists(time, "Current time not available on chain: " + chainId);
    return time;
  };
  this.sortedRequestsService = function () {
    var _this$state17, _this$state17$service;
    var result = (_this$state17 = _this.state) == null ? void 0 : (_this$state17$service = _this$state17.services) == null ? void 0 : _this$state17$service.sortedRequests;
    assertExists(result, "Sorted request service not set");
    return result;
  };
  this.listChains = function () {
    var _this$state18;
    return Object.keys(((_this$state18 = _this.state) == null ? void 0 : _this$state18.chains) || {}).map(Number);
  };
  this.descendingRequests = function () {
    return _this.state.descendingRequests || [];
  };
  this.filterRequests = function (query) {
    return filter(_this.descendingRequests(), query);
  };
};

// return true only if value is not null or undefined
// This class checks for existence for values you could potentially read. It mirrors the read interface but returns bools from functions.
var Has = function Has(state) {
  var _this = this;
  this.state = state;
  this.inputRequest = function () {
    // the rule about reads is they will only throw errors if it cant return the value you request.
    // If no errors are thrown the read was successful.
    // Reads will never not return a value without throwing an error, enforced by TS.
    return exists(ignoreExistenceError(_this.read.inputRequest));
  };
  this.sortedRequestsService = function () {
    return exists(ignoreExistenceError(_this.read.sortedRequestsService));
  };
  this.requestChainId = function () {
    return exists(ignoreExistenceError(_this.read.requestChainId));
  };
  this.userAddress = function () {
    return exists(ignoreExistenceError(_this.read.userAddress));
  };
  this.request = function () {
    return exists(ignoreExistenceError(_this.read.request));
  };
  this.collateralProps = function () {
    return exists(ignoreExistenceError(_this.read.collateralProps));
  };
  this.defaultLiveness = function () {
    return exists(ignoreExistenceError(_this.read.defaultLiveness));
  };
  this.currentTime = function () {
    return exists(ignoreExistenceError(_this.read.currentTime));
  };
  // by design, reads do not mutate or cause side effects
  this.read = new Read(state);
};

/**
 * Store. The store is meant to provide a global state that conforms to the type in types/state and
 * allow you to read/write and watch for change events. This uses immer, which manages how the nested
 * object gets updated to allow shallow change detection through nested paths.
 */
var Store = /*#__PURE__*/function () {
  /**
   * constructor.
   *
   * @param {Emit} emit - Change callback, passes you the current and previous state any time theres a state change.
   * @param {State} state - The full state type which conforms to the state object.
   */
  function Store(emit, state) {
    this.emit = emit;
    this.state = state;
  }
  /**
   * write. Allows caller to write to state. This wraps the state in "immer" which manages nested updates to state
   * through a proxy interface. When write is complete, an event is emitted with the current and previous state.
   *
   * @param {WriteCallback} cb
   */
  var _proto = Store.prototype;
  _proto.write = function write(cb) {
    var prevState = this.state;
    // immer's produce method, takes an object, and passes a draft of that object to the callback. Any changes to the draft
    // will be returned as the new state at the end of the callback. Changes to this object are optimized to be used in state
    // for React or other front-end state managers.
    this.state = produce(this.state, cb);
    // Once state is changed, an event is emitted, this is how we get changes out of the client and also allow for change detection.
    this.emit(this.state, prevState);
  }
  // same as write
  ;
  _proto.writeAsync =
  /*#__PURE__*/
  function () {
    var _writeAsync = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cb) {
      var prevState;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            prevState = this.state;
            _context.next = 3;
            return produce(this.state, cb);
          case 3:
            this.state = _context.sent;
            this.emit(this.state, prevState);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function writeAsync(_x) {
      return _writeAsync.apply(this, arguments);
    }
    return writeAsync;
  }();
  _proto.read = function read() {
    return this.state;
  };
  return Store;
}();

/**
 * OracleStore. Wraps the store with a specific state shape and passes the Write client through to end user.
 */
var OracleStore = function OracleStore(emit, state) {
  var _this = this;
  if (emit === void 0) {
    emit = function emit() {
      return undefined;
    };
  }
  if (state === void 0) {
    state = {};
  }
  this.emit = emit;
  this.state = state;
  /**
   * write - Function for updating state.
   *
   * @param {WriteCallback} cb - Sends a write client to the caller for safer and easier state mutations rather than the raw object.
   */
  this.write = function (cb) {
    _this.store.write(function (state) {
      return cb(new Write(state), state);
    });
  };
  /**
   * read - Function for reading from state. Returns a read client to the user.
   *
   * @returns {Read}
   */
  this.read = function () {
    return new Read(_this.store.read());
  };
  /**
   * get - Function for getting access to the raw state object, not wrapped by the reader class.
   * State should not be modified directly and treated as read only.
   *
   * @returns {State}
   */
  this.get = function () {
    return _this.store.read();
  };
  /**
   * has. Checks for existence. Mirrors the read interface, but instead of reading values returns true or false.
   *
   * @returns {Has}
   */
  this.has = function () {
    return new Has(_this.store.read());
  };
  this.store = new Store(emit, state);
};

var index$m = {
  __proto__: null,
  Write: Write,
  Store: Store,
  Read: Read,
  Has: Has,
  'default': OracleStore
};

var Update = function Update(store) {
  var _this = this;
  this.store = store;
  this.all = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return _this.oracle();
        case 2:
          _context.next = 4;
          return _this.request();
        case 4:
          _context.next = 6;
          return _this.collateralProps();
        case 6:
          _context.next = 8;
          return _this.userCollateralBalance();
        case 8:
          _context.next = 10;
          return _this.oracleAllowance();
        case 10:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  this.request = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var request, chainId, oo, contractRequest;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            request = params || _this.read().inputRequest();
            chainId = request.chainId;
            oo = _this.read().oracleService(chainId); // // pull in data from contract on chain
            _context2.next = 5;
            return oo.fetchRequest(request);
          case 5:
            contractRequest = _context2.sent;
            _this.write(function (write) {
              // create the erc20 service to handle currency
              if (contractRequest.currency) {
                write.services(chainId).erc20s(contractRequest.currency);
              }
              write.chains(chainId).optimisticOracle()
              // update request object with all the data we have about it. order is important,
              // we want to prioritize latest state pulled from contract.
              .request(_extends({}, contractRequest));
            });
            _this.sortedRequests(chainId);
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  this.oracle = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    var chainId, oo, _yield$oo$getProps, defaultLiveness;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          chainId = _this.read().requestChainId();
          oo = _this.read().oracleService();
          _context3.next = 4;
          return oo.getProps();
        case 4:
          _yield$oo$getProps = _context3.sent;
          defaultLiveness = _yield$oo$getProps.defaultLiveness;
          _this.write(function (write) {
            return write.chains(chainId).optimisticOracle().defaultLiveness(defaultLiveness);
          });
        case 7:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  this.userCollateralBalance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
    var chainId, account, token, result;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          chainId = _this.read().requestChainId();
          account = _this.read().userAddress();
          token = _this.read().collateralService();
          _context4.next = 5;
          return token.contract.balanceOf(account);
        case 5:
          result = _context4.sent;
          _this.write(function (write) {
            return write.chains(chainId).erc20s(token.address).balance(account, result);
          });
        case 7:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  this.collateralProps = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var chainId, token, props;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          chainId = _this.read().requestChainId();
          token = _this.read().collateralService();
          _context5.next = 4;
          return token.getProps();
        case 4:
          props = _context5.sent;
          _this.write(function (write) {
            return write.chains(chainId).erc20s(token.address).props(props);
          });
        case 6:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  this.oracleAllowance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
    var chainId, account, oracleAddress, token, result;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          chainId = _this.read().requestChainId();
          account = _this.read().userAddress();
          oracleAddress = _this.read().oracleAddress();
          token = _this.read().collateralService();
          _context6.next = 6;
          return token.contract.allowance(account, oracleAddress);
        case 6:
          result = _context6.sent;
          _this.write(function (write) {
            return write.chains(chainId).erc20s(token.address).allowance(account, oracleAddress, result);
          });
        case 8:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  this.balance = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(chainId, token, account) {
      var tokenService, result;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            tokenService = _this.read().tokenService(chainId, token);
            _context7.next = 3;
            return tokenService.contract.balanceOf(account);
          case 3:
            result = _context7.sent;
            _this.write(function (write) {
              return write.chains(chainId).erc20s(token).balance(account, result);
            });
          case 5:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    return function (_x2, _x3, _x4) {
      return _ref7.apply(this, arguments);
    };
  }();
  this.allowance = /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(chainId, token, account, spender) {
      var tokenService, result;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            tokenService = _this.read().tokenService(chainId, token);
            _context8.next = 3;
            return tokenService.contract.allowance(account, spender);
          case 3:
            result = _context8.sent;
            _this.write(function (write) {
              return write.chains(chainId).erc20s(token).allowance(account, spender, result);
            });
          case 5:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    return function (_x5, _x6, _x7, _x8) {
      return _ref8.apply(this, arguments);
    };
  }();
  this.isConfirmed = /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(chainId, hash, confirmations) {
      var txService;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            txService = _this.read().transactionService(chainId);
            return _context9.abrupt("return", txService.isConfirmed(hash, confirmations));
          case 2:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }));
    return function (_x9, _x10, _x11) {
      return _ref9.apply(this, arguments);
    };
  }();
  // update new events from this range query, will accumulate new events
  this.oracleEvents = /*#__PURE__*/function () {
    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(chainId, startBlock, endBlock) {
      var provider, oracle;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            if (startBlock === void 0) {
              startBlock = 0;
            }
            provider = _this.read().provider(chainId);
            oracle = _this.read().oracleService(chainId);
            _context10.t0 = endBlock;
            if (_context10.t0) {
              _context10.next = 8;
              break;
            }
            _context10.next = 7;
            return provider.getBlockNumber();
          case 7:
            _context10.t0 = _context10.sent;
          case 8:
            endBlock = _context10.t0;
            _context10.next = 11;
            return oracle.update(startBlock, endBlock);
          case 11:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    return function (_x12, _x13, _x14) {
      return _ref10.apply(this, arguments);
    };
  }();
  // takes all known events, decodes them into requests and puts them into a sorted table. then updates the sorted list.
  this.sortedRequests = function (chainId) {
    var sortedRequestsService = _this.read().sortedRequestsService();
    var oracle = _this.read().oracleService(chainId);
    var requests = oracle.listRequests();
    var oracleType = _this.read().oracleType();
    Object.values(requests).forEach(function (value) {
      // chains can have colliding keys ( mainly testnet forks), so we always need to append chain to to keep key unique across chains otherwise
      // collisions will cause overwrites, removing ability to list identical requests across chains.
      sortedRequestsService.setByRequest(_extends({}, value, {
        oracleType: oracleType
      }));
    });
    // query all known requests and update our state with the entire list.
    // this is expensive, consider optimizing after proven detrimental.
    var descendingRequests = sortedRequestsService.descending();
    _this.write(function (w) {
      w.descendingRequests(descendingRequests);
    });
  };
  // this updates the current active request object used in the details page, as new properties might come in from events
  // current request needs access to things like transation hash, only available through events.
  this.activeRequestFromEvents = function (params) {
    var request = params || _this.read().inputRequest();
    var chainId = request.chainId;
    // pull in request data generated from events
    var requestIndexData = _this.read().oracleService().getRequest(request);
    // we really only care about a handful of props from event based requests. We also dont want to override
    // any properties that might overlap with the data queried from the contract.
    var requestTx = requestIndexData.requestTx,
      proposeTx = requestIndexData.proposeTx,
      disputeTx = requestIndexData.disputeTx,
      settleTx = requestIndexData.settleTx,
      requestBlockNumber = requestIndexData.requestBlockNumber,
      proposeBlockNumber = requestIndexData.proposeBlockNumber,
      disputeBlockNumber = requestIndexData.disputeBlockNumber,
      settleBlockNumber = requestIndexData.settleBlockNumber;
    var update = _extends({}, request, {
      requestTx: requestTx,
      proposeTx: proposeTx,
      disputeTx: disputeTx,
      settleTx: settleTx,
      requestBlockNumber: requestBlockNumber,
      proposeBlockNumber: proposeBlockNumber,
      disputeBlockNumber: disputeBlockNumber,
      settleBlockNumber: settleBlockNumber
    });
    _this.write(function (write) {
      write.chains(chainId).optimisticOracle().request(update);
    });
  };
  this.read = store.read;
  this.write = store.write;
};

function initMemory() {
  return undefined;
}
function Handlers(store) {
  var update = new Update(store);
  return {
    start: function start(params) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              store.write(function (write) {
                return write.inputs().user().set(params);
              });
              // ignore erorrs caused by data not existing on reads, pass through other errors
              _context.next = 3;
              return ignoreExistenceErrorAsync(update.userCollateralBalance);
            case 3:
              _context.next = 5;
              return ignoreExistenceErrorAsync(update.oracleAllowance);
            case 5:
              return _context.abrupt("return", "done");
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

var setUser = {
  __proto__: null,
  initMemory: initMemory,
  Handlers: Handlers
};

function initMemory$1() {
  return undefined;
}
function Handlers$1(store) {
  return {
    start: function start() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              store.write(function (write) {
                write.inputs().user().clear();
              });
              return _context.abrupt("return", "done");
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

var clearUser = {
  __proto__: null,
  initMemory: initMemory$1,
  Handlers: Handlers$1
};

function initMemory$2() {
  return undefined;
}
function Handlers$2(store) {
  return {
    start: function start(params) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              store.write(function (write) {
                return write.inputs().request(params);
              });
              return _context.abrupt("return", "done");
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

var setActiveRequest = {
  __proto__: null,
  initMemory: initMemory$2,
  Handlers: Handlers$2
};

function initMemory$3() {
  return {};
}
function Handlers$3(store) {
  var _update = new Update(store);
  return {
    start: function start(params, memory) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var chainId, currency, spender, amount, account, signer, erc20, tx;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              chainId = params.chainId, currency = params.currency, spender = params.spender, amount = params.amount, account = params.account, signer = params.signer;
              _context.t0 = assert;
              _context.t1 = chainId;
              _context.next = 5;
              return signer.getChainId();
            case 5:
              _context.t2 = _context.sent;
              _context.t3 = _context.t1 === _context.t2;
              (0, _context.t0)(_context.t3, "Signer on wrong chainid");
              _context.t4 = assert;
              _context.t5 = account;
              _context.next = 12;
              return signer.getAddress();
            case 12:
              _context.t6 = _context.sent;
              _context.t7 = _context.t5 === _context.t6;
              (0, _context.t4)(_context.t7, "Signer on wrong account");
              // create service if it does not exist
              store.write(function (w) {
                return w.services(chainId).erc20s(currency);
              });
              erc20 = store.read().tokenService(chainId, currency);
              _context.next = 19;
              return erc20.approve(signer, spender, amount);
            case 19:
              tx = _context.sent;
              memory.hash = tx.hash;
              return _context.abrupt("return", "confirm");
            case 22:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    },
    confirm: function confirm(params, memory, context) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var chainId, confirmations, checkTxIntervalSec, hash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              chainId = params.chainId, confirmations = params.confirmations, checkTxIntervalSec = params.checkTxIntervalSec;
              hash = memory.hash;
              assert(hash, "requires hash");
              _context2.next = 5;
              return _update.isConfirmed(chainId, hash, confirmations);
            case 5:
              if (!_context2.sent) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", "update");
            case 7:
              return _context2.abrupt("return", context.sleep(checkTxIntervalSec * 1000));
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    },
    update: function update(params) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var chainId, currency, spender, account;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              chainId = params.chainId, currency = params.currency, spender = params.spender, account = params.account;
              _context3.next = 3;
              return _update.balance(chainId, currency, account);
            case 3:
              _context3.next = 5;
              return _update.allowance(chainId, currency, account, spender);
            case 5:
              return _context3.abrupt("return", "done");
            case 6:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
  };
}

var approve = {
  __proto__: null,
  initMemory: initMemory$3,
  Handlers: Handlers$3
};

function initMemory$4() {
  return {};
}
function Handlers$4(store) {
  var _update = new Update(store);
  return {
    start: function start(params, memory) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var requester, identifier, timestamp, ancillaryData, chainId, signer, oracle, tx;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              requester = params.requester, identifier = params.identifier, timestamp = params.timestamp, ancillaryData = params.ancillaryData, chainId = params.chainId, signer = params.signer;
              _context.t0 = assert;
              _context.t1 = chainId;
              _context.next = 5;
              return signer.getChainId();
            case 5:
              _context.t2 = _context.sent;
              _context.t3 = _context.t1 === _context.t2;
              (0, _context.t0)(_context.t3, "Signer on wrong chainid");
              oracle = store.read().oracleService(chainId);
              _context.next = 11;
              return oracle.disputePrice(signer, {
                requester: requester,
                identifier: identifier,
                timestamp: timestamp,
                ancillaryData: ancillaryData
              });
            case 11:
              tx = _context.sent;
              memory.hash = tx.hash;
              return _context.abrupt("return", "confirm");
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    },
    confirm: function confirm(params, memory, context) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var chainId, confirmations, checkTxIntervalSec, hash, receipt;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              chainId = params.chainId, confirmations = params.confirmations, checkTxIntervalSec = params.checkTxIntervalSec;
              hash = memory.hash;
              assert(hash, "requires hash");
              _context2.next = 5;
              return _update.isConfirmed(chainId, hash, confirmations);
            case 5:
              receipt = _context2.sent;
              if (!receipt) {
                _context2.next = 9;
                break;
              }
              memory.receipt = receipt;
              return _context2.abrupt("return", "update");
            case 9:
              return _context2.abrupt("return", context.sleep(checkTxIntervalSec * 1000));
            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    },
    update: function update(params, memory) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var chainId, currency, account, receipt, oracle;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              chainId = params.chainId, currency = params.currency, account = params.account;
              receipt = memory.receipt;
              oracle = store.read().oracleService(chainId);
              _context3.next = 5;
              return _update.balance(chainId, currency, account);
            case 5:
              if (receipt) {
                oracle.updateFromTransactionReceipt(receipt);
              }
              store.write(function (w) {
                w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));
              });
              _update.sortedRequests(chainId);
              return _context3.abrupt("return", "done");
            case 9:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
  };
}

var disputePrice = {
  __proto__: null,
  initMemory: initMemory$4,
  Handlers: Handlers$4
};

function initMemory$5() {
  return {};
}
function Handlers$5(store) {
  var _update = new Update(store);
  return {
    start: function start(params, memory) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var requester, identifier, timestamp, ancillaryData, chainId, signer, proposedPrice, oracle, tx;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              requester = params.requester, identifier = params.identifier, timestamp = params.timestamp, ancillaryData = params.ancillaryData, chainId = params.chainId, signer = params.signer, proposedPrice = params.proposedPrice;
              _context.t0 = assert;
              _context.t1 = chainId;
              _context.next = 5;
              return signer.getChainId();
            case 5:
              _context.t2 = _context.sent;
              _context.t3 = _context.t1 === _context.t2;
              (0, _context.t0)(_context.t3, "Signer on wrong chainid");
              oracle = store.read().oracleService(chainId);
              _context.next = 11;
              return oracle.proposePrice(signer, {
                requester: requester,
                identifier: identifier,
                timestamp: timestamp,
                ancillaryData: ancillaryData
              }, proposedPrice);
            case 11:
              tx = _context.sent;
              memory.hash = tx.hash;
              return _context.abrupt("return", "confirm");
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    },
    confirm: function confirm(params, memory, context) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var chainId, confirmations, checkTxIntervalSec, hash, receipt;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              chainId = params.chainId, confirmations = params.confirmations, checkTxIntervalSec = params.checkTxIntervalSec;
              hash = memory.hash;
              assert(hash, "requires hash");
              _context2.next = 5;
              return _update.isConfirmed(chainId, hash, confirmations);
            case 5:
              receipt = _context2.sent;
              if (!receipt) {
                _context2.next = 9;
                break;
              }
              memory.receipt = receipt;
              return _context2.abrupt("return", "update");
            case 9:
              return _context2.abrupt("return", context.sleep(checkTxIntervalSec * 1000));
            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    },
    update: function update(params, memory) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var chainId, currency, account, receipt, oracle;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              chainId = params.chainId, currency = params.currency, account = params.account;
              receipt = memory.receipt;
              oracle = store.read().oracleService(chainId);
              _context3.next = 5;
              return _update.balance(chainId, currency, account);
            case 5:
              if (receipt) {
                oracle.updateFromTransactionReceipt(receipt);
              }
              store.write(function (w) {
                w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));
              });
              _context3.next = 9;
              return _update.sortedRequests(chainId);
            case 9:
              return _context3.abrupt("return", "done");
            case 10:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
  };
}

var proposePrice = {
  __proto__: null,
  initMemory: initMemory$5,
  Handlers: Handlers$5
};

function initMemory$6() {
  return undefined;
}
function Handlers$6(store) {
  return {
    start: function start(params) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var provider, chainId, error;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              provider = params.provider, chainId = params.chainId;
              _context.prev = 1;
              _context.next = 4;
              return provider.send("wallet_switchEthereumChain", [{
                chainId: hexValue(chainId)
              }]);
            case 4:
              return _context.abrupt("return", "done");
            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](1);
              error = _context.t0;
              if (!(error.code === -32603 || error.code === 4902)) {
                _context.next = 12;
                break;
              }
              return _context.abrupt("return", "addAndSwitch");
            case 12:
              throw error;
            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[1, 7]]);
      }))();
    },
    addAndSwitch: function addAndSwitch(params) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var chainId, provider, config, chainMetadata;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              chainId = params.chainId, provider = params.provider;
              config = store.read().chainConfig(chainId);
              chainMetadata = chainConfigToChainMetadata(config);
              _context2.next = 5;
              return provider.send("wallet_addEthereumChain", [_extends({}, chainMetadata, {
                chainId: hexValue(chainId)
              })]);
            case 5:
              _context2.next = 7;
              return provider.send("wallet_switchEthereumChain", [{
                chainId: hexValue(chainId)
              }]);
            case 7:
              return _context2.abrupt("return", "done");
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    }
  };
}

var switchOrAddChain = {
  __proto__: null,
  initMemory: initMemory$6,
  Handlers: Handlers$6
};

function initMemory$7() {
  return {
    iterations: 0
  };
}
function Handlers$7(store) {
  var update = new Update(store);
  return {
    start: function start(params, memory, ctx) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var request, shouldUpdate, _ref, _ref$checkTxIntervalS, checkTxIntervalSec;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return ignoreExistenceErrorAsync(store.read().request);
            case 2:
              request = _context.sent;
              // requests can change externally if not already in one of these states
              shouldUpdate = request && request.state !== RequestState.Invalid && request.state !== RequestState.Settled;
              if (!shouldUpdate) {
                _context.next = 8;
                break;
              }
              _context.next = 7;
              return update.request();
            case 7:
              // count how many times we have updated this request as a sanity check
              memory.iterations++;
            case 8:
              _context.next = 10;
              return ignoreExistenceErrorAsync(store.read().chainConfig);
            case 10:
              _context.t0 = _context.sent;
              if (_context.t0) {
                _context.next = 13;
                break;
              }
              _context.t0 = {};
            case 13:
              _ref = _context.t0;
              _ref$checkTxIntervalS = _ref.checkTxIntervalSec;
              checkTxIntervalSec = _ref$checkTxIntervalS === void 0 ? 30 : _ref$checkTxIntervalS;
              return _context.abrupt("return", ctx.sleep(checkTxIntervalSec * 1000));
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

var pollActiveRequest = {
  __proto__: null,
  initMemory: initMemory$7,
  Handlers: Handlers$7
};

function initMemory$8() {
  return {
    iterations: 0
  };
}
function Handlers$8(store) {
  var update = new Update(store);
  return {
    start: function start(params, memory, ctx) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _memory$state;
        var provider, chainId, _params$startBlock, startBlock, _params$endBlock, endBlock, maxRange, rangeState, currentStart, currentEnd;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              provider = store.read().provider(params.chainId);
              chainId = params.chainId;
              _params$startBlock = params.startBlock;
              startBlock = _params$startBlock === void 0 ? 0 : _params$startBlock;
              _params$endBlock = params.endBlock;
              if (!(_params$endBlock === void 0)) {
                _context.next = 11;
                break;
              }
              _context.next = 8;
              return provider.getBlockNumber();
            case 8:
              _context.t0 = _context.sent;
              _context.next = 12;
              break;
            case 11:
              _context.t0 = _params$endBlock;
            case 12:
              endBlock = _context.t0;
              maxRange = params.maxRange;
              memory.error = undefined;
              // we use this wierd range thing because in the case we cant query the entire block range due to provider error
              // we want to move start block closer to endblock to reduce the range until it stops erroring. These range functions
              // will do that for us.
              rangeState = memory.state || rangeStart({
                startBlock: startBlock,
                endBlock: endBlock,
                maxRange: maxRange
              });
              currentStart = rangeState.currentStart, currentEnd = rangeState.currentEnd;
              _context.prev = 17;
              _context.next = 20;
              return update.oracleEvents(chainId, currentStart, currentEnd);
            case 20:
              _context.next = 22;
              return update.sortedRequests(chainId);
            case 22:
              _context.next = 24;
              return ignoreExistenceErrorAsync(update.activeRequestFromEvents);
            case 24:
              // we signal that the current range was a success, now move currentStart, currentEnd accordingly
              // we set multiplier to 1 so we dont grow the range on success, this tends to create more errors and slow down querying
              memory.state = rangeSuccessDescending(_extends({}, rangeState, {
                multiplier: 1
              }));
              _context.next = 31;
              break;
            case 27:
              _context.prev = 27;
              _context.t1 = _context["catch"](17);
              memory.error = _context.t1;
              // the provider threw an error so we will reduce our range by moving startblock closer to endblock next iteration
              memory.state = rangeFailureDescending(rangeState);
            case 31:
              memory.iterations++;
              // the range functions will tell us when we have successfully queried the entire range of blocks.
              if (!(memory != null && (_memory$state = memory.state) != null && _memory$state.done)) {
                _context.next = 34;
                break;
              }
              return _context.abrupt("return", "done");
            case 34:
              return _context.abrupt("return", ctx.sleep(100));
            case 35:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[17, 27]]);
      }))();
    }
  };
}

var fetchPastEvents = {
  __proto__: null,
  initMemory: initMemory$8,
  Handlers: Handlers$8
};

function initMemory$9() {
  return {
    iterations: 0
  };
}
function Handlers$9(store) {
  var update = new Update(store);
  return {
    start: function start(params, memory, ctx) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var chainId, startBlock, _params$pollRateSec, pollRateSec, provider, latestBlock, currentBlock;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // start at the latest block, we have other command to get historical events
              chainId = params.chainId, startBlock = params.startBlock, _params$pollRateSec = params.pollRateSec, pollRateSec = _params$pollRateSec === void 0 ? 50 : _params$pollRateSec;
              provider = store.read().provider(chainId);
              _context.next = 4;
              return provider.getBlockNumber();
            case 4:
              latestBlock = _context.sent;
              // our current block is the start block, or last known block we have queried up to
              currentBlock = memory.lastBlock || startBlock || latestBlock;
              memory.error = undefined;
              _context.prev = 7;
              if (!(latestBlock !== currentBlock)) {
                _context.next = 17;
                break;
              }
              _context.next = 11;
              return update.oracleEvents(chainId, currentBlock, latestBlock);
            case 11:
              _context.next = 13;
              return ignoreExistenceErrorAsync(update.activeRequestFromEvents);
            case 13:
              // reset our last block seen to the latest (end) block
              memory.lastBlock = latestBlock;
              // just count how many successful iterations we do as a kind of sanity check
              memory.iterations++;
              _context.next = 18;
              break;
            case 17:
              // if we dont have a lastblock set, set it to our current block
              memory.lastBlock = memory.lastBlock || currentBlock;
            case 18:
              _context.next = 23;
              break;
            case 20:
              _context.prev = 20;
              _context.t0 = _context["catch"](7);
              // store an error for an iteration if we need to debug. we want to keep polling though.
              memory.error = _context.t0;
            case 23:
              _context.next = 25;
              return update.sortedRequests(chainId);
            case 25:
              return _context.abrupt("return", ctx.sleep(pollRateSec * 1000));
            case 26:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[7, 20]]);
      }))();
    }
  };
}

var pollNewEvents = {
  __proto__: null,
  initMemory: initMemory$9,
  Handlers: Handlers$9
};

function initMemory$a() {
  return undefined;
}
function Handlers$a(store) {
  return {
    start: function start(params) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var chainId, transactionHash, _params$eventIndex, eventIndex, filteredRequests, found, _requestInput, provider, receipt, oracle, oracleAddress, oracleLogs, decodedLogs, log, requestInput;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              chainId = params.chainId, transactionHash = params.transactionHash, _params$eventIndex = params.eventIndex, eventIndex = _params$eventIndex === void 0 ? 0 : _params$eventIndex; // search all known requests first
              filteredRequests = store.read().descendingRequests().filter(function (request) {
                var _request$requestTx, _request$proposeTx, _request$disputeTx, _request$settleTx, _request$requestLogIn, _request$proposeLogIn, _request$disputeLogIn, _request$settleLogInd;
                if (request.chainId.toString() !== chainId.toString()) return false;
                if (![request == null ? void 0 : (_request$requestTx = request.requestTx) == null ? void 0 : _request$requestTx.toLowerCase(), request == null ? void 0 : (_request$proposeTx = request.proposeTx) == null ? void 0 : _request$proposeTx.toLowerCase(), request == null ? void 0 : (_request$disputeTx = request.disputeTx) == null ? void 0 : _request$disputeTx.toLowerCase(), request == null ? void 0 : (_request$settleTx = request.settleTx) == null ? void 0 : _request$settleTx.toLowerCase()].includes(transactionHash.toLowerCase())) return false;
                return [request == null ? void 0 : (_request$requestLogIn = request.requestLogIndex) == null ? void 0 : _request$requestLogIn.toString(), request == null ? void 0 : (_request$proposeLogIn = request.proposeLogIndex) == null ? void 0 : _request$proposeLogIn.toString(), request == null ? void 0 : (_request$disputeLogIn = request.disputeLogIndex) == null ? void 0 : _request$disputeLogIn.toString(), request == null ? void 0 : (_request$settleLogInd = request.settleLogIndex) == null ? void 0 : _request$settleLogInd.toString()].includes(eventIndex.toString());
              }); // if we found a request from known requests, then set it as our selected request
              if (!(filteredRequests.length === 1)) {
                _context.next = 7;
                break;
              }
              found = filteredRequests[0]; // we can parse out the necessary params to kick off fetching the state of the request
              _requestInput = {
                timestamp: found.timestamp,
                requester: found.requester,
                ancillaryData: found.ancillaryData,
                identifier: found.identifier,
                chainId: chainId
              };
              store.write(function (write) {
                return write.inputs().request(_requestInput);
              });
              return _context.abrupt("return", "done");
            case 7:
              // have to do all of this to fetch the identifier, ancData, requester and timestamp from the request
              provider = store.read().provider(chainId);
              _context.next = 10;
              return provider.getTransactionReceipt(transactionHash);
            case 10:
              receipt = _context.sent;
              assert(receipt, "Unable to find transaction receipt from hash: " + transactionHash);
              oracle = store.read().oracleService(chainId);
              oracleAddress = store.read().oracleAddress(chainId); // filter out logs that originate from oracle contract
              oracleLogs = receipt.logs.filter(function (log) {
                return log.address.toLowerCase() === oracleAddress.toLowerCase();
              }); // decode logs using abi
              decodedLogs = oracleLogs.map(function (log) {
                return oracle.parseLog(log);
              }); // this is the event we care about, we index into the appropriate oracle event generated from this tx
              // we want to keep backwards compatibility with previous links which were indexed by an array index and not logIndex
              log = decodedLogs.find(function (log) {
                var _log$logIndex;
                return (log == null ? void 0 : (_log$logIndex = log.logIndex) == null ? void 0 : _log$logIndex.toString()) === eventIndex.toString();
              }) || decodedLogs[eventIndex] || decodedLogs[0]; // we dont actually know the type of the log, so we need to do some validation before continuing
              assert(log, "Unable to find optimistic oracle event at " + transactionHash + " eventIndex " + eventIndex);
              assert(log.args, "Unable to find optimistic oracle event args at " + transactionHash + " eventIndex " + eventIndex);
              assert(log.args.timestamp, "Unable to find optimistic oracle event.timestamp at " + transactionHash + " eventIndex " + eventIndex);
              assert(log.args.requester, "Unable to find optimistic oracle event.requester at " + transactionHash + " eventIndex " + eventIndex);
              assert(log.args.ancillaryData, "Unable to find optimistic oracle event.ancillaryData at " + transactionHash + " eventIndex " + eventIndex);
              assert(log.args.identifier, "Unable to find optimistic oracle event.identifier at " + transactionHash + " eventIndex " + eventIndex);
              // we can parse out the necessary params to kick off fetching the state of the request
              requestInput = {
                timestamp: log.args.timestamp,
                requester: log.args.requester,
                ancillaryData: log.args.ancillaryData,
                identifier: log.args.identifier,
                chainId: chainId
              };
              store.write(function (write) {
                return write.inputs().request(requestInput);
              });
              return _context.abrupt("return", "done");
            case 26:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

var setActiveRequestByTransaction = {
  __proto__: null,
  initMemory: initMemory$a,
  Handlers: Handlers$a
};

function initMemory$b() {
  return {};
}
function Handlers$b(store) {
  var _update = new Update(store);
  return {
    start: function start(params, memory) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var requester, identifier, timestamp, ancillaryData, chainId, signer, oracle, tx;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              requester = params.requester, identifier = params.identifier, timestamp = params.timestamp, ancillaryData = params.ancillaryData, chainId = params.chainId, signer = params.signer;
              _context.t0 = assert;
              _context.t1 = chainId;
              _context.next = 5;
              return signer.getChainId();
            case 5:
              _context.t2 = _context.sent;
              _context.t3 = _context.t1 === _context.t2;
              (0, _context.t0)(_context.t3, "Signer on wrong chainid");
              oracle = store.read().oracleService(chainId);
              _context.next = 11;
              return oracle.settle(signer, {
                requester: requester,
                identifier: identifier,
                timestamp: timestamp,
                ancillaryData: ancillaryData
              });
            case 11:
              tx = _context.sent;
              memory.hash = tx.hash;
              return _context.abrupt("return", "confirm");
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    },
    confirm: function confirm(params, memory, context) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var chainId, confirmations, checkTxIntervalSec, hash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              chainId = params.chainId, confirmations = params.confirmations, checkTxIntervalSec = params.checkTxIntervalSec;
              hash = memory.hash;
              assert(hash, "requires hash");
              _context2.next = 5;
              return _update.isConfirmed(chainId, hash, confirmations);
            case 5:
              if (!_context2.sent) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", "update");
            case 7:
              return _context2.abrupt("return", context.sleep(checkTxIntervalSec * 1000));
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    },
    update: function update(params) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var chainId, currency, account, oracle;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              chainId = params.chainId, currency = params.currency, account = params.account;
              oracle = store.read().oracleService(chainId);
              _context3.next = 4;
              return _update.balance(chainId, currency, account);
            case 4:
              store.write(function (w) {
                w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));
              });
              _update.sortedRequests(chainId);
              return _context3.abrupt("return", "done");
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
  };
}

var settle = {
  __proto__: null,
  initMemory: initMemory$b,
  Handlers: Handlers$b
};

function initMemory$c() {
  return undefined;
}
function Handlers$c(store) {
  var update = new Update(store);
  return {
    start: function start(params, memory, ctx) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var chainId, _params$pollRateSec, pollRateSec, _params$concurrency, concurrency, oracle, requests, requestsToFetch;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              chainId = params.chainId, _params$pollRateSec = params.pollRateSec, pollRateSec = _params$pollRateSec === void 0 ? 15 : _params$pollRateSec, _params$concurrency = params.concurrency, concurrency = _params$concurrency === void 0 ? 5 : _params$concurrency;
              oracle = store.read().oracleService(chainId);
              requests = oracle.listRequests();
              requestsToFetch = requests.filter(function (request) {
                return request.eventBased === undefined;
              });
              _context.next = 6;
              return bluebird.map(requestsToFetch, function (request) {
                return update.request(request);
              }, {
                concurrency: concurrency
              });
            case 6:
              return _context.abrupt("return", ctx.sleep(pollRateSec * 1000));
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

var fetchEventBased = {
  __proto__: null,
  initMemory: initMemory$c,
  Handlers: Handlers$c
};

// client to pass into handlers to allow them to modify context
var ContextClient = /*#__PURE__*/function () {
  function ContextClient(context) {
    this.context = context;
  }
  var _proto = ContextClient.prototype;
  _proto.sleep = function sleep(ms) {
    this.context.sleep = ms;
  };
  return ContextClient;
}();
var Step = function Step(handlers) {
  return /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(context, now) {
      var copy, handler, memory, state;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            assert(!context.done, "Context has ended");
            assert(handlers[context.state], "No handler for state: " + context.state);
            // conext is read only for some reason, have to copy it
            copy = Object.assign({}, context);
            _context.prev = 3;
            // remove sleep, assume it should be reset if needed
            if (copy.sleep) copy.sleep = undefined;
            handler = handlers[copy.state]; // have to copy this out because memory becomes read only for some reason?
            memory = Object.assign({}, copy.memory); // handlers take in params and return a new state or nothin
            _context.next = 9;
            return handler(copy.params, memory, new ContextClient(copy));
          case 9:
            state = _context.sent;
            copy.memory = memory;
            // update context state
            if (state) copy.state = state;
            // check for done
            if (state === "done") copy.done = true;
            _context.next = 18;
            break;
          case 15:
            _context.prev = 15;
            _context.t0 = _context["catch"](3);
            return _context.abrupt("return", _extends({}, copy, {
              error: _context.t0,
              state: "error",
              done: true,
              updated: now
            }));
          case 18:
            copy.updated = now;
            return _context.abrupt("return", copy);
          case 20:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[3, 15]]);
    }));
    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
};
function shouldStep(context, now) {
  if (!context) return false;
  if (context.done) return false;
  if (context.updated === undefined) return true;
  if (!(context != null && context.sleep)) return true;
  return now - context.updated >= context.sleep;
}
function create(type, params, memory, override, now) {
  if (override === void 0) {
    override = {};
  }
  if (now === void 0) {
    now = Date.now();
  }
  var context = _extends({
    id: uid(type + "_"),
    state: "start",
    done: false,
    updated: undefined,
    created: now,
    type: type
  }, override, {
    params: params,
    memory: memory
  });
  return context;
}
var ContextManager = /*#__PURE__*/function () {
  function ContextManager(type, handlers, initMemory, emit) {
    var _this = this;
    this.type = type;
    this.handlers = handlers;
    this.initMemory = initMemory;
    this.emit = emit;
    this.create = function (params, user) {
      var context = create(_this.type, params, _this.initMemory(params), {
        user: user
      });
      _this.emit(context);
      return context.id;
    };
  }
  // this step function will keep looping until either the state machine is done transitioning, or sleep has been specified
  var _proto2 = ContextManager.prototype;
  _proto2.step =
  /*#__PURE__*/
  function () {
    var _step = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(context, now, iterations) {
      var step, next;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (now === void 0) {
              now = /*#__PURE__*/Date.now();
            }
            if (iterations === void 0) {
              iterations = 10;
            }
            step = Step(this.handlers);
            next = context;
          case 4:
            if (!shouldStep(next, now)) {
              _context2.next = 12;
              break;
            }
            assert(iterations >= 0, "Infinite loop detected in state machine, make sure it each state transitions to done: " + context.type);
            _context2.next = 8;
            return step(next, now);
          case 8:
            next = _context2.sent;
            iterations--;
            _context2.next = 4;
            break;
          case 12:
            return _context2.abrupt("return", next);
          case 13:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function step(_x3, _x4, _x5) {
      return _step.apply(this, arguments);
    }
    return step;
  }();
  return ContextManager;
}();

function initMemory$d() {
  return {
    iterations: 0
  };
}
function Handlers$d(store) {
  var update = new Update(store);
  return {
    start: function start(params, memory, ctx) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _ref, _ref$checkTxIntervalS, checkTxIntervalSec;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return ignoreExistenceErrorAsync(update.userCollateralBalance);
            case 2:
              _context.next = 4;
              return ignoreExistenceErrorAsync(update.oracleAllowance);
            case 4:
              memory.iterations++;
              // this is set differently for every chain
              _context.next = 7;
              return ignoreExistenceErrorAsync(store.read().chainConfig);
            case 7:
              _context.t0 = _context.sent;
              if (_context.t0) {
                _context.next = 10;
                break;
              }
              _context.t0 = {};
            case 10:
              _ref = _context.t0;
              _ref$checkTxIntervalS = _ref.checkTxIntervalSec;
              checkTxIntervalSec = _ref$checkTxIntervalS === void 0 ? 30 : _ref$checkTxIntervalS;
              return _context.abrupt("return", ctx.sleep(checkTxIntervalSec * 1000));
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

function initMemory$e() {
  return undefined;
}
function Handlers$e(store) {
  var update = new Update(store);
  return {
    start: function start() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var has;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              has = store.has(); // we can ignore errors where reads fail, but all other errors will propogate
              // this will rerun when user is set.
              if (has.defaultLiveness()) {
                _context.next = 4;
                break;
              }
              _context.next = 4;
              return ignoreExistenceErrorAsync(update.oracle);
            case 4:
              _context.next = 6;
              return ignoreExistenceErrorAsync(update.request);
            case 6:
              if (has.collateralProps()) {
                _context.next = 9;
                break;
              }
              _context.next = 9;
              return ignoreExistenceErrorAsync(update.collateralProps);
            case 9:
              return _context.abrupt("return", "done");
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

/**
 * StateMachine. This class will be used to handle all change requests by the user, including setting state which
 * may require triggering fetching data from chain, or initiating transactions that require tracking.
 *
 * This class is meant to step through states of a Context object. This object can have variable
 * parameters and memory. There are several concepts to understand before using this class:
 *
 * 1. Handlers - This is the state machine state handlers, it is an objected keyed by each state, with a function handler.
 * 2. Params - These are common parameters set by the caller, passed into each handler function.
 * 3. Memory - This is a writing space within the state machine handlers that accumulates through states.
 * 4. Context - This is the sum of all data needed to transition through the state machine states. It includes params, memory and metadata about the runtime.
 * 5. Context.done - This is a special property on context.done which represents that the state machine is done transitioning this context.
 * 6. Context.state = "done" - This is a reserved state on context.state, if set to "done" its the same thing as done = true.
 * 7. Context.state = "error" - This is a reserved state on context.state, if set to "error" it means the context is done, but also there is an context.error object.
 * 8. Interval - This is a property on the context which specifies the maximum rate in MS this context will transition, based on the current timestamp.
 */
var StateMachine = /*#__PURE__*/function () {
  function StateMachine(store) {
    var _this = this,
      _this$types;
    this.store = store;
    this.pending = [];
    this.handleCreate = function (context) {
      _this.push(context);
      _this.saveContext(context);
    };
    /**
     * tick. Process all pending contexts, move them to done if needed
     *
     * @param {} now - Specify the timestamp this tick is running on.
     * @returns {Promise<boolean>} - Returns if there are still any pending contexts to run.
     */
    this.tick = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(now) {
        var context, next;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (now === void 0) {
                now = Date.now();
              }
              context = _this.shift(); // if this cant step, then push it to back of queue
              if (shouldStep(context, now)) {
                _context.next = 6;
                break;
              }
              context && !context.done && _this.push(context);
              // if we can step, then step it and push result into queue
              _context.next = 72;
              break;
            case 6:
              _context.t0 = context.type;
              _context.next = _context.t0 === ContextType.setUser ? 9 : _context.t0 === ContextType.clearUser ? 13 : _context.t0 === ContextType.setActiveRequest ? 17 : _context.t0 === ContextType.approve ? 21 : _context.t0 === ContextType.disputePrice ? 25 : _context.t0 === ContextType.proposePrice ? 29 : _context.t0 === ContextType.switchOrAddChain ? 33 : _context.t0 === ContextType.pollActiveRequest ? 37 : _context.t0 === ContextType.pollActiveUser ? 41 : _context.t0 === ContextType.fetchPastEvents ? 45 : _context.t0 === ContextType.pollNewEvents ? 49 : _context.t0 === ContextType.setActiveRequestByTransaction ? 53 : _context.t0 === ContextType.settle ? 57 : _context.t0 === ContextType.updateActiveRequest ? 61 : _context.t0 === ContextType.fetchEventBased ? 65 : 69;
              break;
            case 9:
              _context.next = 11;
              return _this.types[context.type].step(context, now);
            case 11:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 13:
              _context.next = 15;
              return _this.types[context.type].step(context, now);
            case 15:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 17:
              _context.next = 19;
              return _this.types[context.type].step(context, now);
            case 19:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 21:
              _context.next = 23;
              return _this.types[context.type].step(context, now);
            case 23:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 25:
              _context.next = 27;
              return _this.types[context.type].step(context, now);
            case 27:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 29:
              _context.next = 31;
              return _this.types[context.type].step(context, now);
            case 31:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 33:
              _context.next = 35;
              return _this.types[context.type].step(context, now);
            case 35:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 37:
              _context.next = 39;
              return _this.types[context.type].step(context, now);
            case 39:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 41:
              _context.next = 43;
              return _this.types[context.type].step(context, now);
            case 43:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 45:
              _context.next = 47;
              return _this.types[context.type].step(context, now);
            case 47:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 49:
              _context.next = 51;
              return _this.types[context.type].step(context, now);
            case 51:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 53:
              _context.next = 55;
              return _this.types[context.type].step(context, now);
            case 55:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 57:
              _context.next = 59;
              return _this.types[context.type].step(context, now);
            case 59:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 61:
              _context.next = 63;
              return _this.types[context.type].step(context, now);
            case 63:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 65:
              _context.next = 67;
              return _this.types[context.type].step(context, now);
            case 67:
              next = _context.sent;
              return _context.abrupt("break", 70);
            case 69:
              throw new Error("Unable to handle type: " + context.type);
            case 70:
              if (!next.done) {
                _this.push(next);
              }
              _this.saveContext(next);
            case 72:
              return _context.abrupt("return", _this.size() > 0);
            case 73:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
    // need to initizlie state types here manually for each new context type
    this.types = (_this$types = {}, _this$types[ContextType.setUser] = new ContextManager(ContextType.setUser, Handlers(store), initMemory, this.handleCreate), _this$types[ContextType.clearUser] = new ContextManager(ContextType.clearUser, Handlers$1(store), initMemory$1, this.handleCreate), _this$types[ContextType.setActiveRequest] = new ContextManager(ContextType.setActiveRequest, Handlers$2(store), initMemory$2, this.handleCreate), _this$types[ContextType.approve] = new ContextManager(ContextType.approve, Handlers$3(store), initMemory$3, this.handleCreate), _this$types[ContextType.disputePrice] = new ContextManager(ContextType.disputePrice, Handlers$4(store), initMemory$4, this.handleCreate), _this$types[ContextType.proposePrice] = new ContextManager(ContextType.proposePrice, Handlers$5(store), initMemory$5, this.handleCreate), _this$types[ContextType.switchOrAddChain] = new ContextManager(ContextType.switchOrAddChain, Handlers$6(store), initMemory$6, this.handleCreate), _this$types[ContextType.pollActiveRequest] = new ContextManager(ContextType.pollActiveRequest, Handlers$7(store), initMemory$7, this.handleCreate), _this$types[ContextType.pollActiveUser] = new ContextManager(ContextType.pollActiveUser, Handlers$d(store), initMemory$d, this.handleCreate), _this$types[ContextType.fetchPastEvents] = new ContextManager(ContextType.fetchPastEvents, Handlers$8(store), initMemory$8, this.handleCreate), _this$types[ContextType.pollNewEvents] = new ContextManager(ContextType.pollNewEvents, Handlers$9(store), initMemory$9, this.handleCreate), _this$types[ContextType.setActiveRequestByTransaction] = new ContextManager(ContextType.setActiveRequestByTransaction, Handlers$a(store), initMemory$a, this.handleCreate), _this$types[ContextType.settle] = new ContextManager(ContextType.settle, Handlers$b(store), initMemory$b, this.handleCreate), _this$types[ContextType.updateActiveRequest] = new ContextManager(ContextType.updateActiveRequest, Handlers$e(store), initMemory$e, this.handleCreate), _this$types[ContextType.fetchEventBased] = new ContextManager(ContextType.fetchEventBased, Handlers$c(store), initMemory$c, this.handleCreate), _this$types);
  }
  var _proto = StateMachine.prototype;
  _proto.saveContext = function saveContext(context) {
    this.store.write(function (w) {
      return w.command(context);
    });
  }
  // remove element from front of queue
  ;
  _proto.shift = function shift() {
    return this.pending.shift();
  }
  // remove element from back of queue
  ;
  _proto.pop = function pop() {
    return this.pending.pop();
  };
  _proto.size = function size() {
    return this.pending.length;
  };
  _proto.push = function push(context) {
    this.pending.push(context);
  };
  return StateMachine;
}();



var index$n = {
  __proto__: null,
  setUser: setUser,
  clearUser: clearUser,
  setActiveRequest: setActiveRequest,
  approve: approve,
  disputePrice: disputePrice,
  proposePrice: proposePrice,
  switchOrAddChain: switchOrAddChain,
  pollActiveRequest: pollActiveRequest,
  fetchPastEvents: fetchPastEvents,
  pollNewEvents: pollNewEvents,
  setActiveRequestByTransaction: setActiveRequestByTransaction,
  settle: settle,
  fetchEventBased: fetchEventBased,
  StateMachine: StateMachine,
  ContextClient: ContextClient,
  Step: Step,
  shouldStep: shouldStep,
  create: create,
  ContextManager: ContextManager
};

var Client$1 = /*#__PURE__*/function () {
  function Client(store, update, sm, poller) {
    this.store = store;
    this.update = update;
    this.sm = sm;
    this.poller = poller;
    this.intervalStarted = false;
  }
  var _proto = Client.prototype;
  _proto.setUser = function setUser(params) {
    var address = params.address && ethers$1.utils.getAddress(params.address);
    return this.sm.types.setUser.create(_extends({}, params, {
      address: address
    }));
  };
  _proto.clearUser = function clearUser() {
    return this.sm.types.clearUser.create(undefined);
  };
  _proto.setActiveRequest = function setActiveRequest(params) {
    var requester = ethers$1.utils.getAddress(params.requester);
    // these are case and number senstive
    var ancillaryData = params.ancillaryData.toLowerCase();
    var identifier = params.identifier.toLowerCase();
    var chainId = Number(params.chainId);
    var timestamp = Number(params.timestamp);
    var result = this.sm.types.setActiveRequest.create({
      requester: requester,
      ancillaryData: ancillaryData,
      identifier: identifier,
      chainId: chainId,
      timestamp: timestamp
    });
    this.sm.types.updateActiveRequest.create(undefined);
    return result;
  };
  _proto.setActiveRequestByTransaction = function setActiveRequestByTransaction(params) {
    var result = this.sm.types.setActiveRequestByTransaction.create(params);
    this.sm.types.updateActiveRequest.create(undefined);
    return result;
  };
  _proto.approveCollateral = function approveCollateral() {
    var _this$store$read$chai = this.store.read().chainConfig(),
      checkTxIntervalSec = _this$store$read$chai.checkTxIntervalSec;
    var request = this.store.read().request();
    var inputRequest = this.store.read().inputRequest();
    var user = this.store.read().user();
    var oracleAddress = this.store.read().oracleAddress();
    assert(user.address, "requires a user account address");
    assert(user.signer, "requires a user signer");
    assert(user.chainId === inputRequest.chainId, "On wrong chain");
    assert(request.currency, "Request currency is unknown");
    return this.sm.types.approve.create({
      currency: request.currency,
      account: user.address,
      chainId: inputRequest.chainId,
      signer: user.signer,
      spender: oracleAddress,
      amount: ethers$1.constants.MaxUint256.toString(),
      confirmations: 1,
      checkTxIntervalSec: checkTxIntervalSec
    }, user.address);
  };
  _proto.proposePrice = function proposePrice(proposedPriceDecimals) {
    var _this$store$read$chai2 = this.store.read().chainConfig(),
      checkTxIntervalSec = _this$store$read$chai2.checkTxIntervalSec;
    var proposedPrice = toWei(proposedPriceDecimals);
    var inputRequest = this.store.read().inputRequest();
    var request = this.store.read().request();
    var user = this.store.read().user();
    assert(user.address, "requires a user account address");
    assert(user.signer, "requires a user signer");
    assert(user.chainId === inputRequest.chainId, "On wrong chain");
    assert(request.currency, "Request currency is unknown");
    return this.sm.types.proposePrice.create(_extends({}, inputRequest, {
      proposedPrice: proposedPrice,
      signer: user.signer,
      account: user.address,
      currency: request.currency,
      confirmations: 1,
      checkTxIntervalSec: checkTxIntervalSec
    }), user.address);
  };
  _proto.disputePrice = function disputePrice() {
    var _this$store$read$chai3 = this.store.read().chainConfig(),
      checkTxIntervalSec = _this$store$read$chai3.checkTxIntervalSec;
    var inputRequest = this.store.read().inputRequest();
    var user = this.store.read().user();
    var request = this.store.read().request();
    assert(user.address, "requires a user account address");
    assert(user.signer, "requires a user signer");
    assert(user.chainId === inputRequest.chainId, "On wrong chain");
    assert(request.currency, "Request currency is unknown");
    return this.sm.types.disputePrice.create(_extends({}, inputRequest, {
      confirmations: 1,
      signer: user.signer,
      account: user.address,
      currency: request.currency,
      checkTxIntervalSec: checkTxIntervalSec
    }), user.address);
  };
  _proto.settle = function settle() {
    var _this$store$read$chai4 = this.store.read().chainConfig(),
      checkTxIntervalSec = _this$store$read$chai4.checkTxIntervalSec;
    var inputRequest = this.store.read().inputRequest();
    var user = this.store.read().user();
    var request = this.store.read().request();
    assert(user.address, "requires a user account address");
    assert(user.signer, "requires a user signer");
    assert(user.chainId === inputRequest.chainId, "On wrong chain");
    assert(request.currency, "Request currency is unknown");
    return this.sm.types.settle.create(_extends({}, inputRequest, {
      confirmations: 1,
      signer: user.signer,
      account: user.address,
      currency: request.currency,
      checkTxIntervalSec: checkTxIntervalSec
    }), user.address);
  };
  _proto.switchOrAddChain = function switchOrAddChain() {
    var inputRequest = this.store.read().inputRequest();
    var user = this.store.read().user();
    assert(user.provider, "requires user provider");
    assert(user.address, "requires user address");
    assert(inputRequest.chainId, "requires active request chainId");
    return this.sm.types.switchOrAddChain.create({
      chainId: inputRequest.chainId,
      provider: user.provider
    }, user.address);
  }
  // runs statemachine step loop pretty fast by default.
  ;
  _proto.startInterval = function startInterval(delayMs) {
    var _this = this;
    if (delayMs === void 0) {
      delayMs = 1;
    }
    assert(!this.intervalStarted, "Interval already started, try stopping first");
    this.intervalStarted = true;
    loop( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            assert(_this.intervalStarted, "Interval Stopped");
            // it turns out since these 2 state machines share the same immer state, they need to be run serially and
            // cant be run concurrently or you get wierd state oscillations. For now keep them in the same timing loop.
            _context.next = 3;
            return _this.sm.tick();
          case 3:
            _context.next = 5;
            return _this.poller.tick();
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })), delayMs)["catch"](function (err) {
      console.error(err);
      _this.intervalStarted = false;
      _this.store.write(function (w) {
        return w.error(err);
      });
    });
  };
  _proto.stopInterval = function stopInterval() {
    assert(!this.intervalStarted, "Interval already stopped");
    this.intervalStarted = false;
  };
  return Client;
}();
function makeProvider(rpcUrls) {
  var providers = rpcUrls.map(function (url) {
    var provider = ethers$1.getDefaultProvider(url);
    // turn off all polling, we will poll manually
    provider.polling = false;
    return provider;
  });
  var provider = new ethers$1.providers.FallbackProvider(providers, 1);
  // turn off all polling, we will poll manually
  provider.polling = false;
  return provider;
}
function factory$1(config, emit, OptimisticOracle, sortedRequests) {
  var store = new OracleStore(emit);
  store.write(function (write) {
    write.config(config);
    // maintains queryable ordered list of requests across all chains
    write.sortedRequestsService(sortedRequests);
    for (var _i = 0, _Object$values = Object.values(config.chains); _i < _Object$values.length; _i++) {
      var chain = _Object$values[_i];
      var provider = makeProvider(chain.rpcUrls);
      write.chains(chain.chainId).optimisticOracle().address(chain.optimisticOracleAddress);
      write.services(chain.chainId).provider(provider);
      write.services(chain.chainId).multicall2(chain.multicall2Address);
      write.services(chain.chainId).optimisticOracle(new OptimisticOracle(provider, chain.optimisticOracleAddress, chain.chainId));
    }
  });
  var update = new Update(store);
  // this first state machine is for user actions
  var sm = new StateMachine(store);
  // this one is system actions used for long running commands independent of the user
  var poller = new StateMachine(store);
  // start the request list checkers
  for (var _i2 = 0, _Object$entries = Object.entries(config.chains); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _Object$entries[_i2],
      chainId = _Object$entries$_i[0],
      chainConfig = _Object$entries$_i[1];
    poller.types.fetchPastEvents.create({
      chainId: Number(chainId),
      startBlock: chainConfig.earliestBlockNumber,
      maxRange: chainConfig.maxEventRangeQuery
    }, "poller");
    // long running poller which only looks for new events
    poller.types.pollNewEvents.create({
      chainId: Number(chainId),
      pollRateSec: chainConfig.checkTxIntervalSec
    }, "poller");
    // updates event based data on all requests
    if (!chainConfig.disableFetchEventBased) poller.types.fetchEventBased.create({
      chainId: Number(chainId)
    }, "poller");
  }
  // create active request poller for all chains. Should only have one of these
  poller.types.pollActiveRequest.create(undefined, "poller");
  // polls user for balances/approvals on the current chain, in case it changes external to app
  poller.types.pollActiveUser.create(undefined, "poller");
  return new Client$1(store, update, sm, poller);
}

var client = {
  __proto__: null,
  Client: Client$1,
  factory: factory$1
};

var OptimisticOracle$1 = /*#__PURE__*/function () {
  function OptimisticOracle(provider, address, chainId) {
    var _this = this;
    this.provider = provider;
    this.address = address;
    this.chainId = chainId;
    this.events = [];
    this.requests = {};
    this.upsertRequest = function (request) {
      var id = requestId(request);
      var cachedRequest = _this.requests[id] || {};
      var update = _extends({}, cachedRequest, request, {
        chainId: _this.chainId,
        eventBased: false
      });
      _this.requests[id] = update;
      return update;
    };
    this.parseLog = function (log) {
      var description = _this.contract["interface"].parseLog(log);
      return _extends({}, log, description, {
        event: description.name,
        eventSignature: description.signature
      });
    };
    this.updateFromEvents = function (events) {
      events.forEach(function (event) {
        if (isUnique(_this.events, event, eventKey)) {
          insertOrderedAscending(_this.events, event, eventKey);
        }
      });
      var _optimisticOracle$get = getEventState$7(_this.events),
        _optimisticOracle$get2 = _optimisticOracle$get.requests,
        requests = _optimisticOracle$get2 === void 0 ? {} : _optimisticOracle$get2;
      Object.values(requests).map(function (request) {
        return _this.upsertRequest(request);
      });
    };
    this.contract = connect$a(address, provider);
  }
  var _proto = OptimisticOracle.prototype;
  _proto.setDisputeHash = function setDisputeHash(_ref, hash) {
    var requester = _ref.requester,
      identifier = _ref.identifier,
      timestamp = _ref.timestamp,
      ancillaryData = _ref.ancillaryData;
    return this.upsertRequest({
      requester: requester,
      identifier: identifier,
      timestamp: timestamp,
      ancillaryData: ancillaryData,
      disputeTx: hash
    });
  };
  _proto.setProposeHash = function setProposeHash(_ref2, hash) {
    var requester = _ref2.requester,
      identifier = _ref2.identifier,
      timestamp = _ref2.timestamp,
      ancillaryData = _ref2.ancillaryData;
    return this.upsertRequest({
      requester: requester,
      identifier: identifier,
      timestamp: timestamp,
      ancillaryData: ancillaryData,
      proposeTx: hash
    });
  };
  _proto.setSettleHash = function setSettleHash(_ref3, hash) {
    var requester = _ref3.requester,
      identifier = _ref3.identifier,
      timestamp = _ref3.timestamp,
      ancillaryData = _ref3.ancillaryData;
    return this.upsertRequest({
      requester: requester,
      identifier: identifier,
      timestamp: timestamp,
      ancillaryData: ancillaryData,
      settleTx: hash
    });
  };
  _proto.fetchRequest = /*#__PURE__*/function () {
    var _fetchRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref4) {
      var requester, identifier, timestamp, ancillaryData, request, state;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            requester = _ref4.requester, identifier = _ref4.identifier, timestamp = _ref4.timestamp, ancillaryData = _ref4.ancillaryData;
            _context.next = 3;
            return this.contract.callStatic.getRequest(requester, identifier, timestamp, ancillaryData);
          case 3:
            request = _context.sent;
            _context.next = 6;
            return this.contract.callStatic.getState(requester, identifier, timestamp, ancillaryData);
          case 6:
            state = _context.sent;
            return _context.abrupt("return", this.upsertRequest(_extends({}, request, {
              state: state,
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            })));
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function fetchRequest(_x) {
      return _fetchRequest.apply(this, arguments);
    }
    return fetchRequest;
  }();
  _proto.getRequest = function getRequest(key) {
    var id = requestId(key);
    var request = this.requests[id] || key;
    return _extends({}, request);
  };
  _proto.disputePrice = /*#__PURE__*/function () {
    var _disputePrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signer, _ref5) {
      var requester, identifier, timestamp, ancillaryData, contract, tx;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            requester = _ref5.requester, identifier = _ref5.identifier, timestamp = _ref5.timestamp, ancillaryData = _ref5.ancillaryData;
            contract = connect$a(this.address, signer);
            _context2.next = 4;
            return contract.disputePrice(requester, identifier, timestamp, ancillaryData);
          case 4:
            tx = _context2.sent;
            this.setDisputeHash({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }, tx.hash);
            return _context2.abrupt("return", tx);
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function disputePrice(_x2, _x3) {
      return _disputePrice.apply(this, arguments);
    }
    return disputePrice;
  }();
  _proto.proposePrice = /*#__PURE__*/function () {
    var _proposePrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(signer, _ref6, price) {
      var requester, identifier, timestamp, ancillaryData, contract, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            requester = _ref6.requester, identifier = _ref6.identifier, timestamp = _ref6.timestamp, ancillaryData = _ref6.ancillaryData;
            contract = connect$a(this.address, signer);
            _context3.next = 4;
            return contract.proposePrice(requester, identifier, timestamp, ancillaryData, price);
          case 4:
            tx = _context3.sent;
            this.setProposeHash({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }, tx.hash);
            return _context3.abrupt("return", tx);
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function proposePrice(_x4, _x5, _x6) {
      return _proposePrice.apply(this, arguments);
    }
    return proposePrice;
  }();
  _proto.settle = /*#__PURE__*/function () {
    var _settle = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(signer, _ref7) {
      var requester, identifier, timestamp, ancillaryData, contract, tx;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            requester = _ref7.requester, identifier = _ref7.identifier, timestamp = _ref7.timestamp, ancillaryData = _ref7.ancillaryData;
            contract = connect$a(this.address, signer);
            _context4.next = 4;
            return contract.settle(requester, identifier, timestamp, ancillaryData);
          case 4:
            tx = _context4.sent;
            this.setSettleHash({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }, tx.hash);
            return _context4.abrupt("return", tx);
          case 7:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function settle(_x7, _x8) {
      return _settle.apply(this, arguments);
    }
    return settle;
  }();
  _proto.update = /*#__PURE__*/function () {
    var _update = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(startBlock, endBlock) {
      var events;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            if (startBlock === void 0) {
              startBlock = 0;
            }
            if (endBlock === void 0) {
              endBlock = "latest";
            }
            _context5.next = 4;
            return this.contract.queryFilter({}, startBlock, endBlock);
          case 4:
            events = _context5.sent;
            this.updateFromEvents(events);
          case 6:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function update(_x9, _x10) {
      return _update.apply(this, arguments);
    }
    return update;
  }();
  _proto.getProps = /*#__PURE__*/function () {
    var _getProps = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.contract.defaultLiveness();
          case 2:
            _context6.t0 = _context6.sent;
            return _context6.abrupt("return", {
              defaultLiveness: _context6.t0
            });
          case 4:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function getProps() {
      return _getProps.apply(this, arguments);
    }
    return getProps;
  }();
  _proto.updateFromTransactionReceipt = function updateFromTransactionReceipt(receipt) {
    var _this2 = this;
    var events = receipt.logs.map(function (log) {
      return _this2.parseLog(log);
    });
    this.updateFromEvents(events);
  };
  _proto.listRequests = function listRequests() {
    return Object.values(this.requests);
  };
  return OptimisticOracle;
}();

var optimisticOracle = {
  __proto__: null,
  OptimisticOracle: OptimisticOracle$1
};

// this was copied out of store and made to be 1. a class, and 2. sync.  Could not modify old implementation since
// other services rely on this currently and it causes cascading refactors. This has been copied without modification to logic.
var SortedStore = function SortedStore() {
  var _this = this;
  this.ids = [];
  this.map = new Map();
  this.getStart = function (id, inclusive) {
    if (inclusive === void 0) {
      inclusive = true;
    }
    if (inclusive) {
      return sortedIndex$1(_this.ids, id);
    } else {
      return sortedLastIndex$1(_this.ids, id);
    }
  };
  this.getEnd = function (id, inclusive) {
    if (inclusive === void 0) {
      inclusive = false;
    }
    return _this.getStart(id, !inclusive);
  };
  this.del = function (id) {
    var index = sortedIndex$1(_this.ids, id);
    _this.ids.splice(index, 1);
    var result = _this.map.get(id);
    _this.map["delete"](id);
    return result;
  };
  // keeps typescript from complaining that return values may be undefined
  this.getSafe = function (id) {
    var result = _this.map.get(id);
    if (exists(result)) return result;
    throw new Error("Missing data for index: " + id);
  };
  this.has = function (id) {
    return _this.map.has(id);
  };
  this.set = function (id, data) {
    if (_this.map.has(id)) {
      _this.map.set(id, data);
    } else {
      var index = sortedIndex$1(_this.ids, id);
      _this.ids.splice(index, 0, id);
      _this.map.set(id, data);
    }
  };
  this.get = function (id) {
    return _this.map.get(id);
  };
  this.values = function () {
    return _this.ids.map(_this.getSafe);
  };
  this.entries = function () {
    return _this.ids.map(function (id) {
      return [id, _this.getSafe(id)];
    });
  };
  this.keys = function () {
    return [].concat(_this.ids);
  };
  this.clear = function () {
    _this.map.clear();
    _this.ids.length = 0;
  };
  this.size = function () {
    return _this.ids.length;
  };
  this["delete"] = function (id) {
    if (!_this.map.has(id)) return;
    _this.del(id);
  };
  // assume [a,b)
  this.between = function (a, b) {
    var start = _this.getStart(a);
    var end = _this.getEnd(b);
    return _this.ids.slice(start, end).map(_this.getSafe);
  };
  this.slice = function (id, length) {
    var start = _this.getStart(id);
    return _this.ids.slice(start, start + length).map(_this.getSafe);
  };
};
// this sorts requests across all chains and oracles
var SortedRequests = /*#__PURE__*/function (_SortedStore) {
  _inheritsLoose(SortedRequests, _SortedStore);
  function SortedRequests() {
    return _SortedStore.apply(this, arguments) || this;
  }
  var _proto = SortedRequests.prototype;
  _proto.setByRequest = function setByRequest(value) {
    return this.set(this.id(value), value);
  };
  _proto.descending = function descending() {
    // sadly you cannot control lodash sorting descending, so reverse is necessary
    return this.values().reverse();
  };
  _proto.ascending = function ascending() {
    return this.values();
  };
  _proto.getByRequest = function getByRequest(request) {
    // always return at least the original query data
    return this.get(this.id(request)) || request;
  };
  _proto.id = function id(request) {
    return requestId(request) + "!" + request.chainId + "!" + request.oracleType;
  };
  return SortedRequests;
}(SortedStore);

var sortedRequests = {
  __proto__: null,
  SortedStore: SortedStore,
  SortedRequests: SortedRequests
};

function validateSolidityRequest(request) {
  assert(request.proposer, "Missing proposer");
  assert(request.disputer, "Missing disputer");
  assert(request.currency, "Missing currency");
  assert(request.settled, "Missing settled");
  assert(request.proposedPrice, "Missing proposedPrice");
  assert(request.resolvedPrice, "Missing resolvedPrice");
  assert(request.expirationTime, "Missing expirationTime");
  assert(request.reward, "Missing reward");
  assert(request.finalFee, "Missing finalFee");
  assert(request.bond, "Missing bond");
  assert(request.customLiveness, "Missing customLiveness");
  return {
    proposer: request.proposer,
    disputer: request.disputer,
    currency: request.currency,
    settled: request.settled,
    proposedPrice: request.proposedPrice,
    resolvedPrice: request.resolvedPrice,
    expirationTime: request.expirationTime,
    reward: request.reward,
    finalFee: request.finalFee,
    bond: request.bond,
    customLiveness: request.customLiveness
  };
}
var SkinnyOptimisticOracle = /*#__PURE__*/function () {
  function SkinnyOptimisticOracle(provider, address, chainId) {
    var _this = this;
    this.provider = provider;
    this.address = address;
    this.chainId = chainId;
    this.events = [];
    this.requests = {};
    this.upsertRequest = function (request) {
      var id = requestId(request);
      var cachedRequest = _this.requests[id] || {};
      var update = _extends({}, cachedRequest, request, {
        chainId: _this.chainId,
        eventBased: false
      });
      _this.requests[id] = update;
      return update;
    };
    this.updateFromEvents = function (events) {
      events.forEach(function (event) {
        if (isUnique(_this.events, event, eventKey)) {
          insertOrderedAscending(_this.events, event, eventKey);
        }
      });
      var _optimisticOracle$get = getEventState$8(_this.events),
        _optimisticOracle$get2 = _optimisticOracle$get.requests,
        requests = _optimisticOracle$get2 === void 0 ? {} : _optimisticOracle$get2;
      Object.values(requests).map(function (request) {
        return _this.upsertRequest(request);
      });
    };
    this.parseLog = function (log) {
      var description = _this.contract["interface"].parseLog(log);
      return _extends({}, log, description, {
        event: description.name,
        eventSignature: description.signature
      });
    };
    this.contract = connect$b(address, provider);
  }
  var _proto = SkinnyOptimisticOracle.prototype;
  _proto.setDisputeHash = function setDisputeHash(_ref, hash) {
    var requester = _ref.requester,
      identifier = _ref.identifier,
      timestamp = _ref.timestamp,
      ancillaryData = _ref.ancillaryData;
    return this.upsertRequest({
      requester: requester,
      identifier: identifier,
      timestamp: timestamp,
      ancillaryData: ancillaryData,
      disputeTx: hash
    });
  };
  _proto.setProposeHash = function setProposeHash(_ref2, hash) {
    var requester = _ref2.requester,
      identifier = _ref2.identifier,
      timestamp = _ref2.timestamp,
      ancillaryData = _ref2.ancillaryData;
    return this.upsertRequest({
      requester: requester,
      identifier: identifier,
      timestamp: timestamp,
      ancillaryData: ancillaryData,
      proposeTx: hash
    });
  };
  _proto.setSettleHash = function setSettleHash(_ref3, hash) {
    var requester = _ref3.requester,
      identifier = _ref3.identifier,
      timestamp = _ref3.timestamp,
      ancillaryData = _ref3.ancillaryData;
    return this.upsertRequest({
      requester: requester,
      identifier: identifier,
      timestamp: timestamp,
      ancillaryData: ancillaryData,
      settleTx: hash
    });
  };
  _proto.fetchRequest = /*#__PURE__*/function () {
    var _fetchRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", this.getRequest(key));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function fetchRequest(_x) {
      return _fetchRequest.apply(this, arguments);
    }
    return fetchRequest;
  }();
  _proto.getRequest = function getRequest(key) {
    var id = requestId(key);
    var request = this.requests[id] || key;
    return _extends({}, request);
  };
  _proto.disputePrice = /*#__PURE__*/function () {
    var _disputePrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signer, _ref4) {
      var requester, identifier, timestamp, ancillaryData, request, contract, tx;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            requester = _ref4.requester, identifier = _ref4.identifier, timestamp = _ref4.timestamp, ancillaryData = _ref4.ancillaryData;
            request = validateSolidityRequest(this.getRequest({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }));
            contract = connect$b(this.address, signer);
            _context2.next = 5;
            return contract.disputePrice(requester, identifier, timestamp, ancillaryData, request);
          case 5:
            tx = _context2.sent;
            this.setDisputeHash({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }, tx.hash);
            return _context2.abrupt("return", tx);
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function disputePrice(_x2, _x3) {
      return _disputePrice.apply(this, arguments);
    }
    return disputePrice;
  }();
  _proto.proposePrice = /*#__PURE__*/function () {
    var _proposePrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(signer, _ref5, price) {
      var requester, identifier, timestamp, ancillaryData, request, contract, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            requester = _ref5.requester, identifier = _ref5.identifier, timestamp = _ref5.timestamp, ancillaryData = _ref5.ancillaryData;
            request = validateSolidityRequest(this.getRequest({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }));
            contract = connect$b(this.address, signer);
            _context3.next = 5;
            return contract.proposePrice(requester, identifier, timestamp, ancillaryData, request, price);
          case 5:
            tx = _context3.sent;
            this.setProposeHash({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }, tx.hash);
            return _context3.abrupt("return", tx);
          case 8:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function proposePrice(_x4, _x5, _x6) {
      return _proposePrice.apply(this, arguments);
    }
    return proposePrice;
  }();
  _proto.settle = /*#__PURE__*/function () {
    var _settle = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(signer, _ref6) {
      var requester, identifier, timestamp, ancillaryData, request, contract, tx;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            requester = _ref6.requester, identifier = _ref6.identifier, timestamp = _ref6.timestamp, ancillaryData = _ref6.ancillaryData;
            request = validateSolidityRequest(this.getRequest({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }));
            contract = connect$b(this.address, signer);
            _context4.next = 5;
            return contract.settle(requester, identifier, timestamp, ancillaryData, request);
          case 5:
            tx = _context4.sent;
            this.setSettleHash({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }, tx.hash);
            return _context4.abrupt("return", tx);
          case 8:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function settle(_x7, _x8) {
      return _settle.apply(this, arguments);
    }
    return settle;
  }();
  _proto.update = /*#__PURE__*/function () {
    var _update = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(startBlock, endBlock) {
      var events;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            if (startBlock === void 0) {
              startBlock = 0;
            }
            if (endBlock === void 0) {
              endBlock = "latest";
            }
            _context5.next = 4;
            return this.contract.queryFilter({}, startBlock, endBlock);
          case 4:
            events = _context5.sent;
            this.updateFromEvents(events);
          case 6:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function update(_x9, _x10) {
      return _update.apply(this, arguments);
    }
    return update;
  }();
  _proto.getProps = /*#__PURE__*/function () {
    var _getProps = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.contract.defaultLiveness();
          case 2:
            _context6.t0 = _context6.sent;
            return _context6.abrupt("return", {
              defaultLiveness: _context6.t0
            });
          case 4:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function getProps() {
      return _getProps.apply(this, arguments);
    }
    return getProps;
  }();
  _proto.updateFromTransactionReceipt = function updateFromTransactionReceipt(receipt) {
    var _this2 = this;
    var events = receipt.logs.map(function (log) {
      return _this2.parseLog(log);
    });
    this.updateFromEvents(events);
  };
  _proto.listRequests = function listRequests() {
    return Object.values(this.requests);
  };
  return SkinnyOptimisticOracle;
}();

var skinnyOptimisticOracle = {
  __proto__: null,
  SkinnyOptimisticOracle: SkinnyOptimisticOracle
};

var OptimisticOracleV2 = /*#__PURE__*/function () {
  function OptimisticOracleV2(provider, address, chainId) {
    var _this = this;
    this.provider = provider;
    this.address = address;
    this.chainId = chainId;
    this.events = [];
    this.requests = {};
    this.upsertRequest = function (request) {
      var id = requestId(request);
      var cachedRequest = _this.requests[id] || {};
      var update = _extends({}, cachedRequest, request, request.requestSettings || {}, {
        chainId: _this.chainId
      });
      _this.requests[id] = update;
      return update;
    };
    this.updateFromEvents = function (events) {
      events.forEach(function (event) {
        if (isUnique(_this.events, event, eventKey)) {
          insertOrderedAscending(_this.events, event, eventKey);
        }
      });
      var _getEventState = getEventState$9(_this.events),
        _getEventState$reques = _getEventState.requests,
        requests = _getEventState$reques === void 0 ? {} : _getEventState$reques;
      Object.values(requests).map(function (request) {
        return _this.upsertRequest(request);
      });
    };
    this.parseLog = function (log) {
      var description = _this.contract["interface"].parseLog(log);
      return _extends({}, log, description, {
        event: description.name,
        eventSignature: description.signature
      });
    };
    this.contract = connect$c(address, provider);
  }
  var _proto = OptimisticOracleV2.prototype;
  _proto.setDisputeHash = function setDisputeHash(_ref, hash) {
    var requester = _ref.requester,
      identifier = _ref.identifier,
      timestamp = _ref.timestamp,
      ancillaryData = _ref.ancillaryData;
    return this.upsertRequest({
      requester: requester,
      identifier: identifier,
      timestamp: timestamp,
      ancillaryData: ancillaryData,
      disputeTx: hash
    });
  };
  _proto.setProposeHash = function setProposeHash(_ref2, hash) {
    var requester = _ref2.requester,
      identifier = _ref2.identifier,
      timestamp = _ref2.timestamp,
      ancillaryData = _ref2.ancillaryData;
    return this.upsertRequest({
      requester: requester,
      identifier: identifier,
      timestamp: timestamp,
      ancillaryData: ancillaryData,
      proposeTx: hash
    });
  };
  _proto.setSettleHash = function setSettleHash(_ref3, hash) {
    var requester = _ref3.requester,
      identifier = _ref3.identifier,
      timestamp = _ref3.timestamp,
      ancillaryData = _ref3.ancillaryData;
    return this.upsertRequest({
      requester: requester,
      identifier: identifier,
      timestamp: timestamp,
      ancillaryData: ancillaryData,
      settleTx: hash
    });
  };
  _proto.fetchRequest = /*#__PURE__*/function () {
    var _fetchRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref4) {
      var requester, identifier, timestamp, ancillaryData, request, state;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            requester = _ref4.requester, identifier = _ref4.identifier, timestamp = _ref4.timestamp, ancillaryData = _ref4.ancillaryData;
            _context.next = 3;
            return this.contract.callStatic.getRequest(requester, identifier, timestamp, ancillaryData);
          case 3:
            request = _context.sent;
            _context.next = 6;
            return this.contract.callStatic.getState(requester, identifier, timestamp, ancillaryData);
          case 6:
            state = _context.sent;
            return _context.abrupt("return", this.upsertRequest(_extends({}, request, {
              state: state,
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            })));
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function fetchRequest(_x) {
      return _fetchRequest.apply(this, arguments);
    }
    return fetchRequest;
  }();
  _proto.getRequest = function getRequest(key) {
    var id = requestId(key);
    var request = this.requests[id] || key;
    return _extends({}, request);
  };
  _proto.disputePrice = /*#__PURE__*/function () {
    var _disputePrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signer, _ref5) {
      var requester, identifier, timestamp, ancillaryData, contract, tx;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            requester = _ref5.requester, identifier = _ref5.identifier, timestamp = _ref5.timestamp, ancillaryData = _ref5.ancillaryData;
            contract = connect$c(this.address, signer);
            _context2.next = 4;
            return contract.disputePrice(requester, identifier, timestamp, ancillaryData);
          case 4:
            tx = _context2.sent;
            this.setDisputeHash({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }, tx.hash);
            return _context2.abrupt("return", tx);
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function disputePrice(_x2, _x3) {
      return _disputePrice.apply(this, arguments);
    }
    return disputePrice;
  }();
  _proto.proposePrice = /*#__PURE__*/function () {
    var _proposePrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(signer, _ref6, price) {
      var requester, identifier, timestamp, ancillaryData, contract, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            requester = _ref6.requester, identifier = _ref6.identifier, timestamp = _ref6.timestamp, ancillaryData = _ref6.ancillaryData;
            contract = connect$c(this.address, signer);
            _context3.next = 4;
            return contract.proposePrice(requester, identifier, timestamp, ancillaryData, price);
          case 4:
            tx = _context3.sent;
            this.setProposeHash({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }, tx.hash);
            return _context3.abrupt("return", tx);
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function proposePrice(_x4, _x5, _x6) {
      return _proposePrice.apply(this, arguments);
    }
    return proposePrice;
  }();
  _proto.settle = /*#__PURE__*/function () {
    var _settle = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(signer, _ref7) {
      var requester, identifier, timestamp, ancillaryData, contract, tx;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            requester = _ref7.requester, identifier = _ref7.identifier, timestamp = _ref7.timestamp, ancillaryData = _ref7.ancillaryData;
            contract = connect$c(this.address, signer);
            _context4.next = 4;
            return contract.settle(requester, identifier, timestamp, ancillaryData);
          case 4:
            tx = _context4.sent;
            this.setSettleHash({
              requester: requester,
              identifier: identifier,
              timestamp: timestamp,
              ancillaryData: ancillaryData
            }, tx.hash);
            return _context4.abrupt("return", tx);
          case 7:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function settle(_x7, _x8) {
      return _settle.apply(this, arguments);
    }
    return settle;
  }();
  _proto.update = /*#__PURE__*/function () {
    var _update = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(startBlock, endBlock) {
      var events;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            if (startBlock === void 0) {
              startBlock = 0;
            }
            if (endBlock === void 0) {
              endBlock = "latest";
            }
            _context5.next = 4;
            return this.contract.queryFilter({}, startBlock, endBlock);
          case 4:
            events = _context5.sent;
            this.updateFromEvents(events);
          case 6:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function update(_x9, _x10) {
      return _update.apply(this, arguments);
    }
    return update;
  }();
  _proto.getProps = /*#__PURE__*/function () {
    var _getProps = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return this.contract.defaultLiveness();
          case 2:
            _context6.t0 = _context6.sent;
            return _context6.abrupt("return", {
              defaultLiveness: _context6.t0
            });
          case 4:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function getProps() {
      return _getProps.apply(this, arguments);
    }
    return getProps;
  }();
  _proto.updateFromTransactionReceipt = function updateFromTransactionReceipt(receipt) {
    var _this2 = this;
    var events = receipt.logs.map(function (log) {
      return _this2.parseLog(log);
    });
    this.updateFromEvents(events);
  };
  _proto.listRequests = function listRequests() {
    return Object.values(this.requests);
  };
  return OptimisticOracleV2;
}();

var optimisticOracleV2 = {
  __proto__: null,
  OptimisticOracleV2: OptimisticOracleV2
};



var index$o = {
  __proto__: null,
  erc20: erc20,
  optimisticOracle: optimisticOracle,
  statemachines: index$n,
  sortedRequests: sortedRequests,
  skinnyOptimisticOracle: skinnyOptimisticOracle,
  optimisticOracleV2: optimisticOracleV2
};



var ethers = {
  __proto__: null,
  Provider: Provider,
  JsonRpcSigner: JsonRpcSigner,
  JsonRpcProvider: JsonRpcProvider,
  Web3Provider: Web3Provider,
  FallbackProvider: FallbackProvider
};



var misc = {
  __proto__: null
};



var interfaces = {
  __proto__: null,
  get RequestState () { return RequestState; }
};



var index$p = {
  __proto__: null,
  state: state,
  ethers: ethers,
  misc: misc,
  statemachine: statemachine,
  interfaces: interfaces
};

var SkinnyFactory = (function (config, emit, sortedRequests) {
  if (sortedRequests === void 0) {
    sortedRequests = new SortedRequests();
  }
  var fullConfig = DefaultConfig({
    getMulticall2Address: getMulticall2Address
  })(_extends({}, config), OracleType.Skinny);
  return factory$1(fullConfig, emit, SkinnyOptimisticOracle, sortedRequests);
});

var OptimisticFactory = (function (config, emit, sortedRequests) {
  if (sortedRequests === void 0) {
    sortedRequests = new SortedRequests();
  }
  var fullConfig = DefaultConfig({
    getMulticall2Address: getMulticall2Address
  })(_extends({}, config), OracleType.Optimistic);
  return factory$1(fullConfig, emit, OptimisticOracle$1, sortedRequests);
});

var OptimisticV2Factory = (function (config, emit, sortedRequests) {
  if (sortedRequests === void 0) {
    sortedRequests = new SortedRequests();
  }
  var fullConfig = DefaultConfig({
    getMulticall2Address: getMulticall2Address
  })(_extends({}, config), OracleType.OptimisticV2);
  return factory$1(fullConfig, emit, OptimisticOracleV2, sortedRequests);
});

var EventHandler = function EventHandler(oracleType, publicEmit) {
  return function (state, prev) {
    return publicEmit(oracleType, state, prev);
  };
};
var factory$2 = (function (configTable, emit) {
  var sortedRequests = new SortedRequests();
  return Object.fromEntries(Object.entries(configTable).map(function (_ref) {
    var oracleType = _ref[0],
      config = _ref[1];
    assert(config, "requires config for type: " + oracleType);
    switch (oracleType) {
      case OracleType.Optimistic:
        return [oracleType, OptimisticFactory(config, EventHandler(oracleType, emit), sortedRequests)];
      case OracleType.Skinny:
        return [oracleType, SkinnyFactory(config, EventHandler(oracleType, emit), sortedRequests)];
      case OracleType.OptimisticV2:
        return [oracleType, OptimisticV2Factory(config, EventHandler(oracleType, emit), sortedRequests)];
      default:
        throw new Error("Unknown oracle type: " + oracleType);
    }
  }));
});



var index$q = {
  __proto__: null,
  client: client,
  services: index$o,
  types: index$p,
  store: index$m,
  utils: utils$2,
  errors: errors,
  skinnyFactory: SkinnyFactory,
  optimisticFactory: OptimisticFactory,
  factory: factory$2,
  optimisticV2Factory: OptimisticV2Factory
};

export { BlockFinder, Coingecko, Factory$d as Multicall, Multicall2Factory as Multicall2, index$l as across, index$d as clients, index$q as oracle, index$e as stores, index$j as tables, utils };
//# sourceMappingURL=index.js.map
