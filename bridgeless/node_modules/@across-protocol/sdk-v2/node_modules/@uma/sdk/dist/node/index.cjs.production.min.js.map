{"version":3,"file":"index.cjs.production.min.js","sources":["../src/clients/registry/client.ts","../src/utils.ts","../src/clients/emp/client.ts","../src/clients/erc20/client.ts","../src/clients/multicall/client.ts","../src/clients/multicall2/client.ts","../src/clients/lsp-creator/client.ts","../src/clients/lsp/client.ts","../src/clients/bridgeDepositBox/client.ts","../src/clients/bridgePool/client.ts","../src/clients/etherchain/client.ts","../src/clients/rateModelStore/client.ts","../src/clients/optimisticOracle/client.ts","../src/clients/skinnyOptimisticOracle/client.ts","../src/clients/optimisticOracleV2/client.ts","../src/stores/js-map/store.ts","../src/stores/sorted-js-map/store.ts","../src/stores/google-datastore/store.ts","../src/tables/base/table.ts","../src/tables/blocks/utils.ts","../src/tables/emps/utils.ts","../src/tables/historical-prices/utils.ts","../src/tables/erc20s/utils.ts","../src/tables/blocks/table.ts","../src/tables/emps/table.ts","../src/tables/historical-prices/table.ts","../src/tables/erc20s/table.ts","../src/across/utils.ts","../src/across/feeCalculator.ts","../src/across/constants.ts","../src/across/rateModel.ts","../src/blockFinder.ts","../src/coingecko/coingecko.ts","../src/across/gasFeeCalculator.ts","../src/multicall.ts","../src/multicall2.ts","../src/across/transactionManager.ts","../src/across/clients/bridgePool.ts","../src/across/clients/optimismBridge.ts","../src/across/clients/bobaBridge.ts","../src/across/lpFeeCalculator.ts","../src/oracle/errors.ts","../src/oracle/types/state.ts","../src/oracle/types/statemachine.ts","../src/oracle/utils.ts","../src/oracle/services/erc20.ts","../src/oracle/store/write.ts","../src/oracle/store/read.ts","../src/oracle/store/has.ts","../src/oracle/store/store.ts","../src/oracle/store/index.ts","../src/oracle/services/update.ts","../src/oracle/services/statemachines/setUser.ts","../src/oracle/services/statemachines/clearUser.ts","../src/oracle/services/statemachines/setActiveRequest.ts","../src/oracle/services/statemachines/approve.ts","../src/oracle/services/statemachines/disputePrice.ts","../src/oracle/services/statemachines/proposePrice.ts","../src/oracle/services/statemachines/switchOrAddChain.ts","../src/oracle/services/statemachines/pollActiveRequest.ts","../src/oracle/services/statemachines/fetchPastEvents.ts","../src/oracle/services/statemachines/pollNewEvents.ts","../src/oracle/services/statemachines/setActiveRequestByTransaction.ts","../src/oracle/services/statemachines/settle.ts","../src/oracle/services/statemachines/fetchEventBased.ts","../src/oracle/services/statemachines/utils.ts","../src/oracle/services/statemachines/pollActiveUser.ts","../src/oracle/services/statemachines/updateActiveRequest.ts","../src/oracle/services/statemachines/statemachine.ts","../src/oracle/client.ts","../src/oracle/services/optimisticOracle.ts","../src/oracle/services/sortedRequests.ts","../src/oracle/services/skinnyOptimisticOracle.ts","../src/oracle/services/optimisticOracleV2.ts","../src/oracle/skinnyFactory.ts","../src/oracle/optimisticFactory.ts","../src/oracle/optimisticV2Factory.ts","../src/oracle/factory.ts"],"sourcesContent":["import {\n  RegistryEthers,\n  RegistryEthers__factory,\n  getRegistryAddress as getAbi,\n  getRegistryAddress as getAddress,\n} from \"@uma/contracts-node\";\n\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\n\nexport type Instance = RegistryEthers;\nconst Factory = RegistryEthers__factory;\n\nexport type Network = string | number;\n\nexport { getAddress, getAbi };\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport interface EventState {\n  contracts?: { [key: string]: NewContractRegistered };\n}\n\nexport type NewContractRegistered = GetEventType<Instance, \"NewContractRegistered\">;\n\n// experimenting with a generalized way of handling events and returning state, inspired from react style reducers\nexport function reduceEvents(state: EventState = {}, event: Event): EventState {\n  switch (event.event) {\n    case \"NewContractRegistered\": {\n      const typedEvent = event as NewContractRegistered;\n      const { contractAddress } = typedEvent.args;\n      const contracts = state?.contracts || {};\n      return {\n        ...state,\n        contracts: {\n          ...contracts,\n          [contractAddress]: typedEvent,\n        },\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[]): EventState {\n  return events.reduce(reduceEvents, {});\n}\n","import assert from \"assert\";\nimport { BigNumber, Contract } from \"ethers\";\nimport type Multicall2 from \"./multicall2\";\nimport zip from \"lodash/zip\";\n\nexport type BigNumberish = number | string | BigNumber;\n// check if a value is not null or undefined, useful for numbers which could be 0.\n// \"is\" syntax: https://stackoverflow.com/questions/40081332/what-does-the-is-keyword-do-in-typescript\n/* eslint-disable-next-line @typescript-eslint/ban-types */\nexport function exists<T>(value: T | null | undefined): value is NonNullable<T> {\n  return value !== null && value !== undefined;\n}\n\n// useful for maintaining balances from events\nexport type Balances = { [key: string]: string };\nexport function Balances(balances: Balances = {}) {\n  function create(id: string, amount = \"0\") {\n    assert(!has(id), \"balance already exists\");\n    return set(id, amount);\n  }\n  function has(id: string) {\n    return exists(balances[id]);\n  }\n  function set(id: string, amount: string) {\n    balances[id] = amount;\n    return amount;\n  }\n  function add(id: string, amount: BigNumberish) {\n    return set(id, BigNumber.from(amount).add(getOrCreate(id)).toString());\n  }\n  function sub(id: string, amount: BigNumberish) {\n    return set(id, BigNumber.from(getOrCreate(id)).sub(amount).toString());\n  }\n  function get(id: string) {\n    assert(has(id), \"balance does not exist\");\n    return balances[id];\n  }\n  function getOrCreate(id: string) {\n    if (has(id)) return get(id);\n    return create(id);\n  }\n  return { create, add, sub, get, balances, set, has, getOrCreate };\n}\n\n// Copied from common, but modified for ethers Bignumber\nexport const ConvertDecimals = (fromDecimals: number, toDecimals: number) => {\n  assert(fromDecimals >= 0, \"requires fromDecimals as an integer >= 0\");\n  assert(toDecimals >= 0, \"requires toDecimals as an integer >= 0\");\n  // amount: string, BN, number - integer amount in fromDecimals smallest unit that want to convert toDecimals\n  // returns: string with toDecimals in smallest unit\n  return (amount: BigNumberish): string => {\n    assert(exists(amount), \"must provide an amount to convert\");\n    amount = BigNumber.from(amount);\n    if (amount.isZero()) return amount.toString();\n    const diff = fromDecimals - toDecimals;\n    if (diff == 0) return amount.toString();\n    if (diff > 0) return amount.div(BigNumber.from(\"10\").pow(diff)).toString();\n    return amount.mul(BigNumber.from(\"10\").pow(-1 * diff)).toString();\n  };\n};\n\n// async sleep\nexport const sleep = (delay = 0) => new Promise((res) => setTimeout(res, delay));\n\n// Loop forever but wait until execution is finished before starting next timer. Throw an error to break this\n// or add another utlity function if you need it to end on condition.\nexport async function loop(fn: (...args: any[]) => any, delay: number, ...args: any[]) {\n  do {\n    await fn(...args);\n    await sleep(delay);\n    /* eslint-disable-next-line no-constant-condition */\n  } while (true);\n}\n\nexport type Call = [string, ...BigNumberish[]];\nexport type Calls = Call[];\nexport type BatchReadWithErrorsType = ReturnType<ReturnType<typeof BatchReadWithErrors>>;\nexport const BatchReadWithErrors = (multicall2: Multicall2) => (contract: Contract) => async <R>(\n  calls: Calls\n): Promise<R> => {\n  // multicall batch takes array of {method} objects\n  const results = await multicall2\n    .batch(\n      contract,\n      calls.map(([method, ...args]) => ({ method, args }))\n    )\n    .readWithErrors();\n  // convert results of multicall, an array of responses, into an object keyed by contract method\n  return Object.fromEntries(\n    zip(calls, results).map(([call, result]) => {\n      if (call == null) return [];\n      const [method] = call;\n      if (!result?.result) return [method, undefined];\n      return [method, result.result[0] || result.result];\n    })\n  );\n};\n\n/**\n * @notice Return average block-time for a period.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function averageBlockTimeSeconds(chainId?: number): Promise<number> {\n  // TODO: Call an external API to get this data. Currently this value is a hard-coded estimate\n  // based on the data from https://etherscan.io/chart/blocktime. ~13.5 seconds has been the average\n  // since April 2016, although this value seems to spike periodically for a relatively short period of time.\n  const defaultBlockTimeSeconds = 12;\n  if (!defaultBlockTimeSeconds) {\n    throw \"Missing default block time value\";\n  }\n\n  switch (chainId) {\n    // Source: https://polygonscan.com/chart/blocktime\n    case 10:\n      return 0.5;\n    case 42161:\n      return 0.5;\n    case 288:\n      return 150;\n    case 137:\n      return 2.5;\n    case 1:\n      return defaultBlockTimeSeconds;\n    default:\n      return defaultBlockTimeSeconds;\n  }\n}\n\nexport async function estimateBlocksElapsed(\n  seconds: number,\n  cushionPercentage = 0.0,\n  chainId?: number\n): Promise<number> {\n  const cushionMultiplier = cushionPercentage + 1.0;\n  const averageBlockTime = await averageBlockTimeSeconds(chainId);\n  return Math.floor((seconds * cushionMultiplier) / averageBlockTime);\n}\n","import { ExpiringMultiPartyEthers, ExpiringMultiPartyEthers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\nimport { Balances } from \"../../utils\";\n\nexport type Instance = ExpiringMultiPartyEthers;\nconst Factory = ExpiringMultiPartyEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport interface EventState {\n  // any address that created a position, regardless of if they have closed it\n  sponsors?: string[];\n  tokens?: Balances;\n  collateral?: Balances;\n  expired?: boolean;\n}\n\nexport type RequestTransferPositionExecuted = GetEventType<Instance, \"RequestTransferPositionExecuted\">;\nexport type PositionCreated = GetEventType<Instance, \"PositionCreated\">;\nexport type NewSponsor = GetEventType<Instance, \"NewSponsor\">;\nexport type SettleExpiredPosition = GetEventType<Instance, \"SettleExpiredPosition\">;\nexport type Redeem = GetEventType<Instance, \"Redeem\">;\nexport type Withdrawal = GetEventType<Instance, \"Withdrawal\">;\nexport type LiquidationCreated = GetEventType<Instance, \"LiquidationCreated\">;\n\n// experimenting with a generalized way of handling events and returning state, inspired from react style reducers\nexport function reduceEvents(state: EventState = {}, event: Event): EventState {\n  switch (event.event) {\n    case \"RequestTransferPositionExecuted\": {\n      const typedEvent = event as RequestTransferPositionExecuted;\n      const { oldSponsor, newSponsor } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      const collateralBalance = collateral.get(oldSponsor);\n      collateral.set(oldSponsor, \"0\");\n      collateral.set(newSponsor, collateralBalance);\n      const tokenBalance = tokens.get(oldSponsor);\n      tokens.set(oldSponsor, \"0\");\n      tokens.set(newSponsor, tokenBalance.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    case \"PositionCreated\": {\n      const typedEvent = event as PositionCreated;\n      const { sponsor, collateralAmount, tokenAmount } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      collateral.add(sponsor, collateralAmount.toString());\n      tokens.add(sponsor, tokenAmount.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    case \"NewSponsor\": {\n      const typedEvent = event as NewSponsor;\n      const { sponsor } = typedEvent.args;\n      const sponsors = new Set(state.sponsors || []);\n      sponsors.add(sponsor);\n      return {\n        ...state,\n        sponsors: Array.from(sponsors.values()),\n      };\n    }\n    case \"SettleExpiredPosition\": {\n      const typedEvent = event as SettleExpiredPosition;\n      const { caller, collateralReturned, tokensBurned } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      collateral.sub(caller, collateralReturned.toString());\n      tokens.sub(caller, tokensBurned.toString());\n      return {\n        ...state,\n        expired: true,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    case \"Redeem\": {\n      const typedEvent = event as Redeem;\n      const { sponsor, collateralAmount, tokenAmount } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      collateral.sub(sponsor, collateralAmount.toString());\n      tokens.sub(sponsor, tokenAmount.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    case \"LiquidationCreated\": {\n      const typedEvent = event as LiquidationCreated;\n      const { sponsor, tokensOutstanding, liquidatedCollateral } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      collateral.sub(sponsor, liquidatedCollateral.toString());\n      tokens.sub(sponsor, tokensOutstanding.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    // these 2 are the same\n    case \"Withdrawal\":\n    case \"RequestWithdrawalExecuted\": {\n      const typedEvent = event as Withdrawal;\n      const { sponsor, collateralAmount } = typedEvent.args;\n      const collateral = Balances(state.collateral || {});\n      collateral.sub(sponsor, collateralAmount.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n      };\n    }\n    case \"ContractExpired\": {\n      return {\n        ...state,\n        expired: true,\n      };\n    }\n  }\n  return state;\n}\n\nexport function getEventState(events: Event[], initialState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, initialState);\n}\n","import { ERC20Ethers, ERC20Ethers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\nimport { Balances } from \"../../utils\";\nimport { set } from \"lodash\";\n\nexport type Instance = ERC20Ethers;\nconst Factory = ERC20Ethers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport interface EventState {\n  // any address that created a position, regardless of if they have closed it\n  balances?: Balances;\n  // approvals are keyed both ways here for ease of lookup by either owner or spender\n  approvalsByOwner?: {\n    [owner: string]: {\n      [spender: string]: {\n        amount: string;\n      };\n    };\n  };\n  approvalsBySpender?: {\n    [spender: string]: {\n      [owner: string]: {\n        amount: string;\n      };\n    };\n  };\n}\n\nexport type Transfer = GetEventType<Instance, \"Transfer\">;\nexport type Approval = GetEventType<Instance, \"Approval\">;\n\n// takes all events and returns user balances and approvals\nexport function reduceEvents(state: EventState = {}, event: Event): EventState {\n  switch (event.event) {\n    case \"Transfer\": {\n      const typedEvent = event as Transfer;\n      const { from, to, value } = typedEvent.args;\n      const balances = Balances(state.balances || {});\n      balances.sub(from, value);\n      balances.add(to, value);\n      return {\n        ...state,\n        balances: balances.balances,\n      };\n    }\n    case \"Approval\": {\n      const typedEvent = event as Approval;\n      const { owner, spender, value } = typedEvent.args;\n      set(state, [\"approvalsByOwner\", owner, spender], value.toString());\n      set(state, [\"approvalsBySpender\", spender, owner], value.toString());\n      return {\n        ...state,\n      };\n    }\n  }\n  return state;\n}\n\nexport function getEventState(events: Event[], initialState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, initialState);\n}\n","import { MulticallEthers, MulticallEthers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider } from \"../..\";\n\nexport type Instance = MulticallEthers;\nconst Factory = MulticallEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n","import { Multicall2Ethers, Multicall2Ethers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider } from \"../..\";\n\nexport type Instance = Multicall2Ethers;\nconst Factory = Multicall2Ethers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n","import {\n  LongShortPairCreatorEthers,\n  LongShortPairCreatorEthers__factory,\n  getLongShortPairCreatorAbi as getAbi,\n  getLongShortPairCreatorAddress as getAddress,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\n\n// exporting Registry type in case its needed\nexport type Instance = LongShortPairCreatorEthers;\nconst Factory = LongShortPairCreatorEthers__factory;\n\nexport type Network = string | number;\n\nexport { getAddress, getAbi };\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport type CreatedLongShortPair = GetEventType<Instance, \"CreatedLongShortPair\">;\n\nexport interface EventState {\n  contracts?: {\n    [lspAddress: string]: CreatedLongShortPair;\n  };\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"CreatedLongShortPair\": {\n      const typedEvent = event as CreatedLongShortPair;\n      const contracts = state?.contracts || {};\n      return {\n        ...state,\n        contracts: {\n          ...contracts,\n          [typedEvent.args.longShortPair]: typedEvent,\n        },\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import { LongShortPairEthers, LongShortPairEthers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\nimport { Balances } from \"../../utils\";\n\nexport type Instance = LongShortPairEthers;\nconst Factory = LongShortPairEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport type TokensCreated = GetEventType<Instance, \"TokensCreated\">;\nexport type TokensRedeemed = GetEventType<Instance, \"TokensRedeemed\">;\nexport type ContractExpired = GetEventType<Instance, \"ContractExpired\">;\nexport type PositionSettled = GetEventType<Instance, \"PositionSettled\">;\n\nexport interface EventState {\n  sponsors?: string[];\n  longs?: Balances;\n  shorts?: Balances;\n  collateral?: Balances;\n  expired?: boolean;\n  expiredBy?: string;\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"TokensCreated\": {\n      const typedEvent = event as TokensCreated;\n      const { sponsor, collateralUsed, tokensMinted } = typedEvent.args;\n\n      const sponsors = new Set(state.sponsors || []);\n      const longs = Balances(state.longs || {});\n      const shorts = Balances(state.shorts || {});\n      const collateral = Balances(state.collateral || {});\n\n      sponsors.add(sponsor);\n      longs.add(sponsor, tokensMinted);\n      shorts.add(sponsor, tokensMinted);\n      collateral.add(sponsor, collateralUsed);\n\n      return {\n        ...state,\n        collateral: collateral.balances,\n        shorts: shorts.balances,\n        longs: longs.balances,\n        sponsors: Array.from(sponsors.values()),\n      };\n    }\n    case \"TokensRedeemed\": {\n      const typedEvent = event as TokensRedeemed;\n      const { sponsor, collateralReturned, tokensRedeemed } = typedEvent.args;\n\n      const longs = Balances(state.longs || {});\n      const shorts = Balances(state.shorts || {});\n      const collateral = Balances(state.collateral || {});\n\n      longs.sub(sponsor, tokensRedeemed);\n      shorts.sub(sponsor, tokensRedeemed);\n      collateral.sub(sponsor, collateralReturned);\n\n      return {\n        ...state,\n        collateral: collateral.balances,\n        shorts: shorts.balances,\n        longs: longs.balances,\n      };\n    }\n    case \"ContractExpired\": {\n      const typedEvent = event as ContractExpired;\n      const { caller } = typedEvent.args;\n\n      return {\n        ...state,\n        expired: true,\n        expiredBy: caller,\n      };\n    }\n    case \"PositionSettled\": {\n      const typedEvent = event as PositionSettled;\n      const { sponsor, collateralReturned, longTokens, shortTokens } = typedEvent.args;\n\n      const longs = Balances(state.longs || {});\n      const shorts = Balances(state.shorts || {});\n      const collateral = Balances(state.collateral || {});\n\n      longs.sub(sponsor, longTokens);\n      shorts.sub(sponsor, shortTokens);\n      collateral.sub(sponsor, collateralReturned);\n\n      return {\n        ...state,\n        collateral: collateral.balances,\n        shorts: shorts.balances,\n        longs: longs.balances,\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import { BridgeDepositBoxEthers, BridgeDepositBoxEthers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event, BigNumber } from \"ethers\";\n\nexport type Instance = BridgeDepositBoxEthers;\nconst Factory = BridgeDepositBoxEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport type SetMinimumBridgingDelay = GetEventType<Instance, \"SetMinimumBridgingDelay\">;\nexport type WhitelistToken = GetEventType<Instance, \"WhitelistToken\">;\nexport type DepositsEnabled = GetEventType<Instance, \"DepositsEnabled\">;\nexport type FundsDeposited = GetEventType<Instance, \"FundsDeposited\">;\nexport type TokensBridged = GetEventType<Instance, \"TokensBridged\">;\n\nexport type Deposit = {\n  chainId: BigNumber;\n  depositId: BigNumber;\n  l1Recipient: string;\n  l2Sender: string;\n  l1Token: string;\n  amount: BigNumber;\n  slowRelayFeePct: BigNumber;\n  instantRelayFeePct: BigNumber;\n  quoteTimestamp: BigNumber;\n};\nexport type Whitelist = {\n  l1Token: string;\n  l2Token: string;\n  lastBridgeTime: BigNumber;\n  bridgePool: string;\n};\nexport interface EventState {\n  minimumBridgingDelay?: string;\n  whitelistedTokens?: Record<string, Whitelist>;\n  depositsEnabled?: Record<string, boolean>;\n  deposits?: Record<string, Deposit>;\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"SetMinimumBridgingDelay\": {\n      const typedEvent = event as SetMinimumBridgingDelay;\n      const { newMinimumBridgingDelay } = typedEvent.args;\n      return {\n        ...state,\n        minimumBridgingDelay: newMinimumBridgingDelay.toString(),\n      };\n    }\n    case \"WhitelistToken\": {\n      const typedEvent = event as WhitelistToken;\n      const { l1Token, l2Token, lastBridgeTime, bridgePool } = typedEvent.args;\n      return {\n        ...state,\n        whitelistedTokens: {\n          ...state.whitelistedTokens,\n          [l2Token]: { l1Token, l2Token, lastBridgeTime, bridgePool },\n        },\n      };\n    }\n    case \"DepositsEnabled\": {\n      const typedEvent = event as DepositsEnabled;\n      const { l2Token, depositsEnabled } = typedEvent.args;\n      return {\n        ...state,\n        depositsEnabled: {\n          ...state.depositsEnabled,\n          [l2Token]: depositsEnabled,\n        },\n      };\n    }\n    case \"FundsDeposited\": {\n      const typedEvent = event as FundsDeposited;\n      const {\n        chainId,\n        depositId,\n        l1Recipient,\n        l2Sender,\n        l1Token,\n        amount,\n        slowRelayFeePct,\n        instantRelayFeePct,\n        quoteTimestamp,\n      } = typedEvent.args;\n\n      return {\n        ...state,\n        deposits: {\n          ...state.deposits,\n          [depositId.toString()]: {\n            chainId,\n            depositId,\n            l1Recipient,\n            l2Sender,\n            l1Token,\n            amount,\n            slowRelayFeePct,\n            instantRelayFeePct,\n            quoteTimestamp,\n          },\n        },\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import { BridgePoolEthers, BridgePoolEthers__factory, BridgePoolInterfaceEthers } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType, SerializableEvent } from \"../..\";\nimport { BigNumber } from \"ethers\";\nimport { Balances } from \"../../utils\";\n\nexport type Instance = BridgePoolEthers;\nexport const Factory = BridgePoolEthers__factory;\nexport type Interface = BridgePoolInterfaceEthers;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\nexport function attach(address: string): Instance {\n  return new Factory().attach(address);\n}\n\nexport type LiquidityAdded = GetEventType<Instance, \"LiquidityAdded\">;\nexport type LiquidityRemoved = GetEventType<Instance, \"LiquidityRemoved\">;\nexport type DepositRelayed = GetEventType<Instance, \"DepositRelayed\">;\nexport type RelaySpedUp = GetEventType<Instance, \"RelaySpedUp\">;\nexport type RelayDisputed = GetEventType<Instance, \"RelayDisputed\">;\nexport type RelayCanceled = GetEventType<Instance, \"RelayCanceled\">;\nexport type RelaySettled = GetEventType<Instance, \"RelaySettled\">;\nexport type BridgePoolAdminTransferred = GetEventType<Instance, \"BridgePoolAdminTransferred\">;\n\nexport type DepositData = {\n  chainId: BigNumber;\n  depositId: BigNumber;\n  l1Recipient: string;\n  l2Sender: string;\n  amount: BigNumber;\n  slowRelayFeePct: BigNumber;\n  instantRelayFeePct: BigNumber;\n  quoteTimestamp: number;\n};\nexport type RelayData = {\n  relayState: number;\n  slowRelayer: string;\n  relayId: number;\n  realizedLpFeePct: BigNumber;\n  priceRequestTime: number;\n  proposerBond: BigNumber;\n  finalFee: BigNumber;\n};\nexport interface EventState {\n  oldAdmin?: string;\n  newAdmin?: string;\n  tokens: Balances;\n  lpTokens: Balances;\n  deposits: Record<string, DepositData>;\n  relays: Record<string, RelayData>;\n  instantRelays: Record<string, string>;\n}\n\nexport function eventStateDefaults() {\n  return {\n    tokens: {},\n    lpTokens: {},\n    deposits: {},\n    relays: {},\n    instantRelays: {},\n  };\n}\n\nexport function reduceEvents(state: EventState, event: SerializableEvent): EventState {\n  switch (event.event) {\n    // event LiquidityAdded(address indexed token, uint256 amount, uint256 lpTokensMinted, address liquidityProvider);\n    case \"LiquidityAdded\": {\n      const typedEvent = event as LiquidityAdded;\n      const { amount, lpTokensMinted, liquidityProvider } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const lpTokens = Balances(state.lpTokens || {});\n      tokens.add(liquidityProvider, amount.toString());\n      lpTokens.add(liquidityProvider, lpTokensMinted.toString());\n      return {\n        ...state,\n        tokens: {\n          ...tokens.balances,\n        },\n        lpTokens: {\n          ...lpTokens.balances,\n        },\n      };\n    }\n    // event LiquidityRemoved(address indexed token, uint256 amount, uint256 lpTokensBurnt, address liquidityProvider);\n    case \"LiquidityRemoved\": {\n      const typedEvent = event as LiquidityRemoved;\n      const { amount, lpTokensBurnt, liquidityProvider } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const lpTokens = Balances(state.lpTokens || {});\n      tokens.sub(liquidityProvider, amount.toString());\n      lpTokens.sub(liquidityProvider, lpTokensBurnt.toString());\n      return {\n        ...state,\n        tokens: {\n          ...tokens.balances,\n        },\n        lpTokens: {\n          ...lpTokens.balances,\n        },\n      };\n    }\n    // event DepositRelayed( bytes32 indexed depositHash, DepositData depositData, address l1Token, RelayData relay, bytes32 relayAncillaryDataHash);\n    case \"DepositRelayed\": {\n      const typedEvent = event as DepositRelayed;\n      const { depositHash, depositData, relay, relayAncillaryDataHash } = typedEvent.args;\n      return {\n        ...state,\n        relays: {\n          ...state.relays,\n          [relayAncillaryDataHash]: relay,\n        },\n        deposits: {\n          ...state.deposits,\n          [depositHash]: depositData,\n        },\n      };\n    }\n    // event RelaySpedUp(bytes32 indexed depositHash, address indexed instantRelayer, RelayData relay);\n    case \"RelaySpedUp\": {\n      const typedEvent = event as RelaySpedUp;\n      const { depositHash, instantRelayer } = typedEvent.args;\n      return {\n        ...state,\n        instantRelays: {\n          ...(state.instantRelays || {}),\n          [depositHash]: instantRelayer,\n        },\n      };\n    }\n    // event RelayDisputed(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);\n    case \"RelayDisputed\": {\n      // TODO: finish implementation\n      // const typedEvent = event as RelayDisputed;\n      // const { depositHash, relayHash, disputer } = typedEvent.args;\n      return state;\n    }\n    // event RelayCanceled(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);\n    case \"RelayCanceled\": {\n      // TODO: finish implementation\n      // const typedEvent = event as RelayCanceled;\n      // const { depositHash, relayHash, disputer } = typedEvent.args;\n      return state;\n    }\n    // event RelaySettled(bytes32 indexed depositHash, address indexed caller, RelayData relay);\n    case \"RelaySettled\": {\n      // TODO: finish implementation\n      // const typedEvent = event as RelaySettled;\n      // const { depositHash, caller, relay } = typedEvent.args;\n      return state;\n    }\n    // event BridgePoolAdminTransferred(address oldAdmin, address newAdmin);\n    case \"BridgePoolAdminTransferred\": {\n      const typedEvent = event as BridgePoolAdminTransferred;\n      const { oldAdmin, newAdmin } = typedEvent.args;\n      return {\n        ...state,\n        oldAdmin,\n        newAdmin,\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: SerializableEvent[], eventState: EventState = eventStateDefaults()): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import axios from \"axios\";\nimport get from \"lodash/get\";\n\ntype GasPrice = {\n  safeLow: number;\n  standard: number;\n  fast: number;\n  fastest: number;\n  currentBaseFee: number;\n  recommendedBaseFee: number;\n};\n\nexport class Etherchain {\n  constructor(private url = \"https://www.etherchain.org/api\") {}\n\n  public async getGasPrice(): Promise<GasPrice> {\n    try {\n      const endpoint = this.url + \"/gasPriceOracle\";\n      const result = await axios.get(endpoint);\n      return result.data;\n    } catch (err) {\n      const msg = get(err, \"response.data.error\", get(err, \"response.statusText\", \"Unknown Coingecko Error\"));\n      throw new Error(msg);\n    }\n  }\n}\n","import {\n  RateModelStoreEthers,\n  RateModelStoreEthers__factory,\n  getRateModelStoreAddress as getAddress,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider } from \"../..\";\n\nexport type Instance = RateModelStoreEthers;\nexport const Factory = RateModelStoreEthers__factory;\n\nexport { getAddress };\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\nexport function attach(address: string): Instance {\n  return new Factory().attach(address);\n}\n","import {\n  OptimisticOracleInterfaceEthers,\n  OptimisticOracleInterfaceEthers__factory,\n  getOptimisticOracleInterfaceAbi,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event, BigNumberish, utils, BigNumber } from \"ethers\";\n\nexport type Instance = OptimisticOracleInterfaceEthers;\nconst Factory = OptimisticOracleInterfaceEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport const contractInterface = new utils.Interface(getOptimisticOracleInterfaceAbi());\n\nexport type RequestPrice = GetEventType<Instance, \"RequestPrice\">;\nexport type ProposePrice = GetEventType<Instance, \"ProposePrice\">;\nexport type DisputePrice = GetEventType<Instance, \"DisputePrice\">;\nexport type Settle = GetEventType<Instance, \"Settle\">;\n\nexport enum RequestState {\n  Invalid = 0, // Never requested.\n  Requested, // Requested, no other actions taken.\n  Proposed, // Proposed, but not expired or disputed yet.\n  Expired, // Proposed, not disputed, past liveness.\n  Disputed, // Disputed, but no DVM price returned yet.\n  Resolved, // Disputed and DVM price is available.\n  Settled, // Final price has been set in the contract (can get here from Expired or Resolved).\n}\n\n// all events have these values\nexport type RequestKey = {\n  requester: string;\n  identifier: string;\n  timestamp: number;\n  ancillaryData: string;\n};\nexport type Request = RequestKey &\n  // this is partial since we dont know what events we have to populate parts of this\n  Partial<{\n    proposer: string;\n    disputer: string;\n    currency: string;\n    settled: boolean;\n    refundOnDispute: boolean;\n    proposedPrice: BigNumber;\n    resolvedPrice: BigNumber;\n    expirationTime: BigNumber;\n    reward: BigNumber;\n    finalFee: BigNumber;\n    bond: BigNumber;\n    customLiveness: BigNumber;\n    price: BigNumber;\n    payout: BigNumber;\n    state: RequestState;\n    // metadata about the transaction that triggered the state changes\n    requestTx: string;\n    proposeTx: string;\n    disputeTx: string;\n    settleTx: string;\n    requestBlockNumber: number;\n    proposeBlockNumber: number;\n    disputeBlockNumber: number;\n    settleBlockNumber: number;\n    requestLogIndex: number;\n    proposeLogIndex: number;\n    disputeLogIndex: number;\n    settleLogIndex: number;\n  }>;\n\nexport interface EventState {\n  requests?: Record<string, Request>;\n}\n\nexport function requestId(request: Omit<RequestKey, \"timestamp\"> & { timestamp: BigNumberish }): string {\n  // if enabling sorting, put timestamp first\n  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join(\"!\");\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"RequestPrice\": {\n      const typedEvent = event as RequestPrice;\n      const { requester, identifier, timestamp, ancillaryData, currency, reward, finalFee } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        currency,\n        reward,\n        finalFee,\n        state: RequestState.Requested,\n        requestTx: event.transactionHash,\n        requestBlockNumber: event.blockNumber,\n        requestLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"ProposePrice\": {\n      const typedEvent = event as ProposePrice;\n      const {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        proposer,\n        proposedPrice,\n        expirationTimestamp,\n        currency,\n      } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        currency,\n        proposer,\n        proposedPrice,\n        expirationTime: expirationTimestamp,\n        state: RequestState.Proposed,\n        proposeTx: event.transactionHash,\n        proposeBlockNumber: event.blockNumber,\n        proposeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"DisputePrice\": {\n      const typedEvent = event as DisputePrice;\n      const { requester, identifier, timestamp, ancillaryData, proposer, disputer, proposedPrice } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        proposer,\n        disputer,\n        proposedPrice,\n        state: RequestState.Disputed,\n        disputeTx: event.transactionHash,\n        disputeBlockNumber: event.blockNumber,\n        disputeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"Settle\": {\n      const typedEvent = event as Settle;\n      const { requester, identifier, timestamp, ancillaryData, proposer, disputer, price, payout } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        requester,\n        proposer,\n        disputer,\n        price,\n        payout,\n        state: RequestState.Settled,\n        settleTx: event.transactionHash,\n        settleBlockNumber: event.blockNumber,\n        settleLogIndex: event.logIndex,\n      };\n      break;\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import {\n  SkinnyOptimisticOracleEthers,\n  SkinnyOptimisticOracleEthers__factory,\n  getSkinnyOptimisticOracleAbi,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event, BigNumberish, utils, BigNumber } from \"ethers\";\n\nexport type Instance = SkinnyOptimisticOracleEthers;\nconst Factory = SkinnyOptimisticOracleEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport const contractInterface = new utils.Interface(getSkinnyOptimisticOracleAbi());\n\nexport type RequestPrice = GetEventType<Instance, \"RequestPrice\">;\nexport type ProposePrice = GetEventType<Instance, \"ProposePrice\">;\nexport type DisputePrice = GetEventType<Instance, \"DisputePrice\">;\nexport type Settle = GetEventType<Instance, \"Settle\">;\n\nexport enum RequestState {\n  Invalid = 0, // Never requested.\n  Requested, // Requested, no other actions taken.\n  Proposed, // Proposed, but not expired or disputed yet.\n  Expired, // Proposed, not disputed, past liveness.\n  Disputed, // Disputed, but no DVM price returned yet.\n  Resolved, // Disputed and DVM price is available.\n  Settled, // Final price has been set in the contract (can get here from Expired or Resolved).\n}\n\nexport interface SolidityRequest {\n  proposer: string; // Address of the proposer.\n  disputer: string; // Address of the disputer.\n  currency: string; // ERC20 token used to pay rewards and fees.\n  settled: boolean; // True if the request is settled.\n  proposedPrice: BigNumber; // Price that the proposer submitted.\n  resolvedPrice: BigNumber; // Price resolved once the request is settled.\n  expirationTime: BigNumber; // Time at which the request auto-settles without a dispute.\n  reward: BigNumber; // Amount of the currency to pay to the proposer on settlement.\n  finalFee: BigNumber; // Final fee to pay to the Store upon request to the DVM.\n  bond: BigNumber; // Bond that the proposer and disputer must pay on top of the final fee.\n  customLiveness: BigNumber; // Custom liveness value set by the requester.\n}\n\n// all events have these values\nexport type RequestKey = {\n  requester: string;\n  identifier: string;\n  timestamp: number;\n  ancillaryData: string;\n};\nexport type Request = RequestKey &\n  SolidityRequest &\n  // this is partial since we dont know what events we have to populate parts of this\n  Partial<{\n    refundOnDispute: boolean;\n    state: RequestState;\n    // metadata about the transaction that triggered the state changes\n    requestTx: string;\n    proposeTx: string;\n    disputeTx: string;\n    settleTx: string;\n    requestBlockNumber: number;\n    proposeBlockNumber: number;\n    disputeBlockNumber: number;\n    settleBlockNumber: number;\n    requestLogIndex: number;\n    proposeLogIndex: number;\n    disputeLogIndex: number;\n    settleLogIndex: number;\n  }>;\n\nexport interface EventState {\n  requests?: Record<string, Request>;\n}\n\nexport function requestId(request: Omit<RequestKey, \"timestamp\"> & { timestamp: BigNumberish }): string {\n  // if enabling sorting, put timestamp first\n  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join(\"!\");\n}\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"RequestPrice\": {\n      const typedEvent = event as RequestPrice;\n      const { requester, identifier, timestamp, ancillaryData, request } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      state.requests[id] = {\n        // need to maintain previous state in case it exists\n        ...state.requests[id],\n        ...request,\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        state: RequestState.Requested,\n        requestTx: event.transactionHash,\n        requestBlockNumber: event.blockNumber,\n        requestLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"ProposePrice\": {\n      const typedEvent = event as ProposePrice;\n      const { requester, identifier, timestamp, ancillaryData, request } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      state.requests[id] = {\n        ...state.requests[id],\n        ...request,\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        state: RequestState.Proposed,\n        proposeTx: event.transactionHash,\n        proposeBlockNumber: event.blockNumber,\n        proposeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"DisputePrice\": {\n      const typedEvent = event as DisputePrice;\n      const { requester, identifier, timestamp, ancillaryData, request } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      state.requests[id] = {\n        ...state.requests[id],\n        ...request,\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        state: RequestState.Disputed,\n        disputeTx: event.transactionHash,\n        disputeBlockNumber: event.blockNumber,\n        disputeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"Settle\": {\n      const typedEvent = event as Settle;\n      const { requester, identifier, timestamp, ancillaryData, request } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      state.requests[id] = {\n        ...state.requests[id],\n        ...request,\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        state: RequestState.Settled,\n        settleTx: event.transactionHash,\n        settleBlockNumber: event.blockNumber,\n        settleLogIndex: event.logIndex,\n      };\n      break;\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import {\n  OptimisticOracleV2InterfaceEthers,\n  OptimisticOracleV2InterfaceEthers__factory,\n  getOptimisticOracleV2InterfaceAbi,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event, BigNumberish, utils, BigNumber } from \"ethers\";\n\nexport type Instance = OptimisticOracleV2InterfaceEthers;\nconst Factory = OptimisticOracleV2InterfaceEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport const contractInterface = new utils.Interface(getOptimisticOracleV2InterfaceAbi());\n\nexport type RequestPrice = GetEventType<Instance, \"RequestPrice\">;\nexport type ProposePrice = GetEventType<Instance, \"ProposePrice\">;\nexport type DisputePrice = GetEventType<Instance, \"DisputePrice\">;\nexport type Settle = GetEventType<Instance, \"Settle\">;\n\nexport enum RequestState {\n  Invalid = 0, // Never requested.\n  Requested, // Requested, no other actions taken.\n  Proposed, // Proposed, but not expired or disputed yet.\n  Expired, // Proposed, not disputed, past liveness.\n  Disputed, // Disputed, but no DVM price returned yet.\n  Resolved, // Disputed and DVM price is available.\n  Settled, // Final price has been set in the contract (can get here from Expired or Resolved).\n}\n\n// all events have these values\nexport type RequestKey = {\n  requester: string;\n  identifier: string;\n  timestamp: number;\n  ancillaryData: string;\n};\nexport type RequestSettings = {\n  eventBased: boolean; // True if the request is set to be event-based.\n  refundOnDispute: boolean; // True if the requester should be refunded their reward on dispute.\n  callbackOnPriceProposed: boolean; // True if callbackOnPriceProposed callback is required.\n  callbackOnPriceDisputed: boolean; // True if callbackOnPriceDisputed callback is required.\n  callbackOnPriceSettled: boolean; // True if callbackOnPriceSettled callback is required.\n  bond: BigNumber; // Bond that the proposer and disputer must pay on top of the final fee.\n  customLiveness: BigNumber; // Custom liveness value set by the requester.\n};\nexport type Request = RequestKey &\n  // this is partial since we dont know what events we have to populate parts of this\n  Partial<{\n    proposer: string;\n    disputer: string;\n    currency: string;\n    settled: boolean;\n    refundOnDispute: boolean;\n    proposedPrice: BigNumber;\n    resolvedPrice: BigNumber;\n    expirationTime: BigNumber;\n    reward: BigNumber;\n    finalFee: BigNumber;\n    price: BigNumber;\n    payout: BigNumber;\n    state: RequestState;\n    // metadata about the transaction that triggered the state changes\n    requestTx: string;\n    proposeTx: string;\n    disputeTx: string;\n    settleTx: string;\n    requestBlockNumber: number;\n    proposeBlockNumber: number;\n    disputeBlockNumber: number;\n    settleBlockNumber: number;\n    requestLogIndex: number;\n    proposeLogIndex: number;\n    disputeLogIndex: number;\n    settleLogIndex: number;\n    requestSettings: RequestSettings;\n  }>;\n\nexport interface EventState {\n  requests?: Record<string, Request>;\n}\n\nexport function requestId(request: Omit<RequestKey, \"timestamp\"> & { timestamp: BigNumberish }): string {\n  // if enabling sorting, put timestamp first\n  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join(\"!\");\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"RequestPrice\": {\n      const typedEvent = event as RequestPrice;\n      const { requester, identifier, timestamp, ancillaryData, currency, reward, finalFee } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        currency,\n        reward,\n        finalFee,\n        state: RequestState.Requested,\n        requestTx: event.transactionHash,\n        requestBlockNumber: event.blockNumber,\n        requestLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"ProposePrice\": {\n      const typedEvent = event as ProposePrice;\n      const {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        proposer,\n        proposedPrice,\n        expirationTimestamp,\n        currency,\n      } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        currency,\n        proposer,\n        proposedPrice,\n        expirationTime: expirationTimestamp,\n        state: RequestState.Proposed,\n        proposeTx: event.transactionHash,\n        proposeBlockNumber: event.blockNumber,\n        proposeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"DisputePrice\": {\n      const typedEvent = event as DisputePrice;\n      const { requester, identifier, timestamp, ancillaryData, proposer, disputer, proposedPrice } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        proposer,\n        disputer,\n        proposedPrice,\n        state: RequestState.Disputed,\n        disputeTx: event.transactionHash,\n        disputeBlockNumber: event.blockNumber,\n        disputeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"Settle\": {\n      const typedEvent = event as Settle;\n      const { requester, identifier, timestamp, ancillaryData, proposer, disputer, price, payout } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        requester,\n        proposer,\n        disputer,\n        price,\n        payout,\n        state: RequestState.Settled,\n        settleTx: event.transactionHash,\n        settleBlockNumber: event.blockNumber,\n        settleLogIndex: event.logIndex,\n      };\n      break;\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import type { Store } from \"../index\";\n\nexport default function <I, D>(map: Map<I, D> = new Map<I, D>()): Store<I, D> {\n  async function get(id: I) {\n    return map.get(id);\n  }\n  async function set(id: I, data: D) {\n    map.set(id, data);\n  }\n  async function has(id: I) {\n    return map.has(id);\n  }\n  async function del(id: I) {\n    map.delete(id);\n  }\n  async function entries() {\n    return Array.from(map.entries());\n  }\n  async function values() {\n    return Array.from(map.values());\n  }\n  async function keys() {\n    return Array.from(map.keys());\n  }\n  async function size() {\n    return map.size;\n  }\n  async function clear() {\n    map.clear();\n  }\n  return {\n    get,\n    set,\n    has,\n    delete: del,\n    entries,\n    values,\n    keys,\n    size,\n    clear,\n  };\n}\n","import { sortedIndex, sortedLastIndex } from \"lodash\";\nimport type { SortedStore } from \"../index\";\nimport { exists } from \"../../utils\";\n\n// this class will basically give you similar functionality to a sorted key value store this is really useful for\n// time series data, and JS does not have a native way to do this, but comes for free with most NoSql databases.\nexport default function <Id, Data>(): SortedStore<Id, Data> {\n  const ids: Id[] = [];\n  const map = new Map<Id, Data>();\n\n  function getStart(id: Id, inclusive = true) {\n    if (inclusive) {\n      return sortedIndex(ids, id);\n    } else {\n      return sortedLastIndex(ids, id);\n    }\n  }\n  function getEnd(id: Id, inclusive = false) {\n    return getStart(id, !inclusive);\n  }\n  function del(id: Id) {\n    const index = sortedIndex(ids, id);\n    ids.splice(index, 1);\n    const result = map.get(id);\n    map.delete(id);\n    return result;\n  }\n  // keeps typescript from complaining that return values may be undefined\n  function getSafe(id: Id) {\n    const result = map.get(id);\n    if (exists(result)) return result;\n    throw new Error(\"Missing data for index: \" + id);\n  }\n\n  return {\n    async has(id: Id) {\n      return map.has(id);\n    },\n    async set(id: Id, data: Data) {\n      if (map.has(id)) {\n        map.set(id, data);\n      } else {\n        const index = sortedIndex(ids, id);\n        ids.splice(index, 0, id);\n        map.set(id, data);\n      }\n    },\n    async get(id: Id) {\n      return map.get(id);\n    },\n    async values() {\n      return ids.map(getSafe);\n    },\n    async entries() {\n      return ids.map((id) => [id, getSafe(id)]);\n    },\n    async keys() {\n      return [...ids];\n    },\n    async clear() {\n      map.clear();\n      ids.length = 0;\n    },\n    async size() {\n      return ids.length;\n    },\n    async delete(id: Id) {\n      if (!map.has(id)) return;\n      del(id);\n    },\n    // assume [a,b)\n    async between(a: Id, b: Id) {\n      const start = getStart(a);\n      const end = getEnd(b);\n      return ids.slice(start, end).map(getSafe);\n    },\n    async slice(id: Id, length: number) {\n      const start = getStart(id);\n      return ids.slice(start, start + length).map(getSafe);\n    },\n  };\n}\n","import { exists } from \"../../utils\";\nimport type { SortedStore } from \"..\";\nimport { Datastore, Key } from \"@google-cloud/datastore\";\nimport highland from \"highland\";\n\n//-\n// Use an array, `excludeFromIndexes`, to exclude properties from indexing.\n// This will allow storing string values larger than 1500 bytes.\n// Example:\n// [\n//   'description',\n//   'embeddedEntity.description',\n//   'arrayValue[]',\n//   'arrayValue[].description'\n// ]\n//-\nexport default function <I extends string | number, D>(\n  kind: string,\n  store: Datastore,\n  excludeFromIndexes: string[] = []\n): SortedStore<I, D> {\n  function makeKey(id: I): Key {\n    return store.key([kind, id]);\n  }\n  // return value or undefined if it doesnt exist\n  async function get(id: I) {\n    try {\n      const [result] = await store.get(makeKey(id));\n      return result;\n    } catch (err) {\n      return;\n    }\n  }\n  async function set(id: I, data: D) {\n    await store.save({\n      key: makeKey(id),\n      data,\n      excludeFromIndexes,\n    });\n  }\n  async function has(id: I) {\n    // horribly ineficient to actually query data to see if it exists, but cannot find a better way\n    return exists(await get(id));\n  }\n  async function del(id: I) {\n    await store.delete(makeKey(id));\n  }\n  async function entries() {\n    const [results] = await store.createQuery(kind).run();\n    return results.map((result) => {\n      return [result[store.KEY].name, result];\n    }) as [I, D][];\n  }\n  async function values() {\n    const [results] = await store.createQuery(kind).run();\n    return results;\n  }\n  // all this does is map over full entries to return the id of the entry. have not found a better way to query this.\n  async function keys() {\n    const [results] = await store.createQuery(kind).select(\"__key__\").run();\n    return results.map((result) => {\n      return result[store.KEY].name;\n    }) as I[];\n  }\n  // theres no way to really do built into the store client. Google recommends managing a size entry yourself.\n  async function size(): Promise<number> {\n    throw new Error(\"size not supported in google store\");\n  }\n  // this actually queries all values, then batches them to delete N at a time. This is a horrible way\n  // to do this, but I could not find a better way to \"drop\" all kinds from the table.\n  async function clear() {\n    await highland(store.createQuery(kind).runStream())\n      .map((val: any) => {\n        return val[store.KEY];\n      })\n      .batch(500)\n      .map(async (keys) => {\n        return store.delete(keys);\n      })\n      .flatMap(highland)\n      .collect()\n      .toPromise(Promise);\n  }\n  async function slice(id: I, length: number) {\n    const [result] = await store.createQuery(kind).filter(\"__key__\", \">=\", makeKey(id)).limit(length).run();\n    return result;\n  }\n  async function between(a: I, b: I) {\n    const [result] = await store\n      .createQuery(kind)\n      .filter(\"__key__\", \">=\", makeKey(a))\n      .filter(\"__key__\", \"<\", makeKey(b))\n      .run();\n    return result;\n  }\n\n  return {\n    get,\n    set,\n    has,\n    delete: del,\n    entries,\n    values,\n    keys,\n    size,\n    clear,\n    between,\n    slice,\n  };\n}\n","import assert from \"assert\";\nimport { exists } from \"../../utils\";\nimport type { stores, MakeId, MaybeId, HasId } from \"../..\";\n\n// This interface has to be implemented manually in order to have control over the types of the \"overloaded\" functions\ninterface KnownReturnMembers<I, D> {\n  create: (data: D & MaybeId<I>) => Promise<D & HasId<I>>;\n  set: (data: D & HasId<I>) => Promise<D & HasId<I>>;\n  get: (id: I) => Promise<D & { id: I }>;\n  has: (id: I) => Promise<boolean>;\n  update: (id: I, data: Partial<D>) => Promise<D & HasId<I>>;\n}\n\n// The final type composes the types defined explicitly and those from the implemented interface\ntype TableReturnType<I, D, S> = KnownReturnMembers<I, D> & Omit<S, keyof KnownReturnMembers<I, D>>;\n\nexport default function Table<I, D, S extends stores.Store<I, D>>(\n  config: { makeId: MakeId<I, D>; type: string },\n  store: S\n): TableReturnType<I, D, S> {\n  const { makeId, type } = config;\n  async function create(data: D & MaybeId<I>) {\n    const id = exists(data.id) ? data.id : makeId(data);\n    assert(!(await has(id)), `${type} exists: ` + id);\n    return set({ id, ...data });\n  }\n  async function set(data: D & HasId<I>) {\n    await store.set(data.id, { ...data });\n    return data;\n  }\n  async function get(id: I) {\n    assert(await store.has(id), `${type} does not exist`);\n    return ((await store.get(id)) as unknown) as D & { id: I };\n  }\n  async function has(id: I) {\n    return store.has(id);\n  }\n  async function update(id: I, data: Partial<D>) {\n    const got = await get(id);\n    return set({ ...got, ...data });\n  }\n  return {\n    ...store,\n    create,\n    set,\n    get,\n    has,\n    update,\n    makeId,\n    type,\n  };\n}\n","export function makeId(data: Pick<Data, \"number\">) {\n  return data.number;\n}\n\nexport type Data = {\n  id?: number;\n  number: number;\n  hash: string;\n  // block time is in seconds\n  timestamp: number;\n};\n","export function makeId(data: Pick<Data, \"address\">) {\n  return data.address;\n}\n\nexport type Data = {\n  id?: string;\n  name?: string | null;\n  address: string;\n  priceIdentifier?: string | null;\n  expirationTimestamp?: string | null;\n  withdrawalLiveness?: string | null;\n  tokenCurrency?: string | null;\n  collateralCurrency?: string | null;\n  collateralRequirement?: string | null;\n  disputeBondPercentage?: string | null;\n  sponsorDisputeRewardPercentage?: string | null;\n  disputerDisputeRewardPercentage?: string | null;\n  cumulativeFeeMultiplier?: string | null;\n  tokenDecimals?: number | null;\n  collateralDecimals?: number | null;\n  totalTokensOutstanding?: string | null;\n  totalPositionCollateral?: string | null;\n  minSponsorTokens?: string | null;\n  expiryPrice?: string | null;\n  sponsors?: string[] | null;\n  gcr?: string | null;\n  expired?: boolean | null;\n  createdTimestamp?: number | null;\n};\n","export function makeId(data: Pick<Data, \"timestamp\">) {\n  return data.timestamp.toString().padStart(24, \"0\");\n}\n\nexport type Data = {\n  id?: string;\n  timestamp: number;\n  price: string;\n};\n","export function makeId(data: Pick<Data, \"address\">) {\n  return data.address;\n}\n\nexport type Data = {\n  id?: string;\n  address: string;\n  decimals?: number;\n  name?: string;\n  totalSupply?: string;\n  symbol?: string;\n};\n","import { Data, makeId } from \"./utils\";\nimport BaseTable from \"../base\";\nimport { JsMap } from \"../../stores\";\nimport type { Store } from \"../../stores\";\n\n// personally dont like to have this as a named export, but cannot export both function and type as default\nexport const Table = (type = \"Block\", store: Store<number, Data> = JsMap<number, Data>()) => {\n  const table = BaseTable<number, Data, Store<number, Data>>({ type, makeId }, store);\n\n  // delete blocks older than timestamp\n  async function prune(timestamp: number) {\n    const blocks = await table.values();\n    const deleted: Data[] = [];\n    // normally would use a map or filter, but dont want to include bluebird as a dependency\n    for (const block of blocks) {\n      if (block.timestamp < timestamp) {\n        await table.delete(block.id ?? block.number);\n        deleted.push(block);\n      }\n    }\n    return deleted;\n  }\n\n  return {\n    ...table,\n    prune,\n  };\n};\nexport type Table = ReturnType<typeof Table>;\n","import { Data, makeId } from \"./utils\";\nimport BaseTable from \"../base\";\nimport type { Store } from \"../../stores\";\nimport { JsMap } from \"../../stores\";\n\nexport const Table = (type = \"Emp\", store: Store<string, Data> = JsMap()) => {\n  const table = BaseTable<string, Data, Store<string, Data>>({ type, makeId }, store);\n\n  async function addSponsors(id: string, sponsors: string[]) {\n    const data = await table.get(id);\n    // keep sponsors unique\n    const set = new Set([...(data.sponsors || []), ...sponsors]);\n    return table.update(id, { sponsors: Array.from(set.values()) });\n  }\n\n  async function setCreatedTimestamp(id: string, timestamp: number) {\n    return table.update(id, { createdTimestamp: timestamp });\n  }\n\n  return {\n    ...table,\n    addSponsors,\n    setCreatedTimestamp,\n  };\n};\n// want to export the type as the same name\nexport type Table = ReturnType<typeof Table>;\n","import { Data, makeId } from \"./utils\";\nimport BaseTable from \"../base\";\nimport { SortedJsMap } from \"../../stores\";\nimport type { SortedStore } from \"../../stores\";\n\nexport const Table = (type = \"Historical Price\", store: SortedStore<string, Data> = SortedJsMap()) => {\n  const table = BaseTable<string, Data, SortedStore<string, Data>>({ type, makeId }, store);\n  function betweenByTimestamp(a: number, b: number) {\n    return table.between(makeId({ timestamp: a }), makeId({ timestamp: b }));\n  }\n  function sliceByTimestamp(timestamp: number, length: number) {\n    return table.slice(makeId({ timestamp }), length);\n  }\n  function hasByTimestamp(timestamp: number) {\n    return table.has(makeId({ timestamp }));\n  }\n  function getByTimestamp(timestamp: number) {\n    return table.get(makeId({ timestamp }));\n  }\n  return {\n    ...table,\n    betweenByTimestamp,\n    sliceByTimestamp,\n    hasByTimestamp,\n    getByTimestamp,\n  };\n};\nexport type Table = ReturnType<typeof Table>;\n","import { Data, makeId } from \"./utils\";\nimport BaseTable from \"../base\";\nimport { JsMap } from \"../../stores\";\nimport type { Store } from \"../../stores\";\n\nexport const Table = (type = \"Token\", store: Store<string, Data> = JsMap()) => {\n  const table = BaseTable<string, Data, Store<string, Data>>({ type, makeId }, store);\n  async function getOrCreate(address: string) {\n    if (!(await table.has(makeId({ address })))) return table.create({ address });\n    return table.get(makeId({ address }));\n  }\n  async function upsert(address: string, data: Partial<Data>) {\n    await getOrCreate(address);\n    return table.update(address, data);\n  }\n  return {\n    ...table,\n    getOrCreate,\n    upsert,\n  };\n};\nexport type Table = ReturnType<typeof Table>;\n","import { BigNumber, ethers } from \"ethers\";\nimport { ConvertDecimals } from \"../utils\";\nimport Decimal from \"decimal.js\";\n\nexport type BigNumberish = string | number | BigNumber;\nexport type BN = BigNumber;\nexport type Decimalish = string | number | Decimal;\n\n/**\n * toBN.\n *\n * @param {BigNumberish} num\n * @returns {BN}\n */\nexport const toBN = (num: BigNumberish): BN => BigNumber.from(num.toString());\n/**\n * toBNWei.\n *\n * @param {BigNumberish} num\n * @param {number} decimals\n * @returns {BN}\n */\nexport const toBNWei = (num: BigNumberish, decimals?: number): BN => ethers.utils.parseUnits(num.toString(), decimals);\n/**\n * toWei.\n *\n * @param {BigNumberish} num\n * @param {number} decimals\n * @returns {string}\n */\nexport const toWei = (num: BigNumberish, decimals?: number): string => toBNWei(num, decimals).toString();\n/**\n * fromWei.\n *\n * @param {BigNumberish} num\n * @param {number} decimals\n * @returns {string}\n */\nexport const fromWei = (num: BigNumberish, decimals?: number): string =>\n  ethers.utils.formatUnits(num.toString(), decimals);\n\n/**\n * min.\n *\n * @param {BigNumberish} a\n * @param {BigNumberish} b\n * @returns {BN}\n */\nexport function min(a: BigNumberish, b: BigNumberish): BN {\n  const bna = toBN(a);\n  const bnb = toBN(b);\n  return bna.lte(bnb) ? bna : bnb;\n}\n/**\n * max.\n *\n * @param {BigNumberish} a\n * @param {BigNumberish} b\n * @returns {BN}\n */\nexport function max(a: BigNumberish, b: BigNumberish): BN {\n  const bna = toBN(a);\n  const bnb = toBN(b);\n  return bna.gte(bnb) ? bna : bnb;\n}\n\nexport const fixedPointAdjustment = toBNWei(\"1\");\n\n/**\n * Convert an amount of eth into a token given price and token decimals.\n *\n * @param {BigNumberish} fromAmount - Amount of eth to convert.\n * @param {string | number} [ price=1 ] - The price as eth per token, ie how much eth can 1 token buy.\n * @param {} [ toDecimals=18 ] - Number of decimals for the token currency.\n * @returns {string} The number of tokens denominated in token decimals in the smallest unit (wei).\n */\nexport function ethToToken(fromAmount: BigNumberish, price: string | number = 1, toDecimals = 18): string {\n  const priceWei = toBNWei(price);\n  const toAmount = toBNWei(fromAmount).div(priceWei);\n  return ConvertDecimals(18, toDecimals)(toAmount);\n}\n\n/**\n * Convert a gas amount and gas price to wei.\n *\n * @param {number} gas - gas amount.\n * @param {BigNumberish} gasPrice - gas price in gwei.\n * @returns {BigNumber} - total fees in wei.\n */\nexport const gasToEth = (gas: number, gasPrice: BigNumberish): BigNumber => {\n  return BigNumber.from(gas).mul(gasPrice);\n};\n\n/**\n * getGasFees. Low level pure function call to calculate gas fees.\n *\n * @param {number} gas - The gast cost for transfer, use constants defined in file.\n * @param {BigNumberish} gasPrice - Estimated gas price in wei.\n * @param {string | number} [price = 1] - The price of the token in eth, how much eth can 1 token buy.\n * @param {number} [decimals=18] - Number of decimals of token.\n * @returns {string} - The value of fees native to the token/eth provided, in its smallest unit.\n */\nexport function calculateGasFees(\n  gas: number,\n  gasPrice: BigNumberish,\n  price: string | number = 1,\n  decimals = 18\n): string {\n  const amountEth = gasToEth(gas, gasPrice);\n  return ethToToken(amountEth, price, decimals);\n}\n\n/**\n * percent.\n *\n * @param {BigNumberish} numerator\n * @param {BigNumberish} denominator\n * @returns {BN}\n */\nexport function percent(numerator: BigNumberish, denominator: BigNumberish): BN {\n  return fixedPointAdjustment.mul(numerator).div(denominator);\n}\n\n/**\n * calcContinuousCompoundInterest. From https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=0&t=1&given_data_last=find_r&action=solve\n * Returns a yearly interest rate if start/end amount had been continuously compounded over the period elapsed. Multiply result by 100 for a %.\n *\n * @param {string} startAmount\n * @param {string} endAmount\n * @param {string} periodsElapsed\n * @param {string} periodsPerYear\n */\nexport const calcContinuousCompoundInterest = (\n  startAmount: Decimalish,\n  endAmount: Decimalish,\n  periodsElapsed: Decimalish,\n  periodsPerYear: Decimalish\n): string => {\n  const years = new Decimal(periodsPerYear).div(periodsElapsed);\n  return new Decimal(endAmount).div(startAmount).ln().div(years).toString();\n};\n/**\n * calcPeriodicCompoundInterest. Taken from https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=365&t=1&given_data_last=find_r&action=solve\n * This will return a periodically compounded interest rate for 1 year. Multiply result by 100 for a %.\n *\n * @param {string} startAmount - Starting amount or price\n * @param {string} endAmount - Ending amount or price\n * @param {string} periodsElapsed - How many periods elapsed for the start and end amount.\n * @param {string} periodsPerYear - How many periods in 1 year.\n */\nexport const calcPeriodicCompoundInterest = (\n  startAmount: Decimalish,\n  endAmount: Decimalish,\n  periodsElapsed: Decimalish,\n  periodsPerYear: Decimalish\n): string => {\n  const n = new Decimal(periodsPerYear);\n  const A = new Decimal(endAmount);\n  const P = new Decimal(startAmount);\n  const t = new Decimal(periodsPerYear).div(periodsElapsed);\n  const one = new Decimal(1);\n  return n\n    .mul(\n      A.div(P)\n        .pow(one.div(n.div(t)))\n        .sub(one)\n    )\n    .toString();\n};\n\n/**\n * calcApr. Simple apr calculation based on extrapolating the difference for a short period over a year.\n *\n * @param {Decimalish} startAmount - Starting amount or price\n * @param {Decimalish} endAmount - Ending amount or price\n * @param {Decimalish} periodsElapsed - periods elapsed from start to end\n * @param {Decimalish} periodsPerYear - periods per year\n */\nexport const calcApr = (\n  startAmount: Decimalish,\n  endAmount: Decimalish,\n  periodsElapsed: Decimalish,\n  periodsPerYear: Decimalish\n): string => {\n  return new Decimal(endAmount).sub(startAmount).div(startAmount).mul(periodsPerYear).div(periodsElapsed).toString();\n};\n","// This Util calculates the across realized LP fees. See https://gist.github.com/chrismaree/a713725e4fe96c531c42ed7b629d4a85\n// gist for a python implementation of the logic in this file. This implementation is designed to work with both web3.js\n// and ethers BNs in the main entry point function calculateRealizedLpFeePct.\n\nimport Decimal from \"decimal.js\";\nimport { BigNumberish, BN, toBN, toBNWei, fromWei, min, max, fixedPointAdjustment } from \"./utils\";\n\n// note a similar type exists in the constants file, but are strings only. This is a bit more permissive to allow\n// backward compatibility for callers with a rate model defined with bignumbers and not strings.\nexport interface RateModel {\n  UBar: BigNumberish; // denote the utilization kink along the rate model where the slope of the interest rate model changes.\n  R0: BigNumberish; // is the interest rate charged at 0 utilization\n  R1: BigNumberish; // R_0+R_1 is the interest rate charged at UBar\n  R2: BigNumberish; // R_0+R_1+R_2 is the interest rate charged at 100% utilization\n}\n\n// Calculate the rate for a 0 sized deposit (infinitesimally small).\nexport function calculateInstantaneousRate(rateModel: RateModel, utilization: BigNumberish) {\n  const beforeKink = min(utilization, rateModel.UBar).mul(rateModel.R1).div(rateModel.UBar);\n  const afterKink = max(toBN(\"0\"), toBN(utilization).sub(rateModel.UBar))\n    .mul(rateModel.R2)\n    .div(toBNWei(\"1\").sub(rateModel.UBar));\n\n  return toBN(rateModel.R0).add(beforeKink).add(afterKink);\n}\n\n//  Compute area under curve of the piece-wise linear rate model.\nfunction calculateAreaUnderRateCurve(rateModel: RateModel, utilization: BN) {\n  // Area under first piecewise component\n  const utilizationBeforeKink = min(utilization, rateModel.UBar);\n  const rectangle1Area = utilizationBeforeKink.mul(rateModel.R0).div(fixedPointAdjustment);\n  const triangle1Area = toBNWei(\"0.5\")\n    .mul(calculateInstantaneousRate(rateModel, utilizationBeforeKink).sub(rateModel.R0))\n    .mul(utilizationBeforeKink)\n    .div(fixedPointAdjustment)\n    .div(fixedPointAdjustment);\n\n  // Area under second piecewise component\n  const utilizationAfter = max(toBN(\"0\"), utilization.sub(rateModel.UBar));\n  const rectangle2Area = utilizationAfter.mul(toBN(rateModel.R0).add(rateModel.R1)).div(fixedPointAdjustment);\n  const triangle2Area = toBNWei(\"0.5\")\n    .mul(calculateInstantaneousRate(rateModel, utilization).sub(toBN(rateModel.R0).add(rateModel.R1)))\n    .mul(utilizationAfter)\n    .div(fixedPointAdjustment)\n    .div(fixedPointAdjustment);\n\n  return rectangle1Area.add(triangle1Area).add(rectangle2Area).add(triangle2Area);\n}\n\n// converts an APY rate to a one week rate. Uses the Decimal library to take a fractional exponent\nfunction convertApyToWeeklyFee(apy: BN) {\n  // R_week = (1 + apy)^(1/52) - 1\n  const weeklyFeePct = Decimal.pow(\n    new Decimal(\"1\").plus(fromWei(apy)),\n    new Decimal(\"1\").dividedBy(new Decimal(\"52\"))\n  ).minus(new Decimal(\"1\"));\n\n  // Convert from decimal back to BN, scaled by 1e18.\n  return toBN(weeklyFeePct.times(fixedPointAdjustment.toString()).floor().toString());\n}\n\n// Calculate the realized yearly LP Fee APY Percent for a given rate model, utilization before and after the deposit.\nexport function calculateApyFromUtilization(\n  rateModel: RateModel,\n  utilizationBeforeDeposit: BN,\n  utilizationAfterDeposit: BN\n) {\n  if (utilizationBeforeDeposit.eq(utilizationAfterDeposit)) throw new Error(\"Deposit cant have zero size\");\n\n  // Get the area of [0, utilizationBeforeDeposit] and [0, utilizationAfterDeposit]\n  const areaBeforeDeposit = calculateAreaUnderRateCurve(rateModel, utilizationBeforeDeposit);\n  const areaAfterDeposit = calculateAreaUnderRateCurve(rateModel, utilizationAfterDeposit);\n\n  const numerator = areaAfterDeposit.sub(areaBeforeDeposit);\n  const denominator = utilizationAfterDeposit.sub(utilizationBeforeDeposit);\n  return numerator.mul(fixedPointAdjustment).div(denominator);\n}\n\nexport function calculateRealizedLpFeePct(\n  rateModel: RateModel,\n  utilizationBeforeDeposit: BigNumberish,\n  utilizationAfterDeposit: BigNumberish\n) {\n  const apy = calculateApyFromUtilization(rateModel, toBN(utilizationBeforeDeposit), toBN(utilizationAfterDeposit));\n  return convertApyToWeeklyFee(apy);\n}\n","import { ethers } from \"ethers\";\n// these gas costs are estimations, its possible to provide better estimations yourself when invoking getGasFees.\nexport const SLOW_ETH_GAS = 243177;\nexport const SLOW_ERC_GAS = 250939;\nexport const SLOW_UMA_GAS = 273955;\n\n// fast costs are slightly higher and include the slow cost\nexport const FAST_ETH_GAS = 273519;\nexport const FAST_ERC_GAS = 281242;\nexport const FAST_UMA_GAS = 305572;\n\nexport const SPEED_UP_ETH_GAS = 195288;\nexport const SPEED_UP_ERC_GAS = 203011;\nexport const SPEED_UP_UMA_GAS = 227341;\n\n// Bots incur lower than expected costs due to batching mulitple transactions, this roughly estimates the savings\nexport const DEFAULT_GAS_DISCOUNT = 25;\n\nexport const expectedRateModelKeys = [\"UBar\", \"R0\", \"R1\", \"R2\"];\n\n// Amount of blocks to wait following a `TokensBridged` L2 event until we check the L1 state commitment contracts. This\n// offset provides a buffer to allow for any time delay between L2 state changing and L1 state updating. For example,\n// Optimism has a several hour delay.\nexport const L2_STATE_COMMITMENT_DELAY_BLOCKS = 25000;\n\nexport interface RateModel {\n  UBar: string; // denote the utilization kink along the rate model where the slope of the interest rate model changes.\n  R0: string; // is the interest rate charged at 0 utilization\n  R1: string; // R_0+R_1 is the interest rate charged at UBar\n  R2: string; // R_0+R_1+R_2 is the interest rate charged at 100% utilization\n}\n\nexport const AddressZero = ethers.constants.AddressZero;\n// mainnet addresses, hard coded here for convenience, but theres probably a better pattern for this\nexport const ADDRESSES = {\n  ETH: AddressZero,\n  UMA: \"0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828\",\n  WETH: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n  USDC: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n  RateModel: \"0xd18fFeb5fdd1F2e122251eA7Bf357D8Af0B60B50\",\n};\n\nexport const SECONDS_PER_YEAR = 31557600; // based on 365.25 days per year\nexport const DEFAULT_BLOCK_DELTA = 10; // look exchange rate up based on 10 block difference by default\n","import { expectedRateModelKeys, RateModel } from \"./constants\";\nimport { exists } from \"../utils\";\nimport { ethers } from \"ethers\";\n\n// Each L1 token is mapped to an array of stringified rate models, ordered by the block height at which they were\n// published on-chain. This dictionary is used internally to fetch a rate model for a block height.\ntype RateModelEventsDictionary = {\n  [l1TokenAddress: string]: { blockNumber: number; rateModel: string }[];\n};\n\n// Events should be reformatted into this shape to be used as input into methods in this file.\nexport type RateModelEvent = {\n  blockNumber: number;\n  transactionIndex: number;\n  logIndex: number;\n  rateModel: string;\n  l1Token: string;\n};\n\nexport class RateModelDictionary {\n  public rateModelDictionary: RateModelEventsDictionary = {};\n\n  private _throwIfNotInitialized() {\n    if (Object.keys(this.rateModelDictionary).length == 0)\n      throw new Error(\"RateModelUtility method called before updating rate model dictionary!\");\n  }\n\n  updateWithEvents(rateModelEvents: RateModelEvent[]): void {\n    this.rateModelDictionary = createRateModelEventDictionary(rateModelEvents);\n  }\n\n  /**\n   * Return the rate model for L1 token set at the block height.\n   * @param l1Token L1 token address to get rate model for.\n   * @param blockNumber Block height to get rate model for.\n   * @returns Rate model object.\n   */\n  getRateModelForBlockNumber(l1Token: string, blockNumber?: number): RateModel {\n    this._throwIfNotInitialized();\n\n    const l1TokenNormalized = ethers.utils.getAddress(l1Token);\n\n    if (!this.rateModelDictionary[l1TokenNormalized] || this.rateModelDictionary[l1TokenNormalized].length === 0)\n      throw new Error(`No updated rate model events for L1 token: ${l1TokenNormalized}`);\n\n    if (!blockNumber) {\n      // If block number is undefined, use latest updated rate model.\n      return parseAndReturnRateModelFromString(this.rateModelDictionary[l1TokenNormalized].slice(-1)[0].rateModel);\n    } else {\n      const firstEventBlockNumber = this.rateModelDictionary[l1TokenNormalized][0].blockNumber;\n      if (blockNumber < firstEventBlockNumber) {\n        throw new Error(\n          `Block number #${blockNumber} is before first UpdatedRateModel event block ${firstEventBlockNumber}`\n        );\n      }\n\n      // We're looking for the latest rate model update that occurred at or before the block number.\n      // Rate model events are inserted into the array from oldest at index 0 to newest at index length-1, so we'll\n      // reverse the array so it goes from newest at index 0 to oldest at index length-1, and then find the first event\n      // who's block number is less than or equal to the target block number.\n      const rateModel = this.rateModelDictionary[l1TokenNormalized]\n        .slice()\n        .reverse() // reverse() modifies memory in place so create a copy first.\n        .find((event) => event.blockNumber <= blockNumber);\n\n      if (!rateModel)\n        throw new Error(`No updated rate model events before block #${blockNumber} for L1 token: ${l1TokenNormalized}`);\n      return parseAndReturnRateModelFromString(rateModel?.rateModel);\n    }\n  }\n\n  /**\n   * @notice Return all L1 tokens that had a rate model associated with it at the block number.\n   * @param blockNumber Returns l1 tokens that were mapped to a rate model at this block height. If undefined,\n   * this function will return all L1 tokens that have a block number as of the latest block height.\n   * @returns array of L1 token addresses.\n   */\n  getL1TokensFromRateModel(blockNumber: number | undefined = undefined): string[] {\n    this._throwIfNotInitialized();\n\n    return Object.keys(this.rateModelDictionary)\n      .map((l1Token) => {\n        const l1TokenNormalized = ethers.utils.getAddress(l1Token);\n\n        // Check that there is at least one UpdatedRateModel event before the provided block number, otherwise\n        // this L1 token didn't exist in the RateModel at the block height and we shouldn't include it in the returned\n        // array.\n        if (\n          !blockNumber ||\n          this.rateModelDictionary[l1TokenNormalized].find((event) => event.blockNumber <= blockNumber)\n        )\n          return ethers.utils.getAddress(l1Token);\n        else return null;\n      })\n      .filter(exists);\n  }\n}\n/**\n * Helper method that returns parsed rate model from string, or throws.\n * @param rateModelString Stringified rate model to parse.\n * @returns Rate model object. Must conform to `expectedRateModelKeys` format.\n */\n\nexport const parseAndReturnRateModelFromString = (rateModelString: string): RateModel => {\n  const rateModelFromEvent = JSON.parse(rateModelString);\n\n  // Rate model must contain the exact same keys in `expectedRateModelKeys`.\n  for (const key of expectedRateModelKeys) {\n    if (!Object.keys(rateModelFromEvent).includes(key)) {\n      throw new Error(\n        `Rate model does not contain all expected keys. Expected keys: [${expectedRateModelKeys}], actual keys: [${Object.keys(\n          rateModelFromEvent\n        )}]`\n      );\n    }\n  }\n  for (const key of Object.keys(rateModelFromEvent)) {\n    if (!expectedRateModelKeys.includes(key)) {\n      throw new Error(\n        `Rate model contains unexpected keys. Expected keys: [${expectedRateModelKeys}], actual keys: [${Object.keys(\n          rateModelFromEvent\n        )}]`\n      );\n    }\n  }\n\n  return {\n    UBar: rateModelFromEvent.UBar,\n    R0: rateModelFromEvent.R0,\n    R1: rateModelFromEvent.R1,\n    R2: rateModelFromEvent.R2,\n  };\n};\n\n/**\n * Given an unsorted array of updated rate model events, return a dictionary mapping token addresses to sorted\n * rate model events. This method is used internally to enforce chronological sorting of events and mapping rate models\n * to token addresses.\n * @param rateModelEvents Unsorted updated rate model events, each of which contains a token address, the stringified\n * rate model for that token, and the block height of the update.\n * @returns Dictionary mapping token addresses to chronologically sorted rate model updates.\n */\nconst createRateModelEventDictionary = (rateModelEvents: RateModelEvent[]): RateModelEventsDictionary => {\n  const updatedRateModelEventsForToken: RateModelEventsDictionary = {};\n\n  // Sort events in-place from oldest to newest:\n  rateModelEvents.sort((a, b) => {\n    if (a.blockNumber !== b.blockNumber) {\n      return a.blockNumber - b.blockNumber;\n    }\n\n    if (a.transactionIndex !== b.transactionIndex) {\n      return a.transactionIndex - b.transactionIndex;\n    }\n\n    return a.logIndex - b.logIndex;\n  });\n\n  for (const updatedRateModelEvent of rateModelEvents) {\n    // The contract enforces that all rate models are mapped to addresses, therefore we do not need to check that\n    // `l1Token` is a valid address.\n    const l1TokenNormalized = ethers.utils.getAddress(updatedRateModelEvent.l1Token);\n    if (!updatedRateModelEventsForToken[l1TokenNormalized]) updatedRateModelEventsForToken[l1TokenNormalized] = [];\n\n    // We assume that events are returned from oldest to newest, so we can simply push events into the array and\n    // and maintain their time order.\n    updatedRateModelEventsForToken[l1TokenNormalized].push({\n      blockNumber: updatedRateModelEvent.blockNumber,\n      rateModel: updatedRateModelEvent.rateModel,\n    });\n  }\n\n  return updatedRateModelEventsForToken;\n};\n","import assert from \"assert\";\nimport sortedIndexBy from \"lodash/sortedIndexBy\";\nimport clamp from \"lodash/clamp\";\nimport { estimateBlocksElapsed } from \"./utils\";\n\nexport type WithoutStringTimestamp<T extends { timestamp: number | string }> = T & { timestamp: number };\n\nexport default class BlockFinder<T extends { number: number; timestamp: number | string }> {\n  constructor(\n    private readonly requestBlock: (requestedBlock: string | number) => Promise<T>,\n    private readonly blocks: T[] = [],\n    private readonly chainId: number = 1\n  ) {\n    assert(requestBlock, \"requestBlock function must be provided\");\n  }\n\n  /**\n   * @notice Gets the latest block whose timestamp is <= the provided timestamp.\n   * @param {number} timestamp timestamp to search.\n   */\n  public async getBlockForTimestamp(timestamp: number | string): Promise<T> {\n    timestamp = Number(timestamp);\n    assert(timestamp !== undefined && timestamp !== null, \"timestamp must be provided\");\n    // If the last block we have stored is too early, grab the latest block.\n    if (this.blocks.length === 0 || this.blocks[this.blocks.length - 1].timestamp < timestamp) {\n      const block = await this.getLatestBlock();\n      if (timestamp >= block.timestamp) return block;\n    }\n\n    // Check the first block. If it's greater than our timestamp, we need to find an earlier block.\n    if (this.blocks[0].timestamp > timestamp) {\n      const initialBlock = this.blocks[0] as WithoutStringTimestamp<T>;\n      // We use a 2x cushion to reduce the number of iterations in the following loop and increase the chance\n      // that the first block we find sets a floor for the target timestamp. The loop converges on the correct block\n      // slower than the following incremental search performed by `findBlock`, so we want to minimize the number of\n      // loop iterations in favor of searching more blocks over the `findBlock` search.\n      const cushion = 1;\n      const incrementDistance = Math.max(\n        // Ensure the increment block distance is _at least_ a single block to prevent an infinite loop.\n        await estimateBlocksElapsed(initialBlock.timestamp - timestamp, cushion, this.chainId),\n        1\n      );\n\n      // Search backwards by a constant increment until we find a block before the timestamp or hit block 0.\n      for (let multiplier = 1; ; multiplier++) {\n        const distance = multiplier * incrementDistance;\n        const blockNumber = Math.max(0, initialBlock.number - distance);\n        const block = await this.getBlock(blockNumber);\n        if (block.timestamp <= timestamp) break; // Found an earlier block.\n        assert(blockNumber > 0, \"timestamp is before block 0\"); // Block 0 was not earlier than this timestamp. The row.\n      }\n    }\n\n    // Find the index where the block would be inserted and use that as the end block (since it is >= the timestamp).\n    const index = sortedIndexBy(this.blocks, { timestamp } as T, \"timestamp\");\n    return this.findBlock(this.blocks[index - 1], this.blocks[index], timestamp);\n  }\n\n  // Grabs the most recent block and caches it.\n  private async getLatestBlock() {\n    const block = await this.requestBlock(\"latest\");\n    const index = sortedIndexBy(this.blocks, block, \"number\");\n    if (this.blocks[index]?.number !== block.number) this.blocks.splice(index, 0, block);\n    return this.blocks[index];\n  }\n\n  // Grabs the block for a particular number and caches it.\n  private async getBlock(number: number) {\n    let index = sortedIndexBy(this.blocks, { number } as T, \"number\");\n    if (this.blocks[index]?.number === number) return this.blocks[index]; // Return early if block already exists.\n    const block = await this.requestBlock(number);\n\n    // Recompute the index after the async call since the state of this.blocks could have changed!\n    index = sortedIndexBy(this.blocks, { number } as T, \"number\");\n\n    // Rerun this check to avoid duplicate insertion.\n    if (this.blocks[index]?.number === number) return this.blocks[index];\n    this.blocks.splice(index, 0, block); // A simple insert at index.\n    return block;\n  }\n\n  // Return the latest block, between startBlock and endBlock, whose timestamp is <= timestamp.\n  // Effectively, this is an interpolation search algorithm to minimize block requests.\n  // Note: startBlock and endBlock _must_ be different blocks.\n  private async findBlock(_startBlock: T, _endBlock: T, timestamp: number): Promise<T> {\n    const [startBlock, endBlock] = [_startBlock, _endBlock] as WithoutStringTimestamp<T>[];\n    // In the case of equality, the endBlock is expected to be passed as the one whose timestamp === the requested\n    // timestamp.\n    if (endBlock.timestamp === timestamp) return endBlock;\n\n    // If there's no equality, but the blocks are adjacent, return the startBlock, since we want the returned block's\n    // timestamp to be <= the requested timestamp.\n    if (endBlock.number === startBlock.number + 1) return startBlock;\n\n    assert(endBlock.number !== startBlock.number, \"startBlock cannot equal endBlock\");\n    assert(\n      timestamp < endBlock.timestamp && timestamp > startBlock.timestamp,\n      \"timestamp not in between start and end blocks\"\n    );\n\n    // Interpolating the timestamp we're searching for to block numbers.\n    const totalTimeDifference = endBlock.timestamp - startBlock.timestamp;\n    const totalBlockDistance = endBlock.number - startBlock.number;\n    const blockPercentile = (timestamp - startBlock.timestamp) / totalTimeDifference;\n    const estimatedBlock = startBlock.number + Math.round(blockPercentile * totalBlockDistance);\n\n    // Clamp ensures the estimated block is strictly greater than the start block and strictly less than the end block.\n    const newBlock = await this.getBlock(clamp(estimatedBlock, startBlock.number + 1, endBlock.number - 1));\n\n    // Depending on whether the new block is below or above the timestamp, narrow the search space accordingly.\n    if (newBlock.timestamp < timestamp) {\n      return this.findBlock(newBlock, endBlock, timestamp);\n    } else {\n      return this.findBlock(startBlock, newBlock, timestamp);\n    }\n  }\n}\n","import axios from \"axios\";\nimport assert from \"assert\";\nimport { get } from \"lodash\";\n\nexport function msToS(ms: number) {\n  return Math.floor(ms / 1000);\n}\n\ntype CoinGeckoAssetPlatform = {\n  id: string;\n  chain_identifier: number;\n  name: string;\n  shortname: string;\n};\n\ntype CoinGeckoPrice = {\n  address: string;\n  timestamp: number;\n  price: number;\n};\n\nclass Coingecko {\n  private host: string;\n  constructor(host = \"https://api.coingecko.com/api/v3\") {\n    this.host = host;\n  }\n  // Fetch historic prices for a `contract` denominated in `currency` between timestamp `from` and `to`. Note timestamps\n  // are assumed to be js timestamps and are converted to unixtimestamps by dividing by 1000.\n  async getHistoricContractPrices(contract: string, from: number, to: number, currency = \"usd\") {\n    assert(contract, \"requires contract address\");\n    assert(currency, \"requires currency symbol\");\n    assert(from, \"requires from timestamp\");\n    assert(to, \"requires to timestamp\");\n    from = Math.floor(from / 1000);\n    to = Math.floor(to / 1000);\n    const result = await this.call(\n      `coins/ethereum/contract/${contract.toLowerCase()}/market_chart/range/?vs_currency=${currency}&from=${from}&to=${to}`\n    );\n    // fyi timestamps are returned in ms in contrast to the current price endpoint\n    if (result.prices) return result.prices;\n    throw new Error(\"Something went wrong fetching coingecko prices!\");\n  }\n  async getContractDetails(contract_address: string, platform_id = \"ethereum\") {\n    return this.call(`coins/${platform_id}/contract/${contract_address.toLowerCase()}`);\n  }\n  async getCurrentPriceByContract(contract_address: string, currency = \"usd\", platform_id = \"ethereum\") {\n    const result = await this.getContractDetails(contract_address, platform_id);\n    const price = get(result, [\"market_data\", \"current_price\", currency], null);\n    assert(price !== null, \"No current price available for: \" + contract_address);\n    return [result.last_updated, price];\n  }\n  // Return an array of spot prices for an array of collateral addresses in one async call. Note we might in future\n  // This was adapted from packages/merkle-distributor/kpi-options-helpers/calculate-uma-tvl.ts\n  async getContractPrices(\n    addresses: Array<string>,\n    currency = \"usd\",\n    platform_id = \"ethereum\"\n  ): Promise<CoinGeckoPrice[]> {\n    // Generate a unique set with no repeated. join the set with the required coingecko delimiter.\n    const contract_addresses = Array.from(new Set(addresses.filter((n) => n).values()));\n    assert(contract_addresses.length > 0, \"Must supply at least 1 contract address\");\n    // coingecko returns lowercase addresses, so if you expect checksummed addresses, this lookup table will convert them back without having to add ethers as a dependency\n    const lookup = Object.fromEntries(\n      contract_addresses.map((address) => {\n        return [address.toLowerCase(), address];\n      })\n    );\n    // annoying, but have to type this to iterate over entries\n    type Result = {\n      [address: string]: {\n        [currency: string]: number; // usd, eth, ...\n        last_updated_at: number;\n      };\n    };\n    const result: Result = await this.call(\n      `simple/token_price/${platform_id}?contract_addresses=${contract_addresses.join(\n        \"%2C\"\n      )}&vs_currencies=${currency}&include_last_updated_at=true`\n    );\n    return Object.entries(result).map(([key, value]) => {\n      return { address: lookup[key], timestamp: value.last_updated_at, price: value[currency] };\n    });\n  }\n\n  async getPlatforms(): Promise<CoinGeckoAssetPlatform[]> {\n    return this.call(`asset_platforms`);\n  }\n\n  async call(path: string) {\n    try {\n      const { host } = this;\n      const url = `${host}/${path}`;\n      const result = await axios(url);\n      return result.data;\n    } catch (err) {\n      const msg = get(err, \"response.data.error\", get(err, \"response.statusText\", \"Unknown Coingecko Error\"));\n      throw new Error(msg);\n    }\n  }\n}\nexport default Coingecko;\n","import assert from \"assert\";\nimport { calculateGasFees, percent, BigNumberish, toBNWei, fixedPointAdjustment, toWei } from \"./utils\";\nimport { exists } from \"../utils\";\nimport { Provider } from \"@ethersproject/providers\";\nimport { connect as erc20Connect } from \"../clients/erc20\";\nimport { Etherchain } from \"../clients/etherchain\";\nimport Coingecko from \"../coingecko\";\nimport { ethers, BigNumber } from \"ethers\";\nimport * as constants from \"./constants\";\n\n/**\n * Function to estimate gas fees based on coingecko token price and ethers gasPrice. You must still\n * provide a gas amount estimation based on the usage pattern. See constants for current estimations. Returns\n * an amount of gas estimated in the token provided in wei.\n *\n * @param {Provider} ethers Provider\n * @param {BigNumberish} Total amount to be relayed, specified in smallest unit of currency.\n * @param {number} gas - The gas cost for transfer, use constants defined in constants file.\n * @param {string} [tokenAddress = constants.ADDRESSES.ETH] - Token address, for ETH, constants.ADDRESSES.ETH\n */\nexport async function getGasFee(\n  ethersProvider: Provider,\n  gas: number,\n  tokenAddress: string = constants.ADDRESSES.ETH\n): Promise<string> {\n  const { baseFeePerGas } = await ethersProvider.getBlock(\"latest\");\n  let gasPrice: ethers.BigNumber;\n\n  if (baseFeePerGas) {\n    const priorityFeePerGas = (await new Etherchain().getGasPrice()).fastest;\n    // transform priority fee from gwei (eg 4.1) to wei\n    const priorityFeePerGasWei = toWei(priorityFeePerGas, 9);\n    gasPrice = baseFeePerGas.add(priorityFeePerGasWei);\n  } else {\n    // fallback in case baseFeePerGas is undefined / null\n    gasPrice = await ethersProvider.getGasPrice();\n  }\n\n  // We treat ETH differently since we dont need a price conversion like other tokens and return early.\n  if (tokenAddress === constants.ADDRESSES.ETH) {\n    return calculateGasFees(gas, gasPrice);\n  }\n  const coingecko = new Coingecko();\n  const [, tokenPrice] = await coingecko.getCurrentPriceByContract(tokenAddress, \"eth\");\n  const erc20Client = erc20Connect(tokenAddress, ethersProvider);\n  const decimals = await erc20Client.decimals();\n  return calculateGasFees(gas, gasPrice, tokenPrice, decimals);\n}\n\ntype GasTable = Record<string, number> & { DEFAULT: number };\n// These tables are hard coded to mainnet\nfunction makeSlowGasTable(): GasTable {\n  return {\n    [constants.ADDRESSES.UMA]: constants.SLOW_UMA_GAS,\n    [constants.ADDRESSES.ETH]: constants.SLOW_ETH_GAS,\n    [constants.ADDRESSES.WETH]: constants.SLOW_ETH_GAS,\n    DEFAULT: constants.SLOW_ERC_GAS,\n  };\n}\n// instant gas is the amount of gas above slow gas\nfunction makeInstantGasTable(): GasTable {\n  return {\n    [constants.ADDRESSES.UMA]: constants.FAST_UMA_GAS - constants.SLOW_UMA_GAS,\n    [constants.ADDRESSES.ETH]: constants.FAST_ETH_GAS - constants.SLOW_ETH_GAS,\n    [constants.ADDRESSES.WETH]: constants.FAST_ETH_GAS - constants.SLOW_ETH_GAS,\n    DEFAULT: constants.FAST_ERC_GAS - constants.SLOW_ERC_GAS,\n  };\n}\n\nconst GetGasByAddress = (gasTable: GasTable) => (tokenAddress: string): number => {\n  if (exists(gasTable[tokenAddress])) return gasTable[tokenAddress];\n  return gasTable.DEFAULT;\n};\n\nexport const getInstantGasByAddress = GetGasByAddress(makeInstantGasTable());\nexport const getSlowGasByAddress = GetGasByAddress(makeSlowGasTable());\n\nexport type DepositFees = {\n  slowPct: string;\n  instantPct: string;\n};\n\n/**\n * getDepositFees. Returns to you appropriate values for calling the relay deposit function. Returns the slow gas fee\n * and the instant gas fee which is the amount additional to the slow fee as percentages in wei.\n *\n * @param {Provider} ethersProvider - Read provider on mainnet\n * @param {BigNumberish} amountToRelay - Amount in wei of token to relay\n * @param {string} tokenAddress = 0 - Mainnet address of token to relay. Defaults to ETH which is constants.ADDRESSES.ETH.\n * @param {string} discountPercent = DEFAULT_GAS_DISCOUNT- Percent as a value 0-100 of gas fee discount. 0 means no discount. Typically 25 for a 25% gas fee reduction.\n * No need to override this as the values are hardcoded in the sdk.\n * @returns {Promise<DepositFees>} - Returns the fee parameters to the deposit function on the deposit box contract.\n * These are percentages in wei. For example 50% is represented as 0.5 * 1e18.\n */\nexport async function getDepositFees(\n  ethersProvider: Provider,\n  amountToRelay: BigNumberish,\n  tokenAddress: string = constants.ADDRESSES.ETH,\n  discountPercent: number = constants.DEFAULT_GAS_DISCOUNT\n): Promise<DepositFees> {\n  assert(discountPercent >= 0 && discountPercent <= 100, \"discountPercent must be between 0 and 100 percent\");\n  const slowGas = getSlowGasByAddress(tokenAddress);\n  const slowGasDiscounted = Math.floor((1 - discountPercent / 100) * slowGas);\n  const slowGasFee = await getGasFee(ethersProvider, slowGasDiscounted, tokenAddress);\n\n  const instantGas = getInstantGasByAddress(tokenAddress);\n  const instantGasDiscounted = Math.floor((1 - discountPercent / 100) * instantGas);\n  const instantGasFee = await getGasFee(ethersProvider, instantGasDiscounted, tokenAddress);\n\n  return {\n    slowPct: percent(slowGasFee, amountToRelay).toString(),\n    instantPct: percent(instantGasFee, amountToRelay).toString(),\n  };\n}\n\nexport type DepositFeeDetails = {\n  tokenAddress: string;\n  amountToRelay: string;\n  discountPercent: number;\n  feeLimitPercent?: number;\n  instant: {\n    pct: string;\n    total: string;\n  };\n  slow: {\n    pct: string;\n    total: string;\n  };\n  isAmountTooLow: boolean;\n};\n/**\n * getDepositFeesDetails. Same as deposit fees, but returns more information, useful for a frontend display.\n *\n * @param {Provider} ethersProvider - Read provider on mainnet\n * @param {BigNumberish} amountToRelay - Amount in wei of token to relay\n * @param {string} tokenAddress = 0 - Mainnet address of token to relay, for ETH specify constants.ADDRESSES.ETH\n * @param {number} feeLimitPercent? - Optional, percent as a value 0-100 of how much to limit fees as a percentage of the total relayed. Typically 25 or 25% of fees are acceptable out of the total relay amount.\n * For instance 25 means fees can be up to 25% of the total amount to send, fees above this will cause isAmountTooLow to be true.\n * @param {string} discountPercent = DEFAULT_GAS_DISCOUNT - Percent as a value 0-100 of gas fee discount. 0 means no discount. Typically 25 for a 25% gas fee reduction.\n * No need to override this as the values are hardcoded in the sdk.\n * @returns {DepositFeeDetails}\n */\nexport async function getDepositFeesDetails(\n  ethersProvider: Provider,\n  amountToRelay: BigNumberish,\n  tokenAddress: string = constants.ADDRESSES.ETH,\n  feeLimitPercent?: number,\n  discountPercent: number = constants.DEFAULT_GAS_DISCOUNT\n): Promise<DepositFeeDetails> {\n  const { slowPct, instantPct } = await getDepositFees(ethersProvider, amountToRelay, tokenAddress, discountPercent);\n  const slowTotal = BigNumber.from(slowPct).mul(amountToRelay).div(fixedPointAdjustment).toString();\n  const instantTotal = BigNumber.from(instantPct).mul(amountToRelay).div(fixedPointAdjustment).toString();\n  let isAmountTooLow = false;\n\n  if (feeLimitPercent) {\n    assert(feeLimitPercent >= 0 && feeLimitPercent <= 100, \"feeLimitPercent must be between 0 and 100 percent\");\n    isAmountTooLow = BigNumber.from(slowPct)\n      .add(instantPct)\n      .gt(toBNWei(feeLimitPercent / 100));\n  }\n\n  return {\n    amountToRelay: amountToRelay.toString(),\n    discountPercent,\n    feeLimitPercent,\n    tokenAddress,\n    instant: {\n      pct: instantPct,\n      total: instantTotal,\n    },\n    slow: {\n      pct: slowPct,\n      total: slowTotal,\n    },\n    isAmountTooLow,\n  };\n}\n","import { multicall } from \"./clients\";\nimport { Contract } from \"ethers\";\nimport type { SignerOrProvider } from \".\";\nimport zip from \"lodash/zip\";\n\nexport type Call = {\n  method: string;\n  args?: any[];\n};\n\nexport type Request = {\n  contractInstance: Contract;\n  call: Call;\n};\nexport type EncodedResponse = string;\nexport type EncodedRequest = {\n  target: string;\n  callData: string;\n};\n\nexport interface State<MulticallType> {\n  requests: Request[];\n  multicallClient: MulticallType;\n}\n\n// Multicall class that exposes public functions to the user and recursively chains itself.  Acts immutable\n// if you store reference to the parent intsance. Children will contain mutated state.\nexport class Multicall<MulticallType extends multicall.Instance> implements State<multicall.Instance> {\n  public requests: Request[];\n  public multicallClient: MulticallType;\n  constructor(state: State<MulticallType>) {\n    // make a copy of this so we dont mutate the original\n    this.requests = [...state.requests];\n    this.multicallClient = state.multicallClient;\n  }\n\n  // internally add requests to queue. Only called by parent for chaining.\n  protected push(contractInstance: Contract, call: Call) {\n    this.requests.push({ contractInstance, call });\n  }\n\n  // encode requests to multicall contract\n  protected encodeRequest(request: Request) {\n    const { contractInstance, call } = request;\n    return {\n      target: contractInstance.address,\n      callData: contractInstance.interface.encodeFunctionData(call.method, call.args),\n    };\n  }\n\n  // decode response from multicall contract\n  protected decodeResponse(request: Request, response: EncodedResponse) {\n    const { contractInstance, call } = request;\n    return contractInstance.interface.decodeFunctionResult(call.method, response);\n  }\n\n  // adds a new request to the queue, to be executed when read is called. Returns an instance of this class so you can chain.\n  public add(contractInstance: Contract, call: Call) {\n    const child = new Multicall(this);\n    child.push(contractInstance, call);\n    return child;\n  }\n\n  // adds a list of requests to the queue, to be executed when read is called. Returns an instance of this class so you can chain.\n  public batch(contractInstance: Contract, calls: Call[]) {\n    const child = new Multicall(this);\n    calls.forEach((call: Call) => {\n      child.push(contractInstance, call);\n    });\n    return child;\n  }\n  // reads from the contract, returns the read results in order that requests were queued.\n  public async read(_requests: Request[] = this.requests) {\n    const encodedRequests = _requests.map((request) => this.encodeRequest(request));\n    const { returnData } = await this.multicallClient.callStatic.aggregate(encodedRequests);\n    const zipped = zip(_requests, returnData);\n    return zipped.map(([request, response]) => {\n      if (request && response) return this.decodeResponse(request, response);\n      throw new Error(\"Unable to decode contract response\");\n    });\n  }\n}\n\n// Factory that alters construction of multicall to be more friendly for end user\nexport default class Factory extends Multicall<multicall.Instance> {\n  constructor(address: string, provider: SignerOrProvider) {\n    const multicallClient = multicall.connect(address, provider);\n    super({ multicallClient, requests: [] });\n  }\n}\n","import { multicall2 } from \"./clients\";\nimport { Call, Multicall, Request, State } from \"./multicall\";\nimport zip from \"lodash/zip\";\nimport { SignerOrProvider } from \".\";\nimport { Contract } from \"ethers\";\n\nclass Multicall2 extends Multicall<multicall2.Instance> {\n  constructor(state: State<multicall2.Instance>) {\n    super(state);\n  }\n\n  // reads from the contract, returns the read and error results in order that requests were queued.\n  public async readWithErrors(_requests: Request[] = this.requests) {\n    const encodedRequests = _requests.map((request) => this.encodeRequest(request));\n    const [, , returnData] = await this.multicallClient.callStatic.tryBlockAndAggregate(false, encodedRequests);\n    const zipped = zip(_requests, returnData);\n    return zipped.map(([request, response]) => {\n      if (request && response) {\n        return {\n          success: response.success,\n          result: response.success ? this.decodeResponse(request, response.returnData) : undefined,\n        };\n      }\n      throw new Error(\"Unable to decode contract response\");\n    });\n  }\n\n  // adds a new request to the queue, to be executed when read is called. Returns an instance of this class so you can chain.\n  public add(contractInstance: Contract, call: Call) {\n    return new Multicall2(super.add(contractInstance, call));\n  }\n\n  // adds a list of requests to the queue, to be executed when read is called. Returns an instance of this class so you can chain.\n  public batch(contractInstance: Contract, calls: Call[]) {\n    return new Multicall2(super.batch(contractInstance, calls));\n  }\n}\n\n// Factory that alters construction of multicall2 to be more friendly for end user\nexport default class Multicall2Factory extends Multicall2 {\n  constructor(address: string, provider: SignerOrProvider) {\n    const multicallClient = multicall2.connect(address, provider);\n    super({ multicallClient, requests: [] });\n  }\n}\n","import assert from \"assert\";\nimport { Signer } from \"ethers\";\nimport { TransactionRequest, TransactionReceipt } from \"@ethersproject/abstract-provider\";\n\nfunction makeKey(tx: TransactionRequest) {\n  return JSON.stringify(\n    Object.entries(tx).map(([key, value]) => {\n      return [key, (value || \"\").toString()];\n    })\n  );\n}\n\ntype Config = {\n  confirmations?: number;\n};\nexport type Emit = (event: string, key: string, data: TransactionReceipt | string | TransactionRequest | Error) => void;\nexport default (config: Config, signer: Signer, emit: Emit = () => null) => {\n  assert(signer.provider, \"signer requires a provider, use signer.connect(provider)\");\n  const { confirmations = 3 } = config;\n  const requests = new Map<string, TransactionRequest>();\n  const submissions = new Map<string, string>();\n  const mined = new Map<string, TransactionReceipt>();\n  function request(unsignedTx: TransactionRequest) {\n    // this no longer calls signer.populateTransaction, to allow metamask to fill in missing details instead\n    // use overrides if you want to manually fill in other tx details, including the overrides.customData field.\n    const populated = unsignedTx;\n    const key = makeKey(populated);\n    assert(!requests.has(key), \"Transaction already in progress\");\n    requests.set(key, populated);\n    return key;\n  }\n  async function processRequest(key: string) {\n    const request = requests.get(key);\n    assert(request, \"invalid request\");\n    // always delete request, it should only be submitted once\n    requests.delete(key);\n    try {\n      const sent = await signer.sendTransaction(request);\n      submissions.set(key, sent.hash);\n      emit(\"submitted\", key, sent.hash);\n    } catch (err) {\n      emit(\"error\", key, err as Error);\n    }\n  }\n  async function processSubmission(key: string) {\n    const hash = submissions.get(key);\n    assert(hash, \"invalid submission\");\n    assert(signer.provider, \"signer requires a provider, use signer.connect(provider)\");\n    // we look for this transaction, but it may never find it if its sped up\n    const receipt = await signer.provider.getTransactionReceipt(hash).catch(() => undefined);\n    if (receipt == null) return;\n    if (receipt.confirmations < confirmations) return;\n    submissions.delete(key);\n    mined.set(key, receipt);\n    emit(\"mined\", key, receipt);\n  }\n  async function isMined(key: string) {\n    return mined.get(key);\n  }\n  async function update() {\n    for (const key of requests.keys()) {\n      await processRequest(key);\n    }\n    for (const key of submissions.keys()) {\n      await processSubmission(key);\n    }\n  }\n  return {\n    request,\n    isMined,\n    update,\n  };\n};\n","import assert from \"assert\";\nimport { bridgePool, rateModelStore } from \"../../clients\";\nimport { toBNWei, fixedPointAdjustment, calcPeriodicCompoundInterest, calcApr, BigNumberish, fromWei } from \"../utils\";\nimport { BatchReadWithErrors, loop, exists } from \"../../utils\";\nimport Multicall2 from \"../../multicall2\";\nimport TransactionManager from \"../transactionManager\";\nimport { ethers, Signer, BigNumber } from \"ethers\";\nimport type { Overrides } from \"@ethersproject/contracts\";\nimport { TransactionRequest, TransactionReceipt, Log } from \"@ethersproject/abstract-provider\";\nimport { Provider, Block } from \"@ethersproject/providers\";\nimport set from \"lodash/set\";\nimport get from \"lodash/get\";\nimport has from \"lodash/has\";\nimport { calculateInstantaneousRate } from \"../feeCalculator\";\nimport { SECONDS_PER_YEAR, DEFAULT_BLOCK_DELTA, RateModel, ADDRESSES } from \"../constants\";\nimport { parseAndReturnRateModelFromString } from \"../rateModel\";\n\nexport type { Provider };\nexport type BatchReadWithErrorsType = ReturnType<ReturnType<typeof BatchReadWithErrors>>;\n\nexport type Awaited<T> = T extends PromiseLike<infer U> ? U : T;\n\nexport type Config = {\n  multicall2Address: string;\n  rateModelStoreAddress?: string;\n  confirmations?: number;\n  blockDelta?: number;\n};\nexport type Dependencies = {\n  provider: Provider;\n};\nexport type Pool = {\n  address: string;\n  totalPoolSize: string;\n  l1Token: string;\n  liquidReserves: string;\n  pendingReserves: string;\n  exchangeRateCurrent: string;\n  exchangeRatePrevious: string;\n  estimatedApy: string;\n  estimatedApr: string;\n  blocksElapsed: number;\n  secondsElapsed: number;\n  liquidityUtilizationCurrent: string;\n  utilizedReserves: string;\n  projectedApr: string;\n};\nexport type User = {\n  address: string;\n  poolAddress: string;\n  lpTokens: string;\n  positionValue: string;\n  totalDeposited: string;\n  feesEarned: string;\n};\nexport type Transaction = {\n  id: string;\n  state: \"requested\" | \"submitted\" | \"mined\" | \"error\";\n  toAddress: string;\n  fromAddress: string;\n  type: \"Add Liquidity\" | \"Remove Liquidity\";\n  description: string;\n  request?: TransactionRequest;\n  hash?: string;\n  receipt?: TransactionReceipt;\n  error?: Error;\n};\nexport type Token = {\n  decimals: string;\n  symbol: string;\n  name: string;\n};\nexport type State = {\n  pools: Record<string, Pool>;\n  users: Record<string, Record<string, User>>;\n  transactions: Record<string, Transaction>;\n  error?: Error;\n};\nexport type EmitState = (path: string[], data: any) => void;\n\nclass PoolState {\n  private l1Token: string | undefined = undefined;\n  constructor(\n    private batchRead: BatchReadWithErrorsType,\n    private contract: bridgePool.Instance,\n    private address: string\n  ) {}\n  public async read(latestBlock: number, previousBlock?: number) {\n    if (this.l1Token === undefined) this.l1Token = await this.contract.l1Token();\n    // typechain does not have complete types for call options, so we have to cast blockTag to any\n    const exchangeRatePrevious = await this.contract.callStatic.exchangeRateCurrent({\n      blockTag: previousBlock || latestBlock - 1,\n    } as any);\n\n    return {\n      address: this.address,\n      l1Token: this.l1Token,\n      exchangeRatePrevious,\n      ...(await this.batchRead<{\n        exchangeRateCurrent: BigNumber;\n        liquidityUtilizationCurrent: BigNumber;\n        liquidReserves: BigNumber;\n        pendingReserves: BigNumber;\n        utilizedReserves: BigNumber;\n      }>([\n        // its important exchangeRateCurrent is called first, as it calls _sync under the hood which updates the contract\n        // and gives more accurate values for the following properties.\n        [\"exchangeRateCurrent\"],\n        [\"liquidityUtilizationCurrent\"],\n        [\"liquidReserves\"],\n        [\"pendingReserves\"],\n        [\"utilizedReserves\"],\n      ])),\n    };\n  }\n}\n\ntype EventIdParams = { blockNumber: number; transactionIndex: number; logIndex: number };\nexport class PoolEventState {\n  private seen = new Set<string>();\n  private iface: ethers.utils.Interface;\n  constructor(\n    private contract: bridgePool.Instance,\n    private startBlock = 0,\n    private state: bridgePool.EventState = bridgePool.eventStateDefaults()\n  ) {\n    this.iface = new ethers.utils.Interface(bridgePool.Factory.abi);\n  }\n  private makeId(params: EventIdParams) {\n    return [params.blockNumber, params.transactionIndex, params.logIndex].join(\"!\");\n  }\n  hasEvent(params: EventIdParams) {\n    return this.seen.has(this.makeId(params));\n  }\n  private addEvent(params: EventIdParams) {\n    return this.seen.add(this.makeId(params));\n  }\n  private filterSeen = (params: EventIdParams) => {\n    const seen = this.hasEvent(params);\n    if (!seen) this.addEvent(params);\n    return !seen;\n  };\n  public async read(endBlock: number, userAddress?: string) {\n    if (endBlock <= this.startBlock) return this.state;\n    const events = (\n      await Promise.all([\n        ...(await this.contract.queryFilter(\n          this.contract.filters.LiquidityAdded(undefined, undefined, userAddress),\n          this.startBlock,\n          endBlock\n        )),\n        ...(await this.contract.queryFilter(\n          this.contract.filters.LiquidityRemoved(undefined, undefined, userAddress),\n          this.startBlock,\n          endBlock\n        )),\n      ])\n    )\n      .filter(this.filterSeen)\n      .sort((a, b) => {\n        if (a.blockNumber !== b.blockNumber) return a.blockNumber - b.blockNumber;\n        if (a.transactionIndex !== b.transactionIndex) return a.transactionIndex - b.transactionIndex;\n        if (a.logIndex !== b.logIndex) a.logIndex - b.logIndex;\n        // if everything is the same, return a, ie maintain order of array\n        return -1;\n      });\n    // ethers queries are inclusive [start,end] unless start === end, then exclusive (start,end). we increment to make sure we dont see same event twice\n    this.startBlock = endBlock + 1;\n    this.state = bridgePool.getEventState(events, this.state);\n    return this.state;\n  }\n  makeEventFromLog(log: Log) {\n    const description = this.iface.parseLog(log);\n    return {\n      ...log,\n      ...description,\n      event: description.name,\n      eventSignature: description.signature,\n    };\n  }\n  readTxReceipt(receipt: TransactionReceipt) {\n    const events = receipt.logs\n      .map((log) => {\n        try {\n          return this.makeEventFromLog(log);\n        } catch (err) {\n          // return nothing, this throws a lot because logs from other contracts are included in receipt\n          return;\n        }\n      })\n      // filter out undefined\n      .filter(exists)\n      .filter(this.filterSeen);\n\n    this.state = bridgePool.getEventState(events, this.state);\n    return this.state;\n  }\n}\n\nclass UserState {\n  constructor(private contract: bridgePool.Instance) {}\n  public async read(user: string) {\n    return {\n      address: user,\n      balanceOf: await this.contract.balanceOf(user),\n    };\n  }\n}\n\nexport function calculateRemoval(amountWei: BigNumber, percentWei: BigNumber) {\n  const receive = amountWei.mul(percentWei).div(fixedPointAdjustment);\n  const remain = amountWei.sub(receive);\n  return {\n    recieve: receive.toString(),\n    remain: remain.toString(),\n  };\n}\n// params here mimic the user object type\nexport function previewRemoval(\n  values: { positionValue: BigNumberish; feesEarned: BigNumberish; totalDeposited: BigNumberish },\n  percentFloat: number\n) {\n  const percentWei = toBNWei(percentFloat);\n  return {\n    position: {\n      ...calculateRemoval(BigNumber.from(values.totalDeposited), percentWei),\n    },\n    fees: {\n      ...calculateRemoval(BigNumber.from(values.feesEarned), percentWei),\n    },\n    total: {\n      ...calculateRemoval(BigNumber.from(values.positionValue), percentWei),\n    },\n  };\n}\nfunction joinUserState(\n  poolState: Pool,\n  eventState: bridgePool.EventState,\n  userState: Awaited<ReturnType<UserState[\"read\"]>>\n): User {\n  const positionValue = BigNumber.from(poolState.exchangeRateCurrent)\n    .mul(userState.balanceOf)\n    .div(fixedPointAdjustment);\n  const totalDeposited = BigNumber.from(eventState.tokens[userState.address] || \"0\");\n  const feesEarned = positionValue.sub(totalDeposited);\n  return {\n    address: userState.address,\n    poolAddress: poolState.address,\n    lpTokens: userState.balanceOf.toString(),\n    positionValue: positionValue.toString(),\n    totalDeposited: totalDeposited.toString(),\n    feesEarned: feesEarned.toString(),\n  };\n}\nfunction joinPoolState(\n  poolState: Awaited<ReturnType<PoolState[\"read\"]>>,\n  latestBlock: Block,\n  previousBlock: Block,\n  rateModel?: RateModel\n): Pool {\n  const totalPoolSize = poolState.liquidReserves.add(poolState.utilizedReserves);\n  const secondsElapsed = latestBlock.timestamp - previousBlock.timestamp;\n  const blocksElapsed = latestBlock.number - previousBlock.number;\n  const exchangeRatePrevious = poolState.exchangeRatePrevious.toString();\n  const exchangeRateCurrent = poolState.exchangeRateCurrent.toString();\n\n  const estimatedApy = calcPeriodicCompoundInterest(\n    exchangeRatePrevious,\n    exchangeRateCurrent,\n    secondsElapsed,\n    SECONDS_PER_YEAR\n  );\n  const estimatedApr = calcApr(exchangeRatePrevious, exchangeRateCurrent, secondsElapsed, SECONDS_PER_YEAR);\n  let projectedApr = \"\";\n\n  if (rateModel) {\n    projectedApr = fromWei(\n      calculateInstantaneousRate(rateModel, poolState.liquidityUtilizationCurrent)\n        .mul(poolState.liquidityUtilizationCurrent)\n        .div(fixedPointAdjustment)\n    );\n  }\n\n  return {\n    address: poolState.address,\n    totalPoolSize: totalPoolSize.toString(),\n    l1Token: poolState.l1Token,\n    liquidReserves: poolState.liquidReserves.toString(),\n    pendingReserves: poolState.pendingReserves.toString(),\n    exchangeRateCurrent: poolState.exchangeRateCurrent.toString(),\n    exchangeRatePrevious: poolState.exchangeRatePrevious.toString(),\n    estimatedApy,\n    estimatedApr,\n    blocksElapsed,\n    secondsElapsed,\n    liquidityUtilizationCurrent: poolState.liquidityUtilizationCurrent.toString(),\n    projectedApr,\n    utilizedReserves: poolState.utilizedReserves.toString(),\n  };\n}\nexport class ReadPoolClient {\n  private poolState: PoolState;\n  private multicall: Multicall2;\n  private contract: bridgePool.Instance;\n  private batchRead: BatchReadWithErrorsType;\n  constructor(private address: string, private provider: Provider, private multicallAddress: string) {\n    this.multicall = new Multicall2(multicallAddress, provider);\n    this.contract = bridgePool.connect(address, provider);\n    this.batchRead = BatchReadWithErrors(this.multicall)(this.contract);\n    this.poolState = new PoolState(this.batchRead, this.contract, address);\n  }\n  public async read(latestBlock: number) {\n    return this.poolState.read(latestBlock);\n  }\n}\nexport function validateWithdraw(pool: Pool, user: User, lpTokenAmount: BigNumberish) {\n  const l1TokensToReturn = BigNumber.from(lpTokenAmount).mul(pool.exchangeRateCurrent).div(fixedPointAdjustment);\n  assert(BigNumber.from(l1TokensToReturn).gt(\"0\"), \"Must withdraw amount greater than 0\");\n  assert(\n    BigNumber.from(pool.liquidReserves).gte(l1TokensToReturn.add(pool.pendingReserves)),\n    \"Utilization too high to remove that amount, try lowering withdraw amount\"\n  );\n  assert(BigNumber.from(lpTokenAmount).lte(user.lpTokens), \"You cannot withdraw more than you have\");\n  return { lpTokenAmount, l1TokensToReturn: l1TokensToReturn.toString() };\n}\n\nexport class Client {\n  private poolContracts: Record<string, bridgePool.Instance> = {};\n  private multicall: Multicall2;\n  private transactionManagers: Record<string, ReturnType<typeof TransactionManager>> = {};\n  private state: State = { pools: {}, users: {}, transactions: {} };\n  private batchRead: ReturnType<typeof BatchReadWithErrors>;\n  private poolEvents: Record<string, PoolEventState> = {};\n  private intervalStarted = false;\n  private rateModelInstance: rateModelStore.Instance;\n  constructor(private config: Config, private deps: Dependencies, private emit: EmitState) {\n    this.multicall = new Multicall2(config.multicall2Address, deps.provider);\n    this.batchRead = BatchReadWithErrors(this.multicall);\n    this.rateModelInstance = rateModelStore.connect(config.rateModelStoreAddress || ADDRESSES.RateModel, deps.provider);\n  }\n  private getOrCreatePoolContract(address: string) {\n    if (this.poolContracts[address]) return this.poolContracts[address];\n    const contract = bridgePool.connect(address, this.deps.provider);\n    this.poolContracts[address] = contract;\n    return contract;\n  }\n  private getOrCreatePoolEvents(poolAddress: string) {\n    if (this.poolEvents[poolAddress]) return this.poolEvents[poolAddress];\n    this.poolEvents[poolAddress] = new PoolEventState(this.getOrCreatePoolContract(poolAddress));\n    return this.poolEvents[poolAddress];\n  }\n  private getOrCreateTransactionManager(signer: Signer, address: string) {\n    if (this.transactionManagers[address]) return this.transactionManagers[address];\n    const txman = TransactionManager({ confirmations: this.config.confirmations }, signer, (event, id, data) => {\n      if (event === \"submitted\") {\n        this.state.transactions[id].state = event;\n        this.state.transactions[id].hash = data as string;\n        this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n      }\n      if (event === \"mined\") {\n        const txReceipt = data as TransactionReceipt;\n        this.state.transactions[id].state = event;\n        this.state.transactions[id].receipt = txReceipt;\n        this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n        // trigger pool and user update for a known mined transaction\n        const tx = this.state.transactions[id];\n        this.updatePool(tx.toAddress)\n          .then(() => {\n            return this.updateUserWithTransaction(tx.fromAddress, tx.toAddress, txReceipt);\n          })\n          .catch((err) => {\n            this.emit([\"error\"], err);\n          });\n      }\n      if (event === \"error\") {\n        this.state.transactions[id].state = event;\n        this.state.transactions[id].error = data as Error;\n        this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n      }\n    });\n    this.transactionManagers[address] = txman;\n    return txman;\n  }\n  async addEthLiquidity(signer: Signer, pool: string, l1TokenAmount: BigNumberish, overrides: Overrides = {}) {\n    const userAddress = await signer.getAddress();\n    const contract = this.getOrCreatePoolContract(pool);\n    const txman = this.getOrCreateTransactionManager(signer, userAddress);\n\n    // dont allow override value here\n    const request = await contract.populateTransaction.addLiquidity(l1TokenAmount, {\n      ...overrides,\n      value: l1TokenAmount,\n    });\n    const id = await txman.request(request);\n\n    this.state.transactions[id] = {\n      id,\n      state: \"requested\",\n      toAddress: pool,\n      fromAddress: userAddress,\n      type: \"Add Liquidity\",\n      description: `Adding ETH to pool`,\n      request,\n    };\n    this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n    await txman.update();\n    return id;\n  }\n  async addTokenLiquidity(signer: Signer, pool: string, l1TokenAmount: BigNumberish, overrides: Overrides = {}) {\n    const userAddress = await signer.getAddress();\n    const contract = this.getOrCreatePoolContract(pool);\n    const txman = this.getOrCreateTransactionManager(signer, userAddress);\n\n    const request = await contract.populateTransaction.addLiquidity(l1TokenAmount, overrides);\n    const id = await txman.request(request);\n\n    this.state.transactions[id] = {\n      id,\n      state: \"requested\",\n      toAddress: pool,\n      fromAddress: userAddress,\n      type: \"Add Liquidity\",\n      description: `Adding Tokens to pool`,\n      request,\n    };\n\n    this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n    await txman.update();\n    return id;\n  }\n  async validateWithdraw(poolAddress: string, userAddress: string, lpAmount: BigNumberish) {\n    if (!this.hasPool(poolAddress)) {\n      await this.updatePool(poolAddress);\n    }\n    const poolState = this.getPool(poolAddress);\n    if (!this.hasUser(poolAddress, userAddress)) {\n      await this.updateUser(poolAddress, userAddress);\n    }\n    const userState = this.getUser(poolAddress, userAddress);\n    return validateWithdraw(poolState, userState, lpAmount);\n  }\n  async removeTokenLiquidity(signer: Signer, pool: string, lpTokenAmount: BigNumberish, overrides: Overrides = {}) {\n    const userAddress = await signer.getAddress();\n    await this.validateWithdraw(pool, userAddress, lpTokenAmount);\n    const contract = this.getOrCreatePoolContract(pool);\n    const txman = this.getOrCreateTransactionManager(signer, userAddress);\n\n    const request = await contract.populateTransaction.removeLiquidity(lpTokenAmount, false, overrides);\n    const id = await txman.request(request);\n\n    this.state.transactions[id] = {\n      id,\n      state: \"requested\",\n      toAddress: pool,\n      fromAddress: userAddress,\n      type: \"Remove Liquidity\",\n      description: `Withdrawing Tokens from pool`,\n      request,\n    };\n\n    this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n    await txman.update();\n    return id;\n  }\n  async removeEthliquidity(signer: Signer, pool: string, lpTokenAmount: BigNumberish, overrides: Overrides = {}) {\n    const userAddress = await signer.getAddress();\n    await this.validateWithdraw(pool, userAddress, lpTokenAmount);\n    const contract = this.getOrCreatePoolContract(pool);\n    const txman = this.getOrCreateTransactionManager(signer, userAddress);\n\n    const request = await contract.populateTransaction.removeLiquidity(lpTokenAmount, true, overrides);\n    const id = await txman.request(request);\n\n    this.state.transactions[id] = {\n      id,\n      state: \"requested\",\n      toAddress: pool,\n      fromAddress: userAddress,\n      type: \"Remove Liquidity\",\n      description: `Withdrawing Eth from pool`,\n      request,\n    };\n    this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n    await txman.update();\n    return id;\n  }\n  getPool(poolAddress: string) {\n    return this.state.pools[poolAddress];\n  }\n  hasPool(poolAddress: string) {\n    return Boolean(this.state.pools[poolAddress]);\n  }\n  getUser(poolAddress: string, userAddress: string) {\n    return get(this.state, [\"users\", userAddress, poolAddress]);\n  }\n  hasUser(poolAddress: string, userAddress: string) {\n    return has(this.state, [\"users\", userAddress, poolAddress]);\n  }\n  hasTx(id: string) {\n    return has(this.state, [\"transactions\", id]);\n  }\n  getTx(id: string) {\n    return get(this.state, [\"transactions\", id]);\n  }\n  private async updateUserWithTransaction(userAddress: string, poolAddress: string, txReceipt: TransactionReceipt) {\n    const contract = this.getOrCreatePoolContract(poolAddress);\n    if (!this.hasPool(poolAddress)) {\n      await this.updatePool(poolAddress);\n    }\n    const poolState = this.getPool(poolAddress);\n    const getUserState = new UserState(contract);\n    const getPoolEventState = this.getOrCreatePoolEvents(poolAddress);\n    const userState = await getUserState.read(userAddress);\n    const eventState = await getPoolEventState.readTxReceipt(txReceipt);\n    set(this.state, [\"users\", userAddress, poolAddress], joinUserState(poolState, eventState, userState));\n    this.emit([\"users\", userAddress, poolAddress], this.state.users[userAddress][poolAddress]);\n  }\n  async updateUser(userAddress: string, poolAddress: string) {\n    const contract = this.getOrCreatePoolContract(poolAddress);\n    if (!this.hasPool(poolAddress)) {\n      await this.updatePool(poolAddress);\n    }\n    const poolState = this.getPool(poolAddress);\n    const latestBlock = (await this.deps.provider.getBlock(\"latest\")).number;\n    const getUserState = new UserState(contract);\n    const getPoolEventState = this.getOrCreatePoolEvents(poolAddress);\n    const userState = await getUserState.read(userAddress);\n    const eventState = await getPoolEventState.read(latestBlock, userAddress);\n    set(this.state, [\"users\", userAddress, poolAddress], joinUserState(poolState, eventState, userState));\n    this.emit([\"users\", userAddress, poolAddress], this.state.users[userAddress][poolAddress]);\n  }\n  async updatePool(poolAddress: string) {\n    // default to 100 block delta unless specified otherwise in config\n    const { blockDelta = DEFAULT_BLOCK_DELTA } = this.config;\n    const contract = this.getOrCreatePoolContract(poolAddress);\n    const pool = new PoolState(this.batchRead(contract), contract, poolAddress);\n    const latestBlock = await this.deps.provider.getBlock(\"latest\");\n    const previousBlock = await this.deps.provider.getBlock(latestBlock.number - blockDelta);\n    const state = await pool.read(latestBlock.number, previousBlock.number);\n\n    let rateModel: RateModel | undefined = undefined;\n    try {\n      const rateModelRaw = await this.rateModelInstance.callStatic.l1TokenRateModels(state.l1Token);\n      rateModel = parseAndReturnRateModelFromString(rateModelRaw);\n    } catch (err) {\n      // we could swallow this error or just log it since getting the rate model is optional,\n      // but we will just emit it to the caller and let them decide what to do with it.\n      this.emit([\"error\"], err);\n    }\n\n    this.state.pools[poolAddress] = joinPoolState(state, latestBlock, previousBlock, rateModel);\n    this.emit([\"pools\", poolAddress], this.state.pools[poolAddress]);\n  }\n  async updateTransactions() {\n    for (const txMan of Object.values(this.transactionManagers)) {\n      try {\n        await txMan.update();\n      } catch (err) {\n        this.emit([\"error\"], err);\n      }\n    }\n  }\n  // starts transaction checking intervals, defaults to 30 seconds\n  async startInterval(delayMs = 30000) {\n    assert(!this.intervalStarted, \"Interval already started, try stopping first\");\n    this.intervalStarted = true;\n    loop(async () => {\n      assert(this.intervalStarted, \"Bridgepool Interval Stopped\");\n      await this.updateTransactions();\n    }, delayMs).catch((err) => {\n      this.emit([\"error\"], err);\n    });\n  }\n  // starts transaction checking intervals\n  async stopInterval() {\n    this.intervalStarted = false;\n  }\n}\n","import assert from \"assert\";\nimport { Provider } from \"@ethersproject/providers\";\nimport { Contract, Signer, BigNumber, ContractTransaction } from \"ethers\";\nimport { predeploys, getContractInterface } from \"@eth-optimism/contracts\";\nimport { ERC20Ethers__factory, OptimismL1StandardBridgeEthers__factory } from \"@uma/contracts-node\";\nimport { Watcher } from \"@eth-optimism/core-utils\";\n\nexport const l1Contracts: { Proxy__OVM_L1StandardBridge: { [chainId: number]: string } } = {\n  Proxy__OVM_L1StandardBridge: {\n    1: \"0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1\",\n    42: \"0x22F24361D548e5FaAfb36d1437839f080363982B\",\n  },\n};\n\nexport class OptimismBridgeClient {\n  // Gas limit for the L2 transaction initiated by the Sequencer\n  public readonly L2_DEPOSIT_GAS_LIMIT = 2000000;\n\n  public getL1BridgeAddress(chainId: number): string {\n    const l1StandardBridgeAddress = l1Contracts.Proxy__OVM_L1StandardBridge[chainId];\n    assert(typeof l1StandardBridgeAddress === \"string\", \"Chain not supported\");\n    return l1StandardBridgeAddress;\n  }\n\n  /**\n   * Create a transaction to deposit ERC20 tokens to Optimism\n   * @param l1Signer The L1 wallet provider (signer)\n   * @param l1Erc20Address The L1 token address\n   * @param l2Erc20Address The L2 token address\n   * @param amount The amount to be deposited in wei\n   * @returns The submitted transaction\n   */\n  async depositERC20(l1Signer: Signer, l1Erc20Address: string, l2Erc20Address: string, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);\n    const l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1StandardBridge.depositERC20(l1_ERC20.address, l2Erc20Address, amount, this.L2_DEPOSIT_GAS_LIMIT, \"0x\");\n  }\n\n  /**\n   * Create transaction to deposit ETH to Optimism\n   * @param l1Signer The L1 wallet provider (signer)\n   * @param amount The amount to be deposited in wei\n   * @returns The submitted transaction\n   */\n  async depositEth(l1Signer: Signer, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);\n    const l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);\n    return l1StandardBridge.depositETH(this.L2_DEPOSIT_GAS_LIMIT, \"0x\", { value: amount });\n  }\n\n  /**\n   * Wait a L1 transaction to be relayed by the L1 Cross Domain Messenger\n   * @param tx The L1 -> L2 transaction\n   * @param l1RpcProvider Layer 1 RPC provider\n   * @param l2RpcProvider Layer 2 RPC provider\n   * @returns The transaction receipt\n   */\n  async waitRelayToL2(tx: ContractTransaction, l1RpcProvider: Provider, l2RpcProvider: Provider) {\n    const l2Messenger = new Contract(\n      predeploys.L2CrossDomainMessenger,\n      getContractInterface(\"L2CrossDomainMessenger\"),\n      l2RpcProvider\n    );\n    const l1Messenger = new Contract(\n      await l2Messenger.l1CrossDomainMessenger(),\n      getContractInterface(\"L1CrossDomainMessenger\"),\n      l1RpcProvider\n    );\n    // Watch for messages to be relayed between L1 and L2.\n    const watcher = new Watcher({\n      l1: {\n        provider: l1RpcProvider,\n        messengerAddress: l1Messenger.address,\n      },\n      l2: {\n        provider: l2RpcProvider,\n        messengerAddress: l2Messenger.address,\n      },\n    });\n    // Wait for the message to be relayed to L2\n    const [msgHash1] = await watcher.getMessageHashesFromL1Tx(tx.hash);\n    return watcher.getL2TransactionReceipt(msgHash1, true);\n  }\n\n  public async checkAllowance(l1Signer: Signer, l1Erc20Address: string) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1_ERC20.allowance(await l1Signer.getAddress(), l1StandardBridgeAddress);\n  }\n\n  public async approve(l1Signer: Signer, l1Erc20Address: string, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1_ERC20.approve(l1StandardBridgeAddress, amount);\n  }\n}\n","import assert from \"assert\";\nimport { ethers } from \"ethers\";\nimport { Provider } from \"@ethersproject/providers\";\nimport { Signer, BigNumber, ContractTransaction } from \"ethers\";\nimport {\n  ERC20Ethers__factory,\n  OptimismL1StandardBridgeEthers__factory,\n  BobaAddressManagerEthers__factory,\n} from \"@uma/contracts-node\";\nimport { Watcher } from \"@eth-optimism/core-utils\";\nimport { SignerOrProvider } from \"../..\";\n\nexport const l1Contracts: { ADDRESS_MANAGER_ADDRESS: { [chainId: number]: string } } = {\n  ADDRESS_MANAGER_ADDRESS: {\n    // mainnet\n    1: \"0x8376ac6C3f73a25Dd994E0b0669ca7ee0C02F089\",\n    // rinkeby\n    4: \"0x93A96D6A5beb1F661cf052722A1424CDDA3e9418\",\n  },\n};\n\nexport class BobaBridgeClient {\n  // Gas limit for the L2 transaction initiated by the Sequencer\n  public readonly L2_DEPOSIT_GAS_LIMIT = 1300000;\n\n  public async getL1BridgeAddress(chainId: number, l1Provider: SignerOrProvider): Promise<string> {\n    const addressManagerAddress = l1Contracts.ADDRESS_MANAGER_ADDRESS[chainId];\n    assert(typeof addressManagerAddress === \"string\", \"Chain not supported\");\n    const addressManager = BobaAddressManagerEthers__factory.connect(addressManagerAddress, l1Provider);\n    const l1StandardBridgeAddress = await addressManager.getAddress(\"Proxy__OVM_L1StandardBridge\");\n\n    return l1StandardBridgeAddress;\n  }\n\n  /**\n   * Create a transaction to deposit ERC20 tokens to Boba. Mainnet and Rinkeby are currently supported\n   * @param l1Signer The L1 wallet provider (signer)\n   * @param l1Erc20Address The L1 token address\n   * @param l2Erc20Address The L2 token address\n   * @param amount The amount to be deposited in wei\n   * @returns The submitted transaction\n   */\n  async depositERC20(l1Signer: Signer, l1Erc20Address: string, l2Erc20Address: string, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);\n    const l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1StandardBridge.depositERC20(\n      l1_ERC20.address,\n      l2Erc20Address,\n      amount,\n      this.L2_DEPOSIT_GAS_LIMIT,\n      ethers.utils.formatBytes32String(new Date().getTime().toString())\n    );\n  }\n\n  /**\n   * Create transaction to deposit ETH to Boba\n   * @param l1Signer The L1 wallet provider (signer)\n   * @param amount The amount to be deposited in wei\n   * @returns The submitted transaction\n   */\n  async depositEth(l1Signer: Signer, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);\n    const l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);\n    return l1StandardBridge.depositETH(\n      this.L2_DEPOSIT_GAS_LIMIT,\n      ethers.utils.formatBytes32String(new Date().getTime().toString()),\n      { value: amount }\n    );\n  }\n\n  /**\n   * Wait a L1 transaction to be relayed by the L1 Cross Domain Messenger\n   * @param tx The L1 -> L2 transaction\n   * @param l1RpcProvider Layer 1 RPC provider\n   * @param l2RpcProvider Layer 2 RPC provider\n   * @returns The transaction receipt\n   */\n  async waitRelayToL2(tx: ContractTransaction, l1RpcProvider: Provider, l2RpcProvider: Provider) {\n    const chainId = (await l1RpcProvider.getNetwork()).chainId;\n    const addressManagerAddress = l1Contracts.ADDRESS_MANAGER_ADDRESS[chainId];\n    assert(typeof addressManagerAddress === \"string\", \"Chain not supported\");\n    const addressManager = BobaAddressManagerEthers__factory.connect(addressManagerAddress, l1RpcProvider);\n    const proxyL1CrossDomainMessengerAddress = await addressManager.getAddress(\"Proxy__L1CrossDomainMessenger\");\n    const l2CrossDomainMessenger = await addressManager.getAddress(\"L2CrossDomainMessenger\");\n    // Watch for messages to be relayed between L1 and L2.\n    const watcher = new Watcher({\n      l1: {\n        provider: l1RpcProvider,\n        messengerAddress: proxyL1CrossDomainMessengerAddress,\n      },\n      l2: {\n        provider: l2RpcProvider,\n        messengerAddress: l2CrossDomainMessenger,\n      },\n    });\n    // Wait for the message to be relayed to L2\n    const [msgHash] = await watcher.getMessageHashesFromL1Tx(tx.hash);\n    return watcher.getL2TransactionReceipt(msgHash, true);\n  }\n\n  public async checkAllowance(l1Signer: Signer, l1Erc20Address: string) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1_ERC20.allowance(await l1Signer.getAddress(), l1StandardBridgeAddress);\n  }\n\n  public async approve(l1Signer: Signer, l1Erc20Address: string, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1_ERC20.approve(l1StandardBridgeAddress, amount);\n  }\n}\n","import assert from \"assert\";\nimport { Provider, Block } from \"@ethersproject/providers\";\nimport { BigNumber } from \"ethers\";\nimport { bridgePool, rateModelStore } from \"../clients\";\nimport { BigNumberish } from \"./utils\";\nimport { calculateRealizedLpFeePct } from \"./feeCalculator\";\nimport { parseAndReturnRateModelFromString } from \"./rateModel\";\nimport { exists } from \"../utils\";\nimport BlockFinder from \"../blockFinder\";\n\nexport default class LpFeeCalculator {\n  private blockFinder: BlockFinder<Block>;\n  constructor(private provider: Provider) {\n    this.blockFinder = new BlockFinder<Block>(provider.getBlock.bind(provider));\n  }\n  async getLpFeePct(tokenAddress: string, bridgePoolAddress: string, amount: BigNumberish, timestamp?: number) {\n    amount = BigNumber.from(amount);\n    assert(amount.gt(0), \"Amount must be greater than 0\");\n\n    const { blockFinder, provider } = this;\n\n    const bridgePoolInstance = bridgePool.connect(bridgePoolAddress, provider);\n    const rateModelStoreAddress = await rateModelStore.getAddress(await (await this.provider.getNetwork()).chainId);\n    const rateModelStoreInstance = rateModelStore.connect(rateModelStoreAddress, provider);\n\n    const targetBlock = exists(timestamp)\n      ? await blockFinder.getBlockForTimestamp(timestamp)\n      : await provider.getBlock(\"latest\");\n    assert(exists(targetBlock), \"Unable to find target block for timestamp: \" + timestamp || \"latest\");\n    const blockTag = targetBlock.number;\n\n    const [currentUt, nextUt, rateModelForBlockHeight] = await Promise.all([\n      bridgePoolInstance.callStatic.liquidityUtilizationCurrent({ blockTag } as any),\n      bridgePoolInstance.callStatic.liquidityUtilizationPostRelay(amount, { blockTag } as any),\n      rateModelStoreInstance.callStatic.l1TokenRateModels(tokenAddress, { blockTag } as any),\n    ]);\n\n    // Parsing stringified rate model will error if the rate model doesn't contain exactly the expected keys or isn't\n    // a JSON object.\n    const rateModel = parseAndReturnRateModelFromString(rateModelForBlockHeight);\n\n    return calculateRealizedLpFeePct(rateModel, currentUt, nextUt);\n  }\n}\n","import { exists } from \"../utils\";\n\n// This error should be thrown if an expected value does not exist\nexport class ExistenceError extends Error {\n  constructor(message = \"\") {\n    super(message);\n    this.name = \"ExistenceError\";\n    // if this isnt included, we cannot use instanceof to check the type\n    Object.setPrototypeOf(this, ExistenceError.prototype);\n  }\n}\n\n// Special assert which checks for existence and throw existence error\nexport function assertExists<T>(condition: T, message = \"\"): asserts condition is NonNullable<T> {\n  if (!exists(condition)) throw new ExistenceError(message);\n}\n\n// Ignore only existence errors. If thrown properly this can be used to convert a non existent value to undefined.\nexport function ignoreExistenceError<X>(call: () => X): X | undefined {\n  try {\n    return call();\n  } catch (err) {\n    if (err instanceof ExistenceError) return undefined;\n    throw err;\n  }\n}\n\n// same function but for async calls\nexport async function ignoreExistenceErrorAsync<X>(call: () => X): Promise<X | undefined> {\n  try {\n    return await call();\n  } catch (err) {\n    if (err instanceof ExistenceError) return undefined;\n    throw err;\n  }\n}\n","import { JsonRpcSigner, BigNumber, Web3Provider, FallbackProvider } from \"./ethers\";\nimport type { erc20, sortedRequests } from \"../services\";\nimport { Request, OracleInterface } from \"./interfaces\";\nimport type Multicall2 from \"../../multicall2\";\nimport { Context, Memory } from \"./statemachine\";\nimport { RequestState, RequestKey } from \"../../clients/optimisticOracle\";\n\n// create partial picker: https://stackoverflow.com/questions/43159887/make-a-single-property-optional-in-typescript\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport { Context, Memory };\n\nexport type ChainServices = {\n  multicall2: Multicall2;\n  provider: FallbackProvider;\n  erc20s: Record<string, erc20.Erc20>;\n  optimisticOracle: OracleInterface;\n};\n\nexport type Services = {\n  sortedRequests?: sortedRequests.SortedRequests;\n  chains?: Record<number, Partial<ChainServices>>;\n};\n\n// this is required data in order to add a new chain to users wallet\nexport type ChainMetadata = {\n  chainId: number;\n  chainName: string;\n  // require at least 1 url\n  rpcUrls: [string, ...string[]];\n  blockExplorerUrls: [string, ...string[]];\n  nativeCurrency: {\n    name: string;\n    symbol: string;\n    decimals: number;\n  };\n};\n\nexport type ChainConfig = ChainMetadata & {\n  checkTxIntervalSec: number;\n  multicall2Address?: string;\n  optimisticOracleAddress: string;\n  // specify a block number which we do not care about blocks before this. This effectively prevents listing\n  // requests older than this. If not specified, we will lookback to block 0 when considering request history.\n  earliestBlockNumber?: number;\n  maxEventRangeQuery?: number;\n  disableFetchEventBased?: boolean;\n};\n\nexport type InputRequestWithOracleType = InputRequest & { oracleType: OracleType };\nexport type RequestWithOracleType = Request & { oracleType: OracleType };\nexport type RequestsWithOracleType = RequestWithOracleType[];\n// partial config lets user omit some fields which we can infer internally using contracts-frontend\nexport type PartialChainConfig = PartialBy<ChainConfig, \"chainId\" | \"checkTxIntervalSec\" | \"earliestBlockNumber\">;\n\nexport enum OracleType {\n  Optimistic = \"Optimistic\",\n  Skinny = \"Skinny\",\n  OptimisticV2 = \"OptimisticV2\",\n}\n// config definition\nexport type Config = {\n  chains: Record<number, ChainConfig>;\n  oracleType: OracleType;\n};\n\nexport type PartialConfig = {\n  chains: Record<number, PartialChainConfig>;\n};\n\nexport type PartialConfigTable = {\n  [key in OracleType]?: PartialConfig;\n};\nexport type Balances = Record<string, BigNumber>;\n\nexport type User = {\n  address: string;\n  chainId: number;\n  signer: JsonRpcSigner;\n  provider: Web3Provider;\n};\n\nexport enum Flag {\n  MissingRequest = \"MissingRequest\", // the client does not know the request, use client.setActiveRequest\n  MissingUser = \"MissingUser\", // client does not have user data, use client.setUser\n  WrongChain = \"WrongChain\", // user and request chain ids do not match, switch chains with client.switchOrAddChain\n  CanPropose = \"CanPropose\", // The on chain request is in a state where someone could propose, use client.proposePrice\n  CanDispute = \"CanDispute\", // The on chain request is in a state where someone could dispute, use client.disputePrice\n  CanSettle = \"CanSettle\", // The on chain request is in a stae where someone could settle the request.\n  InDvmVote = \"InDvmVote\", // Proposed answer has been disputed and passed to dvm for full vote.\n  RequestSettled = \"RequestSettled\", // Request is finalized, no more changes.\n  InsufficientBalance = \"InsufficientBalance\", // The user does not have enough balance to cover bond collateral for dispute/propose\n  InsufficientApproval = \"InsufficientApproval\", // The oracle contract does not have enough approval to cover bond for dispute/propose, use client.approve\n  ChainChangeInProgress = \"ChainChangeInProgress\", // The user is changing his chain\n  ProposalTxInProgress = \"ProposalTxInProgress\", // The user is sending a proposal tx\n  ApprovalTxInProgress = \"ApprovalTxInProgress\", // The user is sending an approval tx\n  DisputeTxInProgress = \"DisputeTxInProgress\", // The user is sending a dispute tx\n}\nexport type Flags = Record<Flag, boolean>;\n\nexport type InputRequest = RequestKey & { chainId: number };\n\nexport type Inputs = {\n  request: InputRequest;\n  user: Partial<User>;\n};\n\nexport type Erc20Props = {\n  address: string;\n  symbol: string;\n  name: string;\n  decimals: number;\n  totalSupply: BigNumber;\n};\n\nexport type Erc20 = {\n  props: Partial<Erc20Props>;\n  allowances: Record<string, Balances>;\n  balances: Balances;\n};\n\nexport { RequestState };\n\nexport type OptimisticOracle = {\n  address: string;\n  defaultLiveness: BigNumber;\n  requests: Record<string, Request>;\n};\n\nexport type Chain = {\n  erc20s: Record<string, Partial<Erc20>>;\n  optimisticOracle: Partial<OptimisticOracle>;\n  currentTime: BigNumber;\n};\n\nexport type State = Partial<{\n  error: Error;\n  inputs: Partial<Inputs>;\n  chains: Record<number, Partial<Chain>>;\n  config: Config;\n  services: Services;\n  commands: Record<string, Context<unknown, unknown & Memory>>;\n  descendingRequests: Request[];\n}>;\n","import type { ContextClient } from \"../services/statemachines/utils\";\n\n// memory can be any non primitive type or undefined\n// eslint-disable-next-line\nexport type Memory = object | undefined;\n\nexport enum ContextType {\n  setUser = \"setUser\",\n  setActiveRequest = \"setActiveRequest\",\n  approve = \"approve\",\n  clearUser = \"clearUser\",\n  disputePrice = \"disputePrice\",\n  proposePrice = \"proposePrice\",\n  switchOrAddChain = \"switchOrAddChain\",\n  pollActiveRequest = \"pollActiveRequest\",\n  pollActiveUser = \"pollActiveUser\",\n  fetchPastEvents = \"fetchPastEvents\",\n  pollNewEvents = \"pollNewEvents\",\n  setActiveRequestByTransaction = \"setActiveRequestByTransaction\",\n  settle = \"settle\",\n  updateActiveRequest = \"updateActiveRequest\",\n  fetchEventBased = \"fetchEventBased\",\n}\n\nexport type ContextProps = {\n  id: string;\n  user?: string;\n  type: ContextType;\n  state: \"done\" | \"error\" | string;\n  done: boolean;\n  created: number;\n  updated?: number;\n  error?: Error;\n  sleep?: number;\n};\n\nexport type Context<P = undefined, M extends Memory = undefined> = ContextProps & {\n  memory: M;\n  params: P;\n};\n\nexport type Handler<P = undefined, M extends Memory = undefined> = (\n  params: P,\n  memory: M,\n  client: ContextClient\n) => string | undefined | void | Promise<string | undefined | void>;\n\nexport type Handlers<P = undefined, M extends Memory = undefined> = Record<string, Handler<P, M>> & {\n  start: Handler<P, M>;\n};\n\nexport type Step<P = undefined, M extends Memory = undefined> = (\n  context: Context<P, M>,\n  now: number\n) => Promise<Context<P, M>>;\n\nexport type Emit<P = undefined, M extends Memory = undefined> = (context: Context<P, M>) => void;\n","import assert from \"assert\";\nimport { ethers } from \"ethers\";\nimport sortedLastIndexBy from \"lodash/sortedLastIndexBy\";\nimport { ignoreExistenceError } from \"./errors\";\n// this request id does not include chain id\nexport { requestId } from \"../clients/optimisticOracle\";\n\nimport {\n  State,\n  RequestState,\n  Flag,\n  Flags,\n  PartialChainConfig,\n  ChainConfig,\n  PartialConfig,\n  ChainMetadata,\n  Config,\n  OracleType,\n} from \"./types/state\";\nimport type { Provider, TransactionReceipt, BigNumberish } from \"./types/ethers\";\nimport { ContextType } from \"./types/statemachine\";\nimport { Read } from \"./store\";\n\nexport const getAddress = ethers.utils.getAddress;\nexport const hexValue = ethers.utils.hexValue;\n\nexport function initFlags(): Flags {\n  return {\n    [Flag.MissingRequest]: false,\n    [Flag.MissingUser]: false,\n    [Flag.WrongChain]: false,\n    [Flag.CanPropose]: false,\n    [Flag.CanDispute]: false,\n    [Flag.CanSettle]: false,\n    [Flag.InDvmVote]: false,\n    [Flag.RequestSettled]: false,\n    [Flag.InsufficientBalance]: false,\n    [Flag.InsufficientApproval]: false,\n    [Flag.ProposalTxInProgress]: false,\n    [Flag.ApprovalTxInProgress]: false,\n    [Flag.DisputeTxInProgress]: false,\n    [Flag.ChainChangeInProgress]: false,\n  };\n}\n\nexport const nowS = (now = Date.now()): number => Math.floor(now / 1000);\n\n// reduce global state into important UI boolean states. this should never throw errors.\nexport function getFlags(state: State): Record<Flag, boolean> {\n  const read = new Read(state);\n  const flags = initFlags();\n\n  const signer = ignoreExistenceError(read.signer);\n  flags[Flag.MissingUser] = signer ? false : true;\n\n  const inputRequest = ignoreExistenceError(read.inputRequest);\n  flags[Flag.MissingRequest] = inputRequest ? false : true;\n\n  const userChainId = ignoreExistenceError(read.userChainId);\n  const requestChainId = ignoreExistenceError(read.requestChainId);\n  flags[Flag.WrongChain] = userChainId && requestChainId ? userChainId !== requestChainId : false;\n\n  const request = ignoreExistenceError(read.request);\n\n  // these are a bit redundant with request state, but just an alternate way to see current request state\n  flags[Flag.CanPropose] = request?.state === RequestState.Requested;\n  flags[Flag.CanDispute] = request?.state === RequestState.Proposed;\n  flags[Flag.CanSettle] = request?.state === RequestState.Resolved || request?.state === RequestState.Expired;\n  flags[Flag.InDvmVote] = request?.state === RequestState.Disputed;\n  flags[Flag.RequestSettled] = request?.state === RequestState.Settled;\n\n  if (request && request.bond && request.finalFee) {\n    const totalBond = request.bond.add(request.finalFee);\n    const userCollateralBalance = ignoreExistenceError(read.userCollateralBalance);\n    const userCollateralAllowance = ignoreExistenceError(read.userCollateralAllowance);\n    flags[Flag.InsufficientBalance] = userCollateralBalance ? userCollateralBalance.lt(totalBond) : false;\n    flags[Flag.InsufficientApproval] = userCollateralAllowance ? userCollateralAllowance.lt(totalBond) : false;\n  }\n\n  const userAddress = ignoreExistenceError(read.userAddress);\n  const commands = ignoreExistenceError(() => read.filterCommands({ done: false, user: userAddress }));\n  if (userAddress && commands) {\n    commands.forEach((command) => {\n      if (!flags[Flag.ProposalTxInProgress] && command.type === ContextType.proposePrice) {\n        flags[Flag.ProposalTxInProgress] = true;\n      }\n      if (!flags[Flag.DisputeTxInProgress] && command.type === ContextType.disputePrice) {\n        flags[Flag.DisputeTxInProgress] = true;\n      }\n      if (!flags[Flag.ApprovalTxInProgress] && command.type === ContextType.approve) {\n        flags[Flag.ApprovalTxInProgress] = true;\n      }\n      if (!flags[Flag.ChainChangeInProgress] && command.type === ContextType.switchOrAddChain) {\n        flags[Flag.ChainChangeInProgress] = true;\n      }\n    });\n  }\n\n  return flags;\n}\n\nexport function getMulticall2Address(chainId: number): string {\n  switch (chainId.toString()) {\n    case \"1\":\n      return getAddress(\"0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696\");\n    case \"4\":\n      return getAddress(\"0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696\");\n    case \"5\":\n      return getAddress(\"0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696\");\n    case \"42\":\n      return getAddress(\"0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696\");\n    default:\n      throw new Error(`No address found for deployment Multicall2 on chainId ${chainId}`);\n  }\n}\ntype AddressGetter = (chainId: number) => string;\ninterface AddressGetters {\n  getMulticall2Address: AddressGetter;\n}\n\nexport const DefaultChainConfig = ({ getMulticall2Address }: AddressGetters) => (\n  chainId: number,\n  chainConfig: PartialChainConfig\n): ChainConfig => {\n  let multicall2Address = chainConfig.multicall2Address;\n  try {\n    multicall2Address = multicall2Address || getMulticall2Address(chainId);\n  } catch (err) {\n    // ignore, multicall optional\n  }\n\n  const checkTxIntervalSec = chainConfig.checkTxIntervalSec || 5;\n\n  return {\n    ...chainConfig,\n    chainId,\n    multicall2Address,\n    checkTxIntervalSec,\n  };\n};\n\nexport const DefaultConfig = (getters: AddressGetters) => (config: PartialConfig, oracleType: OracleType): Config => {\n  return Object.entries(config.chains).reduce(\n    (config: Config, [chainId, chainConfig]) => {\n      config.chains[Number(chainId)] = DefaultChainConfig(getters)(Number(chainId), chainConfig);\n      return config;\n    },\n    { ...config, chains: {}, oracleType }\n  );\n};\n\nexport class TransactionConfirmer {\n  constructor(private provider: Provider) {}\n  async getReceipt(hash: string): Promise<TransactionReceipt> {\n    return this.provider.getTransactionReceipt(hash);\n  }\n  async isConfirmed(hash: string, confirmations = 1): Promise<false | TransactionReceipt> {\n    try {\n      const receipt = await this.getReceipt(hash);\n      if (receipt.confirmations >= confirmations) return receipt;\n    } catch (err) {\n      // do nothing\n    }\n    return false;\n  }\n}\n\nexport function chainConfigToChainMetadata(config: ChainConfig): ChainMetadata {\n  const {\n    // remove extra fields\n    checkTxIntervalSec,\n    multicall2Address,\n    optimisticOracleAddress,\n    earliestBlockNumber,\n    maxEventRangeQuery,\n    ...chainMetadata\n  } = config;\n  return chainMetadata;\n}\n\n// This state is meant for adjusting a start/end block when querying events. Some apis will fail if the range\n// is too big, so the following functions will adjust range dynamically.\nexport type RangeState = {\n  startBlock: number;\n  endBlock: number;\n  maxRange: number;\n  currentRange: number;\n  currentStart: number; // This is the start value you want for your query.\n  currentEnd: number; // this is the end value you want for your query.\n  done: boolean; // Signals we successfully queried the entire range.\n  multiplier?: number; // Multiplier increases or decreases range by this value, depending on success or failure\n};\n\n/**\n * rangeStart. This starts a new range query and sets defaults for state.  Use this as the first call before starting your queries\n *\n * @param {Pick} state\n * @returns {RangeState}\n */\nexport function rangeStart(\n  state: Pick<RangeState, \"startBlock\" | \"endBlock\" | \"multiplier\"> & { maxRange?: number }\n): RangeState {\n  const { startBlock, endBlock, multiplier = 2 } = state;\n  if (state.maxRange && state.maxRange > 0) {\n    const range = endBlock - startBlock;\n    assert(range > 0, \"End block must be higher than start block\");\n    const currentRange = Math.min(state.maxRange, range);\n    const currentStart = endBlock - currentRange;\n    const currentEnd = endBlock;\n    return {\n      done: false,\n      startBlock,\n      endBlock,\n      maxRange: state.maxRange,\n      currentRange,\n      currentStart,\n      currentEnd,\n      multiplier,\n    };\n  } else {\n    // the largest range we can have, since this is the users query for start and end\n    const maxRange = endBlock - startBlock;\n    assert(maxRange > 0, \"End block must be higher than start block\");\n    const currentStart = startBlock;\n    const currentEnd = endBlock;\n    const currentRange = maxRange;\n\n    return {\n      done: false,\n      startBlock,\n      endBlock,\n      maxRange,\n      currentRange,\n      currentStart,\n      currentEnd,\n      multiplier,\n    };\n  }\n}\n/**\n * rangeSuccessDescending. We have 2 ways of querying events, from oldest to newest, or newest to oldest. Typically we want them in order, from\n * oldest to newest, but for this particular case we want them newest to oldest, ie descending ( larger timestamp to smaller timestamp).\n * This function will increase the range between start/end block and return a new start/end to use since by calling this you are signalling\n * that the last range ended in a successful query.\n *\n * @param {RangeState} state\n * @returns {RangeState}\n */\nexport function rangeSuccessDescending(state: RangeState): RangeState {\n  const { startBlock, currentStart, maxRange, currentRange, multiplier = 2 } = state;\n  // we are done if we succeeded querying where the currentStart matches are initial start block\n  const done = currentStart <= startBlock;\n  // increase range up to max range for every successful query\n  const nextRange = Math.min(Math.ceil(currentRange * multiplier), maxRange);\n  // move our end point to the previously successful start, ie moving from newest to oldest\n  const nextEnd = currentStart;\n  // move our start block to the next range down\n  const nextStart = Math.max(nextEnd - nextRange, startBlock);\n  return {\n    ...state,\n    currentStart: nextStart,\n    currentEnd: nextEnd,\n    currentRange: nextRange,\n    done,\n  };\n}\n/**\n * rangeFailureDescending. Like the previous function, this will decrease the range between start/end for your query, because you are signalling\n * that the last query failed. It will also keep the end of your range the same, while moving the start range up. This is why\n * its considered descending, it will attempt to move from end to start, rather than start to end.\n *\n * @param {RangeState} state\n * @returns {RangeState}\n */\nexport function rangeFailureDescending(state: RangeState): RangeState {\n  const { startBlock, currentEnd, currentRange, multiplier = 2 } = state;\n  const nextRange = Math.floor(currentRange / multiplier);\n  // this will eventually throw an error if you keep calling this function, which protects us against re-querying a broken api in a loop\n  assert(nextRange > 0, \"Range must be above 0\");\n  // we stay at the same end block\n  const nextEnd = currentEnd;\n  // move our start block closer to the end block, shrinking the range\n  const nextStart = Math.max(nextEnd - nextRange, startBlock);\n  return {\n    ...state,\n    currentStart: nextStart,\n    currentEnd: nextEnd,\n    currentRange: nextRange,\n  };\n}\n\n/**\n * eventKey. Make a unique and sortable identifier string for an event\n *\n * @param {Event} event\n * @returns {string} - the unique id\n */\nexport function eventKey(event: {\n  blockNumber: BigNumberish;\n  transactionIndex: BigNumberish;\n  logIndex: BigNumberish;\n}): string {\n  return [\n    // we pad these because numbers of varying lengths will not sort correctly, ie \"10\" will incorrectly sort before \"9\", but \"09\" will be correct.\n    event.blockNumber.toString().padStart(16, \"0\"),\n    event.transactionIndex.toString().padStart(16, \"0\"),\n    event.logIndex?.toString().padStart(16, \"0\"),\n    // ~ is the last printable ascii char, so it does not interfere with sorting\n  ].join(\"~\");\n}\n/**\n * insertOrdered. Inserts items in an array maintaining sorted order, in this case lowest to highest. Does not check duplicates.\n * Mainly used for caching all known events, in order of oldest to newest.\n *\n * @param {T[]} array\n * @param {T} element\n * @param {Function} orderBy\n */\nexport function insertOrderedAscending<T>(array: T[], element: T, orderBy: (element: T) => string | number): T[] {\n  const index = sortedLastIndexBy(array, element, orderBy);\n  array.splice(index, 0, element);\n  return array;\n}\nexport function isUnique<T>(array: T[], element: T, id: (element: T) => string | number): boolean {\n  const elementId = id(element);\n  const found = array.find((next: T) => {\n    return id(next) === elementId;\n  });\n  return found === undefined;\n}\n\nexport function isSupportedOracleType(oracleType: string): oracleType is OracleType {\n  return oracleType in OracleType;\n}\n","import { erc20 } from \"../../clients\";\nimport Multicall2 from \"../../multicall2\";\nimport { BatchReadWithErrors, BatchReadWithErrorsType, Calls } from \"../../utils\";\nimport { Provider, Signer, BigNumberish, TransactionResponse } from \"../types/ethers\";\nimport { Erc20Props } from \"../types/state\";\n\nconst batchProps: Calls = [[\"symbol\"], [\"name\"], [\"decimals\"], [\"totalSupply\"]];\nexport class Erc20 {\n  public contract: erc20.Instance;\n  constructor(protected provider: Provider, public readonly address: string) {\n    this.contract = erc20.connect(address, provider);\n  }\n  async approve(signer: Signer, spender: string, amount: BigNumberish): Promise<TransactionResponse> {\n    const contract = erc20.connect(this.address, signer);\n    return contract.approve(spender, amount);\n  }\n  async getProps(): Promise<Erc20Props> {\n    const { contract } = this;\n    return {\n      address: this.address,\n      symbol: await contract.callStatic.symbol(),\n      name: await contract.callStatic.name(),\n      decimals: await contract.callStatic.decimals(),\n      totalSupply: await contract.callStatic.totalSupply(),\n    };\n  }\n}\nexport class Erc20Multicall extends Erc20 {\n  private batchRead: BatchReadWithErrorsType;\n  constructor(provider: Provider, address: string, private multicall2: Multicall2) {\n    super(provider, address);\n    this.batchRead = BatchReadWithErrors(multicall2)(this.contract);\n  }\n  async getProps(): Promise<Erc20Props> {\n    return {\n      ...(await this.batchRead<Erc20Props>(batchProps)),\n      address: this.address,\n    };\n  }\n}\nexport function factory(provider: Provider, address: string, multicall2?: Multicall2): Erc20 {\n  if (!multicall2) return new Erc20(provider, address);\n  return new Erc20Multicall(provider, address, multicall2);\n}\n","import type * as ethersTypes from \"../types/ethers\";\nimport * as state from \"../types/state\";\nimport * as statemachine from \"../types/statemachine\";\n\nimport { requestId } from \"../utils\";\nimport { factory as Erc20Factory } from \"../services/erc20\";\nimport Multicall2 from \"../../multicall2\";\nimport { SortedRequests } from \"../services/sortedRequests\";\nimport type { OracleInterface, Request, Requests } from \"../types/interfaces\";\n\n// This file contains composable and type safe state writers which mirror the state in types/state.\n// Each component takes in 1 parameters, state and you can include any number of functions to operate on the state.\n// Some things to consider:\n// 1. State can be nested, but it should strictly one direction, each class should ideally only operate on its direct state object.\n// 2. The parent can return new components, but its responsible for initializing the state for the child.\n// 3. You can modify this.state in the component thanks to immer, but you cannot set this.state to a new object, only its properties.\n\nexport class User {\n  constructor(private state: Partial<state.User>) {}\n  set(data: Partial<state.User>): void {\n    // note that this is done because we cannot replace this.state = data or immer loses visibility to the change.\n    if (data.chainId) this.chainId(data.chainId);\n    if (data.address) this.address(data.address);\n    if (data.signer) this.signer(data.signer);\n    if (data.provider) this.provider(data.provider);\n  }\n  clear(): void {\n    delete this.state.chainId;\n    delete this.state.address;\n    delete this.state.signer;\n    delete this.state.provider;\n  }\n  chainId(chainId: number): void {\n    this.state.chainId = chainId;\n  }\n  address(address: string): void {\n    this.state.address = address;\n  }\n  signer(signer: ethersTypes.JsonRpcSigner): void {\n    this.state.signer = signer;\n  }\n  provider(provider: ethersTypes.Web3Provider): void {\n    this.state.provider = provider;\n  }\n}\nexport class Balances {\n  constructor(private state: Partial<state.Balances>) {}\n  set(address: string, amount: ethersTypes.BigNumber): void {\n    this.state[address] = amount;\n  }\n}\nexport class Erc20 {\n  constructor(private state: Partial<state.Erc20>) {}\n  props(data: state.Erc20[\"props\"]): void {\n    this.state.props = data;\n  }\n  balance(account: string, amount: ethersTypes.BigNumber): void {\n    if (!this.state.balances) this.state.balances = {};\n    new Balances(this.state.balances).set(account, amount);\n  }\n  allowance(account: string, spender: string, amount: ethersTypes.BigNumber): void {\n    if (!this.state.allowances) this.state.allowances = {};\n    if (!this.state.allowances[spender]) this.state.allowances[spender] = {};\n    new Balances(this.state.allowances[spender]).set(account, amount);\n  }\n}\nexport class OptimisticOracle {\n  constructor(private state: Partial<state.OptimisticOracle>) {}\n  address(address: string): void {\n    this.state.address = address;\n  }\n  request(request: Request): void {\n    const id = requestId(request);\n    if (!this.state.requests) this.state.requests = {};\n    // merge data in rather than replace\n    this.state.requests[id] = { ...this.state.requests[id], ...request };\n  }\n  defaultLiveness(defaultLiveness: ethersTypes.BigNumber): void {\n    this.state.defaultLiveness = defaultLiveness;\n  }\n}\nexport class Chain {\n  constructor(private state: Partial<state.Chain>) {}\n  erc20s(address: string): Erc20 {\n    if (!this.state?.erc20s) this.state.erc20s = {};\n    if (!this.state.erc20s?.[address]) this.state.erc20s[address] = {};\n    return new Erc20(this.state.erc20s[address]);\n  }\n  optimisticOracle(): OptimisticOracle {\n    if (!this.state?.optimisticOracle) this.state.optimisticOracle = {};\n    return new OptimisticOracle(this.state.optimisticOracle);\n  }\n  currentTime(currentTime: ethersTypes.BigNumber): void {\n    this.state.currentTime = currentTime;\n  }\n}\nexport class Inputs {\n  constructor(private state: Partial<state.Inputs>) {}\n  request(params: state.Inputs[\"request\"]): void {\n    this.state.request = params;\n  }\n  user(): User {\n    if (!this.state.user) this.state.user = {};\n    return new User(this.state.user);\n  }\n}\n\nexport class Services {\n  constructor(private state: Partial<state.ChainServices>) {}\n  provider(provider: ethersTypes.FallbackProvider): void {\n    this.state.provider = provider;\n  }\n  erc20s(address: string): void {\n    if (!this.state?.provider) return;\n    if (!this.state?.erc20s) this.state.erc20s = {};\n    // only add this once\n    if (this.state?.erc20s[address]) return;\n    this.state.erc20s[address] = Erc20Factory(this.state.provider, address, this.state.multicall2);\n  }\n  optimisticOracle(optimisticOracle: OracleInterface): void {\n    if (this.state.optimisticOracle) return;\n    this.state.optimisticOracle = optimisticOracle;\n  }\n  multicall2(multicall2Address?: string): void {\n    if (!multicall2Address) return;\n    if (this.state.multicall2) return;\n    if (!this.state.provider) return;\n    this.state.multicall2 = new Multicall2(multicall2Address, this.state.provider);\n  }\n}\n\n/**\n * Write. The main writer class for this applications global state object. Composes classes that initialize, validate\n * and simplify changes to the global state. This class modifies state directly, and really is only useful in combination with immer.\n */\nexport default class Write {\n  constructor(private state: state.State) {}\n  chains(chainId: number): Chain {\n    if (!this.state?.chains) this.state.chains = {};\n    if (!this.state?.chains?.[chainId]) this.state.chains[chainId] = {};\n    return new Chain(this.state.chains[chainId]);\n  }\n  inputs(): Inputs {\n    if (!this.state.inputs) this.state.inputs = {};\n    return new Inputs(this.state.inputs);\n  }\n  config(config: state.Config): void {\n    this.state.config = config;\n  }\n  services(chainId: number): Services {\n    if (!this.state.services) this.state.services = {};\n    if (!this.state.services.chains) this.state.services.chains = {};\n    if (!this.state.services.chains[chainId]) this.state.services.chains[chainId] = {};\n    return new Services(this.state.services.chains[chainId]);\n  }\n  error(error?: Error): void {\n    this.state.error = error;\n  }\n  command(context: statemachine.Context<unknown, unknown & statemachine.Memory>): void {\n    if (!this.state.commands) this.state.commands = {};\n    this.state.commands[context.id] = context;\n  }\n  sortedRequestsService(sortedRequests: SortedRequests): void {\n    if (this.state?.services?.sortedRequests) return;\n    // only want to add this once\n    this.state.services = { sortedRequests };\n  }\n  descendingRequests(sortedRequests: Requests): void {\n    this.state.descendingRequests = sortedRequests;\n  }\n}\n","import filter from \"lodash/filter\";\n\nimport type {\n  State,\n  Chain,\n  InputRequest,\n  Erc20Props,\n  ChainConfig,\n  Context,\n  Memory,\n  User,\n  OracleType,\n} from \"../types/state\";\nimport type { JsonRpcSigner, BigNumber, Provider } from \"../types/ethers\";\nimport { TransactionConfirmer, requestId } from \"../utils\";\nimport { OracleInterface, Request, Requests } from \"../types/interfaces\";\nimport { Erc20 } from \"../services/erc20\";\nimport { SortedRequests } from \"../services/sortedRequests\";\nimport { assertExists } from \"../errors\";\n\n// This is a typescript compatible way of pulling out values from the global state object, essentially\n// forming a basic API. Most calls are parameterless, requiring first setting state which determines, the\n// user/chain, etc of the query.\n\nexport default class Read {\n  constructor(private state: State) {}\n  chainConfig = (optionalChainId?: number): ChainConfig => {\n    const chainId = optionalChainId || this.requestChainId();\n    const config = this.state?.config?.chains?.[chainId];\n    assertExists(config, \"No config set for chain: \" + chainId);\n    return config;\n  };\n  oracleType = (): OracleType => {\n    const source = this.state?.config?.oracleType;\n    assertExists(source, \"No oracle name set on config\");\n    return source;\n  };\n  requestChainId = (): number => {\n    const chainId = this.state?.inputs?.request?.chainId;\n    assertExists(chainId, \"ChainId is not set on request\");\n    return chainId;\n  };\n  user = (): Partial<User> => {\n    const result = this.state?.inputs?.user;\n    assertExists(result, \"user not set\");\n    return result;\n  };\n  userChainId = (): number => {\n    const chainId = this.state?.inputs?.user?.chainId;\n    assertExists(chainId, \"ChainId is not set\");\n    return chainId;\n  };\n  requestChain = (optionalChainId?: number): Partial<Chain> => {\n    const chainId = optionalChainId || this.requestChainId();\n    const chain = this.state?.chains?.[chainId];\n    assertExists(chain, \"Chain not set\");\n    return chain;\n  };\n  userAddress = (): string => {\n    const address = this.state?.inputs?.user?.address;\n    assertExists(address, \"User address is not set\");\n    return address;\n  };\n  oracleAddress = (optionalChainId?: number): string => {\n    const chain = this.requestChain(optionalChainId);\n    const address = chain?.optimisticOracle?.address;\n    assertExists(address, \"Optimistic oracle address not set\");\n    return address;\n  };\n  signer = (): JsonRpcSigner => {\n    const signer = this.state?.inputs?.user?.signer;\n    assertExists(signer, \"Signer is not set\");\n    return signer;\n  };\n  inputRequest = (): InputRequest => {\n    const input = this.state?.inputs?.request;\n    assertExists(input, \"Input request is not set\");\n    return input;\n  };\n  defaultLiveness = (): BigNumber => {\n    const chain = this.requestChain();\n    const liveness = chain?.optimisticOracle?.defaultLiveness;\n    assertExists(liveness, \"Optimistic oracle defaultLiveness set\");\n    return liveness;\n  };\n  request = (): Request => {\n    const chain = this.requestChain();\n    const input = this.inputRequest();\n    const id = requestId(input);\n    const request = chain?.optimisticOracle?.requests?.[id];\n    assertExists(request, \"Request has not been fetched\");\n    return request;\n  };\n  collateralProps = (): Partial<Erc20Props> => {\n    const request = this.request();\n    assertExists(request.currency, \"Request currency not set\");\n    const chain = this.requestChain();\n    const props = chain.erc20s?.[request.currency]?.props;\n    assertExists(props, \"Props not set on collateral token\");\n    return props;\n  };\n  userCollateralBalance = (): BigNumber => {\n    const request = this.request();\n    assertExists(request.currency, \"Request currency not set\");\n    const chain = this.requestChain();\n    const user = this.userAddress();\n    const balance = chain?.erc20s?.[request.currency]?.balances?.[user];\n    assertExists(balance, \"Balance not set on collateral token for user\");\n    return balance;\n  };\n  userCollateralAllowance = (): BigNumber => {\n    const request = this.request();\n    assertExists(request.currency, \"Request currency not set\");\n    const chain = this.requestChain();\n    const user = this.userAddress();\n    const oracle = this.oracleAddress();\n    const allowance = chain?.erc20s?.[request.currency]?.allowances?.[oracle]?.[user];\n    assertExists(allowance, \"Allowance not set on user on collateral token for oracle\");\n    return allowance;\n  };\n  oracleService = (optionalChainId?: number): OracleInterface => {\n    const chainId = optionalChainId || this.requestChainId();\n    const result = this.state?.services?.chains?.[chainId]?.optimisticOracle;\n    assertExists(result, \"Optimistic Oracle Not found on chain \" + chainId);\n    return result;\n  };\n  collateralService = (): Erc20 => {\n    const chainId = this.requestChainId();\n    const request = this.request();\n    assertExists(request.currency, \"Request currency not set\");\n    const result = this.state?.services?.chains?.[chainId]?.erc20s?.[request.currency];\n    assertExists(result, \"Token not supported on chain \" + chainId);\n    return result;\n  };\n  command = (id: string): Context<unknown, unknown & Memory> => {\n    const result = this.state?.commands?.[id];\n    assertExists(result, \"Unable to find command \" + id);\n    return result;\n  };\n  tokenService = (chainId: number, address: string): Erc20 => {\n    const result = this.state?.services?.chains?.[chainId]?.erc20s?.[address];\n    assertExists(result, \"Token service not found: \" + [chainId, address].join(\".\"));\n    return result;\n  };\n  provider = (chainId: number): Provider => {\n    const result = this.state?.services?.chains?.[chainId]?.provider;\n    assertExists(result, \"Provider not found on chainid: \" + chainId);\n    return result;\n  };\n  transactionService = (chainId: number): TransactionConfirmer => {\n    const provider = this.provider(chainId);\n    return new TransactionConfirmer(provider);\n  };\n  listCommands = (): Context<unknown, unknown & Memory>[] => {\n    return Object.values(this.state?.commands || []);\n  };\n  filterCommands = (search: { user?: string; done?: boolean }): Context<unknown, unknown & Memory>[] => {\n    return filter(this.listCommands(), search) as Context<unknown, unknown & Memory>[];\n  };\n  chain = (optionalChainId?: number): Partial<Chain> => {\n    const chainId = optionalChainId || this.requestChainId();\n    const chain = this.state?.chains?.[chainId];\n    assertExists(chain, \"No chain for chainId: \" + chainId);\n    return chain;\n  };\n  currentTime = (optionalChainId?: number): BigNumber => {\n    const chainId = optionalChainId || this.requestChainId();\n    const chain = this.chain(chainId);\n    const time = chain?.currentTime;\n    assertExists(time, \"Current time not available on chain: \" + chainId);\n    return time;\n  };\n  sortedRequestsService = (): SortedRequests => {\n    const result = this.state?.services?.sortedRequests;\n    assertExists(result, \"Sorted request service not set\");\n    return result;\n  };\n  listChains = (): number[] => {\n    return Object.keys(this.state?.chains || {}).map(Number);\n  };\n  descendingRequests = (): Requests => {\n    return this.state.descendingRequests || [];\n  };\n  filterRequests = (query: Partial<Request>): Requests => {\n    return filter(this.descendingRequests(), query);\n  };\n}\n","// return true only if value is not null or undefined\nimport { exists } from \"../../utils\";\n\n// we only ignore this specific error type explicitly emitted from reader class, meaning value is undefined\nimport { ignoreExistenceError } from \"../errors\";\nimport type { State } from \"../types/state\";\n\nimport Read from \"./read\";\n\n// This class checks for existence for values you could potentially read. It mirrors the read interface but returns bools from functions.\nexport default class Has {\n  private read: Read;\n  constructor(private state: State) {\n    // by design, reads do not mutate or cause side effects\n    this.read = new Read(state);\n  }\n  inputRequest = (): boolean => {\n    // the rule about reads is they will only throw errors if it cant return the value you request.\n    // If no errors are thrown the read was successful.\n    // Reads will never not return a value without throwing an error, enforced by TS.\n    return exists(ignoreExistenceError(this.read.inputRequest));\n  };\n  sortedRequestsService = (): boolean => {\n    return exists(ignoreExistenceError(this.read.sortedRequestsService));\n  };\n  requestChainId = (): boolean => {\n    return exists(ignoreExistenceError(this.read.requestChainId));\n  };\n  userAddress = (): boolean => {\n    return exists(ignoreExistenceError(this.read.userAddress));\n  };\n  request = (): boolean => {\n    return exists(ignoreExistenceError(this.read.request));\n  };\n  collateralProps = (): boolean => {\n    return exists(ignoreExistenceError(this.read.collateralProps));\n  };\n  defaultLiveness = (): boolean => {\n    return exists(ignoreExistenceError(this.read.defaultLiveness));\n  };\n  currentTime = (): boolean => {\n    return exists(ignoreExistenceError(this.read.currentTime));\n  };\n}\n","import produce from \"immer\";\n\nexport type WriteCallback<S> = (state: S) => void;\nexport type Emit<S> = (state: S, prev: S) => void;\n/**\n * Store. The store is meant to provide a global state that conforms to the type in types/state and\n * allow you to read/write and watch for change events. This uses immer, which manages how the nested\n * object gets updated to allow shallow change detection through nested paths.\n */\nexport default class Store<S> {\n  /**\n   * constructor.\n   *\n   * @param {Emit} emit - Change callback, passes you the current and previous state any time theres a state change.\n   * @param {State} state - The full state type which conforms to the state object.\n   */\n  constructor(private emit: Emit<S>, private state: S) {}\n  /**\n   * write. Allows caller to write to state. This wraps the state in \"immer\" which manages nested updates to state\n   * through a proxy interface. When write is complete, an event is emitted with the current and previous state.\n   *\n   * @param {WriteCallback} cb\n   */\n  write(cb: WriteCallback<S>): void {\n    const prevState = this.state;\n\n    // immer's produce method, takes an object, and passes a draft of that object to the callback. Any changes to the draft\n    // will be returned as the new state at the end of the callback. Changes to this object are optimized to be used in state\n    // for React or other front-end state managers.\n    this.state = produce(this.state, cb);\n\n    // Once state is changed, an event is emitted, this is how we get changes out of the client and also allow for change detection.\n    this.emit(this.state, prevState);\n  }\n  // same as write\n  async writeAsync(cb: WriteCallback<S>): Promise<void> {\n    const prevState = this.state;\n    this.state = await produce(this.state, cb);\n    this.emit(this.state, prevState);\n  }\n  read(): S {\n    return this.state;\n  }\n}\n","import Write from \"./write\";\nimport Read from \"./read\";\nimport Has from \"./has\";\n\nimport Store, { Emit as GenericEmit } from \"./store\";\nimport { State } from \"../types/state\";\n\ntype WriteCallback = (write: Write, state: State) => void;\ntype Emit = GenericEmit<State>;\n\nexport { Write, Store, Read, Emit, WriteCallback, Has };\n\n/**\n * OracleStore. Wraps the store with a specific state shape and passes the Write client through to end user.\n */\nexport default class OracleStore {\n  private store: Store<State>;\n  constructor(private emit: Emit = () => undefined, private state: State = {}) {\n    this.store = new Store<State>(emit, state);\n  }\n  /**\n   * write - Function for updating state.\n   *\n   * @param {WriteCallback} cb - Sends a write client to the caller for safer and easier state mutations rather than the raw object.\n   */\n  write = (cb: WriteCallback): void => {\n    this.store.write((state) => cb(new Write(state), state));\n  };\n  /**\n   * read - Function for reading from state. Returns a read client to the user.\n   *\n   * @returns {Read}\n   */\n  read = (): Read => {\n    return new Read(this.store.read());\n  };\n  /**\n   * get - Function for getting access to the raw state object, not wrapped by the reader class.\n   * State should not be modified directly and treated as read only.\n   *\n   * @returns {State}\n   */\n  get = (): State => {\n    return this.store.read();\n  };\n  /**\n   * has. Checks for existence. Mirrors the read interface, but instead of reading values returns true or false.\n   *\n   * @returns {Has}\n   */\n  has = (): Has => {\n    return new Has(this.store.read());\n  };\n}\n","import Store from \"../store\";\nimport { InputRequest } from \"../types/state\";\nimport { TransactionReceipt } from \"../types/ethers\";\n\nexport class Update {\n  private read: Store[\"read\"];\n  private write: Store[\"write\"];\n  constructor(private store: Store) {\n    this.read = store.read;\n    this.write = store.write;\n  }\n  all = async (): Promise<void> => {\n    await this.oracle();\n    await this.request();\n    await this.collateralProps();\n    await this.userCollateralBalance();\n    await this.oracleAllowance();\n  };\n  request = async (params?: InputRequest): Promise<void> => {\n    const request = params || this.read().inputRequest();\n    const chainId = request.chainId;\n    const oo = this.read().oracleService(chainId);\n    // // pull in data from contract on chain\n    const contractRequest = await oo.fetchRequest(request);\n    this.write((write) => {\n      // create the erc20 service to handle currency\n      if (contractRequest.currency) {\n        write.services(chainId).erc20s(contractRequest.currency);\n      }\n      write\n        .chains(chainId)\n        .optimisticOracle()\n        // update request object with all the data we have about it. order is important,\n        // we want to prioritize latest state pulled from contract.\n        .request({ ...contractRequest });\n    });\n    this.sortedRequests(chainId);\n  };\n  oracle = async (): Promise<void> => {\n    const chainId = this.read().requestChainId();\n    const oo = this.read().oracleService();\n    const { defaultLiveness } = await oo.getProps();\n    this.write((write) => write.chains(chainId).optimisticOracle().defaultLiveness(defaultLiveness));\n  };\n  userCollateralBalance = async (): Promise<void> => {\n    const chainId = this.read().requestChainId();\n    const account = this.read().userAddress();\n    const token = this.read().collateralService();\n    const result = await token.contract.balanceOf(account);\n    this.write((write) => write.chains(chainId).erc20s(token.address).balance(account, result));\n  };\n  collateralProps = async (): Promise<void> => {\n    const chainId = this.read().requestChainId();\n    const token = this.read().collateralService();\n    const props = await token.getProps();\n    this.write((write) => write.chains(chainId).erc20s(token.address).props(props));\n  };\n  oracleAllowance = async (): Promise<void> => {\n    const chainId = this.read().requestChainId();\n    const account = this.read().userAddress();\n    const oracleAddress = this.read().oracleAddress();\n    const token = this.read().collateralService();\n    const result = await token.contract.allowance(account, oracleAddress);\n    this.write((write) => write.chains(chainId).erc20s(token.address).allowance(account, oracleAddress, result));\n  };\n  balance = async (chainId: number, token: string, account: string): Promise<void> => {\n    const tokenService = this.read().tokenService(chainId, token);\n    const result = await tokenService.contract.balanceOf(account);\n    this.write((write) => write.chains(chainId).erc20s(token).balance(account, result));\n  };\n  allowance = async (chainId: number, token: string, account: string, spender: string): Promise<void> => {\n    const tokenService = this.read().tokenService(chainId, token);\n    const result = await tokenService.contract.allowance(account, spender);\n    this.write((write) => write.chains(chainId).erc20s(token).allowance(account, spender, result));\n  };\n  isConfirmed = async (chainId: number, hash: string, confirmations: number): Promise<boolean | TransactionReceipt> => {\n    const txService = this.read().transactionService(chainId);\n    return txService.isConfirmed(hash, confirmations);\n  };\n  // update new events from this range query, will accumulate new events\n  oracleEvents = async (chainId: number, startBlock = 0, endBlock?: number): Promise<void> => {\n    const provider = this.read().provider(chainId);\n    const oracle = this.read().oracleService(chainId);\n    endBlock = endBlock || (await provider.getBlockNumber());\n    await oracle.update(startBlock, endBlock);\n  };\n  // takes all known events, decodes them into requests and puts them into a sorted table. then updates the sorted list.\n  sortedRequests = (chainId: number): void => {\n    const sortedRequestsService = this.read().sortedRequestsService();\n    const oracle = this.read().oracleService(chainId);\n    const requests = oracle.listRequests();\n    const oracleType = this.read().oracleType();\n    Object.values(requests).forEach((value) => {\n      // chains can have colliding keys ( mainly testnet forks), so we always need to append chain to to keep key unique across chains otherwise\n      // collisions will cause overwrites, removing ability to list identical requests across chains.\n      sortedRequestsService.setByRequest({ ...value, oracleType });\n    });\n    // query all known requests and update our state with the entire list.\n    // this is expensive, consider optimizing after proven detrimental.\n    const descendingRequests = sortedRequestsService.descending();\n    this.write((w) => {\n      w.descendingRequests(descendingRequests);\n    });\n  };\n  // this updates the current active request object used in the details page, as new properties might come in from events\n  // current request needs access to things like transation hash, only available through events.\n  activeRequestFromEvents = (params?: InputRequest): void => {\n    const request = params || this.read().inputRequest();\n    const chainId = request.chainId;\n    // pull in request data generated from events\n    const requestIndexData = this.read().oracleService().getRequest(request);\n    // we really only care about a handful of props from event based requests. We also dont want to override\n    // any properties that might overlap with the data queried from the contract.\n    const {\n      requestTx,\n      proposeTx,\n      disputeTx,\n      settleTx,\n      requestBlockNumber,\n      proposeBlockNumber,\n      disputeBlockNumber,\n      settleBlockNumber,\n    } = requestIndexData;\n\n    const update = {\n      ...request,\n      requestTx,\n      proposeTx,\n      disputeTx,\n      settleTx,\n      requestBlockNumber,\n      proposeBlockNumber,\n      disputeBlockNumber,\n      settleBlockNumber,\n    };\n\n    this.write((write) => {\n      write.chains(chainId).optimisticOracle().request(update);\n    });\n  };\n}\n","import { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { User } from \"../../types/state\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\n// require exports for a new context handler\nexport type Params = Partial<User>;\nexport type Memory = undefined;\n\nexport function initMemory(): Memory {\n  return undefined;\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params) {\n      store.write((write) => write.inputs().user().set(params));\n\n      // ignore erorrs caused by data not existing on reads, pass through other errors\n      await ignoreExistenceErrorAsync(update.userCollateralBalance);\n      await ignoreExistenceErrorAsync(update.oracleAllowance);\n\n      return \"done\";\n    },\n  };\n}\n","import Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\n\n// require exports for a new context handler\nexport type Params = undefined;\nexport type Memory = undefined;\n\nexport function initMemory(): Memory {\n  return undefined;\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  return {\n    async start() {\n      store.write((write) => {\n        write.inputs().user().clear();\n      });\n      return \"done\";\n    },\n  };\n}\n","import Store from \"../../store\";\nimport { Inputs } from \"../../types/state\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\n\n// required exports for state machine\nexport type Params = Inputs[\"request\"];\nexport type Memory = undefined;\nexport function initMemory(): Memory {\n  return undefined;\n}\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  return {\n    async start(params: Params) {\n      store.write((write) => write.inputs().request(params));\n      return \"done\";\n    },\n  };\n}\n","import assert from \"assert\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Signer } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\n\nexport type Params = {\n  currency: string;\n  chainId: number;\n  signer: Signer;\n  account: string;\n  spender: string;\n  amount: string;\n  confirmations: number;\n  checkTxIntervalSec: number;\n};\n\nexport type Memory = { hash?: string };\n\nexport function initMemory(): Memory {\n  return {};\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory) {\n      const { chainId, currency, spender, amount, account, signer } = params;\n      assert(chainId === (await signer.getChainId()), \"Signer on wrong chainid\");\n      assert(account === (await signer.getAddress()), \"Signer on wrong account\");\n\n      // create service if it does not exist\n      store.write((w) => w.services(chainId).erc20s(currency));\n      const erc20 = store.read().tokenService(chainId, currency);\n      const tx = await erc20.approve(signer, spender, amount);\n      memory.hash = tx.hash;\n      return \"confirm\";\n    },\n    async confirm(params: Params, memory: Memory, context: ContextClient) {\n      const { chainId, confirmations, checkTxIntervalSec } = params;\n      const { hash } = memory;\n      assert(hash, \"requires hash\");\n      if (await update.isConfirmed(chainId, hash, confirmations)) {\n        return \"update\";\n      }\n      // wait x seconds before running this state again\n      return context.sleep(checkTxIntervalSec * 1000);\n    },\n    async update(params: Params) {\n      const { chainId, currency, spender, account } = params;\n      await update.balance(chainId, currency, account);\n      await update.allowance(chainId, currency, account, spender);\n      return \"done\";\n    },\n  };\n}\n","import assert from \"assert\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Signer, TransactionReceipt } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { InputRequest } from \"../../types/state\";\nimport { ContextClient } from \"./utils\";\n\nexport type Params = InputRequest & {\n  signer: Signer;\n  confirmations: number;\n  currency: string;\n  account: string;\n  checkTxIntervalSec: number;\n};\n\nexport type Memory = { hash?: string; receipt?: TransactionReceipt };\n\nexport function initMemory(): Memory {\n  return {};\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory) {\n      const { requester, identifier, timestamp, ancillaryData, chainId, signer } = params;\n      assert(chainId === (await signer.getChainId()), \"Signer on wrong chainid\");\n\n      const oracle = store.read().oracleService(chainId);\n      const tx = await oracle.disputePrice(signer, { requester, identifier, timestamp, ancillaryData });\n      memory.hash = tx.hash;\n      return \"confirm\";\n    },\n    async confirm(params: Params, memory: Memory, context: ContextClient) {\n      const { chainId, confirmations, checkTxIntervalSec } = params;\n      const { hash } = memory;\n      assert(hash, \"requires hash\");\n      const receipt = await update.isConfirmed(chainId, hash, confirmations);\n      if (receipt) {\n        memory.receipt = receipt as TransactionReceipt;\n        return \"update\";\n      }\n      // wait x seconds before running this state again\n      return context.sleep(checkTxIntervalSec * 1000);\n    },\n    async update(params: Params, memory: Memory) {\n      const { chainId, currency, account } = params;\n      const { receipt } = memory;\n      const oracle = store.read().oracleService(chainId);\n      await update.balance(chainId, currency, account);\n      if (receipt) {\n        oracle.updateFromTransactionReceipt(receipt);\n      }\n      store.write((w) => {\n        w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));\n      });\n      update.sortedRequests(chainId);\n      return \"done\";\n    },\n  };\n}\n","import assert from \"assert\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Signer, TransactionReceipt } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { InputRequest } from \"../../types/state\";\nimport { ContextClient } from \"./utils\";\n\nexport type Params = InputRequest & {\n  signer: Signer;\n  confirmations: number;\n  currency: string;\n  account: string;\n  proposedPrice: string;\n  checkTxIntervalSec: number;\n};\n\nexport type Memory = { hash?: string; receipt?: TransactionReceipt };\n\nexport function initMemory(): Memory {\n  return {};\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory) {\n      const { requester, identifier, timestamp, ancillaryData, chainId, signer, proposedPrice } = params;\n      assert(chainId === (await signer.getChainId()), \"Signer on wrong chainid\");\n      const oracle = store.read().oracleService(chainId);\n      const tx = await oracle.proposePrice(signer, { requester, identifier, timestamp, ancillaryData }, proposedPrice);\n      memory.hash = tx.hash;\n      return \"confirm\";\n    },\n    async confirm(params: Params, memory: Memory, context: ContextClient) {\n      const { chainId, confirmations, checkTxIntervalSec } = params;\n      const { hash } = memory;\n      assert(hash, \"requires hash\");\n      const receipt = await update.isConfirmed(chainId, hash, confirmations);\n      if (receipt) {\n        memory.receipt = receipt as TransactionReceipt;\n        return \"update\";\n      }\n      // wait x seconds before running this state again\n      return context.sleep(checkTxIntervalSec * 1000);\n    },\n    async update(params: Params, memory: Memory) {\n      const { chainId, currency, account } = params;\n      const { receipt } = memory;\n      const oracle = store.read().oracleService(chainId);\n      await update.balance(chainId, currency, account);\n      if (receipt) {\n        oracle.updateFromTransactionReceipt(receipt);\n      }\n      store.write((w) => {\n        w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));\n      });\n      await update.sortedRequests(chainId);\n      return \"done\";\n    },\n  };\n}\n","import Store from \"../../store\";\nimport { Web3Provider } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { chainConfigToChainMetadata, hexValue } from \"../../utils\";\n\nexport type Params = {\n  chainId: number;\n  provider: Web3Provider;\n};\n\nexport type Memory = undefined;\n\nexport function initMemory(): Memory {\n  return undefined;\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  return {\n    async start(params: Params) {\n      const { provider, chainId } = params;\n      try {\n        await provider.send(\"wallet_switchEthereumChain\", [\n          {\n            chainId: hexValue(chainId),\n          },\n        ]);\n        return \"done\";\n      } catch (err) {\n        const error = (err as unknown) as Error & { code: number };\n        if (error.code === -32603 || error.code === 4902) {\n          return \"addAndSwitch\";\n        }\n        throw error;\n      }\n    },\n    async addAndSwitch(params: Params) {\n      const { chainId, provider } = params;\n      const config = store.read().chainConfig(chainId);\n      const chainMetadata = chainConfigToChainMetadata(config);\n      await provider.send(\"wallet_addEthereumChain\", [\n        {\n          ...chainMetadata,\n          chainId: hexValue(chainId),\n        },\n      ]);\n      await provider.send(\"wallet_switchEthereumChain\", [\n        {\n          chainId: hexValue(chainId),\n        },\n      ]);\n      return \"done\";\n    },\n  };\n}\n","// this should only run as a single instance, will continue updating the active request as needed.\n// this is a single poller for requests on all chains\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { RequestState } from \"../../types/state\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\n// required exports for state machine\nexport type Params = undefined;\nexport type Memory = { iterations: number };\nexport function initMemory(): Memory {\n  return { iterations: 0 };\n}\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient): Promise<void | undefined> {\n      const request = await ignoreExistenceErrorAsync(store.read().request);\n      // requests can change externally if not already in one of these states\n      const shouldUpdate = request && request.state !== RequestState.Invalid && request.state !== RequestState.Settled;\n\n      if (shouldUpdate) {\n        await update.request();\n        // count how many times we have updated this request as a sanity check\n        memory.iterations++;\n      }\n\n      const { checkTxIntervalSec = 30 } = (await ignoreExistenceErrorAsync(store.read().chainConfig)) || {};\n      return ctx.sleep(checkTxIntervalSec * 1000);\n    },\n  };\n}\n","// this will attempt to fetch all events down to startBlock in descending order. It will try to reduce the\n// range of blocks queried to prevent errors with the provider. This can sometimes lead to really long query times\n// for providers on chains which are very restrictive about block range.\n// Normally you want to query events in order, ie oldest to newest, but in this case we want to prioritize the\n// newest requests first in the case we cant fetch the whole range. Also we will store all events in order and\n// process them on each iteration, so we should always have a consistent view of request with our currently known events.\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\nimport { Update } from \"../update\";\nimport { rangeStart, rangeSuccessDescending, rangeFailureDescending, RangeState } from \"../../utils\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\nexport type Params = {\n  chainId: number;\n  startBlock?: number;\n  endBlock?: number;\n  maxRange?: number;\n};\n\nexport type Memory = { error?: Error; state?: RangeState; iterations: number };\n\nexport function initMemory(): Memory {\n  return { iterations: 0 };\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient) {\n      const provider = store.read().provider(params.chainId);\n      const { chainId, startBlock = 0, endBlock = await provider.getBlockNumber(), maxRange } = params;\n\n      memory.error = undefined;\n      // we use this wierd range thing because in the case we cant query the entire block range due to provider error\n      // we want to move start block closer to endblock to reduce the range until it stops erroring. These range functions\n      // will do that for us.\n      const rangeState = memory.state || rangeStart({ startBlock, endBlock, maxRange });\n      const { currentStart, currentEnd } = rangeState;\n\n      try {\n        // this just queries events between start and end\n        await update.oracleEvents(chainId, currentStart, currentEnd);\n        // reprocess all known events and create a table of requests from it\n        await update.sortedRequests(chainId);\n\n        // try to update the active request by event data\n        await ignoreExistenceErrorAsync(update.activeRequestFromEvents);\n\n        // we signal that the current range was a success, now move currentStart, currentEnd accordingly\n        // we set multiplier to 1 so we dont grow the range on success, this tends to create more errors and slow down querying\n        memory.state = rangeSuccessDescending({ ...rangeState, multiplier: 1 });\n      } catch (err) {\n        memory.error = (err as unknown) as Error;\n        // the provider threw an error so we will reduce our range by moving startblock closer to endblock next iteration\n        memory.state = rangeFailureDescending(rangeState);\n      }\n      memory.iterations++;\n      // the range functions will tell us when we have successfully queried the entire range of blocks.\n      if (memory?.state?.done) return \"done\";\n      // sleep to let other contexts run, but just resume right after.\n      return ctx.sleep(100);\n    },\n  };\n}\n","// this statemachine will continue to poll for new events from startBlock ( or latest block if not defined).\n// It will maintain memory of the last block it polled for events up to, and use that as the start block for next\n// iteration, while always querying up to the latest block.\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\nimport { Update } from \"../update\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\nexport type Params = {\n  chainId: number;\n  startBlock?: number;\n  pollRateSec?: number;\n};\n\nexport type Memory = { error?: Error; lastBlock?: number; iterations: number };\n\nexport function initMemory(): Memory {\n  return { iterations: 0 };\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient) {\n      // start at the latest block, we have other command to get historical events\n      const { chainId, startBlock, pollRateSec = 50 } = params;\n      const provider = store.read().provider(chainId);\n      const latestBlock = await provider.getBlockNumber();\n      // our current block is the start block, or last known block we have queried up to\n      const currentBlock = memory.lastBlock || startBlock || latestBlock;\n      memory.error = undefined;\n      try {\n        // dont worry about querying if latest and current are the same. This optimization causes wierd effects\n        // during testing, as block number rarely changes unless user moves it manually, giving the impression that events are missed.\n        if (latestBlock !== currentBlock) {\n          // this pulls all events from current to latest block\n          await update.oracleEvents(chainId, currentBlock, latestBlock);\n\n          // we can just try to update the current active request, we dont care if it fails, active request might not be set\n          await ignoreExistenceErrorAsync(update.activeRequestFromEvents);\n\n          // reset our last block seen to the latest (end) block\n          memory.lastBlock = latestBlock;\n          // just count how many successful iterations we do as a kind of sanity check\n          memory.iterations++;\n        } else {\n          // if we dont have a lastblock set, set it to our current block\n          memory.lastBlock = memory.lastBlock || currentBlock;\n        }\n      } catch (err) {\n        // store an error for an iteration if we need to debug. we want to keep polling though.\n        memory.error = (err as unknown) as Error;\n      }\n\n      // update our request table list with all known events\n      // this needs to be done outside the block sorted requests holds requests across different clients\n      await update.sortedRequests(chainId);\n\n      // we dont need to poll these events very fast, so just set to once a min\n      return ctx.sleep(pollRateSec * 1000);\n    },\n  };\n}\n","import assert from \"assert\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\n\n// required exports for state machine\nexport type Params = { chainId: number; transactionHash: string; eventIndex?: number };\nexport type Memory = undefined;\nexport function initMemory(): Memory {\n  return undefined;\n}\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  return {\n    async start(params: Params) {\n      const { chainId, transactionHash, eventIndex = 0 } = params;\n\n      // search all known requests first\n      const filteredRequests = store\n        .read()\n        .descendingRequests()\n        .filter((request) => {\n          if (request.chainId.toString() !== chainId.toString()) return false;\n          if (\n            ![\n              request?.requestTx?.toLowerCase(),\n              request?.proposeTx?.toLowerCase(),\n              request?.disputeTx?.toLowerCase(),\n              request?.settleTx?.toLowerCase(),\n            ].includes(transactionHash.toLowerCase())\n          )\n            return false;\n          return [\n            request?.requestLogIndex?.toString(),\n            request?.proposeLogIndex?.toString(),\n            request?.disputeLogIndex?.toString(),\n            request?.settleLogIndex?.toString(),\n          ].includes(eventIndex.toString());\n        });\n\n      // if we found a request from known requests, then set it as our selected request\n      if (filteredRequests.length === 1) {\n        const [found] = filteredRequests;\n        // we can parse out the necessary params to kick off fetching the state of the request\n        const requestInput = {\n          timestamp: found.timestamp,\n          requester: found.requester,\n          ancillaryData: found.ancillaryData,\n          identifier: found.identifier,\n          chainId,\n        };\n        store.write((write) => write.inputs().request(requestInput));\n        return \"done\";\n      }\n\n      // have to do all of this to fetch the identifier, ancData, requester and timestamp from the request\n      const provider = store.read().provider(chainId);\n      const receipt = await provider.getTransactionReceipt(transactionHash);\n      assert(receipt, \"Unable to find transaction receipt from hash: \" + transactionHash);\n      const oracle = store.read().oracleService(chainId);\n      const oracleAddress = store.read().oracleAddress(chainId);\n      // filter out logs that originate from oracle contract\n      const oracleLogs = receipt.logs.filter((log) => log.address.toLowerCase() === oracleAddress.toLowerCase());\n      // decode logs using abi\n      const decodedLogs = oracleLogs.map((log) => oracle.parseLog(log));\n\n      // this is the event we care about, we index into the appropriate oracle event generated from this tx\n      // we want to keep backwards compatibility with previous links which were indexed by an array index and not logIndex\n      const log =\n        decodedLogs.find((log) => log?.logIndex?.toString() === eventIndex.toString()) ||\n        decodedLogs[eventIndex] ||\n        decodedLogs[0];\n      // we dont actually know the type of the log, so we need to do some validation before continuing\n      assert(log, `Unable to find optimistic oracle event at ${transactionHash} eventIndex ${eventIndex}`);\n      assert(log.args, `Unable to find optimistic oracle event args at ${transactionHash} eventIndex ${eventIndex}`);\n      assert(\n        log.args.timestamp,\n        `Unable to find optimistic oracle event.timestamp at ${transactionHash} eventIndex ${eventIndex}`\n      );\n      assert(\n        log.args.requester,\n        `Unable to find optimistic oracle event.requester at ${transactionHash} eventIndex ${eventIndex}`\n      );\n      assert(\n        log.args.ancillaryData,\n        `Unable to find optimistic oracle event.ancillaryData at ${transactionHash} eventIndex ${eventIndex}`\n      );\n      assert(\n        log.args.identifier,\n        `Unable to find optimistic oracle event.identifier at ${transactionHash} eventIndex ${eventIndex}`\n      );\n\n      // we can parse out the necessary params to kick off fetching the state of the request\n      const requestInput = {\n        timestamp: log.args.timestamp,\n        requester: log.args.requester,\n        ancillaryData: log.args.ancillaryData,\n        identifier: log.args.identifier,\n        chainId,\n      };\n\n      store.write((write) => write.inputs().request(requestInput));\n      return \"done\";\n    },\n  };\n}\n","import assert from \"assert\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Signer } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { InputRequest } from \"../../types/state\";\nimport { ContextClient } from \"./utils\";\n\nexport type Params = InputRequest & {\n  signer: Signer;\n  confirmations: number;\n  currency: string;\n  account: string;\n  checkTxIntervalSec: number;\n};\n\nexport type Memory = { hash?: string };\n\nexport function initMemory(): Memory {\n  return {};\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory) {\n      const { requester, identifier, timestamp, ancillaryData, chainId, signer } = params;\n      assert(chainId === (await signer.getChainId()), \"Signer on wrong chainid\");\n\n      const oracle = store.read().oracleService(chainId);\n      const tx = await oracle.settle(signer, { requester, identifier, timestamp, ancillaryData });\n      memory.hash = tx.hash;\n      return \"confirm\";\n    },\n    async confirm(params: Params, memory: Memory, context: ContextClient) {\n      const { chainId, confirmations, checkTxIntervalSec } = params;\n      const { hash } = memory;\n      assert(hash, \"requires hash\");\n      if (await update.isConfirmed(chainId, hash, confirmations)) {\n        return \"update\";\n      }\n      // wait x seconds before running this state again\n      return context.sleep(checkTxIntervalSec * 1000);\n    },\n    async update(params: Params) {\n      const { chainId, currency, account } = params;\n      const oracle = store.read().oracleService(chainId);\n      await update.balance(chainId, currency, account);\n      store.write((w) => {\n        w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));\n      });\n      update.sortedRequests(chainId);\n      return \"done\";\n    },\n  };\n}\n","import bluebird from \"bluebird\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\n\n// required exports for state machine\nexport type Params = {\n  chainId: number;\n  concurrency?: number;\n  pollRateSec?: number;\n};\n\nexport type Memory = undefined;\n\nexport function initMemory(): Memory {\n  return undefined;\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient): Promise<void | undefined> {\n      const { chainId, pollRateSec = 15, concurrency = 5 } = params;\n      const oracle = store.read().oracleService(chainId);\n      const requests = oracle.listRequests();\n      const requestsToFetch = requests.filter((request) => request.eventBased === undefined);\n      await bluebird.map(requestsToFetch, (request) => update.request(request), { concurrency });\n      return ctx.sleep(pollRateSec * 1000);\n    },\n  };\n}\n","import assert from \"assert\";\nimport uid from \"lodash/uniqueId\";\n\nimport { Handlers, Memory, Context, Step as StepType, ContextProps, ContextType } from \"../../types/statemachine\";\n\n// client to pass into handlers to allow them to modify context\nexport class ContextClient {\n  constructor(private context: ContextProps) {}\n  sleep(ms?: number): void {\n    this.context.sleep = ms;\n  }\n}\n\nexport const Step = <P = undefined, M extends Memory = undefined>(handlers: Handlers<P, M>): StepType<P, M> => async (\n  context: Context<P, M>,\n  now: number\n): Promise<Context<P, M>> => {\n  assert(!context.done, \"Context has ended\");\n  assert(handlers[context.state], \"No handler for state: \" + context.state);\n  // conext is read only for some reason, have to copy it\n  const copy = Object.assign({}, context);\n\n  try {\n    // remove sleep, assume it should be reset if needed\n    if (copy.sleep) copy.sleep = undefined;\n    const handler = handlers[copy.state];\n    // have to copy this out because memory becomes read only for some reason?\n    const memory = Object.assign({}, copy.memory);\n    // handlers take in params and return a new state or nothin\n    const state = await handler(copy.params, memory, new ContextClient(copy));\n    copy.memory = memory;\n    // update context state\n    if (state) copy.state = state;\n    // check for done\n    if (state === \"done\") copy.done = true;\n  } catch (err) {\n    return {\n      ...copy,\n      error: err as Error,\n      state: \"error\",\n      done: true,\n      updated: now,\n    };\n  }\n  copy.updated = now;\n  return copy;\n};\n\nexport function shouldStep(context: Context<unknown, unknown & Memory> | undefined, now: number): context is Context {\n  if (!context) return false;\n  if (context.done) return false;\n  if (context.updated === undefined) return true;\n  if (!context?.sleep) return true;\n  return now - context.updated >= context.sleep;\n}\n\nexport function create<P, M extends Memory>(\n  type: ContextType,\n  params: P,\n  memory: M,\n  override: Partial<ContextProps> = {},\n  now = Date.now()\n): Context<P, M> {\n  const context: Context<P, M> = {\n    id: uid(type + \"_\"),\n    state: \"start\",\n    done: false,\n    updated: undefined,\n    created: now,\n    type,\n    // override any part of the context, not recommended for most cases\n    ...override,\n    params,\n    memory,\n  };\n  return context;\n}\n\nexport class ContextManager<P, M extends Memory> {\n  constructor(\n    private type: ContextType,\n    private handlers: Handlers<P, M>,\n    private initMemory: (params: P) => M,\n    private emit: (ctx: Context<P, M>) => void\n  ) {}\n  create = (params: P, user?: string): string => {\n    const context = create<P, M>(this.type, params, this.initMemory(params), { user });\n    this.emit(context);\n    return context.id;\n  };\n  // this step function will keep looping until either the state machine is done transitioning, or sleep has been specified\n  async step(context: Context<P, M>, now: number = Date.now(), iterations = 10): Promise<Context<P, M>> {\n    const step = Step<P, M>(this.handlers);\n    let next = context;\n    while (shouldStep(next, now)) {\n      assert(\n        iterations >= 0,\n        \"Infinite loop detected in state machine, make sure it each state transitions to done: \" + context.type\n      );\n      next = await step(next, now);\n      iterations--;\n    }\n    return next;\n  }\n}\n","import { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\nexport type Params = undefined;\nexport type Memory = { iterations: number };\n\nexport function initMemory(): Memory {\n  return { iterations: 0 };\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient) {\n      await ignoreExistenceErrorAsync(update.userCollateralBalance);\n      await ignoreExistenceErrorAsync(update.oracleAllowance);\n      memory.iterations++;\n      // this is set differently for every chain\n      const { checkTxIntervalSec = 30 } = (await ignoreExistenceErrorAsync(store.read().chainConfig)) || {};\n      return ctx.sleep(checkTxIntervalSec * 1000);\n    },\n  };\n}\n","import { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\n// required exports for state machine\nexport type Params = undefined;\nexport type Memory = undefined;\nexport function initMemory(): Memory {\n  return undefined;\n}\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start() {\n      const has = store.has();\n      // we can ignore errors where reads fail, but all other errors will propogate\n      // this will rerun when user is set.\n      if (!has.defaultLiveness()) {\n        await ignoreExistenceErrorAsync(update.oracle);\n      }\n\n      await ignoreExistenceErrorAsync(update.request);\n\n      if (!has.collateralProps()) {\n        await ignoreExistenceErrorAsync(update.collateralProps);\n      }\n\n      return \"done\";\n    },\n  };\n}\n","import { Context, Memory, ContextType } from \"../../types/statemachine\";\nimport type Store from \"../../store\";\nimport { ContextManager, shouldStep } from \"./utils\";\n\n// context types, import new ones here\nimport * as setUser from \"./setUser\";\nimport * as clearUser from \"./clearUser\";\nimport * as setActiveRequest from \"./setActiveRequest\";\nimport * as approve from \"./approve\";\nimport * as disputePrice from \"./disputePrice\";\nimport * as proposePrice from \"./proposePrice\";\nimport * as switchOrAddChain from \"./switchOrAddChain\";\nimport * as pollActiveRequest from \"./pollActiveRequest\";\nimport * as pollActiveUser from \"./pollActiveUser\";\nimport * as fetchPastEvents from \"./fetchPastEvents\";\nimport * as pollNewEvents from \"./pollNewEvents\";\nimport * as updateActiveRequest from \"./updateActiveRequest\";\nimport * as settle from \"./settle\";\nimport * as setActiveRequestByTransaction from \"./setActiveRequestByTransaction\";\nimport * as fetchEventBased from \"./fetchEventBased\";\n\n/**\n * StateMachine. This class will be used to handle all change requests by the user, including setting state which\n * may require triggering fetching data from chain, or initiating transactions that require tracking.\n *\n * This class is meant to step through states of a Context object. This object can have variable\n * parameters and memory. There are several concepts to understand before using this class:\n *\n * 1. Handlers - This is the state machine state handlers, it is an objected keyed by each state, with a function handler.\n * 2. Params - These are common parameters set by the caller, passed into each handler function.\n * 3. Memory - This is a writing space within the state machine handlers that accumulates through states.\n * 4. Context - This is the sum of all data needed to transition through the state machine states. It includes params, memory and metadata about the runtime.\n * 5. Context.done - This is a special property on context.done which represents that the state machine is done transitioning this context.\n * 6. Context.state = \"done\" - This is a reserved state on context.state, if set to \"done\" its the same thing as done = true.\n * 7. Context.state = \"error\" - This is a reserved state on context.state, if set to \"error\" it means the context is done, but also there is an context.error object.\n * 8. Interval - This is a property on the context which specifies the maximum rate in MS this context will transition, based on the current timestamp.\n */\nexport class StateMachine {\n  private pending: Context<unknown, unknown & Memory>[] = [];\n  // this needs to be updated when adding new context type\n  public types: {\n    [ContextType.setUser]: ContextManager<setUser.Params, setUser.Memory>;\n    [ContextType.clearUser]: ContextManager<clearUser.Params, clearUser.Memory>;\n    [ContextType.setActiveRequest]: ContextManager<setActiveRequest.Params, setActiveRequest.Memory>;\n    [ContextType.approve]: ContextManager<approve.Params, approve.Memory>;\n    [ContextType.disputePrice]: ContextManager<disputePrice.Params, disputePrice.Memory>;\n    [ContextType.proposePrice]: ContextManager<proposePrice.Params, proposePrice.Memory>;\n    [ContextType.switchOrAddChain]: ContextManager<switchOrAddChain.Params, switchOrAddChain.Memory>;\n    [ContextType.pollActiveRequest]: ContextManager<pollActiveRequest.Params, pollActiveRequest.Memory>;\n    [ContextType.pollActiveUser]: ContextManager<pollActiveUser.Params, pollActiveUser.Memory>;\n    [ContextType.fetchPastEvents]: ContextManager<fetchPastEvents.Params, fetchPastEvents.Memory>;\n    [ContextType.pollNewEvents]: ContextManager<pollNewEvents.Params, pollNewEvents.Memory>;\n    [ContextType.setActiveRequestByTransaction]: ContextManager<\n      setActiveRequestByTransaction.Params,\n      setActiveRequestByTransaction.Memory\n    >;\n    [ContextType.settle]: ContextManager<settle.Params, settle.Memory>;\n    [ContextType.updateActiveRequest]: ContextManager<updateActiveRequest.Params, updateActiveRequest.Memory>;\n    [ContextType.fetchEventBased]: ContextManager<fetchEventBased.Params, fetchEventBased.Memory>;\n  };\n  constructor(private store: Store) {\n    // need to initizlie state types here manually for each new context type\n    this.types = {\n      [ContextType.setUser]: new ContextManager<setUser.Params, setUser.Memory>(\n        ContextType.setUser,\n        setUser.Handlers(store),\n        setUser.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.clearUser]: new ContextManager<clearUser.Params, clearUser.Memory>(\n        ContextType.clearUser,\n        clearUser.Handlers(store),\n        clearUser.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.setActiveRequest]: new ContextManager<setActiveRequest.Params, setActiveRequest.Memory>(\n        ContextType.setActiveRequest,\n        setActiveRequest.Handlers(store),\n        setActiveRequest.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.approve]: new ContextManager<approve.Params, approve.Memory>(\n        ContextType.approve,\n        approve.Handlers(store),\n        approve.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.disputePrice]: new ContextManager<disputePrice.Params, disputePrice.Memory>(\n        ContextType.disputePrice,\n        disputePrice.Handlers(store),\n        disputePrice.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.proposePrice]: new ContextManager<proposePrice.Params, proposePrice.Memory>(\n        ContextType.proposePrice,\n        proposePrice.Handlers(store),\n        proposePrice.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.switchOrAddChain]: new ContextManager<switchOrAddChain.Params, switchOrAddChain.Memory>(\n        ContextType.switchOrAddChain,\n        switchOrAddChain.Handlers(store),\n        switchOrAddChain.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.pollActiveRequest]: new ContextManager<pollActiveRequest.Params, pollActiveRequest.Memory>(\n        ContextType.pollActiveRequest,\n        pollActiveRequest.Handlers(store),\n        pollActiveRequest.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.pollActiveUser]: new ContextManager<pollActiveUser.Params, pollActiveUser.Memory>(\n        ContextType.pollActiveUser,\n        pollActiveUser.Handlers(store),\n        pollActiveUser.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.fetchPastEvents]: new ContextManager<fetchPastEvents.Params, fetchPastEvents.Memory>(\n        ContextType.fetchPastEvents,\n        fetchPastEvents.Handlers(store),\n        fetchPastEvents.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.pollNewEvents]: new ContextManager<pollNewEvents.Params, pollNewEvents.Memory>(\n        ContextType.pollNewEvents,\n        pollNewEvents.Handlers(store),\n        pollNewEvents.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.setActiveRequestByTransaction]: new ContextManager<\n        setActiveRequestByTransaction.Params,\n        setActiveRequestByTransaction.Memory\n      >(\n        ContextType.setActiveRequestByTransaction,\n        setActiveRequestByTransaction.Handlers(store),\n        setActiveRequestByTransaction.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.settle]: new ContextManager<settle.Params, settle.Memory>(\n        ContextType.settle,\n        settle.Handlers(store),\n        settle.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.updateActiveRequest]: new ContextManager<updateActiveRequest.Params, updateActiveRequest.Memory>(\n        ContextType.updateActiveRequest,\n        updateActiveRequest.Handlers(store),\n        updateActiveRequest.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.fetchEventBased]: new ContextManager<fetchEventBased.Params, fetchEventBased.Memory>(\n        ContextType.fetchEventBased,\n        fetchEventBased.Handlers(store),\n        fetchEventBased.initMemory,\n        this.handleCreate\n      ),\n    };\n  }\n  private saveContext(context: Context<unknown, unknown & Memory>) {\n    this.store.write((w) => w.command(context));\n  }\n  private handleCreate = (context: Context<unknown, unknown & Memory>) => {\n    this.push(context);\n    this.saveContext(context);\n  };\n\n  // remove element from front of queue\n  private shift(): Context<unknown, unknown & Memory> | undefined {\n    return this.pending.shift();\n  }\n  // remove element from back of queue\n  private pop(): Context<unknown, unknown & Memory> | undefined {\n    return this.pending.pop();\n  }\n  private size(): number {\n    return this.pending.length;\n  }\n  private push(context: Context<unknown, unknown & Memory>): void {\n    this.pending.push(context);\n  }\n  /**\n   * tick. Process all pending contexts, move them to done if needed\n   *\n   * @param {} now - Specify the timestamp this tick is running on.\n   * @returns {Promise<boolean>} - Returns if there are still any pending contexts to run.\n   */\n  tick = async (now = Date.now()): Promise<boolean> => {\n    const context = this.shift();\n    // if this cant step, then push it to back of queue\n    if (!shouldStep(context, now)) {\n      context && !context.done && this.push(context);\n      // if we can step, then step it and push result into queue\n    } else {\n      let next;\n      switch (context.type) {\n        // need to update this function with the new context processor\n        case ContextType.setUser: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<setUser.Params, setUser.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.clearUser: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<clearUser.Params, clearUser.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.setActiveRequest: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<setActiveRequest.Params, setActiveRequest.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.approve: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<approve.Params, approve.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.disputePrice: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<disputePrice.Params, disputePrice.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.proposePrice: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<proposePrice.Params, proposePrice.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.switchOrAddChain: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<switchOrAddChain.Params, switchOrAddChain.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.pollActiveRequest: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<pollActiveRequest.Params, pollActiveRequest.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.pollActiveUser: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<pollActiveUser.Params, pollActiveUser.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.fetchPastEvents: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<fetchPastEvents.Params, fetchPastEvents.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.pollNewEvents: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<pollNewEvents.Params, pollNewEvents.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.setActiveRequestByTransaction: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<setActiveRequestByTransaction.Params, setActiveRequestByTransaction.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.settle: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<settle.Params, settle.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.updateActiveRequest: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<updateActiveRequest.Params, updateActiveRequest.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.fetchEventBased: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<fetchEventBased.Params, fetchEventBased.Memory>,\n            now\n          );\n          break;\n        }\n        default: {\n          throw new Error(\"Unable to handle type: \" + context.type);\n        }\n      }\n      if (!next.done) {\n        this.push(next);\n      }\n      this.saveContext(next);\n    }\n\n    return this.size() > 0;\n  };\n}\n","import assert from \"assert\";\nimport { ethers } from \"ethers\";\nimport Store, { Emit } from \"./store\";\nimport type { state } from \"./types\";\nimport type { FallbackProvider } from \"./types/ethers\";\nimport { InputRequest, User } from \"./types/state\";\nimport { Update } from \"./services/update\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { StateMachine, setActiveRequestByTransaction } from \"./services/statemachines\";\nimport { loop } from \"../utils\";\nimport { toWei } from \"../across/utils\";\nimport { NewOracle } from \"./types/interfaces\";\n\nexport class Client {\n  private intervalStarted = false;\n  constructor(\n    public readonly store: Store,\n    public readonly update: Update,\n    public readonly sm: StateMachine,\n    public readonly poller: StateMachine\n  ) {}\n  setUser(params: Partial<User>): string {\n    const address = params.address && ethers.utils.getAddress(params.address);\n    return this.sm.types.setUser.create({ ...params, address });\n  }\n  clearUser(): string {\n    return this.sm.types.clearUser.create(undefined);\n  }\n  setActiveRequest(params: InputRequest): string {\n    const requester = ethers.utils.getAddress(params.requester);\n    // these are case and number senstive\n    const ancillaryData = params.ancillaryData.toLowerCase();\n    const identifier = params.identifier.toLowerCase();\n    const chainId = Number(params.chainId);\n    const timestamp = Number(params.timestamp);\n    const result = this.sm.types.setActiveRequest.create({ requester, ancillaryData, identifier, chainId, timestamp });\n    this.sm.types.updateActiveRequest.create(undefined);\n    return result;\n  }\n  setActiveRequestByTransaction(params: setActiveRequestByTransaction.Params): string {\n    const result = this.sm.types.setActiveRequestByTransaction.create(params);\n    this.sm.types.updateActiveRequest.create(undefined);\n    return result;\n  }\n  approveCollateral(): string {\n    const { checkTxIntervalSec } = this.store.read().chainConfig();\n    const request = this.store.read().request();\n    const inputRequest = this.store.read().inputRequest();\n    const user = this.store.read().user();\n    const oracleAddress = this.store.read().oracleAddress();\n    assert(user.address, \"requires a user account address\");\n    assert(user.signer, \"requires a user signer\");\n    assert(user.chainId === inputRequest.chainId, \"On wrong chain\");\n    assert(request.currency, \"Request currency is unknown\");\n    return this.sm.types.approve.create(\n      {\n        currency: request.currency,\n        account: user.address,\n        chainId: inputRequest.chainId,\n        signer: user.signer,\n        spender: oracleAddress,\n        amount: ethers.constants.MaxUint256.toString(),\n        confirmations: 1,\n        checkTxIntervalSec,\n      },\n      user.address\n    );\n  }\n  proposePrice(proposedPriceDecimals: string | number): string {\n    const { checkTxIntervalSec } = this.store.read().chainConfig();\n    const proposedPrice = toWei(proposedPriceDecimals);\n    const inputRequest = this.store.read().inputRequest();\n    const request = this.store.read().request();\n    const user = this.store.read().user();\n    assert(user.address, \"requires a user account address\");\n    assert(user.signer, \"requires a user signer\");\n    assert(user.chainId === inputRequest.chainId, \"On wrong chain\");\n    assert(request.currency, \"Request currency is unknown\");\n    return this.sm.types.proposePrice.create(\n      {\n        ...inputRequest,\n        proposedPrice,\n        signer: user.signer,\n        account: user.address,\n        currency: request.currency,\n        confirmations: 1,\n        checkTxIntervalSec,\n      },\n      user.address\n    );\n  }\n  disputePrice(): string {\n    const { checkTxIntervalSec } = this.store.read().chainConfig();\n    const inputRequest = this.store.read().inputRequest();\n    const user = this.store.read().user();\n    const request = this.store.read().request();\n    assert(user.address, \"requires a user account address\");\n    assert(user.signer, \"requires a user signer\");\n    assert(user.chainId === inputRequest.chainId, \"On wrong chain\");\n    assert(request.currency, \"Request currency is unknown\");\n    return this.sm.types.disputePrice.create(\n      {\n        ...inputRequest,\n        confirmations: 1,\n        signer: user.signer,\n        account: user.address,\n        currency: request.currency,\n        checkTxIntervalSec,\n      },\n      user.address\n    );\n  }\n  settle(): string {\n    const { checkTxIntervalSec } = this.store.read().chainConfig();\n    const inputRequest = this.store.read().inputRequest();\n    const user = this.store.read().user();\n    const request = this.store.read().request();\n    assert(user.address, \"requires a user account address\");\n    assert(user.signer, \"requires a user signer\");\n    assert(user.chainId === inputRequest.chainId, \"On wrong chain\");\n    assert(request.currency, \"Request currency is unknown\");\n    return this.sm.types.settle.create(\n      {\n        ...inputRequest,\n        confirmations: 1,\n        signer: user.signer,\n        account: user.address,\n        currency: request.currency,\n        checkTxIntervalSec,\n      },\n      user.address\n    );\n  }\n  switchOrAddChain(): string {\n    const inputRequest = this.store.read().inputRequest();\n    const user = this.store.read().user();\n    assert(user.provider, \"requires user provider\");\n    assert(user.address, \"requires user address\");\n    assert(inputRequest.chainId, \"requires active request chainId\");\n    return this.sm.types.switchOrAddChain.create(\n      { chainId: inputRequest.chainId, provider: user.provider },\n      user.address\n    );\n  }\n  // runs statemachine step loop pretty fast by default.\n  startInterval(delayMs = 1): void {\n    assert(!this.intervalStarted, \"Interval already started, try stopping first\");\n    this.intervalStarted = true;\n    loop(async () => {\n      assert(this.intervalStarted, \"Interval Stopped\");\n      // it turns out since these 2 state machines share the same immer state, they need to be run serially and\n      // cant be run concurrently or you get wierd state oscillations. For now keep them in the same timing loop.\n      await this.sm.tick();\n      await this.poller.tick();\n    }, delayMs).catch((err) => {\n      console.error(err);\n      this.intervalStarted = false;\n      this.store.write((w) => w.error(err));\n    });\n  }\n  stopInterval(): void {\n    assert(!this.intervalStarted, \"Interval already stopped\");\n    this.intervalStarted = false;\n  }\n}\n\nfunction makeProvider(rpcUrls: string[]): FallbackProvider {\n  const providers = rpcUrls.map((url) => {\n    const provider = ethers.getDefaultProvider(url);\n    // turn off all polling, we will poll manually\n    provider.polling = false;\n    return provider;\n  });\n  const provider = new ethers.providers.FallbackProvider(providers, 1);\n  // turn off all polling, we will poll manually\n  provider.polling = false;\n  return provider;\n}\nexport function factory(\n  config: state.Config,\n  emit: Emit,\n  OptimisticOracle: NewOracle,\n  sortedRequests: SortedRequests\n): Client {\n  const store = new Store(emit);\n  store.write((write) => {\n    write.config(config);\n    // maintains queryable ordered list of requests across all chains\n    write.sortedRequestsService(sortedRequests);\n    for (const chain of Object.values(config.chains)) {\n      const provider = makeProvider(chain.rpcUrls);\n      write.chains(chain.chainId).optimisticOracle().address(chain.optimisticOracleAddress);\n      write.services(chain.chainId).provider(provider);\n      write.services(chain.chainId).multicall2(chain.multicall2Address);\n      write\n        .services(chain.chainId)\n        .optimisticOracle(new OptimisticOracle(provider, chain.optimisticOracleAddress, chain.chainId));\n    }\n  });\n  const update = new Update(store);\n\n  // this first state machine is for user actions\n  const sm = new StateMachine(store);\n  // this one is system actions used for long running commands independent of the user\n  const poller = new StateMachine(store);\n\n  // start the request list checkers\n  for (const [chainId, chainConfig] of Object.entries(config.chains)) {\n    poller.types.fetchPastEvents.create(\n      {\n        chainId: Number(chainId),\n        startBlock: chainConfig.earliestBlockNumber,\n        maxRange: chainConfig.maxEventRangeQuery,\n      },\n      \"poller\"\n    );\n    // long running poller which only looks for new events\n    poller.types.pollNewEvents.create(\n      { chainId: Number(chainId), pollRateSec: chainConfig.checkTxIntervalSec },\n      \"poller\"\n    );\n    // updates event based data on all requests\n    if (!chainConfig.disableFetchEventBased)\n      poller.types.fetchEventBased.create({ chainId: Number(chainId) }, \"poller\");\n  }\n  // create active request poller for all chains. Should only have one of these\n  poller.types.pollActiveRequest.create(undefined, \"poller\");\n  // polls user for balances/approvals on the current chain, in case it changes external to app\n  poller.types.pollActiveUser.create(undefined, \"poller\");\n\n  return new Client(store, update, sm, poller);\n}\n","import { optimisticOracle } from \"../../clients\";\nimport { BigNumberish, Provider, Signer, TransactionResponse, Log, TransactionReceipt } from \"../types/ethers\";\nimport type { OracleInterface, RequestKey, OracleProps, Request } from \"../types/interfaces\";\nimport { requestId, insertOrderedAscending, eventKey, isUnique } from \"../utils\";\n\nimport {\n  RequestPrice,\n  ProposePrice,\n  DisputePrice,\n  Settle,\n  Request as RawRequest,\n} from \"../../clients/optimisticOracle\";\n\nexport type OptimisticOracleEvent = RequestPrice | ProposePrice | DisputePrice | Settle;\n\nexport type { RequestPrice, ProposePrice, DisputePrice, Settle };\n\nexport class OptimisticOracle implements OracleInterface {\n  private readonly contract: optimisticOracle.Instance;\n  private readonly events: OptimisticOracleEvent[] = [];\n  private requests: Record<string, Request> = {};\n  constructor(protected provider: Provider, protected address: string, public readonly chainId: number) {\n    this.contract = optimisticOracle.connect(address, provider);\n  }\n  private upsertRequest = (request: RawRequest): Request => {\n    const id = requestId(request);\n    const cachedRequest = this.requests[id] || {};\n    const update = { ...cachedRequest, ...request, chainId: this.chainId, eventBased: false };\n    this.requests[id] = update;\n    return update;\n  };\n  parseLog = (log: Log) => {\n    const description = this.contract.interface.parseLog(log);\n    return {\n      ...log,\n      ...description,\n      event: description.name,\n      eventSignature: description.signature,\n    };\n  };\n  private setDisputeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, disputeTx: hash });\n  }\n  private setProposeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, proposeTx: hash });\n  }\n  private setSettleHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, settleTx: hash });\n  }\n  private updateFromEvents = (events: OptimisticOracleEvent[]) => {\n    events.forEach((event) => {\n      if (isUnique(this.events, event, eventKey)) {\n        insertOrderedAscending(this.events, event, eventKey);\n      }\n    });\n    const { requests = {} } = optimisticOracle.getEventState(this.events);\n    Object.values(requests).map((request) => this.upsertRequest(request));\n  };\n  async fetchRequest({ requester, identifier, timestamp, ancillaryData }: RequestKey): Promise<Request> {\n    const request = await this.contract.callStatic.getRequest(requester, identifier, timestamp, ancillaryData);\n    const state = await this.contract.callStatic.getState(requester, identifier, timestamp, ancillaryData);\n    return this.upsertRequest({ ...request, state, requester, identifier, timestamp, ancillaryData });\n  }\n\n  getRequest(key: RequestKey): Request {\n    const id = requestId(key);\n    const request = this.requests[id] || key;\n    return { ...request };\n  }\n  async disputePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.disputePrice(requester, identifier, timestamp, ancillaryData);\n    this.setDisputeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async proposePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey,\n    price: BigNumberish\n  ): Promise<TransactionResponse> {\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.proposePrice(requester, identifier, timestamp, ancillaryData, price);\n    this.setProposeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async settle(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.settle(requester, identifier, timestamp, ancillaryData);\n    this.setSettleHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async update(startBlock = 0, endBlock: number | \"latest\" = \"latest\"): Promise<void> {\n    const events = await this.contract.queryFilter({}, startBlock, endBlock);\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  async getProps(): Promise<OracleProps> {\n    return {\n      defaultLiveness: await this.contract.defaultLiveness(),\n    };\n  }\n  updateFromTransactionReceipt(receipt: TransactionReceipt): void {\n    const events = receipt.logs.map((log) => this.parseLog(log));\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  listRequests(): Request[] {\n    return Object.values(this.requests);\n  }\n}\n","// this is a special service that works across all oracles type, chains, etc, to give a combined\n// view of all requests across running instances.\nimport sortedIndex from \"lodash/sortedIndex\";\nimport sortedLastIndex from \"lodash/sortedLastIndex\";\n\nimport { exists } from \"../../utils\";\nimport { requestId } from \"../utils\";\n\nimport { InputRequestWithOracleType, RequestWithOracleType, RequestsWithOracleType } from \"../types/state\";\n\n// this was copied out of store and made to be 1. a class, and 2. sync.  Could not modify old implementation since\n// other services rely on this currently and it causes cascading refactors. This has been copied without modification to logic.\nexport class SortedStore<Id, Data> {\n  private ids: Id[] = [];\n  private map = new Map<Id, Data>();\n  private getStart = (id: Id, inclusive = true): number => {\n    if (inclusive) {\n      return sortedIndex(this.ids, id);\n    } else {\n      return sortedLastIndex(this.ids, id);\n    }\n  };\n  private getEnd = (id: Id, inclusive = false): number => {\n    return this.getStart(id, !inclusive);\n  };\n  private del = (id: Id): Data | undefined => {\n    const index = sortedIndex(this.ids, id);\n    this.ids.splice(index, 1);\n    const result = this.map.get(id);\n    this.map.delete(id);\n    return result;\n  };\n  // keeps typescript from complaining that return values may be undefined\n  private getSafe = (id: Id): Data => {\n    const result = this.map.get(id);\n    if (exists(result)) return result;\n    throw new Error(\"Missing data for index: \" + id);\n  };\n  has = (id: Id): boolean => {\n    return this.map.has(id);\n  };\n  set = (id: Id, data: Data): void => {\n    if (this.map.has(id)) {\n      this.map.set(id, data);\n    } else {\n      const index = sortedIndex(this.ids, id);\n      this.ids.splice(index, 0, id);\n      this.map.set(id, data);\n    }\n  };\n  get = (id: Id): Data | undefined => {\n    return this.map.get(id);\n  };\n  values = (): Data[] => {\n    return this.ids.map(this.getSafe);\n  };\n  entries = (): [Id, Data][] => {\n    return this.ids.map((id) => [id, this.getSafe(id)]);\n  };\n  keys = (): Id[] => {\n    return [...this.ids];\n  };\n  clear = (): void => {\n    this.map.clear();\n    this.ids.length = 0;\n  };\n  size = (): number => {\n    return this.ids.length;\n  };\n  delete = (id: Id): void => {\n    if (!this.map.has(id)) return;\n    this.del(id);\n  };\n  // assume [a,b)\n  between = (a: Id, b: Id): Data[] => {\n    const start = this.getStart(a);\n    const end = this.getEnd(b);\n    return this.ids.slice(start, end).map(this.getSafe);\n  };\n  slice = (id: Id, length: number): Data[] => {\n    const start = this.getStart(id);\n    return this.ids.slice(start, start + length).map(this.getSafe);\n  };\n}\n\n// this sorts requests across all chains and oracles\nexport class SortedRequests extends SortedStore<string, RequestWithOracleType> {\n  setByRequest(value: InputRequestWithOracleType): void {\n    return this.set(this.id(value), value);\n  }\n  descending(): RequestsWithOracleType {\n    // sadly you cannot control lodash sorting descending, so reverse is necessary\n    return this.values().reverse();\n  }\n  ascending(): RequestsWithOracleType {\n    return this.values();\n  }\n  getByRequest(request: InputRequestWithOracleType): RequestWithOracleType {\n    // always return at least the original query data\n    return this.get(this.id(request)) || request;\n  }\n  id(request: InputRequestWithOracleType): string {\n    return requestId(request) + \"!\" + request.chainId + \"!\" + request.oracleType;\n  }\n}\n","import assert from \"assert\";\nimport { skinnyOptimisticOracle as optimisticOracle } from \"../../clients\";\nimport { BigNumberish, Provider, Signer, TransactionResponse, Log, TransactionReceipt } from \"../types/ethers\";\nimport type { OracleInterface, RequestKey, OracleProps, Request } from \"../types/interfaces\";\nimport { requestId, insertOrderedAscending, eventKey, isUnique } from \"../utils\";\n\nimport {\n  RequestPrice,\n  ProposePrice,\n  DisputePrice,\n  Settle,\n  SolidityRequest,\n} from \"../../clients/skinnyOptimisticOracle\";\n\nexport type OptimisticOracleEvent = RequestPrice | ProposePrice | DisputePrice | Settle;\n\nexport type { RequestPrice, ProposePrice, DisputePrice, Settle };\n\nfunction validateSolidityRequest(request: Request): SolidityRequest {\n  assert(request.proposer, \"Missing proposer\");\n  assert(request.disputer, \"Missing disputer\");\n  assert(request.currency, \"Missing currency\");\n  assert(request.settled, \"Missing settled\");\n  assert(request.proposedPrice, \"Missing proposedPrice\");\n  assert(request.resolvedPrice, \"Missing resolvedPrice\");\n  assert(request.expirationTime, \"Missing expirationTime\");\n  assert(request.reward, \"Missing reward\");\n  assert(request.finalFee, \"Missing finalFee\");\n  assert(request.bond, \"Missing bond\");\n  assert(request.customLiveness, \"Missing customLiveness\");\n  return {\n    proposer: request.proposer,\n    disputer: request.disputer,\n    currency: request.currency,\n    settled: request.settled,\n    proposedPrice: request.proposedPrice,\n    resolvedPrice: request.resolvedPrice,\n    expirationTime: request.expirationTime,\n    reward: request.reward,\n    finalFee: request.finalFee,\n    bond: request.bond,\n    customLiveness: request.customLiveness,\n  };\n}\n\nexport class SkinnyOptimisticOracle implements OracleInterface {\n  private readonly contract: optimisticOracle.Instance;\n  private readonly events: OptimisticOracleEvent[] = [];\n  private requests: Record<string, Request> = {};\n  constructor(protected provider: Provider, protected address: string, public readonly chainId: number) {\n    this.contract = optimisticOracle.connect(address, provider);\n  }\n  private upsertRequest = (request: Omit<Request, \"chainId\">): Request => {\n    const id = requestId(request);\n    const cachedRequest = this.requests[id] || {};\n    const update = { ...cachedRequest, ...request, chainId: this.chainId, eventBased: false };\n    this.requests[id] = update;\n    return update;\n  };\n  private setDisputeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, disputeTx: hash });\n  }\n  private setProposeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, proposeTx: hash });\n  }\n  private setSettleHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, settleTx: hash });\n  }\n  private updateFromEvents = (events: OptimisticOracleEvent[]) => {\n    events.forEach((event) => {\n      if (isUnique(this.events, event, eventKey)) {\n        insertOrderedAscending(this.events, event, eventKey);\n      }\n    });\n    const { requests = {} } = optimisticOracle.getEventState(this.events);\n    Object.values(requests).map((request) => this.upsertRequest(request));\n  };\n  async fetchRequest(key: RequestKey): Promise<Request> {\n    // skinny oo does not have a way to query request data from contract, can only find this though events.\n    return this.getRequest(key);\n  }\n\n  parseLog = (log: Log) => {\n    const description = this.contract.interface.parseLog(log);\n    return {\n      ...log,\n      ...description,\n      event: description.name,\n      eventSignature: description.signature,\n    };\n  };\n  getRequest(key: RequestKey): Request {\n    const id = requestId(key);\n    const request = this.requests[id] || key;\n    return { ...request };\n  }\n  async disputePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const request = validateSolidityRequest(this.getRequest({ requester, identifier, timestamp, ancillaryData }));\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.disputePrice(requester, identifier, timestamp, ancillaryData, request);\n    this.setDisputeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async proposePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey,\n    price: BigNumberish\n  ): Promise<TransactionResponse> {\n    const request = validateSolidityRequest(this.getRequest({ requester, identifier, timestamp, ancillaryData }));\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.proposePrice(requester, identifier, timestamp, ancillaryData, request, price);\n    this.setProposeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async settle(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const request = validateSolidityRequest(this.getRequest({ requester, identifier, timestamp, ancillaryData }));\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.settle(requester, identifier, timestamp, ancillaryData, request);\n    this.setSettleHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async update(startBlock = 0, endBlock: number | \"latest\" = \"latest\"): Promise<void> {\n    const events = await this.contract.queryFilter({}, startBlock, endBlock);\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  async getProps(): Promise<OracleProps> {\n    return {\n      defaultLiveness: await this.contract.defaultLiveness(),\n    };\n  }\n  updateFromTransactionReceipt(receipt: TransactionReceipt): void {\n    const events = receipt.logs.map((log) => this.parseLog(log));\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  listRequests(): Request[] {\n    return Object.values(this.requests);\n  }\n}\n","// This is almost a direct copy of the OO v1 service, just with updated abis and different contract addresses\nimport { BigNumberish, Provider, Signer, TransactionResponse, Log, TransactionReceipt } from \"../types/ethers\";\nimport type { OracleInterface, RequestKey, OracleProps, Request } from \"../types/interfaces\";\nimport { requestId, insertOrderedAscending, eventKey, isUnique } from \"../utils\";\n\nimport {\n  RequestPrice,\n  ProposePrice,\n  DisputePrice,\n  Settle,\n  connect,\n  Instance,\n  getEventState,\n  Request as RawRequest,\n} from \"../../clients/optimisticOracleV2\";\n\nexport type OptimisticOracleEvent = RequestPrice | ProposePrice | DisputePrice | Settle;\n\nexport type { RequestPrice, ProposePrice, DisputePrice, Settle };\n\nexport class OptimisticOracleV2 implements OracleInterface {\n  private readonly contract: Instance;\n  private readonly events: OptimisticOracleEvent[] = [];\n  private requests: Record<string, Request> = {};\n  constructor(protected provider: Provider, protected address: string, public readonly chainId: number) {\n    this.contract = connect(address, provider);\n  }\n  private upsertRequest = (request: RawRequest): Request => {\n    const id = requestId(request);\n    const cachedRequest = this.requests[id] || {};\n    const update = { ...cachedRequest, ...request, ...(request.requestSettings || {}), chainId: this.chainId };\n    this.requests[id] = update;\n    return update;\n  };\n  private setDisputeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, disputeTx: hash });\n  }\n  private setProposeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, proposeTx: hash });\n  }\n  private setSettleHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, settleTx: hash });\n  }\n  private updateFromEvents = (events: OptimisticOracleEvent[]) => {\n    events.forEach((event) => {\n      if (isUnique(this.events, event, eventKey)) {\n        insertOrderedAscending(this.events, event, eventKey);\n      }\n    });\n    const { requests = {} } = getEventState(this.events);\n    Object.values(requests).map((request) => this.upsertRequest(request));\n  };\n  async fetchRequest({ requester, identifier, timestamp, ancillaryData }: RequestKey): Promise<Request> {\n    const request = await this.contract.callStatic.getRequest(requester, identifier, timestamp, ancillaryData);\n    const state = await this.contract.callStatic.getState(requester, identifier, timestamp, ancillaryData);\n    return this.upsertRequest({ ...request, state, requester, identifier, timestamp, ancillaryData });\n  }\n\n  parseLog = (log: Log) => {\n    const description = this.contract.interface.parseLog(log);\n    return {\n      ...log,\n      ...description,\n      event: description.name,\n      eventSignature: description.signature,\n    };\n  };\n  getRequest(key: RequestKey): Request {\n    const id = requestId(key);\n    const request = this.requests[id] || key;\n    return { ...request };\n  }\n  async disputePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const contract = connect(this.address, signer);\n    const tx = await contract.disputePrice(requester, identifier, timestamp, ancillaryData);\n    this.setDisputeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async proposePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey,\n    price: BigNumberish\n  ): Promise<TransactionResponse> {\n    const contract = connect(this.address, signer);\n    const tx = await contract.proposePrice(requester, identifier, timestamp, ancillaryData, price);\n    this.setProposeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async settle(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const contract = connect(this.address, signer);\n    const tx = await contract.settle(requester, identifier, timestamp, ancillaryData);\n    this.setSettleHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async update(startBlock = 0, endBlock: number | \"latest\" = \"latest\"): Promise<void> {\n    const events = await this.contract.queryFilter({}, startBlock, endBlock);\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  async getProps(): Promise<OracleProps> {\n    return {\n      defaultLiveness: await this.contract.defaultLiveness(),\n    };\n  }\n  updateFromTransactionReceipt(receipt: TransactionReceipt): void {\n    const events = receipt.logs.map((log) => this.parseLog(log));\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  listRequests(): Request[] {\n    return Object.values(this.requests);\n  }\n}\n","import { Client, factory } from \"./client\";\nimport { SkinnyOptimisticOracle } from \"./services/skinnyOptimisticOracle\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { DefaultConfig, getMulticall2Address } from \"./utils\";\nimport { state } from \"./types\";\nimport { Emit } from \"./store\";\n\nexport default (\n  config: state.PartialConfig,\n  emit: Emit,\n  sortedRequests: SortedRequests = new SortedRequests()\n): Client => {\n  const fullConfig = DefaultConfig({\n    getMulticall2Address,\n  })({ ...config }, state.OracleType.Skinny);\n  return factory(fullConfig, emit, SkinnyOptimisticOracle, sortedRequests);\n};\n","import { Client, factory } from \"./client\";\nimport { OptimisticOracle } from \"./services/optimisticOracle\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { DefaultConfig, getMulticall2Address } from \"./utils\";\nimport { state } from \"./types\";\nimport { Emit } from \"./store\";\n\nexport default (\n  config: state.PartialConfig,\n  emit: Emit,\n  sortedRequests: SortedRequests = new SortedRequests()\n): Client => {\n  const fullConfig = DefaultConfig({\n    getMulticall2Address,\n  })({ ...config }, state.OracleType.Optimistic);\n  return factory(fullConfig, emit, OptimisticOracle, sortedRequests);\n};\n","import { Client, factory } from \"./client\";\nimport { OptimisticOracleV2 } from \"./services/optimisticOracleV2\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { DefaultConfig, getMulticall2Address } from \"./utils\";\nimport { state } from \"./types\";\nimport { Emit } from \"./store\";\n\nexport default (\n  config: state.PartialConfig,\n  emit: Emit,\n  sortedRequests: SortedRequests = new SortedRequests()\n): Client => {\n  const fullConfig = DefaultConfig({\n    getMulticall2Address,\n  })({ ...config }, state.OracleType.OptimisticV2);\n  return factory(fullConfig, emit, OptimisticOracleV2, sortedRequests);\n};\n","import assert from \"assert\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { ClientTable } from \"./types/interfaces\";\nimport { State, OracleType, PartialConfigTable } from \"./types/state\";\nimport { Emit } from \"./store\";\nimport SkinnyFactory from \"./skinnyFactory\";\nimport OptimisticFactory from \"./optimisticFactory\";\nimport OptimisticV2Factory from \"./optimisticV2Factory\";\n\nexport type PublicEmit = (oracleType: OracleType, state: State, prev: State) => void;\nconst EventHandler = (oracleType: OracleType, publicEmit: PublicEmit): Emit => (state: State, prev: State) =>\n  publicEmit(oracleType, state, prev);\n\nexport default (configTable: PartialConfigTable, emit: PublicEmit): ClientTable => {\n  const sortedRequests = new SortedRequests();\n  return Object.fromEntries(\n    Object.entries(configTable).map(([oracleType, config]) => {\n      assert(config, \"requires config for type: \" + oracleType);\n      switch (oracleType) {\n        case OracleType.Optimistic:\n          return [oracleType, OptimisticFactory(config, EventHandler(oracleType, emit), sortedRequests)];\n        case OracleType.Skinny:\n          return [oracleType, SkinnyFactory(config, EventHandler(oracleType, emit), sortedRequests)];\n        case OracleType.OptimisticV2:\n          return [oracleType, OptimisticV2Factory(config, EventHandler(oracleType, emit), sortedRequests)];\n        default:\n          throw new Error(\"Unknown oracle type: \" + oracleType);\n      }\n    })\n  );\n};\n"],"names":["Factory","RegistryEthers__factory","reduceEvents","state","event","typedEvent","contractAddress","args","contracts","[object Object]","address","provider","connect","events","reduce","exists","value","Balances","balances","create","id","amount","assert","has","set","get","getOrCreate","add","BigNumber","from","toString","sub","ConvertDecimals","fromDecimals","toDecimals","isZero","diff","div","pow","mul","sleep","delay","Promise","res","setTimeout","async","loop","fn","BatchReadWithErrors","multicall2","contract","results","batch","calls","map","method","readWithErrors","Object","fromEntries","zip","call","result","undefined","averageBlockTimeSeconds","chainId","estimateBlocksElapsed","seconds","cushionPercentage","cushionMultiplier","averageBlockTime","Math","floor","ExpiringMultiPartyEthers__factory","oldSponsor","newSponsor","tokens","collateral","collateralBalance","tokenBalance","sponsor","collateralAmount","tokenAmount","sponsors","Set","Array","values","caller","collateralReturned","tokensBurned","expired","tokensOutstanding","liquidatedCollateral","initialState","ERC20Ethers__factory","to","owner","spender","MulticallEthers__factory","Multicall2Ethers__factory","LongShortPairCreatorEthers__factory","longShortPair","eventState","LongShortPairEthers__factory","collateralUsed","tokensMinted","longs","shorts","tokensRedeemed","expiredBy","longTokens","shortTokens","BridgeDepositBoxEthers__factory","newMinimumBridgingDelay","minimumBridgingDelay","l1Token","l2Token","lastBridgeTime","bridgePool","whitelistedTokens","depositsEnabled","depositId","l1Recipient","l2Sender","slowRelayFeePct","instantRelayFeePct","quoteTimestamp","deposits","BridgePoolEthers__factory","lpTokensMinted","liquidityProvider","lpTokens","lpTokensBurnt","depositHash","depositData","relay","relayAncillaryDataHash","relays","instantRelayer","instantRelays","oldAdmin","newAdmin","getEventState","attach","Etherchain","constructor","url","this","endpoint","axios","data","err","msg","Error","RateModelStoreEthers__factory","OptimisticOracleInterfaceEthers__factory","contractInterface","utils","Interface","getOptimisticOracleInterfaceAbi","RequestState","requestId","request","timestamp","identifier","requester","ancillaryData","join","currency","reward","finalFee","requests","Requested","requestTx","transactionHash","requestBlockNumber","blockNumber","requestLogIndex","logIndex","proposer","proposedPrice","expirationTimestamp","expirationTime","Proposed","proposeTx","proposeBlockNumber","proposeLogIndex","disputer","Disputed","disputeTx","disputeBlockNumber","disputeLogIndex","price","payout","Settled","settleTx","settleBlockNumber","settleLogIndex","SkinnyOptimisticOracleEthers__factory","getSkinnyOptimisticOracleAbi","OptimisticOracleV2InterfaceEthers__factory","getOptimisticOracleV2InterfaceAbi","Map","delete","entries","keys","size","clear","ids","getStart","inclusive","sortedIndex","sortedLastIndex","getSafe","index","splice","length","del","a","b","start","end","getEnd","slice","kind","store","excludeFromIndexes","makeKey","key","save","createQuery","run","KEY","name","select","highland","runStream","val","flatMap","collect","toPromise","between","filter","limit","Table","config","makeId","type","update","number","padStart","JsMap","table","BaseTable","prune","blocks","deleted","block","_block$id","push","addSponsors","setCreatedTimestamp","createdTimestamp","SortedJsMap","betweenByTimestamp","sliceByTimestamp","hasByTimestamp","getByTimestamp","upsert","toBN","num","toBNWei","decimals","ethers","parseUnits","toWei","fromWei","formatUnits","min","bna","bnb","lte","max","gte","fixedPointAdjustment","ethToToken","fromAmount","priceWei","toAmount","gasToEth","gas","gasPrice","calculateGasFees","percent","numerator","denominator","calcPeriodicCompoundInterest","startAmount","endAmount","periodsElapsed","periodsPerYear","n","Decimal","A","P","t","one","calcApr","calcContinuousCompoundInterest","years","ln","calculateInstantaneousRate","rateModel","utilization","beforeKink","UBar","R1","afterKink","R2","R0","calculateAreaUnderRateCurve","utilizationBeforeKink","rectangle1Area","triangle1Area","utilizationAfter","rectangle2Area","triangle2Area","calculateApyFromUtilization","utilizationBeforeDeposit","utilizationAfterDeposit","eq","areaBeforeDeposit","calculateRealizedLpFeePct","apy","weeklyFeePct","plus","dividedBy","minus","times","convertApyToWeeklyFee","expectedRateModelKeys","AddressZero","constants","ADDRESSES","ETH","UMA","WETH","USDC","RateModel","DEFAULT_BLOCK_DELTA","parseAndReturnRateModelFromString","rateModelString","rateModelFromEvent","JSON","parse","includes","_throwIfNotInitialized","rateModelDictionary","updateWithEvents","rateModelEvents","updatedRateModelEventsForToken","sort","transactionIndex","updatedRateModelEvent","l1TokenNormalized","getAddress","createRateModelEventDictionary","getRateModelForBlockNumber","firstEventBlockNumber","reverse","find","getL1TokensFromRateModel","BlockFinder","requestBlock","Number","getLatestBlock","initialBlock","cushion","incrementDistance","multiplier","getBlock","sortedIndexBy","findBlock","_this$blocks$index","_this$blocks$index2","_this$blocks$index3","_startBlock","_endBlock","startBlock","endBlock","estimatedBlock","round","newBlock","clamp","Coingecko","host","toLowerCase","prices","contract_address","platform_id","getContractDetails","last_updated","addresses","contract_addresses","lookup","last_updated_at","path","getGasFee","ethersProvider","tokenAddress","baseFeePerGas","priorityFeePerGas","getGasPrice","fastest","priorityFeePerGasWei","coingecko","tokenPrice","getCurrentPriceByContract","erc20Client","erc20Connect","makeSlowGasTable","DEFAULT","makeInstantGasTable","GetGasByAddress","gasTable","getInstantGasByAddress","getSlowGasByAddress","getDepositFees","amountToRelay","discountPercent","slowGas","slowGasDiscounted","slowGasFee","instantGas","instantGasDiscounted","instantGasFee","slowPct","instantPct","feeLimitPercent","slowTotal","instantTotal","isAmountTooLow","gt","instant","pct","total","slow","Multicall","multicallClient","contractInstance","encodeRequest","target","callData","interface","encodeFunctionData","decodeResponse","response","decodeFunctionResult","child","forEach","_requests","encodedRequests","returnData","callStatic","aggregate","Multicall2","super","tryBlockAndAggregate","success","Multicall2Factory","signer","emit","confirmations","submissions","mined","processRequest","sent","sendTransaction","hash","processSubmission","receipt","getTransactionReceipt","catch","unsignedTx","populated","stringify","isMined","PoolState","batchRead","latestBlock","previousBlock","exchangeRatePrevious","exchangeRateCurrent","blockTag","PoolEventState","params","seen","hasEvent","addEvent","iface","abi","userAddress","all","queryFilter","filters","LiquidityAdded","LiquidityRemoved","filterSeen","makeEventFromLog","log","description","parseLog","eventSignature","signature","readTxReceipt","logs","UserState","user","balanceOf","calculateRemoval","amountWei","percentWei","receive","remain","recieve","joinUserState","poolState","userState","positionValue","totalDeposited","feesEarned","poolAddress","validateWithdraw","pool","lpTokenAmount","l1TokensToReturn","liquidReserves","pendingReserves","percentFloat","position","fees","multicallAddress","multicall","read","deps","pools","users","transactions","multicall2Address","rateModelInstance","rateModelStore","rateModelStoreAddress","getOrCreatePoolContract","poolContracts","getOrCreatePoolEvents","poolEvents","getOrCreateTransactionManager","transactionManagers","txman","TransactionManager","txReceipt","tx","updatePool","toAddress","then","updateUserWithTransaction","fromAddress","error","l1TokenAmount","overrides","populateTransaction","addLiquidity","lpAmount","hasPool","getPool","hasUser","updateUser","getUser","removeLiquidity","Boolean","hasTx","getTx","getUserState","getPoolEventState","blockDelta","rateModelRaw","l1TokenRateModels","totalPoolSize","utilizedReserves","secondsElapsed","blocksElapsed","estimatedApy","estimatedApr","projectedApr","liquidityUtilizationCurrent","joinPoolState","txMan","delayMs","intervalStarted","updateTransactions","l1Contracts","Proxy__OVM_L1StandardBridge","1","42","ADDRESS_MANAGER_ADDRESS","4","getL1BridgeAddress","l1StandardBridgeAddress","l1Signer","l1Erc20Address","l2Erc20Address","getChainId","l1StandardBridge","OptimismL1StandardBridgeEthers__factory","l1_ERC20","depositERC20","L2_DEPOSIT_GAS_LIMIT","depositETH","l1RpcProvider","l2RpcProvider","l2Messenger","Contract","predeploys","L2CrossDomainMessenger","getContractInterface","l1Messenger","l1CrossDomainMessenger","watcher","Watcher","l1","messengerAddress","l2","msgHash1","getMessageHashesFromL1Tx","getL2TransactionReceipt","allowance","approve","l1Provider","addressManagerAddress","addressManager","BobaAddressManagerEthers__factory","formatBytes32String","Date","getTime","getNetwork","proxyL1CrossDomainMessengerAddress","l2CrossDomainMessenger","msgHash","blockFinder","bind","bridgePoolAddress","bridgePoolInstance","rateModelStoreInstance","targetBlock","getBlockForTimestamp","currentUt","nextUt","rateModelForBlockHeight","liquidityUtilizationPostRelay","ExistenceError","message","setPrototypeOf","prototype","assertExists","condition","ignoreExistenceError","ignoreExistenceErrorAsync","OracleType","Flag","ContextType","hexValue","initFlags","MissingRequest","MissingUser","WrongChain","CanPropose","CanDispute","CanSettle","InDvmVote","RequestSettled","InsufficientBalance","InsufficientApproval","ProposalTxInProgress","ApprovalTxInProgress","DisputeTxInProgress","ChainChangeInProgress","getMulticall2Address","DefaultChainConfig","chainConfig","checkTxIntervalSec","DefaultConfig","getters","oracleType","chains","TransactionConfirmer","getReceipt","chainConfigToChainMetadata","chainMetadata","rangeStart","maxRange","range","currentRange","done","currentStart","currentEnd","rangeSuccessDescending","nextRange","ceil","nextEnd","nextStart","rangeFailureDescending","eventKey","_event$logIndex","insertOrderedAscending","array","element","orderBy","sortedLastIndexBy","isUnique","elementId","next","nowS","now","Read","flags","inputRequest","userChainId","requestChainId","Resolved","Expired","bond","totalBond","userCollateralBalance","userCollateralAllowance","lt","commands","filterCommands","command","proposePrice","disputePrice","switchOrAddChain","batchProps","Erc20","erc20","symbol","totalSupply","Erc20Multicall","factory","User","props","balance","account","allowances","OptimisticOracle","defaultLiveness","Chain","erc20s","_this$state","_this$state$erc20s","optimisticOracle","_this$state2","currentTime","Inputs","Services","_this$state3","_this$state4","_this$state5","Erc20Factory","Write","_this$state6","_this$state7","_this$state7$chains","inputs","services","context","sortedRequestsService","sortedRequests","_this$state8","_this$state8$services","descendingRequests","optionalChainId","_this$state$config","_this$state$config$ch","source","_this$state2$config","_this$state3$inputs","_this$state3$inputs$r","_this$state4$inputs","_this$state5$inputs","_this$state5$inputs$u","chain","_this$state6$chains","_this$state7$inputs","_this$state7$inputs$u","requestChain","_chain$optimisticOrac","_this$state8$inputs","_this$state8$inputs$u","input","_this$state9","_this$state9$inputs","liveness","_chain$optimisticOrac2","_chain$optimisticOrac3","_chain$optimisticOrac4","_chain$erc20s","_chain$erc20s$request","_chain$erc20s2","_chain$erc20s2$reques","_chain$erc20s2$reques2","oracle","oracleAddress","_chain$erc20s3","_chain$erc20s3$reques","_chain$erc20s3$reques2","_chain$erc20s3$reques3","_this$state10","_this$state10$service","_this$state10$service2","_this$state10$service3","_this$state11","_this$state11$service","_this$state11$service2","_this$state11$service3","_this$state11$service4","_this$state12","_this$state12$command","_this$state13","_this$state13$service","_this$state13$service2","_this$state13$service3","_this$state13$service4","_this$state14","_this$state14$service","_this$state14$service2","_this$state14$service3","_this$state15","search","listCommands","_this$state16","_this$state16$chains","time","_this$state17","_this$state17$service","_this$state18","query","Has","collateralProps","Store","write","cb","prevState","produce","OracleStore","Update","oracleAllowance","oo","oracleService","contractRequest","fetchRequest","getProps","token","collateralService","tokenService","transactionService","isConfirmed","getBlockNumber","listRequests","setByRequest","descending","w","requestIndexData","getRequest","initMemory","Handlers","memory","updateFromTransactionReceipt","send","code","iterations","ctx","Invalid","rangeState","oracleEvents","activeRequestFromEvents","_memory$state","pollRateSec","currentBlock","lastBlock","eventIndex","filteredRequests","_request$requestTx","_request$proposeTx","_request$disputeTx","_request$settleTx","_request$requestLogIn","_request$proposeLogIn","_request$disputeLogIn","_request$settleLogInd","found","requestInput","decodedLogs","_log$logIndex","settle","concurrency","requestsToFetch","eventBased","bluebird","ContextClient","ms","Step","handlers","copy","assign","handler","updated","shouldStep","override","uid","created","ContextManager","step","StateMachine","saveContext","shift","setUser","clearUser","setActiveRequest","pollActiveRequest","pollActiveUser","fetchPastEvents","pollNewEvents","setActiveRequestByTransaction","updateActiveRequest","fetchEventBased","types","handleCreate","pending","pop","Client","sm","poller","approveCollateral","MaxUint256","proposedPriceDecimals","startInterval","tick","console","stopInterval","makeProvider","rpcUrls","providers","getDefaultProvider","polling","FallbackProvider","optimisticOracleAddress","earliestBlockNumber","maxEventRangeQuery","disableFetchEventBased","upsertRequest","setDisputeHash","setProposeHash","setSettleHash","getState","updateFromEvents","SortedStore","SortedRequests","ascending","getByRequest","validateSolidityRequest","settled","resolvedPrice","customLiveness","SkinnyOptimisticOracle","OptimisticOracleV2","requestSettings","Skinny","Optimistic","OptimisticV2","EventHandler","publicEmit","prev","configTable","OptimisticFactory","SkinnyFactory","OptimisticV2Factory"],"mappings":"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"}