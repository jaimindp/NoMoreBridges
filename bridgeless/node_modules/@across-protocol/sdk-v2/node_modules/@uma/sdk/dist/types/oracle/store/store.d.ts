export declare type WriteCallback<S> = (state: S) => void;
export declare type Emit<S> = (state: S, prev: S) => void;
/**
 * Store. The store is meant to provide a global state that conforms to the type in types/state and
 * allow you to read/write and watch for change events. This uses immer, which manages how the nested
 * object gets updated to allow shallow change detection through nested paths.
 */
export default class Store<S> {
    private emit;
    private state;
    /**
     * constructor.
     *
     * @param {Emit} emit - Change callback, passes you the current and previous state any time theres a state change.
     * @param {State} state - The full state type which conforms to the state object.
     */
    constructor(emit: Emit<S>, state: S);
    /**
     * write. Allows caller to write to state. This wraps the state in "immer" which manages nested updates to state
     * through a proxy interface. When write is complete, an event is emitted with the current and previous state.
     *
     * @param {WriteCallback} cb
     */
    write(cb: WriteCallback<S>): void;
    writeAsync(cb: WriteCallback<S>): Promise<void>;
    read(): S;
}
