import { bridgePool } from "../../clients";
import { BigNumberish } from "../utils";
import { BatchReadWithErrors } from "../../utils";
import { ethers, Signer, BigNumber } from "ethers";
import type { Overrides } from "@ethersproject/contracts";
import { TransactionRequest, TransactionReceipt, Log } from "@ethersproject/abstract-provider";
import { Provider } from "@ethersproject/providers";
export type { Provider };
export declare type BatchReadWithErrorsType = ReturnType<ReturnType<typeof BatchReadWithErrors>>;
export declare type Awaited<T> = T extends PromiseLike<infer U> ? U : T;
export declare type Config = {
    multicall2Address: string;
    rateModelStoreAddress?: string;
    confirmations?: number;
    blockDelta?: number;
};
export declare type Dependencies = {
    provider: Provider;
};
export declare type Pool = {
    address: string;
    totalPoolSize: string;
    l1Token: string;
    liquidReserves: string;
    pendingReserves: string;
    exchangeRateCurrent: string;
    exchangeRatePrevious: string;
    estimatedApy: string;
    estimatedApr: string;
    blocksElapsed: number;
    secondsElapsed: number;
    liquidityUtilizationCurrent: string;
    utilizedReserves: string;
    projectedApr: string;
};
export declare type User = {
    address: string;
    poolAddress: string;
    lpTokens: string;
    positionValue: string;
    totalDeposited: string;
    feesEarned: string;
};
export declare type Transaction = {
    id: string;
    state: "requested" | "submitted" | "mined" | "error";
    toAddress: string;
    fromAddress: string;
    type: "Add Liquidity" | "Remove Liquidity";
    description: string;
    request?: TransactionRequest;
    hash?: string;
    receipt?: TransactionReceipt;
    error?: Error;
};
export declare type Token = {
    decimals: string;
    symbol: string;
    name: string;
};
export declare type State = {
    pools: Record<string, Pool>;
    users: Record<string, Record<string, User>>;
    transactions: Record<string, Transaction>;
    error?: Error;
};
export declare type EmitState = (path: string[], data: any) => void;
declare type EventIdParams = {
    blockNumber: number;
    transactionIndex: number;
    logIndex: number;
};
export declare class PoolEventState {
    private contract;
    private startBlock;
    private state;
    private seen;
    private iface;
    constructor(contract: bridgePool.Instance, startBlock?: number, state?: bridgePool.EventState);
    private makeId;
    hasEvent(params: EventIdParams): boolean;
    private addEvent;
    private filterSeen;
    read(endBlock: number, userAddress?: string): Promise<bridgePool.EventState>;
    makeEventFromLog(log: Log): {
        event: string;
        eventSignature: string;
        eventFragment: ethers.utils.EventFragment;
        name: string;
        signature: string;
        topic: string;
        args: ethers.utils.Result;
        blockNumber: number;
        blockHash: string;
        transactionIndex: number;
        removed: boolean;
        address: string;
        data: string;
        topics: string[];
        transactionHash: string;
        logIndex: number;
    };
    readTxReceipt(receipt: TransactionReceipt): bridgePool.EventState;
}
export declare function calculateRemoval(amountWei: BigNumber, percentWei: BigNumber): {
    recieve: string;
    remain: string;
};
export declare function previewRemoval(values: {
    positionValue: BigNumberish;
    feesEarned: BigNumberish;
    totalDeposited: BigNumberish;
}, percentFloat: number): {
    position: {
        recieve: string;
        remain: string;
    };
    fees: {
        recieve: string;
        remain: string;
    };
    total: {
        recieve: string;
        remain: string;
    };
};
export declare class ReadPoolClient {
    private address;
    private provider;
    private multicallAddress;
    private poolState;
    private multicall;
    private contract;
    private batchRead;
    constructor(address: string, provider: Provider, multicallAddress: string);
    read(latestBlock: number): Promise<{
        exchangeRateCurrent: ethers.BigNumber;
        liquidityUtilizationCurrent: ethers.BigNumber;
        liquidReserves: ethers.BigNumber;
        pendingReserves: ethers.BigNumber;
        utilizedReserves: ethers.BigNumber;
        address: string;
        l1Token: string;
        exchangeRatePrevious: ethers.BigNumber;
    }>;
}
export declare function validateWithdraw(pool: Pool, user: User, lpTokenAmount: BigNumberish): {
    lpTokenAmount: import("../../utils").BigNumberish;
    l1TokensToReturn: string;
};
export declare class Client {
    private config;
    private deps;
    private emit;
    private poolContracts;
    private multicall;
    private transactionManagers;
    private state;
    private batchRead;
    private poolEvents;
    private intervalStarted;
    private rateModelInstance;
    constructor(config: Config, deps: Dependencies, emit: EmitState);
    private getOrCreatePoolContract;
    private getOrCreatePoolEvents;
    private getOrCreateTransactionManager;
    addEthLiquidity(signer: Signer, pool: string, l1TokenAmount: BigNumberish, overrides?: Overrides): Promise<string>;
    addTokenLiquidity(signer: Signer, pool: string, l1TokenAmount: BigNumberish, overrides?: Overrides): Promise<string>;
    validateWithdraw(poolAddress: string, userAddress: string, lpAmount: BigNumberish): Promise<{
        lpTokenAmount: import("../../utils").BigNumberish;
        l1TokensToReturn: string;
    }>;
    removeTokenLiquidity(signer: Signer, pool: string, lpTokenAmount: BigNumberish, overrides?: Overrides): Promise<string>;
    removeEthliquidity(signer: Signer, pool: string, lpTokenAmount: BigNumberish, overrides?: Overrides): Promise<string>;
    getPool(poolAddress: string): Pool;
    hasPool(poolAddress: string): boolean;
    getUser(poolAddress: string, userAddress: string): User;
    hasUser(poolAddress: string, userAddress: string): boolean;
    hasTx(id: string): boolean;
    getTx(id: string): Transaction;
    private updateUserWithTransaction;
    updateUser(userAddress: string, poolAddress: string): Promise<void>;
    updatePool(poolAddress: string): Promise<void>;
    updateTransactions(): Promise<void>;
    startInterval(delayMs?: number): Promise<void>;
    stopInterval(): Promise<void>;
}
