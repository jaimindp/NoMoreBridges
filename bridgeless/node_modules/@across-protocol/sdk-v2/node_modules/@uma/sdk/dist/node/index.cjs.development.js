'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var rateModelStore = require('@uma/contracts-node');
var assert = _interopDefault(require('assert'));
var ethers$1 = require('ethers');
var zip = _interopDefault(require('lodash/zip'));
var lodash = require('lodash');
var axios = _interopDefault(require('axios'));
var get = _interopDefault(require('lodash/get'));
var highland = _interopDefault(require('highland'));
var Decimal = _interopDefault(require('decimal.js'));
var sortedIndexBy = _interopDefault(require('lodash/sortedIndexBy'));
var clamp = _interopDefault(require('lodash/clamp'));
var providers = require('@ethersproject/providers');
var set = _interopDefault(require('lodash/set'));
var has = _interopDefault(require('lodash/has'));
var contracts = require('@eth-optimism/contracts');
var coreUtils = require('@eth-optimism/core-utils');
var sortedLastIndexBy = _interopDefault(require('lodash/sortedLastIndexBy'));
var filter = _interopDefault(require('lodash/filter'));
var produce = _interopDefault(require('immer'));
var bluebird = _interopDefault(require('bluebird'));
var uid = _interopDefault(require('lodash/uniqueId'));
var sortedIndex = _interopDefault(require('lodash/sortedIndex'));
var sortedLastIndex = _interopDefault(require('lodash/sortedLastIndex'));

const Factory = rateModelStore.RegistryEthers__factory;
function connect(address, provider) {
  return Factory.connect(address, provider);
}
// experimenting with a generalized way of handling events and returning state, inspired from react style reducers
function reduceEvents(state = {}, event) {
  switch (event.event) {
    case "NewContractRegistered":
      {
        const typedEvent = event;
        const {
          contractAddress
        } = typedEvent.args;
        const contracts = (state == null ? void 0 : state.contracts) || {};
        return {
          ...state,
          contracts: {
            ...contracts,
            [contractAddress]: typedEvent
          }
        };
      }
  }
  return state;
}
function getEventState(events) {
  return events.reduce(reduceEvents, {});
}



var index = {
  __proto__: null,
  getAddress: rateModelStore.getRegistryAddress,
  getAbi: rateModelStore.getRegistryAddress,
  connect: connect,
  reduceEvents: reduceEvents,
  getEventState: getEventState
};

// check if a value is not null or undefined, useful for numbers which could be 0.
// "is" syntax: https://stackoverflow.com/questions/40081332/what-does-the-is-keyword-do-in-typescript
/* eslint-disable-next-line @typescript-eslint/ban-types */
function exists(value) {
  return value !== null && value !== undefined;
}
function Balances(balances = {}) {
  function create(id, amount = "0") {
    assert(!has(id), "balance already exists");
    return set(id, amount);
  }
  function has(id) {
    return exists(balances[id]);
  }
  function set(id, amount) {
    balances[id] = amount;
    return amount;
  }
  function add(id, amount) {
    return set(id, ethers$1.BigNumber.from(amount).add(getOrCreate(id)).toString());
  }
  function sub(id, amount) {
    return set(id, ethers$1.BigNumber.from(getOrCreate(id)).sub(amount).toString());
  }
  function get(id) {
    assert(has(id), "balance does not exist");
    return balances[id];
  }
  function getOrCreate(id) {
    if (has(id)) return get(id);
    return create(id);
  }
  return {
    create,
    add,
    sub,
    get,
    balances,
    set,
    has,
    getOrCreate
  };
}
// Copied from common, but modified for ethers Bignumber
const ConvertDecimals = (fromDecimals, toDecimals) => {
  assert(fromDecimals >= 0, "requires fromDecimals as an integer >= 0");
  assert(toDecimals >= 0, "requires toDecimals as an integer >= 0");
  // amount: string, BN, number - integer amount in fromDecimals smallest unit that want to convert toDecimals
  // returns: string with toDecimals in smallest unit
  return amount => {
    assert(exists(amount), "must provide an amount to convert");
    amount = ethers$1.BigNumber.from(amount);
    if (amount.isZero()) return amount.toString();
    const diff = fromDecimals - toDecimals;
    if (diff == 0) return amount.toString();
    if (diff > 0) return amount.div(ethers$1.BigNumber.from("10").pow(diff)).toString();
    return amount.mul(ethers$1.BigNumber.from("10").pow(-1 * diff)).toString();
  };
};
// async sleep
const sleep = (delay = 0) => new Promise(res => setTimeout(res, delay));
// Loop forever but wait until execution is finished before starting next timer. Throw an error to break this
// or add another utlity function if you need it to end on condition.
async function loop(fn, delay, ...args) {
  do {
    await fn(...args);
    await sleep(delay);
    /* eslint-disable-next-line no-constant-condition */
  } while (true);
}
const BatchReadWithErrors = multicall2 => contract => async calls => {
  // multicall batch takes array of {method} objects
  const results = await multicall2.batch(contract, calls.map(([method, ...args]) => ({
    method,
    args
  }))).readWithErrors();
  // convert results of multicall, an array of responses, into an object keyed by contract method
  return Object.fromEntries(zip(calls, results).map(([call, result]) => {
    if (call == null) return [];
    const [method] = call;
    if (!(result != null && result.result)) return [method, undefined];
    return [method, result.result[0] || result.result];
  }));
};
/**
 * @notice Return average block-time for a period.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
async function averageBlockTimeSeconds(chainId) {
  // TODO: Call an external API to get this data. Currently this value is a hard-coded estimate
  // based on the data from https://etherscan.io/chart/blocktime. ~13.5 seconds has been the average
  // since April 2016, although this value seems to spike periodically for a relatively short period of time.
  const defaultBlockTimeSeconds = 12;
  switch (chainId) {
    // Source: https://polygonscan.com/chart/blocktime
    case 10:
      return 0.5;
    case 42161:
      return 0.5;
    case 288:
      return 150;
    case 137:
      return 2.5;
    case 1:
      return defaultBlockTimeSeconds;
    default:
      return defaultBlockTimeSeconds;
  }
}
async function estimateBlocksElapsed(seconds, cushionPercentage = 0.0, chainId) {
  const cushionMultiplier = cushionPercentage + 1.0;
  const averageBlockTime = await averageBlockTimeSeconds(chainId);
  return Math.floor(seconds * cushionMultiplier / averageBlockTime);
}

var utils = {
  __proto__: null,
  exists: exists,
  Balances: Balances,
  ConvertDecimals: ConvertDecimals,
  sleep: sleep,
  loop: loop,
  BatchReadWithErrors: BatchReadWithErrors,
  averageBlockTimeSeconds: averageBlockTimeSeconds,
  estimateBlocksElapsed: estimateBlocksElapsed
};

const Factory$1 = rateModelStore.ExpiringMultiPartyEthers__factory;
function connect$1(address, provider) {
  return Factory$1.connect(address, provider);
}
// experimenting with a generalized way of handling events and returning state, inspired from react style reducers
function reduceEvents$1(state = {}, event) {
  switch (event.event) {
    case "RequestTransferPositionExecuted":
      {
        const typedEvent = event;
        const {
          oldSponsor,
          newSponsor
        } = typedEvent.args;
        const tokens = Balances(state.tokens || {});
        const collateral = Balances(state.collateral || {});
        const collateralBalance = collateral.get(oldSponsor);
        collateral.set(oldSponsor, "0");
        collateral.set(newSponsor, collateralBalance);
        const tokenBalance = tokens.get(oldSponsor);
        tokens.set(oldSponsor, "0");
        tokens.set(newSponsor, tokenBalance.toString());
        return {
          ...state,
          collateral: collateral.balances,
          tokens: tokens.balances
        };
      }
    case "PositionCreated":
      {
        const typedEvent = event;
        const {
          sponsor,
          collateralAmount,
          tokenAmount
        } = typedEvent.args;
        const tokens = Balances(state.tokens || {});
        const collateral = Balances(state.collateral || {});
        collateral.add(sponsor, collateralAmount.toString());
        tokens.add(sponsor, tokenAmount.toString());
        return {
          ...state,
          collateral: collateral.balances,
          tokens: tokens.balances
        };
      }
    case "NewSponsor":
      {
        const typedEvent = event;
        const {
          sponsor
        } = typedEvent.args;
        const sponsors = new Set(state.sponsors || []);
        sponsors.add(sponsor);
        return {
          ...state,
          sponsors: Array.from(sponsors.values())
        };
      }
    case "SettleExpiredPosition":
      {
        const typedEvent = event;
        const {
          caller,
          collateralReturned,
          tokensBurned
        } = typedEvent.args;
        const tokens = Balances(state.tokens || {});
        const collateral = Balances(state.collateral || {});
        collateral.sub(caller, collateralReturned.toString());
        tokens.sub(caller, tokensBurned.toString());
        return {
          ...state,
          expired: true,
          collateral: collateral.balances,
          tokens: tokens.balances
        };
      }
    case "Redeem":
      {
        const typedEvent = event;
        const {
          sponsor,
          collateralAmount,
          tokenAmount
        } = typedEvent.args;
        const tokens = Balances(state.tokens || {});
        const collateral = Balances(state.collateral || {});
        collateral.sub(sponsor, collateralAmount.toString());
        tokens.sub(sponsor, tokenAmount.toString());
        return {
          ...state,
          collateral: collateral.balances,
          tokens: tokens.balances
        };
      }
    case "LiquidationCreated":
      {
        const typedEvent = event;
        const {
          sponsor,
          tokensOutstanding,
          liquidatedCollateral
        } = typedEvent.args;
        const tokens = Balances(state.tokens || {});
        const collateral = Balances(state.collateral || {});
        collateral.sub(sponsor, liquidatedCollateral.toString());
        tokens.sub(sponsor, tokensOutstanding.toString());
        return {
          ...state,
          collateral: collateral.balances,
          tokens: tokens.balances
        };
      }
    // these 2 are the same
    case "Withdrawal":
    case "RequestWithdrawalExecuted":
      {
        const typedEvent = event;
        const {
          sponsor,
          collateralAmount
        } = typedEvent.args;
        const collateral = Balances(state.collateral || {});
        collateral.sub(sponsor, collateralAmount.toString());
        return {
          ...state,
          collateral: collateral.balances
        };
      }
    case "ContractExpired":
      {
        return {
          ...state,
          expired: true
        };
      }
  }
  return state;
}
function getEventState$1(events, initialState = {}) {
  return events.reduce(reduceEvents$1, initialState);
}



var index$1 = {
  __proto__: null,
  connect: connect$1,
  reduceEvents: reduceEvents$1,
  getEventState: getEventState$1
};

const Factory$2 = rateModelStore.ERC20Ethers__factory;
function connect$2(address, provider) {
  return Factory$2.connect(address, provider);
}
// takes all events and returns user balances and approvals
function reduceEvents$2(state = {}, event) {
  switch (event.event) {
    case "Transfer":
      {
        const typedEvent = event;
        const {
          from,
          to,
          value
        } = typedEvent.args;
        const balances = Balances(state.balances || {});
        balances.sub(from, value);
        balances.add(to, value);
        return {
          ...state,
          balances: balances.balances
        };
      }
    case "Approval":
      {
        const typedEvent = event;
        const {
          owner,
          spender,
          value
        } = typedEvent.args;
        lodash.set(state, ["approvalsByOwner", owner, spender], value.toString());
        lodash.set(state, ["approvalsBySpender", spender, owner], value.toString());
        return {
          ...state
        };
      }
  }
  return state;
}
function getEventState$2(events, initialState = {}) {
  return events.reduce(reduceEvents$2, initialState);
}



var index$2 = {
  __proto__: null,
  connect: connect$2,
  reduceEvents: reduceEvents$2,
  getEventState: getEventState$2
};

const Factory$3 = rateModelStore.MulticallEthers__factory;
function connect$3(address, provider) {
  return Factory$3.connect(address, provider);
}



var index$3 = {
  __proto__: null,
  connect: connect$3
};

const Factory$4 = rateModelStore.Multicall2Ethers__factory;
function connect$4(address, provider) {
  return Factory$4.connect(address, provider);
}



var index$4 = {
  __proto__: null,
  connect: connect$4
};

const Factory$5 = rateModelStore.LongShortPairCreatorEthers__factory;
function connect$5(address, provider) {
  return Factory$5.connect(address, provider);
}
function reduceEvents$3(state, event) {
  switch (event.event) {
    case "CreatedLongShortPair":
      {
        const typedEvent = event;
        const contracts = (state == null ? void 0 : state.contracts) || {};
        return {
          ...state,
          contracts: {
            ...contracts,
            [typedEvent.args.longShortPair]: typedEvent
          }
        };
      }
  }
  return state;
}
function getEventState$3(events, eventState = {}) {
  return events.reduce(reduceEvents$3, eventState);
}



var index$5 = {
  __proto__: null,
  getAddress: rateModelStore.getLongShortPairCreatorAddress,
  getAbi: rateModelStore.getLongShortPairCreatorAbi,
  connect: connect$5,
  reduceEvents: reduceEvents$3,
  getEventState: getEventState$3
};

const Factory$6 = rateModelStore.LongShortPairEthers__factory;
function connect$6(address, provider) {
  return Factory$6.connect(address, provider);
}
function reduceEvents$4(state, event) {
  switch (event.event) {
    case "TokensCreated":
      {
        const typedEvent = event;
        const {
          sponsor,
          collateralUsed,
          tokensMinted
        } = typedEvent.args;
        const sponsors = new Set(state.sponsors || []);
        const longs = Balances(state.longs || {});
        const shorts = Balances(state.shorts || {});
        const collateral = Balances(state.collateral || {});
        sponsors.add(sponsor);
        longs.add(sponsor, tokensMinted);
        shorts.add(sponsor, tokensMinted);
        collateral.add(sponsor, collateralUsed);
        return {
          ...state,
          collateral: collateral.balances,
          shorts: shorts.balances,
          longs: longs.balances,
          sponsors: Array.from(sponsors.values())
        };
      }
    case "TokensRedeemed":
      {
        const typedEvent = event;
        const {
          sponsor,
          collateralReturned,
          tokensRedeemed
        } = typedEvent.args;
        const longs = Balances(state.longs || {});
        const shorts = Balances(state.shorts || {});
        const collateral = Balances(state.collateral || {});
        longs.sub(sponsor, tokensRedeemed);
        shorts.sub(sponsor, tokensRedeemed);
        collateral.sub(sponsor, collateralReturned);
        return {
          ...state,
          collateral: collateral.balances,
          shorts: shorts.balances,
          longs: longs.balances
        };
      }
    case "ContractExpired":
      {
        const typedEvent = event;
        const {
          caller
        } = typedEvent.args;
        return {
          ...state,
          expired: true,
          expiredBy: caller
        };
      }
    case "PositionSettled":
      {
        const typedEvent = event;
        const {
          sponsor,
          collateralReturned,
          longTokens,
          shortTokens
        } = typedEvent.args;
        const longs = Balances(state.longs || {});
        const shorts = Balances(state.shorts || {});
        const collateral = Balances(state.collateral || {});
        longs.sub(sponsor, longTokens);
        shorts.sub(sponsor, shortTokens);
        collateral.sub(sponsor, collateralReturned);
        return {
          ...state,
          collateral: collateral.balances,
          shorts: shorts.balances,
          longs: longs.balances
        };
      }
  }
  return state;
}
function getEventState$4(events, eventState = {}) {
  return events.reduce(reduceEvents$4, eventState);
}



var index$6 = {
  __proto__: null,
  connect: connect$6,
  reduceEvents: reduceEvents$4,
  getEventState: getEventState$4
};

const Factory$7 = rateModelStore.BridgeDepositBoxEthers__factory;
function connect$7(address, provider) {
  return Factory$7.connect(address, provider);
}
function reduceEvents$5(state, event) {
  switch (event.event) {
    case "SetMinimumBridgingDelay":
      {
        const typedEvent = event;
        const {
          newMinimumBridgingDelay
        } = typedEvent.args;
        return {
          ...state,
          minimumBridgingDelay: newMinimumBridgingDelay.toString()
        };
      }
    case "WhitelistToken":
      {
        const typedEvent = event;
        const {
          l1Token,
          l2Token,
          lastBridgeTime,
          bridgePool
        } = typedEvent.args;
        return {
          ...state,
          whitelistedTokens: {
            ...state.whitelistedTokens,
            [l2Token]: {
              l1Token,
              l2Token,
              lastBridgeTime,
              bridgePool
            }
          }
        };
      }
    case "DepositsEnabled":
      {
        const typedEvent = event;
        const {
          l2Token,
          depositsEnabled
        } = typedEvent.args;
        return {
          ...state,
          depositsEnabled: {
            ...state.depositsEnabled,
            [l2Token]: depositsEnabled
          }
        };
      }
    case "FundsDeposited":
      {
        const typedEvent = event;
        const {
          chainId,
          depositId,
          l1Recipient,
          l2Sender,
          l1Token,
          amount,
          slowRelayFeePct,
          instantRelayFeePct,
          quoteTimestamp
        } = typedEvent.args;
        return {
          ...state,
          deposits: {
            ...state.deposits,
            [depositId.toString()]: {
              chainId,
              depositId,
              l1Recipient,
              l2Sender,
              l1Token,
              amount,
              slowRelayFeePct,
              instantRelayFeePct,
              quoteTimestamp
            }
          }
        };
      }
  }
  return state;
}
function getEventState$5(events, eventState = {}) {
  return events.reduce(reduceEvents$5, eventState);
}



var index$7 = {
  __proto__: null,
  connect: connect$7,
  reduceEvents: reduceEvents$5,
  getEventState: getEventState$5
};

const Factory$8 = rateModelStore.BridgePoolEthers__factory;
function connect$8(address, provider) {
  return Factory$8.connect(address, provider);
}
function attach(address) {
  return new Factory$8().attach(address);
}
function eventStateDefaults() {
  return {
    tokens: {},
    lpTokens: {},
    deposits: {},
    relays: {},
    instantRelays: {}
  };
}
function reduceEvents$6(state, event) {
  switch (event.event) {
    // event LiquidityAdded(address indexed token, uint256 amount, uint256 lpTokensMinted, address liquidityProvider);
    case "LiquidityAdded":
      {
        const typedEvent = event;
        const {
          amount,
          lpTokensMinted,
          liquidityProvider
        } = typedEvent.args;
        const tokens = Balances(state.tokens || {});
        const lpTokens = Balances(state.lpTokens || {});
        tokens.add(liquidityProvider, amount.toString());
        lpTokens.add(liquidityProvider, lpTokensMinted.toString());
        return {
          ...state,
          tokens: {
            ...tokens.balances
          },
          lpTokens: {
            ...lpTokens.balances
          }
        };
      }
    // event LiquidityRemoved(address indexed token, uint256 amount, uint256 lpTokensBurnt, address liquidityProvider);
    case "LiquidityRemoved":
      {
        const typedEvent = event;
        const {
          amount,
          lpTokensBurnt,
          liquidityProvider
        } = typedEvent.args;
        const tokens = Balances(state.tokens || {});
        const lpTokens = Balances(state.lpTokens || {});
        tokens.sub(liquidityProvider, amount.toString());
        lpTokens.sub(liquidityProvider, lpTokensBurnt.toString());
        return {
          ...state,
          tokens: {
            ...tokens.balances
          },
          lpTokens: {
            ...lpTokens.balances
          }
        };
      }
    // event DepositRelayed( bytes32 indexed depositHash, DepositData depositData, address l1Token, RelayData relay, bytes32 relayAncillaryDataHash);
    case "DepositRelayed":
      {
        const typedEvent = event;
        const {
          depositHash,
          depositData,
          relay,
          relayAncillaryDataHash
        } = typedEvent.args;
        return {
          ...state,
          relays: {
            ...state.relays,
            [relayAncillaryDataHash]: relay
          },
          deposits: {
            ...state.deposits,
            [depositHash]: depositData
          }
        };
      }
    // event RelaySpedUp(bytes32 indexed depositHash, address indexed instantRelayer, RelayData relay);
    case "RelaySpedUp":
      {
        const typedEvent = event;
        const {
          depositHash,
          instantRelayer
        } = typedEvent.args;
        return {
          ...state,
          instantRelays: {
            ...(state.instantRelays || {}),
            [depositHash]: instantRelayer
          }
        };
      }
    // event RelayDisputed(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);
    case "RelayDisputed":
      {
        // TODO: finish implementation
        // const typedEvent = event as RelayDisputed;
        // const { depositHash, relayHash, disputer } = typedEvent.args;
        return state;
      }
    // event RelayCanceled(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);
    case "RelayCanceled":
      {
        // TODO: finish implementation
        // const typedEvent = event as RelayCanceled;
        // const { depositHash, relayHash, disputer } = typedEvent.args;
        return state;
      }
    // event RelaySettled(bytes32 indexed depositHash, address indexed caller, RelayData relay);
    case "RelaySettled":
      {
        // TODO: finish implementation
        // const typedEvent = event as RelaySettled;
        // const { depositHash, caller, relay } = typedEvent.args;
        return state;
      }
    // event BridgePoolAdminTransferred(address oldAdmin, address newAdmin);
    case "BridgePoolAdminTransferred":
      {
        const typedEvent = event;
        const {
          oldAdmin,
          newAdmin
        } = typedEvent.args;
        return {
          ...state,
          oldAdmin,
          newAdmin
        };
      }
  }
  return state;
}
function getEventState$6(events, eventState = eventStateDefaults()) {
  return events.reduce(reduceEvents$6, eventState);
}



var index$8 = {
  __proto__: null,
  Factory: Factory$8,
  connect: connect$8,
  attach: attach,
  eventStateDefaults: eventStateDefaults,
  reduceEvents: reduceEvents$6,
  getEventState: getEventState$6
};

class Etherchain {
  constructor(url = "https://www.etherchain.org/api") {
    this.url = url;
  }
  async getGasPrice() {
    try {
      const endpoint = this.url + "/gasPriceOracle";
      const result = await axios.get(endpoint);
      return result.data;
    } catch (err) {
      const msg = get(err, "response.data.error", get(err, "response.statusText", "Unknown Coingecko Error"));
      throw new Error(msg);
    }
  }
}



var index$9 = {
  __proto__: null,
  Etherchain: Etherchain
};

const Factory$9 = rateModelStore.RateModelStoreEthers__factory;
function connect$9(address, provider) {
  return Factory$9.connect(address, provider);
}
function attach$1(address) {
  return new Factory$9().attach(address);
}



var index$a = {
  __proto__: null,
  Factory: Factory$9,
  getAddress: rateModelStore.getRateModelStoreAddress,
  connect: connect$9,
  attach: attach$1
};

const Factory$a = rateModelStore.OptimisticOracleInterfaceEthers__factory;
function connect$a(address, provider) {
  return Factory$a.connect(address, provider);
}
const contractInterface = /*#__PURE__*/new ethers$1.utils.Interface( /*#__PURE__*/rateModelStore.getOptimisticOracleInterfaceAbi());
var RequestState;
(function (RequestState) {
  RequestState[RequestState["Invalid"] = 0] = "Invalid";
  RequestState[RequestState["Requested"] = 1] = "Requested";
  RequestState[RequestState["Proposed"] = 2] = "Proposed";
  RequestState[RequestState["Expired"] = 3] = "Expired";
  RequestState[RequestState["Disputed"] = 4] = "Disputed";
  RequestState[RequestState["Resolved"] = 5] = "Resolved";
  RequestState[RequestState["Settled"] = 6] = "Settled";
})(RequestState || (RequestState = {}));
function requestId(request) {
  // if enabling sorting, put timestamp first
  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join("!");
}
function reduceEvents$7(state, event) {
  switch (event.event) {
    case "RequestPrice":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          currency,
          reward,
          finalFee
        } = typedEvent.args;
        const id = requestId(typedEvent.args);
        if (!state.requests) state.requests = {};
        const request = state.requests[id] || {
          requester,
          identifier,
          timestamp,
          ancillaryData
        };
        state.requests[id] = {
          ...request,
          currency,
          reward,
          finalFee,
          state: RequestState.Requested,
          requestTx: event.transactionHash,
          requestBlockNumber: event.blockNumber,
          requestLogIndex: event.logIndex
        };
        break;
      }
    case "ProposePrice":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          proposer,
          proposedPrice,
          expirationTimestamp,
          currency
        } = typedEvent.args;
        const id = requestId(typedEvent.args);
        if (!state.requests) state.requests = {};
        const request = state.requests[id] || {
          requester,
          identifier,
          timestamp,
          ancillaryData
        };
        state.requests[id] = {
          ...request,
          currency,
          proposer,
          proposedPrice,
          expirationTime: expirationTimestamp,
          state: RequestState.Proposed,
          proposeTx: event.transactionHash,
          proposeBlockNumber: event.blockNumber,
          proposeLogIndex: event.logIndex
        };
        break;
      }
    case "DisputePrice":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          proposer,
          disputer,
          proposedPrice
        } = typedEvent.args;
        const id = requestId(typedEvent.args);
        if (!state.requests) state.requests = {};
        const request = state.requests[id] || {
          requester,
          identifier,
          timestamp,
          ancillaryData
        };
        state.requests[id] = {
          ...request,
          proposer,
          disputer,
          proposedPrice,
          state: RequestState.Disputed,
          disputeTx: event.transactionHash,
          disputeBlockNumber: event.blockNumber,
          disputeLogIndex: event.logIndex
        };
        break;
      }
    case "Settle":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          proposer,
          disputer,
          price,
          payout
        } = typedEvent.args;
        const id = requestId(typedEvent.args);
        if (!state.requests) state.requests = {};
        const request = state.requests[id] || {
          requester,
          identifier,
          timestamp,
          ancillaryData
        };
        state.requests[id] = {
          ...request,
          requester,
          proposer,
          disputer,
          price,
          payout,
          state: RequestState.Settled,
          settleTx: event.transactionHash,
          settleBlockNumber: event.blockNumber,
          settleLogIndex: event.logIndex
        };
        break;
      }
  }
  return state;
}
function getEventState$7(events, eventState = {}) {
  return events.reduce(reduceEvents$7, eventState);
}



var index$b = {
  __proto__: null,
  connect: connect$a,
  contractInterface: contractInterface,
  get RequestState () { return RequestState; },
  requestId: requestId,
  reduceEvents: reduceEvents$7,
  getEventState: getEventState$7
};

const Factory$b = rateModelStore.SkinnyOptimisticOracleEthers__factory;
function connect$b(address, provider) {
  return Factory$b.connect(address, provider);
}
const contractInterface$1 = /*#__PURE__*/new ethers$1.utils.Interface( /*#__PURE__*/rateModelStore.getSkinnyOptimisticOracleAbi());
var RequestState$1;
(function (RequestState) {
  RequestState[RequestState["Invalid"] = 0] = "Invalid";
  RequestState[RequestState["Requested"] = 1] = "Requested";
  RequestState[RequestState["Proposed"] = 2] = "Proposed";
  RequestState[RequestState["Expired"] = 3] = "Expired";
  RequestState[RequestState["Disputed"] = 4] = "Disputed";
  RequestState[RequestState["Resolved"] = 5] = "Resolved";
  RequestState[RequestState["Settled"] = 6] = "Settled";
})(RequestState$1 || (RequestState$1 = {}));
function requestId$1(request) {
  // if enabling sorting, put timestamp first
  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join("!");
}
function reduceEvents$8(state, event) {
  switch (event.event) {
    case "RequestPrice":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          request
        } = typedEvent.args;
        const id = requestId$1(typedEvent.args);
        if (!state.requests) state.requests = {};
        state.requests[id] = {
          // need to maintain previous state in case it exists
          ...state.requests[id],
          ...request,
          requester,
          identifier,
          timestamp,
          ancillaryData,
          state: RequestState$1.Requested,
          requestTx: event.transactionHash,
          requestBlockNumber: event.blockNumber,
          requestLogIndex: event.logIndex
        };
        break;
      }
    case "ProposePrice":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          request
        } = typedEvent.args;
        const id = requestId$1(typedEvent.args);
        if (!state.requests) state.requests = {};
        state.requests[id] = {
          ...state.requests[id],
          ...request,
          requester,
          identifier,
          timestamp,
          ancillaryData,
          state: RequestState$1.Proposed,
          proposeTx: event.transactionHash,
          proposeBlockNumber: event.blockNumber,
          proposeLogIndex: event.logIndex
        };
        break;
      }
    case "DisputePrice":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          request
        } = typedEvent.args;
        const id = requestId$1(typedEvent.args);
        if (!state.requests) state.requests = {};
        state.requests[id] = {
          ...state.requests[id],
          ...request,
          requester,
          identifier,
          timestamp,
          ancillaryData,
          state: RequestState$1.Disputed,
          disputeTx: event.transactionHash,
          disputeBlockNumber: event.blockNumber,
          disputeLogIndex: event.logIndex
        };
        break;
      }
    case "Settle":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          request
        } = typedEvent.args;
        const id = requestId$1(typedEvent.args);
        if (!state.requests) state.requests = {};
        state.requests[id] = {
          ...state.requests[id],
          ...request,
          requester,
          identifier,
          timestamp,
          ancillaryData,
          state: RequestState$1.Settled,
          settleTx: event.transactionHash,
          settleBlockNumber: event.blockNumber,
          settleLogIndex: event.logIndex
        };
        break;
      }
  }
  return state;
}
function getEventState$8(events, eventState = {}) {
  return events.reduce(reduceEvents$8, eventState);
}



var index$c = {
  __proto__: null,
  connect: connect$b,
  contractInterface: contractInterface$1,
  get RequestState () { return RequestState$1; },
  requestId: requestId$1,
  reduceEvents: reduceEvents$8,
  getEventState: getEventState$8
};

const Factory$c = rateModelStore.OptimisticOracleV2InterfaceEthers__factory;
function connect$c(address, provider) {
  return Factory$c.connect(address, provider);
}
const contractInterface$2 = /*#__PURE__*/new ethers$1.utils.Interface( /*#__PURE__*/rateModelStore.getOptimisticOracleV2InterfaceAbi());
var RequestState$2;
(function (RequestState) {
  RequestState[RequestState["Invalid"] = 0] = "Invalid";
  RequestState[RequestState["Requested"] = 1] = "Requested";
  RequestState[RequestState["Proposed"] = 2] = "Proposed";
  RequestState[RequestState["Expired"] = 3] = "Expired";
  RequestState[RequestState["Disputed"] = 4] = "Disputed";
  RequestState[RequestState["Resolved"] = 5] = "Resolved";
  RequestState[RequestState["Settled"] = 6] = "Settled";
})(RequestState$2 || (RequestState$2 = {}));
function requestId$2(request) {
  // if enabling sorting, put timestamp first
  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join("!");
}
function reduceEvents$9(state, event) {
  switch (event.event) {
    case "RequestPrice":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          currency,
          reward,
          finalFee
        } = typedEvent.args;
        const id = requestId$2(typedEvent.args);
        if (!state.requests) state.requests = {};
        const request = state.requests[id] || {
          requester,
          identifier,
          timestamp,
          ancillaryData
        };
        state.requests[id] = {
          ...request,
          currency,
          reward,
          finalFee,
          state: RequestState$2.Requested,
          requestTx: event.transactionHash,
          requestBlockNumber: event.blockNumber,
          requestLogIndex: event.logIndex
        };
        break;
      }
    case "ProposePrice":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          proposer,
          proposedPrice,
          expirationTimestamp,
          currency
        } = typedEvent.args;
        const id = requestId$2(typedEvent.args);
        if (!state.requests) state.requests = {};
        const request = state.requests[id] || {
          requester,
          identifier,
          timestamp,
          ancillaryData
        };
        state.requests[id] = {
          ...request,
          currency,
          proposer,
          proposedPrice,
          expirationTime: expirationTimestamp,
          state: RequestState$2.Proposed,
          proposeTx: event.transactionHash,
          proposeBlockNumber: event.blockNumber,
          proposeLogIndex: event.logIndex
        };
        break;
      }
    case "DisputePrice":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          proposer,
          disputer,
          proposedPrice
        } = typedEvent.args;
        const id = requestId$2(typedEvent.args);
        if (!state.requests) state.requests = {};
        const request = state.requests[id] || {
          requester,
          identifier,
          timestamp,
          ancillaryData
        };
        state.requests[id] = {
          ...request,
          proposer,
          disputer,
          proposedPrice,
          state: RequestState$2.Disputed,
          disputeTx: event.transactionHash,
          disputeBlockNumber: event.blockNumber,
          disputeLogIndex: event.logIndex
        };
        break;
      }
    case "Settle":
      {
        const typedEvent = event;
        const {
          requester,
          identifier,
          timestamp,
          ancillaryData,
          proposer,
          disputer,
          price,
          payout
        } = typedEvent.args;
        const id = requestId$2(typedEvent.args);
        if (!state.requests) state.requests = {};
        const request = state.requests[id] || {
          requester,
          identifier,
          timestamp,
          ancillaryData
        };
        state.requests[id] = {
          ...request,
          requester,
          proposer,
          disputer,
          price,
          payout,
          state: RequestState$2.Settled,
          settleTx: event.transactionHash,
          settleBlockNumber: event.blockNumber,
          settleLogIndex: event.logIndex
        };
        break;
      }
  }
  return state;
}
function getEventState$9(events, eventState = {}) {
  return events.reduce(reduceEvents$9, eventState);
}



var index$d = {
  __proto__: null,
  connect: connect$c,
  contractInterface: contractInterface$2,
  get RequestState () { return RequestState$2; },
  requestId: requestId$2,
  reduceEvents: reduceEvents$9,
  getEventState: getEventState$9
};



var index$e = {
  __proto__: null,
  registry: index,
  emp: index$1,
  erc20: index$2,
  multicall: index$3,
  multicall2: index$4,
  lspCreator: index$5,
  lsp: index$6,
  bridgeDepositBox: index$7,
  bridgePool: index$8,
  etherchain: index$9,
  rateModelStore: index$a,
  optimisticOracle: index$b,
  skinnyOptimisticOracle: index$c,
  optimisticOracleV2: index$d
};

function JsMap (map = new Map()) {
  async function get(id) {
    return map.get(id);
  }
  async function set(id, data) {
    map.set(id, data);
  }
  async function has(id) {
    return map.has(id);
  }
  async function del(id) {
    map.delete(id);
  }
  async function entries() {
    return Array.from(map.entries());
  }
  async function values() {
    return Array.from(map.values());
  }
  async function keys() {
    return Array.from(map.keys());
  }
  async function size() {
    return map.size;
  }
  async function clear() {
    map.clear();
  }
  return {
    get,
    set,
    has,
    delete: del,
    entries,
    values,
    keys,
    size,
    clear
  };
}

// this class will basically give you similar functionality to a sorted key value store this is really useful for
// time series data, and JS does not have a native way to do this, but comes for free with most NoSql databases.
function SortedJsMap () {
  const ids = [];
  const map = new Map();
  function getStart(id, inclusive = true) {
    if (inclusive) {
      return lodash.sortedIndex(ids, id);
    } else {
      return lodash.sortedLastIndex(ids, id);
    }
  }
  function getEnd(id, inclusive = false) {
    return getStart(id, !inclusive);
  }
  function del(id) {
    const index = lodash.sortedIndex(ids, id);
    ids.splice(index, 1);
    const result = map.get(id);
    map.delete(id);
    return result;
  }
  // keeps typescript from complaining that return values may be undefined
  function getSafe(id) {
    const result = map.get(id);
    if (exists(result)) return result;
    throw new Error("Missing data for index: " + id);
  }
  return {
    async has(id) {
      return map.has(id);
    },
    async set(id, data) {
      if (map.has(id)) {
        map.set(id, data);
      } else {
        const index = lodash.sortedIndex(ids, id);
        ids.splice(index, 0, id);
        map.set(id, data);
      }
    },
    async get(id) {
      return map.get(id);
    },
    async values() {
      return ids.map(getSafe);
    },
    async entries() {
      return ids.map(id => [id, getSafe(id)]);
    },
    async keys() {
      return [...ids];
    },
    async clear() {
      map.clear();
      ids.length = 0;
    },
    async size() {
      return ids.length;
    },
    async delete(id) {
      if (!map.has(id)) return;
      del(id);
    },
    // assume [a,b)
    async between(a, b) {
      const start = getStart(a);
      const end = getEnd(b);
      return ids.slice(start, end).map(getSafe);
    },
    async slice(id, length) {
      const start = getStart(id);
      return ids.slice(start, start + length).map(getSafe);
    }
  };
}

//-
// Use an array, `excludeFromIndexes`, to exclude properties from indexing.
// This will allow storing string values larger than 1500 bytes.
// Example:
// [
//   'description',
//   'embeddedEntity.description',
//   'arrayValue[]',
//   'arrayValue[].description'
// ]
//-
function store (kind, store, excludeFromIndexes = []) {
  function makeKey(id) {
    return store.key([kind, id]);
  }
  // return value or undefined if it doesnt exist
  async function get(id) {
    try {
      const [result] = await store.get(makeKey(id));
      return result;
    } catch (err) {
      return;
    }
  }
  async function set(id, data) {
    await store.save({
      key: makeKey(id),
      data,
      excludeFromIndexes
    });
  }
  async function has(id) {
    // horribly ineficient to actually query data to see if it exists, but cannot find a better way
    return exists(await get(id));
  }
  async function del(id) {
    await store.delete(makeKey(id));
  }
  async function entries() {
    const [results] = await store.createQuery(kind).run();
    return results.map(result => {
      return [result[store.KEY].name, result];
    });
  }
  async function values() {
    const [results] = await store.createQuery(kind).run();
    return results;
  }
  // all this does is map over full entries to return the id of the entry. have not found a better way to query this.
  async function keys() {
    const [results] = await store.createQuery(kind).select("__key__").run();
    return results.map(result => {
      return result[store.KEY].name;
    });
  }
  // theres no way to really do built into the store client. Google recommends managing a size entry yourself.
  async function size() {
    throw new Error("size not supported in google store");
  }
  // this actually queries all values, then batches them to delete N at a time. This is a horrible way
  // to do this, but I could not find a better way to "drop" all kinds from the table.
  async function clear() {
    await highland(store.createQuery(kind).runStream()).map(val => {
      return val[store.KEY];
    }).batch(500).map(async keys => {
      return store.delete(keys);
    }).flatMap(highland).collect().toPromise(Promise);
  }
  async function slice(id, length) {
    const [result] = await store.createQuery(kind).filter("__key__", ">=", makeKey(id)).limit(length).run();
    return result;
  }
  async function between(a, b) {
    const [result] = await store.createQuery(kind).filter("__key__", ">=", makeKey(a)).filter("__key__", "<", makeKey(b)).run();
    return result;
  }
  return {
    get,
    set,
    has,
    delete: del,
    entries,
    values,
    keys,
    size,
    clear,
    between,
    slice
  };
}



var index$f = {
  __proto__: null,
  JsMap: JsMap,
  SortedJsMap: SortedJsMap,
  GoogleDatastore: store
};

function Table(config, store) {
  const {
    makeId,
    type
  } = config;
  async function create(data) {
    const id = exists(data.id) ? data.id : makeId(data);
    assert(!(await has(id)), `${type} exists: ` + id);
    return set({
      id,
      ...data
    });
  }
  async function set(data) {
    await store.set(data.id, {
      ...data
    });
    return data;
  }
  async function get(id) {
    assert(await store.has(id), `${type} does not exist`);
    return await store.get(id);
  }
  async function has(id) {
    return store.has(id);
  }
  async function update(id, data) {
    const got = await get(id);
    return set({
      ...got,
      ...data
    });
  }
  return {
    ...store,
    create,
    set,
    get,
    has,
    update,
    makeId,
    type
  };
}

function makeId(data) {
  return data.number;
}

// personally dont like to have this as a named export, but cannot export both function and type as default
const Table$1 = (type = "Block", store = JsMap()) => {
  const table = Table({
    type,
    makeId
  }, store);
  // delete blocks older than timestamp
  async function prune(timestamp) {
    const blocks = await table.values();
    const deleted = [];
    // normally would use a map or filter, but dont want to include bluebird as a dependency
    for (const block of blocks) {
      if (block.timestamp < timestamp) {
        var _block$id;
        await table.delete((_block$id = block.id) != null ? _block$id : block.number);
        deleted.push(block);
      }
    }
    return deleted;
  }
  return {
    ...table,
    prune
  };
};



var index$g = {
  __proto__: null,
  Table: Table$1,
  makeId: makeId
};

function makeId$1(data) {
  return data.address;
}

const Table$2 = (type = "Emp", store = JsMap()) => {
  const table = Table({
    type,
    makeId: makeId$1
  }, store);
  async function addSponsors(id, sponsors) {
    const data = await table.get(id);
    // keep sponsors unique
    const set = new Set([...(data.sponsors || []), ...sponsors]);
    return table.update(id, {
      sponsors: Array.from(set.values())
    });
  }
  async function setCreatedTimestamp(id, timestamp) {
    return table.update(id, {
      createdTimestamp: timestamp
    });
  }
  return {
    ...table,
    addSponsors,
    setCreatedTimestamp
  };
};



var index$h = {
  __proto__: null,
  Table: Table$2,
  makeId: makeId$1
};

function makeId$2(data) {
  return data.timestamp.toString().padStart(24, "0");
}

const Table$3 = (type = "Historical Price", store = SortedJsMap()) => {
  const table = Table({
    type,
    makeId: makeId$2
  }, store);
  function betweenByTimestamp(a, b) {
    return table.between(makeId$2({
      timestamp: a
    }), makeId$2({
      timestamp: b
    }));
  }
  function sliceByTimestamp(timestamp, length) {
    return table.slice(makeId$2({
      timestamp
    }), length);
  }
  function hasByTimestamp(timestamp) {
    return table.has(makeId$2({
      timestamp
    }));
  }
  function getByTimestamp(timestamp) {
    return table.get(makeId$2({
      timestamp
    }));
  }
  return {
    ...table,
    betweenByTimestamp,
    sliceByTimestamp,
    hasByTimestamp,
    getByTimestamp
  };
};



var index$i = {
  __proto__: null,
  Table: Table$3,
  makeId: makeId$2
};

function makeId$3(data) {
  return data.address;
}

const Table$4 = (type = "Token", store = JsMap()) => {
  const table = Table({
    type,
    makeId: makeId$3
  }, store);
  async function getOrCreate(address) {
    if (!(await table.has(makeId$3({
      address
    })))) return table.create({
      address
    });
    return table.get(makeId$3({
      address
    }));
  }
  async function upsert(address, data) {
    await getOrCreate(address);
    return table.update(address, data);
  }
  return {
    ...table,
    getOrCreate,
    upsert
  };
};



var index$j = {
  __proto__: null,
  Table: Table$4,
  makeId: makeId$3
};



var index$k = {
  __proto__: null,
  blocks: index$g,
  emps: index$h,
  historicalPrices: index$i,
  erc20s: index$j,
  base: Table
};

/**
 * toBN.
 *
 * @param {BigNumberish} num
 * @returns {BN}
 */
const toBN = num => ethers$1.BigNumber.from(num.toString());
/**
 * toBNWei.
 *
 * @param {BigNumberish} num
 * @param {number} decimals
 * @returns {BN}
 */
const toBNWei = (num, decimals) => ethers$1.ethers.utils.parseUnits(num.toString(), decimals);
/**
 * toWei.
 *
 * @param {BigNumberish} num
 * @param {number} decimals
 * @returns {string}
 */
const toWei = (num, decimals) => toBNWei(num, decimals).toString();
/**
 * fromWei.
 *
 * @param {BigNumberish} num
 * @param {number} decimals
 * @returns {string}
 */
const fromWei = (num, decimals) => ethers$1.ethers.utils.formatUnits(num.toString(), decimals);
/**
 * min.
 *
 * @param {BigNumberish} a
 * @param {BigNumberish} b
 * @returns {BN}
 */
function min(a, b) {
  const bna = toBN(a);
  const bnb = toBN(b);
  return bna.lte(bnb) ? bna : bnb;
}
/**
 * max.
 *
 * @param {BigNumberish} a
 * @param {BigNumberish} b
 * @returns {BN}
 */
function max(a, b) {
  const bna = toBN(a);
  const bnb = toBN(b);
  return bna.gte(bnb) ? bna : bnb;
}
const fixedPointAdjustment = /*#__PURE__*/toBNWei("1");
/**
 * Convert an amount of eth into a token given price and token decimals.
 *
 * @param {BigNumberish} fromAmount - Amount of eth to convert.
 * @param {string | number} [ price=1 ] - The price as eth per token, ie how much eth can 1 token buy.
 * @param {} [ toDecimals=18 ] - Number of decimals for the token currency.
 * @returns {string} The number of tokens denominated in token decimals in the smallest unit (wei).
 */
function ethToToken(fromAmount, price = 1, toDecimals = 18) {
  const priceWei = toBNWei(price);
  const toAmount = toBNWei(fromAmount).div(priceWei);
  return ConvertDecimals(18, toDecimals)(toAmount);
}
/**
 * Convert a gas amount and gas price to wei.
 *
 * @param {number} gas - gas amount.
 * @param {BigNumberish} gasPrice - gas price in gwei.
 * @returns {BigNumber} - total fees in wei.
 */
const gasToEth = (gas, gasPrice) => {
  return ethers$1.BigNumber.from(gas).mul(gasPrice);
};
/**
 * getGasFees. Low level pure function call to calculate gas fees.
 *
 * @param {number} gas - The gast cost for transfer, use constants defined in file.
 * @param {BigNumberish} gasPrice - Estimated gas price in wei.
 * @param {string | number} [price = 1] - The price of the token in eth, how much eth can 1 token buy.
 * @param {number} [decimals=18] - Number of decimals of token.
 * @returns {string} - The value of fees native to the token/eth provided, in its smallest unit.
 */
function calculateGasFees(gas, gasPrice, price = 1, decimals = 18) {
  const amountEth = gasToEth(gas, gasPrice);
  return ethToToken(amountEth, price, decimals);
}
/**
 * percent.
 *
 * @param {BigNumberish} numerator
 * @param {BigNumberish} denominator
 * @returns {BN}
 */
function percent(numerator, denominator) {
  return fixedPointAdjustment.mul(numerator).div(denominator);
}
/**
 * calcContinuousCompoundInterest. From https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=0&t=1&given_data_last=find_r&action=solve
 * Returns a yearly interest rate if start/end amount had been continuously compounded over the period elapsed. Multiply result by 100 for a %.
 *
 * @param {string} startAmount
 * @param {string} endAmount
 * @param {string} periodsElapsed
 * @param {string} periodsPerYear
 */
const calcContinuousCompoundInterest = (startAmount, endAmount, periodsElapsed, periodsPerYear) => {
  const years = new Decimal(periodsPerYear).div(periodsElapsed);
  return new Decimal(endAmount).div(startAmount).ln().div(years).toString();
};
/**
 * calcPeriodicCompoundInterest. Taken from https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=365&t=1&given_data_last=find_r&action=solve
 * This will return a periodically compounded interest rate for 1 year. Multiply result by 100 for a %.
 *
 * @param {string} startAmount - Starting amount or price
 * @param {string} endAmount - Ending amount or price
 * @param {string} periodsElapsed - How many periods elapsed for the start and end amount.
 * @param {string} periodsPerYear - How many periods in 1 year.
 */
const calcPeriodicCompoundInterest = (startAmount, endAmount, periodsElapsed, periodsPerYear) => {
  const n = new Decimal(periodsPerYear);
  const A = new Decimal(endAmount);
  const P = new Decimal(startAmount);
  const t = new Decimal(periodsPerYear).div(periodsElapsed);
  const one = new Decimal(1);
  return n.mul(A.div(P).pow(one.div(n.div(t))).sub(one)).toString();
};
/**
 * calcApr. Simple apr calculation based on extrapolating the difference for a short period over a year.
 *
 * @param {Decimalish} startAmount - Starting amount or price
 * @param {Decimalish} endAmount - Ending amount or price
 * @param {Decimalish} periodsElapsed - periods elapsed from start to end
 * @param {Decimalish} periodsPerYear - periods per year
 */
const calcApr = (startAmount, endAmount, periodsElapsed, periodsPerYear) => {
  return new Decimal(endAmount).sub(startAmount).div(startAmount).mul(periodsPerYear).div(periodsElapsed).toString();
};

var utils$1 = {
  __proto__: null,
  toBN: toBN,
  toBNWei: toBNWei,
  toWei: toWei,
  fromWei: fromWei,
  min: min,
  max: max,
  fixedPointAdjustment: fixedPointAdjustment,
  ethToToken: ethToToken,
  gasToEth: gasToEth,
  calculateGasFees: calculateGasFees,
  percent: percent,
  calcContinuousCompoundInterest: calcContinuousCompoundInterest,
  calcPeriodicCompoundInterest: calcPeriodicCompoundInterest,
  calcApr: calcApr
};

// This Util calculates the across realized LP fees. See https://gist.github.com/chrismaree/a713725e4fe96c531c42ed7b629d4a85
// Calculate the rate for a 0 sized deposit (infinitesimally small).
function calculateInstantaneousRate(rateModel, utilization) {
  const beforeKink = min(utilization, rateModel.UBar).mul(rateModel.R1).div(rateModel.UBar);
  const afterKink = max(toBN("0"), toBN(utilization).sub(rateModel.UBar)).mul(rateModel.R2).div(toBNWei("1").sub(rateModel.UBar));
  return toBN(rateModel.R0).add(beforeKink).add(afterKink);
}
//  Compute area under curve of the piece-wise linear rate model.
function calculateAreaUnderRateCurve(rateModel, utilization) {
  // Area under first piecewise component
  const utilizationBeforeKink = min(utilization, rateModel.UBar);
  const rectangle1Area = utilizationBeforeKink.mul(rateModel.R0).div(fixedPointAdjustment);
  const triangle1Area = toBNWei("0.5").mul(calculateInstantaneousRate(rateModel, utilizationBeforeKink).sub(rateModel.R0)).mul(utilizationBeforeKink).div(fixedPointAdjustment).div(fixedPointAdjustment);
  // Area under second piecewise component
  const utilizationAfter = max(toBN("0"), utilization.sub(rateModel.UBar));
  const rectangle2Area = utilizationAfter.mul(toBN(rateModel.R0).add(rateModel.R1)).div(fixedPointAdjustment);
  const triangle2Area = toBNWei("0.5").mul(calculateInstantaneousRate(rateModel, utilization).sub(toBN(rateModel.R0).add(rateModel.R1))).mul(utilizationAfter).div(fixedPointAdjustment).div(fixedPointAdjustment);
  return rectangle1Area.add(triangle1Area).add(rectangle2Area).add(triangle2Area);
}
// converts an APY rate to a one week rate. Uses the Decimal library to take a fractional exponent
function convertApyToWeeklyFee(apy) {
  // R_week = (1 + apy)^(1/52) - 1
  const weeklyFeePct = Decimal.pow(new Decimal("1").plus(fromWei(apy)), new Decimal("1").dividedBy(new Decimal("52"))).minus(new Decimal("1"));
  // Convert from decimal back to BN, scaled by 1e18.
  return toBN(weeklyFeePct.times(fixedPointAdjustment.toString()).floor().toString());
}
// Calculate the realized yearly LP Fee APY Percent for a given rate model, utilization before and after the deposit.
function calculateApyFromUtilization(rateModel, utilizationBeforeDeposit, utilizationAfterDeposit) {
  if (utilizationBeforeDeposit.eq(utilizationAfterDeposit)) throw new Error("Deposit cant have zero size");
  // Get the area of [0, utilizationBeforeDeposit] and [0, utilizationAfterDeposit]
  const areaBeforeDeposit = calculateAreaUnderRateCurve(rateModel, utilizationBeforeDeposit);
  const areaAfterDeposit = calculateAreaUnderRateCurve(rateModel, utilizationAfterDeposit);
  const numerator = areaAfterDeposit.sub(areaBeforeDeposit);
  const denominator = utilizationAfterDeposit.sub(utilizationBeforeDeposit);
  return numerator.mul(fixedPointAdjustment).div(denominator);
}
function calculateRealizedLpFeePct(rateModel, utilizationBeforeDeposit, utilizationAfterDeposit) {
  const apy = calculateApyFromUtilization(rateModel, toBN(utilizationBeforeDeposit), toBN(utilizationAfterDeposit));
  return convertApyToWeeklyFee(apy);
}

var feeCalculator = {
  __proto__: null,
  calculateInstantaneousRate: calculateInstantaneousRate,
  calculateApyFromUtilization: calculateApyFromUtilization,
  calculateRealizedLpFeePct: calculateRealizedLpFeePct
};

// these gas costs are estimations, its possible to provide better estimations yourself when invoking getGasFees.
const SLOW_ETH_GAS = 243177;
const SLOW_ERC_GAS = 250939;
const SLOW_UMA_GAS = 273955;
// fast costs are slightly higher and include the slow cost
const FAST_ETH_GAS = 273519;
const FAST_ERC_GAS = 281242;
const FAST_UMA_GAS = 305572;
const SPEED_UP_ETH_GAS = 195288;
const SPEED_UP_ERC_GAS = 203011;
const SPEED_UP_UMA_GAS = 227341;
// Bots incur lower than expected costs due to batching mulitple transactions, this roughly estimates the savings
const DEFAULT_GAS_DISCOUNT = 25;
const expectedRateModelKeys = ["UBar", "R0", "R1", "R2"];
// Amount of blocks to wait following a `TokensBridged` L2 event until we check the L1 state commitment contracts. This
// offset provides a buffer to allow for any time delay between L2 state changing and L1 state updating. For example,
// Optimism has a several hour delay.
const L2_STATE_COMMITMENT_DELAY_BLOCKS = 25000;
const AddressZero = ethers$1.ethers.constants.AddressZero;
// mainnet addresses, hard coded here for convenience, but theres probably a better pattern for this
const ADDRESSES = {
  ETH: AddressZero,
  UMA: "0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828",
  WETH: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
  USDC: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
  RateModel: "0xd18fFeb5fdd1F2e122251eA7Bf357D8Af0B60B50"
};
const SECONDS_PER_YEAR = 31557600; // based on 365.25 days per year
const DEFAULT_BLOCK_DELTA = 10; // look exchange rate up based on 10 block difference by default

var constants = {
  __proto__: null,
  SLOW_ETH_GAS: SLOW_ETH_GAS,
  SLOW_ERC_GAS: SLOW_ERC_GAS,
  SLOW_UMA_GAS: SLOW_UMA_GAS,
  FAST_ETH_GAS: FAST_ETH_GAS,
  FAST_ERC_GAS: FAST_ERC_GAS,
  FAST_UMA_GAS: FAST_UMA_GAS,
  SPEED_UP_ETH_GAS: SPEED_UP_ETH_GAS,
  SPEED_UP_ERC_GAS: SPEED_UP_ERC_GAS,
  SPEED_UP_UMA_GAS: SPEED_UP_UMA_GAS,
  DEFAULT_GAS_DISCOUNT: DEFAULT_GAS_DISCOUNT,
  expectedRateModelKeys: expectedRateModelKeys,
  L2_STATE_COMMITMENT_DELAY_BLOCKS: L2_STATE_COMMITMENT_DELAY_BLOCKS,
  AddressZero: AddressZero,
  ADDRESSES: ADDRESSES,
  SECONDS_PER_YEAR: SECONDS_PER_YEAR,
  DEFAULT_BLOCK_DELTA: DEFAULT_BLOCK_DELTA
};

class RateModelDictionary {
  constructor() {
    this.rateModelDictionary = {};
  }
  _throwIfNotInitialized() {
    if (Object.keys(this.rateModelDictionary).length == 0) throw new Error("RateModelUtility method called before updating rate model dictionary!");
  }
  updateWithEvents(rateModelEvents) {
    this.rateModelDictionary = createRateModelEventDictionary(rateModelEvents);
  }
  /**
   * Return the rate model for L1 token set at the block height.
   * @param l1Token L1 token address to get rate model for.
   * @param blockNumber Block height to get rate model for.
   * @returns Rate model object.
   */
  getRateModelForBlockNumber(l1Token, blockNumber) {
    this._throwIfNotInitialized();
    const l1TokenNormalized = ethers$1.ethers.utils.getAddress(l1Token);
    if (!this.rateModelDictionary[l1TokenNormalized] || this.rateModelDictionary[l1TokenNormalized].length === 0) throw new Error(`No updated rate model events for L1 token: ${l1TokenNormalized}`);
    if (!blockNumber) {
      // If block number is undefined, use latest updated rate model.
      return parseAndReturnRateModelFromString(this.rateModelDictionary[l1TokenNormalized].slice(-1)[0].rateModel);
    } else {
      const firstEventBlockNumber = this.rateModelDictionary[l1TokenNormalized][0].blockNumber;
      if (blockNumber < firstEventBlockNumber) {
        throw new Error(`Block number #${blockNumber} is before first UpdatedRateModel event block ${firstEventBlockNumber}`);
      }
      // We're looking for the latest rate model update that occurred at or before the block number.
      // Rate model events are inserted into the array from oldest at index 0 to newest at index length-1, so we'll
      // reverse the array so it goes from newest at index 0 to oldest at index length-1, and then find the first event
      // who's block number is less than or equal to the target block number.
      const rateModel = this.rateModelDictionary[l1TokenNormalized].slice().reverse() // reverse() modifies memory in place so create a copy first.
      .find(event => event.blockNumber <= blockNumber);
      if (!rateModel) throw new Error(`No updated rate model events before block #${blockNumber} for L1 token: ${l1TokenNormalized}`);
      return parseAndReturnRateModelFromString(rateModel == null ? void 0 : rateModel.rateModel);
    }
  }
  /**
   * @notice Return all L1 tokens that had a rate model associated with it at the block number.
   * @param blockNumber Returns l1 tokens that were mapped to a rate model at this block height. If undefined,
   * this function will return all L1 tokens that have a block number as of the latest block height.
   * @returns array of L1 token addresses.
   */
  getL1TokensFromRateModel(blockNumber = undefined) {
    this._throwIfNotInitialized();
    return Object.keys(this.rateModelDictionary).map(l1Token => {
      const l1TokenNormalized = ethers$1.ethers.utils.getAddress(l1Token);
      // Check that there is at least one UpdatedRateModel event before the provided block number, otherwise
      // this L1 token didn't exist in the RateModel at the block height and we shouldn't include it in the returned
      // array.
      if (!blockNumber || this.rateModelDictionary[l1TokenNormalized].find(event => event.blockNumber <= blockNumber)) return ethers$1.ethers.utils.getAddress(l1Token);else return null;
    }).filter(exists);
  }
}
/**
 * Helper method that returns parsed rate model from string, or throws.
 * @param rateModelString Stringified rate model to parse.
 * @returns Rate model object. Must conform to `expectedRateModelKeys` format.
 */
const parseAndReturnRateModelFromString = rateModelString => {
  const rateModelFromEvent = JSON.parse(rateModelString);
  // Rate model must contain the exact same keys in `expectedRateModelKeys`.
  for (const key of expectedRateModelKeys) {
    if (!Object.keys(rateModelFromEvent).includes(key)) {
      throw new Error(`Rate model does not contain all expected keys. Expected keys: [${expectedRateModelKeys}], actual keys: [${Object.keys(rateModelFromEvent)}]`);
    }
  }
  for (const key of Object.keys(rateModelFromEvent)) {
    if (!expectedRateModelKeys.includes(key)) {
      throw new Error(`Rate model contains unexpected keys. Expected keys: [${expectedRateModelKeys}], actual keys: [${Object.keys(rateModelFromEvent)}]`);
    }
  }
  return {
    UBar: rateModelFromEvent.UBar,
    R0: rateModelFromEvent.R0,
    R1: rateModelFromEvent.R1,
    R2: rateModelFromEvent.R2
  };
};
/**
 * Given an unsorted array of updated rate model events, return a dictionary mapping token addresses to sorted
 * rate model events. This method is used internally to enforce chronological sorting of events and mapping rate models
 * to token addresses.
 * @param rateModelEvents Unsorted updated rate model events, each of which contains a token address, the stringified
 * rate model for that token, and the block height of the update.
 * @returns Dictionary mapping token addresses to chronologically sorted rate model updates.
 */
const createRateModelEventDictionary = rateModelEvents => {
  const updatedRateModelEventsForToken = {};
  // Sort events in-place from oldest to newest:
  rateModelEvents.sort((a, b) => {
    if (a.blockNumber !== b.blockNumber) {
      return a.blockNumber - b.blockNumber;
    }
    if (a.transactionIndex !== b.transactionIndex) {
      return a.transactionIndex - b.transactionIndex;
    }
    return a.logIndex - b.logIndex;
  });
  for (const updatedRateModelEvent of rateModelEvents) {
    // The contract enforces that all rate models are mapped to addresses, therefore we do not need to check that
    // `l1Token` is a valid address.
    const l1TokenNormalized = ethers$1.ethers.utils.getAddress(updatedRateModelEvent.l1Token);
    if (!updatedRateModelEventsForToken[l1TokenNormalized]) updatedRateModelEventsForToken[l1TokenNormalized] = [];
    // We assume that events are returned from oldest to newest, so we can simply push events into the array and
    // and maintain their time order.
    updatedRateModelEventsForToken[l1TokenNormalized].push({
      blockNumber: updatedRateModelEvent.blockNumber,
      rateModel: updatedRateModelEvent.rateModel
    });
  }
  return updatedRateModelEventsForToken;
};

var rateModel = {
  __proto__: null,
  RateModelDictionary: RateModelDictionary,
  parseAndReturnRateModelFromString: parseAndReturnRateModelFromString
};

class BlockFinder {
  constructor(requestBlock, blocks = [], chainId = 1) {
    this.requestBlock = requestBlock;
    this.blocks = blocks;
    this.chainId = chainId;
    assert(requestBlock, "requestBlock function must be provided");
  }
  /**
   * @notice Gets the latest block whose timestamp is <= the provided timestamp.
   * @param {number} timestamp timestamp to search.
   */
  async getBlockForTimestamp(timestamp) {
    timestamp = Number(timestamp);
    assert(timestamp !== undefined && timestamp !== null, "timestamp must be provided");
    // If the last block we have stored is too early, grab the latest block.
    if (this.blocks.length === 0 || this.blocks[this.blocks.length - 1].timestamp < timestamp) {
      const block = await this.getLatestBlock();
      if (timestamp >= block.timestamp) return block;
    }
    // Check the first block. If it's greater than our timestamp, we need to find an earlier block.
    if (this.blocks[0].timestamp > timestamp) {
      const initialBlock = this.blocks[0];
      // We use a 2x cushion to reduce the number of iterations in the following loop and increase the chance
      // that the first block we find sets a floor for the target timestamp. The loop converges on the correct block
      // slower than the following incremental search performed by `findBlock`, so we want to minimize the number of
      // loop iterations in favor of searching more blocks over the `findBlock` search.
      const cushion = 1;
      const incrementDistance = Math.max(
      // Ensure the increment block distance is _at least_ a single block to prevent an infinite loop.
      await estimateBlocksElapsed(initialBlock.timestamp - timestamp, cushion, this.chainId), 1);
      // Search backwards by a constant increment until we find a block before the timestamp or hit block 0.
      for (let multiplier = 1;; multiplier++) {
        const distance = multiplier * incrementDistance;
        const blockNumber = Math.max(0, initialBlock.number - distance);
        const block = await this.getBlock(blockNumber);
        if (block.timestamp <= timestamp) break; // Found an earlier block.
        assert(blockNumber > 0, "timestamp is before block 0"); // Block 0 was not earlier than this timestamp. The row.
      }
    }
    // Find the index where the block would be inserted and use that as the end block (since it is >= the timestamp).
    const index = sortedIndexBy(this.blocks, {
      timestamp
    }, "timestamp");
    return this.findBlock(this.blocks[index - 1], this.blocks[index], timestamp);
  }
  // Grabs the most recent block and caches it.
  async getLatestBlock() {
    var _this$blocks$index;
    const block = await this.requestBlock("latest");
    const index = sortedIndexBy(this.blocks, block, "number");
    if (((_this$blocks$index = this.blocks[index]) == null ? void 0 : _this$blocks$index.number) !== block.number) this.blocks.splice(index, 0, block);
    return this.blocks[index];
  }
  // Grabs the block for a particular number and caches it.
  async getBlock(number) {
    var _this$blocks$index2, _this$blocks$index3;
    let index = sortedIndexBy(this.blocks, {
      number
    }, "number");
    if (((_this$blocks$index2 = this.blocks[index]) == null ? void 0 : _this$blocks$index2.number) === number) return this.blocks[index]; // Return early if block already exists.
    const block = await this.requestBlock(number);
    // Recompute the index after the async call since the state of this.blocks could have changed!
    index = sortedIndexBy(this.blocks, {
      number
    }, "number");
    // Rerun this check to avoid duplicate insertion.
    if (((_this$blocks$index3 = this.blocks[index]) == null ? void 0 : _this$blocks$index3.number) === number) return this.blocks[index];
    this.blocks.splice(index, 0, block); // A simple insert at index.
    return block;
  }
  // Return the latest block, between startBlock and endBlock, whose timestamp is <= timestamp.
  // Effectively, this is an interpolation search algorithm to minimize block requests.
  // Note: startBlock and endBlock _must_ be different blocks.
  async findBlock(_startBlock, _endBlock, timestamp) {
    const [startBlock, endBlock] = [_startBlock, _endBlock];
    // In the case of equality, the endBlock is expected to be passed as the one whose timestamp === the requested
    // timestamp.
    if (endBlock.timestamp === timestamp) return endBlock;
    // If there's no equality, but the blocks are adjacent, return the startBlock, since we want the returned block's
    // timestamp to be <= the requested timestamp.
    if (endBlock.number === startBlock.number + 1) return startBlock;
    assert(endBlock.number !== startBlock.number, "startBlock cannot equal endBlock");
    assert(timestamp < endBlock.timestamp && timestamp > startBlock.timestamp, "timestamp not in between start and end blocks");
    // Interpolating the timestamp we're searching for to block numbers.
    const totalTimeDifference = endBlock.timestamp - startBlock.timestamp;
    const totalBlockDistance = endBlock.number - startBlock.number;
    const blockPercentile = (timestamp - startBlock.timestamp) / totalTimeDifference;
    const estimatedBlock = startBlock.number + Math.round(blockPercentile * totalBlockDistance);
    // Clamp ensures the estimated block is strictly greater than the start block and strictly less than the end block.
    const newBlock = await this.getBlock(clamp(estimatedBlock, startBlock.number + 1, endBlock.number - 1));
    // Depending on whether the new block is below or above the timestamp, narrow the search space accordingly.
    if (newBlock.timestamp < timestamp) {
      return this.findBlock(newBlock, endBlock, timestamp);
    } else {
      return this.findBlock(startBlock, newBlock, timestamp);
    }
  }
}

class LpFeeCalculator {
  constructor(provider) {
    this.provider = provider;
    this.blockFinder = new BlockFinder(provider.getBlock.bind(provider));
  }
  async getLpFeePct(tokenAddress, bridgePoolAddress, amount, timestamp) {
    amount = ethers$1.BigNumber.from(amount);
    assert(amount.gt(0), "Amount must be greater than 0");
    const {
      blockFinder,
      provider
    } = this;
    const bridgePoolInstance = connect$8(bridgePoolAddress, provider);
    const rateModelStoreAddress = await rateModelStore.getRateModelStoreAddress(await (await this.provider.getNetwork()).chainId);
    const rateModelStoreInstance = connect$9(rateModelStoreAddress, provider);
    const targetBlock = exists(timestamp) ? await blockFinder.getBlockForTimestamp(timestamp) : await provider.getBlock("latest");
    assert(exists(targetBlock), "Unable to find target block for timestamp: " + timestamp || "latest");
    const blockTag = targetBlock.number;
    const [currentUt, nextUt, rateModelForBlockHeight] = await Promise.all([bridgePoolInstance.callStatic.liquidityUtilizationCurrent({
      blockTag
    }), bridgePoolInstance.callStatic.liquidityUtilizationPostRelay(amount, {
      blockTag
    }), rateModelStoreInstance.callStatic.l1TokenRateModels(tokenAddress, {
      blockTag
    })]);
    // Parsing stringified rate model will error if the rate model doesn't contain exactly the expected keys or isn't
    // a JSON object.
    const rateModel = parseAndReturnRateModelFromString(rateModelForBlockHeight);
    return calculateRealizedLpFeePct(rateModel, currentUt, nextUt);
  }
}

class Coingecko {
  constructor(host = "https://api.coingecko.com/api/v3") {
    this.host = host;
  }
  // Fetch historic prices for a `contract` denominated in `currency` between timestamp `from` and `to`. Note timestamps
  // are assumed to be js timestamps and are converted to unixtimestamps by dividing by 1000.
  async getHistoricContractPrices(contract, from, to, currency = "usd") {
    assert(contract, "requires contract address");
    assert(currency, "requires currency symbol");
    assert(from, "requires from timestamp");
    assert(to, "requires to timestamp");
    from = Math.floor(from / 1000);
    to = Math.floor(to / 1000);
    const result = await this.call(`coins/ethereum/contract/${contract.toLowerCase()}/market_chart/range/?vs_currency=${currency}&from=${from}&to=${to}`);
    // fyi timestamps are returned in ms in contrast to the current price endpoint
    if (result.prices) return result.prices;
    throw new Error("Something went wrong fetching coingecko prices!");
  }
  async getContractDetails(contract_address, platform_id = "ethereum") {
    return this.call(`coins/${platform_id}/contract/${contract_address.toLowerCase()}`);
  }
  async getCurrentPriceByContract(contract_address, currency = "usd", platform_id = "ethereum") {
    const result = await this.getContractDetails(contract_address, platform_id);
    const price = lodash.get(result, ["market_data", "current_price", currency], null);
    assert(price !== null, "No current price available for: " + contract_address);
    return [result.last_updated, price];
  }
  // Return an array of spot prices for an array of collateral addresses in one async call. Note we might in future
  // This was adapted from packages/merkle-distributor/kpi-options-helpers/calculate-uma-tvl.ts
  async getContractPrices(addresses, currency = "usd", platform_id = "ethereum") {
    // Generate a unique set with no repeated. join the set with the required coingecko delimiter.
    const contract_addresses = Array.from(new Set(addresses.filter(n => n).values()));
    assert(contract_addresses.length > 0, "Must supply at least 1 contract address");
    // coingecko returns lowercase addresses, so if you expect checksummed addresses, this lookup table will convert them back without having to add ethers as a dependency
    const lookup = Object.fromEntries(contract_addresses.map(address => {
      return [address.toLowerCase(), address];
    }));
    const result = await this.call(`simple/token_price/${platform_id}?contract_addresses=${contract_addresses.join("%2C")}&vs_currencies=${currency}&include_last_updated_at=true`);
    return Object.entries(result).map(([key, value]) => {
      return {
        address: lookup[key],
        timestamp: value.last_updated_at,
        price: value[currency]
      };
    });
  }
  async getPlatforms() {
    return this.call(`asset_platforms`);
  }
  async call(path) {
    try {
      const {
        host
      } = this;
      const url = `${host}/${path}`;
      const result = await axios(url);
      return result.data;
    } catch (err) {
      const msg = lodash.get(err, "response.data.error", lodash.get(err, "response.statusText", "Unknown Coingecko Error"));
      throw new Error(msg);
    }
  }
}

/**
 * Function to estimate gas fees based on coingecko token price and ethers gasPrice. You must still
 * provide a gas amount estimation based on the usage pattern. See constants for current estimations. Returns
 * an amount of gas estimated in the token provided in wei.
 *
 * @param {Provider} ethers Provider
 * @param {BigNumberish} Total amount to be relayed, specified in smallest unit of currency.
 * @param {number} gas - The gas cost for transfer, use constants defined in constants file.
 * @param {string} [tokenAddress = constants.ADDRESSES.ETH] - Token address, for ETH, constants.ADDRESSES.ETH
 */
async function getGasFee(ethersProvider, gas, tokenAddress = ADDRESSES.ETH) {
  const {
    baseFeePerGas
  } = await ethersProvider.getBlock("latest");
  let gasPrice;
  if (baseFeePerGas) {
    const priorityFeePerGas = (await new Etherchain().getGasPrice()).fastest;
    // transform priority fee from gwei (eg 4.1) to wei
    const priorityFeePerGasWei = toWei(priorityFeePerGas, 9);
    gasPrice = baseFeePerGas.add(priorityFeePerGasWei);
  } else {
    // fallback in case baseFeePerGas is undefined / null
    gasPrice = await ethersProvider.getGasPrice();
  }
  // We treat ETH differently since we dont need a price conversion like other tokens and return early.
  if (tokenAddress === ADDRESSES.ETH) {
    return calculateGasFees(gas, gasPrice);
  }
  const coingecko = new Coingecko();
  const [, tokenPrice] = await coingecko.getCurrentPriceByContract(tokenAddress, "eth");
  const erc20Client = connect$2(tokenAddress, ethersProvider);
  const decimals = await erc20Client.decimals();
  return calculateGasFees(gas, gasPrice, tokenPrice, decimals);
}
// These tables are hard coded to mainnet
function makeSlowGasTable() {
  return {
    [ADDRESSES.UMA]: SLOW_UMA_GAS,
    [ADDRESSES.ETH]: SLOW_ETH_GAS,
    [ADDRESSES.WETH]: SLOW_ETH_GAS,
    DEFAULT: SLOW_ERC_GAS
  };
}
// instant gas is the amount of gas above slow gas
function makeInstantGasTable() {
  return {
    [ADDRESSES.UMA]: FAST_UMA_GAS - SLOW_UMA_GAS,
    [ADDRESSES.ETH]: FAST_ETH_GAS - SLOW_ETH_GAS,
    [ADDRESSES.WETH]: FAST_ETH_GAS - SLOW_ETH_GAS,
    DEFAULT: FAST_ERC_GAS - SLOW_ERC_GAS
  };
}
const GetGasByAddress = gasTable => tokenAddress => {
  if (exists(gasTable[tokenAddress])) return gasTable[tokenAddress];
  return gasTable.DEFAULT;
};
const getInstantGasByAddress = /*#__PURE__*/GetGasByAddress( /*#__PURE__*/makeInstantGasTable());
const getSlowGasByAddress = /*#__PURE__*/GetGasByAddress( /*#__PURE__*/makeSlowGasTable());
/**
 * getDepositFees. Returns to you appropriate values for calling the relay deposit function. Returns the slow gas fee
 * and the instant gas fee which is the amount additional to the slow fee as percentages in wei.
 *
 * @param {Provider} ethersProvider - Read provider on mainnet
 * @param {BigNumberish} amountToRelay - Amount in wei of token to relay
 * @param {string} tokenAddress = 0 - Mainnet address of token to relay. Defaults to ETH which is constants.ADDRESSES.ETH.
 * @param {string} discountPercent = DEFAULT_GAS_DISCOUNT- Percent as a value 0-100 of gas fee discount. 0 means no discount. Typically 25 for a 25% gas fee reduction.
 * No need to override this as the values are hardcoded in the sdk.
 * @returns {Promise<DepositFees>} - Returns the fee parameters to the deposit function on the deposit box contract.
 * These are percentages in wei. For example 50% is represented as 0.5 * 1e18.
 */
async function getDepositFees(ethersProvider, amountToRelay, tokenAddress = ADDRESSES.ETH, discountPercent = DEFAULT_GAS_DISCOUNT) {
  assert(discountPercent >= 0 && discountPercent <= 100, "discountPercent must be between 0 and 100 percent");
  const slowGas = getSlowGasByAddress(tokenAddress);
  const slowGasDiscounted = Math.floor((1 - discountPercent / 100) * slowGas);
  const slowGasFee = await getGasFee(ethersProvider, slowGasDiscounted, tokenAddress);
  const instantGas = getInstantGasByAddress(tokenAddress);
  const instantGasDiscounted = Math.floor((1 - discountPercent / 100) * instantGas);
  const instantGasFee = await getGasFee(ethersProvider, instantGasDiscounted, tokenAddress);
  return {
    slowPct: percent(slowGasFee, amountToRelay).toString(),
    instantPct: percent(instantGasFee, amountToRelay).toString()
  };
}
/**
 * getDepositFeesDetails. Same as deposit fees, but returns more information, useful for a frontend display.
 *
 * @param {Provider} ethersProvider - Read provider on mainnet
 * @param {BigNumberish} amountToRelay - Amount in wei of token to relay
 * @param {string} tokenAddress = 0 - Mainnet address of token to relay, for ETH specify constants.ADDRESSES.ETH
 * @param {number} feeLimitPercent? - Optional, percent as a value 0-100 of how much to limit fees as a percentage of the total relayed. Typically 25 or 25% of fees are acceptable out of the total relay amount.
 * For instance 25 means fees can be up to 25% of the total amount to send, fees above this will cause isAmountTooLow to be true.
 * @param {string} discountPercent = DEFAULT_GAS_DISCOUNT - Percent as a value 0-100 of gas fee discount. 0 means no discount. Typically 25 for a 25% gas fee reduction.
 * No need to override this as the values are hardcoded in the sdk.
 * @returns {DepositFeeDetails}
 */
async function getDepositFeesDetails(ethersProvider, amountToRelay, tokenAddress = ADDRESSES.ETH, feeLimitPercent, discountPercent = DEFAULT_GAS_DISCOUNT) {
  const {
    slowPct,
    instantPct
  } = await getDepositFees(ethersProvider, amountToRelay, tokenAddress, discountPercent);
  const slowTotal = ethers$1.BigNumber.from(slowPct).mul(amountToRelay).div(fixedPointAdjustment).toString();
  const instantTotal = ethers$1.BigNumber.from(instantPct).mul(amountToRelay).div(fixedPointAdjustment).toString();
  let isAmountTooLow = false;
  if (feeLimitPercent) {
    assert(feeLimitPercent >= 0 && feeLimitPercent <= 100, "feeLimitPercent must be between 0 and 100 percent");
    isAmountTooLow = ethers$1.BigNumber.from(slowPct).add(instantPct).gt(toBNWei(feeLimitPercent / 100));
  }
  return {
    amountToRelay: amountToRelay.toString(),
    discountPercent,
    feeLimitPercent,
    tokenAddress,
    instant: {
      pct: instantPct,
      total: instantTotal
    },
    slow: {
      pct: slowPct,
      total: slowTotal
    },
    isAmountTooLow
  };
}

var gasFeeCalculator = {
  __proto__: null,
  getGasFee: getGasFee,
  getInstantGasByAddress: getInstantGasByAddress,
  getSlowGasByAddress: getSlowGasByAddress,
  getDepositFees: getDepositFees,
  getDepositFeesDetails: getDepositFeesDetails
};

// Multicall class that exposes public functions to the user and recursively chains itself.  Acts immutable
// if you store reference to the parent intsance. Children will contain mutated state.
class Multicall {
  constructor(state) {
    // make a copy of this so we dont mutate the original
    this.requests = [...state.requests];
    this.multicallClient = state.multicallClient;
  }
  // internally add requests to queue. Only called by parent for chaining.
  push(contractInstance, call) {
    this.requests.push({
      contractInstance,
      call
    });
  }
  // encode requests to multicall contract
  encodeRequest(request) {
    const {
      contractInstance,
      call
    } = request;
    return {
      target: contractInstance.address,
      callData: contractInstance.interface.encodeFunctionData(call.method, call.args)
    };
  }
  // decode response from multicall contract
  decodeResponse(request, response) {
    const {
      contractInstance,
      call
    } = request;
    return contractInstance.interface.decodeFunctionResult(call.method, response);
  }
  // adds a new request to the queue, to be executed when read is called. Returns an instance of this class so you can chain.
  add(contractInstance, call) {
    const child = new Multicall(this);
    child.push(contractInstance, call);
    return child;
  }
  // adds a list of requests to the queue, to be executed when read is called. Returns an instance of this class so you can chain.
  batch(contractInstance, calls) {
    const child = new Multicall(this);
    calls.forEach(call => {
      child.push(contractInstance, call);
    });
    return child;
  }
  // reads from the contract, returns the read results in order that requests were queued.
  async read(_requests = this.requests) {
    const encodedRequests = _requests.map(request => this.encodeRequest(request));
    const {
      returnData
    } = await this.multicallClient.callStatic.aggregate(encodedRequests);
    const zipped = zip(_requests, returnData);
    return zipped.map(([request, response]) => {
      if (request && response) return this.decodeResponse(request, response);
      throw new Error("Unable to decode contract response");
    });
  }
}
// Factory that alters construction of multicall to be more friendly for end user
class Factory$d extends Multicall {
  constructor(address, provider) {
    const multicallClient = connect$3(address, provider);
    super({
      multicallClient,
      requests: []
    });
  }
}

class Multicall2 extends Multicall {
  constructor(state) {
    super(state);
  }
  // reads from the contract, returns the read and error results in order that requests were queued.
  async readWithErrors(_requests = this.requests) {
    const encodedRequests = _requests.map(request => this.encodeRequest(request));
    const [,, returnData] = await this.multicallClient.callStatic.tryBlockAndAggregate(false, encodedRequests);
    const zipped = zip(_requests, returnData);
    return zipped.map(([request, response]) => {
      if (request && response) {
        return {
          success: response.success,
          result: response.success ? this.decodeResponse(request, response.returnData) : undefined
        };
      }
      throw new Error("Unable to decode contract response");
    });
  }
  // adds a new request to the queue, to be executed when read is called. Returns an instance of this class so you can chain.
  add(contractInstance, call) {
    return new Multicall2(super.add(contractInstance, call));
  }
  // adds a list of requests to the queue, to be executed when read is called. Returns an instance of this class so you can chain.
  batch(contractInstance, calls) {
    return new Multicall2(super.batch(contractInstance, calls));
  }
}
// Factory that alters construction of multicall2 to be more friendly for end user
class Multicall2Factory extends Multicall2 {
  constructor(address, provider) {
    const multicallClient = connect$4(address, provider);
    super({
      multicallClient,
      requests: []
    });
  }
}

function makeKey(tx) {
  return JSON.stringify(Object.entries(tx).map(([key, value]) => {
    return [key, (value || "").toString()];
  }));
}
var TransactionManager = ((config, signer, emit = () => null) => {
  assert(signer.provider, "signer requires a provider, use signer.connect(provider)");
  const {
    confirmations = 3
  } = config;
  const requests = new Map();
  const submissions = new Map();
  const mined = new Map();
  function request(unsignedTx) {
    // this no longer calls signer.populateTransaction, to allow metamask to fill in missing details instead
    // use overrides if you want to manually fill in other tx details, including the overrides.customData field.
    const populated = unsignedTx;
    const key = makeKey(populated);
    assert(!requests.has(key), "Transaction already in progress");
    requests.set(key, populated);
    return key;
  }
  async function processRequest(key) {
    const request = requests.get(key);
    assert(request, "invalid request");
    // always delete request, it should only be submitted once
    requests.delete(key);
    try {
      const sent = await signer.sendTransaction(request);
      submissions.set(key, sent.hash);
      emit("submitted", key, sent.hash);
    } catch (err) {
      emit("error", key, err);
    }
  }
  async function processSubmission(key) {
    const hash = submissions.get(key);
    assert(hash, "invalid submission");
    assert(signer.provider, "signer requires a provider, use signer.connect(provider)");
    // we look for this transaction, but it may never find it if its sped up
    const receipt = await signer.provider.getTransactionReceipt(hash).catch(() => undefined);
    if (receipt == null) return;
    if (receipt.confirmations < confirmations) return;
    submissions.delete(key);
    mined.set(key, receipt);
    emit("mined", key, receipt);
  }
  async function isMined(key) {
    return mined.get(key);
  }
  async function update() {
    for (const key of requests.keys()) {
      await processRequest(key);
    }
    for (const key of submissions.keys()) {
      await processSubmission(key);
    }
  }
  return {
    request,
    isMined,
    update
  };
});

class PoolState {
  constructor(batchRead, contract, address) {
    this.batchRead = batchRead;
    this.contract = contract;
    this.address = address;
    this.l1Token = undefined;
  }
  async read(latestBlock, previousBlock) {
    if (this.l1Token === undefined) this.l1Token = await this.contract.l1Token();
    // typechain does not have complete types for call options, so we have to cast blockTag to any
    const exchangeRatePrevious = await this.contract.callStatic.exchangeRateCurrent({
      blockTag: previousBlock || latestBlock - 1
    });
    return {
      address: this.address,
      l1Token: this.l1Token,
      exchangeRatePrevious,
      ...(await this.batchRead([
      // its important exchangeRateCurrent is called first, as it calls _sync under the hood which updates the contract
      // and gives more accurate values for the following properties.
      ["exchangeRateCurrent"], ["liquidityUtilizationCurrent"], ["liquidReserves"], ["pendingReserves"], ["utilizedReserves"]]))
    };
  }
}
class PoolEventState {
  constructor(contract, startBlock = 0, state = eventStateDefaults()) {
    this.contract = contract;
    this.startBlock = startBlock;
    this.state = state;
    this.seen = new Set();
    this.filterSeen = params => {
      const seen = this.hasEvent(params);
      if (!seen) this.addEvent(params);
      return !seen;
    };
    this.iface = new ethers$1.ethers.utils.Interface(Factory$8.abi);
  }
  makeId(params) {
    return [params.blockNumber, params.transactionIndex, params.logIndex].join("!");
  }
  hasEvent(params) {
    return this.seen.has(this.makeId(params));
  }
  addEvent(params) {
    return this.seen.add(this.makeId(params));
  }
  async read(endBlock, userAddress) {
    if (endBlock <= this.startBlock) return this.state;
    const events = (await Promise.all([...(await this.contract.queryFilter(this.contract.filters.LiquidityAdded(undefined, undefined, userAddress), this.startBlock, endBlock)), ...(await this.contract.queryFilter(this.contract.filters.LiquidityRemoved(undefined, undefined, userAddress), this.startBlock, endBlock))])).filter(this.filterSeen).sort((a, b) => {
      if (a.blockNumber !== b.blockNumber) return a.blockNumber - b.blockNumber;
      if (a.transactionIndex !== b.transactionIndex) return a.transactionIndex - b.transactionIndex;
      // if everything is the same, return a, ie maintain order of array
      return -1;
    });
    // ethers queries are inclusive [start,end] unless start === end, then exclusive (start,end). we increment to make sure we dont see same event twice
    this.startBlock = endBlock + 1;
    this.state = getEventState$6(events, this.state);
    return this.state;
  }
  makeEventFromLog(log) {
    const description = this.iface.parseLog(log);
    return {
      ...log,
      ...description,
      event: description.name,
      eventSignature: description.signature
    };
  }
  readTxReceipt(receipt) {
    const events = receipt.logs.map(log => {
      try {
        return this.makeEventFromLog(log);
      } catch (err) {
        // return nothing, this throws a lot because logs from other contracts are included in receipt
        return;
      }
    })
    // filter out undefined
    .filter(exists).filter(this.filterSeen);
    this.state = getEventState$6(events, this.state);
    return this.state;
  }
}
class UserState {
  constructor(contract) {
    this.contract = contract;
  }
  async read(user) {
    return {
      address: user,
      balanceOf: await this.contract.balanceOf(user)
    };
  }
}
function calculateRemoval(amountWei, percentWei) {
  const receive = amountWei.mul(percentWei).div(fixedPointAdjustment);
  const remain = amountWei.sub(receive);
  return {
    recieve: receive.toString(),
    remain: remain.toString()
  };
}
// params here mimic the user object type
function previewRemoval(values, percentFloat) {
  const percentWei = toBNWei(percentFloat);
  return {
    position: {
      ...calculateRemoval(ethers$1.BigNumber.from(values.totalDeposited), percentWei)
    },
    fees: {
      ...calculateRemoval(ethers$1.BigNumber.from(values.feesEarned), percentWei)
    },
    total: {
      ...calculateRemoval(ethers$1.BigNumber.from(values.positionValue), percentWei)
    }
  };
}
function joinUserState(poolState, eventState, userState) {
  const positionValue = ethers$1.BigNumber.from(poolState.exchangeRateCurrent).mul(userState.balanceOf).div(fixedPointAdjustment);
  const totalDeposited = ethers$1.BigNumber.from(eventState.tokens[userState.address] || "0");
  const feesEarned = positionValue.sub(totalDeposited);
  return {
    address: userState.address,
    poolAddress: poolState.address,
    lpTokens: userState.balanceOf.toString(),
    positionValue: positionValue.toString(),
    totalDeposited: totalDeposited.toString(),
    feesEarned: feesEarned.toString()
  };
}
function joinPoolState(poolState, latestBlock, previousBlock, rateModel) {
  const totalPoolSize = poolState.liquidReserves.add(poolState.utilizedReserves);
  const secondsElapsed = latestBlock.timestamp - previousBlock.timestamp;
  const blocksElapsed = latestBlock.number - previousBlock.number;
  const exchangeRatePrevious = poolState.exchangeRatePrevious.toString();
  const exchangeRateCurrent = poolState.exchangeRateCurrent.toString();
  const estimatedApy = calcPeriodicCompoundInterest(exchangeRatePrevious, exchangeRateCurrent, secondsElapsed, SECONDS_PER_YEAR);
  const estimatedApr = calcApr(exchangeRatePrevious, exchangeRateCurrent, secondsElapsed, SECONDS_PER_YEAR);
  let projectedApr = "";
  if (rateModel) {
    projectedApr = fromWei(calculateInstantaneousRate(rateModel, poolState.liquidityUtilizationCurrent).mul(poolState.liquidityUtilizationCurrent).div(fixedPointAdjustment));
  }
  return {
    address: poolState.address,
    totalPoolSize: totalPoolSize.toString(),
    l1Token: poolState.l1Token,
    liquidReserves: poolState.liquidReserves.toString(),
    pendingReserves: poolState.pendingReserves.toString(),
    exchangeRateCurrent: poolState.exchangeRateCurrent.toString(),
    exchangeRatePrevious: poolState.exchangeRatePrevious.toString(),
    estimatedApy,
    estimatedApr,
    blocksElapsed,
    secondsElapsed,
    liquidityUtilizationCurrent: poolState.liquidityUtilizationCurrent.toString(),
    projectedApr,
    utilizedReserves: poolState.utilizedReserves.toString()
  };
}
class ReadPoolClient {
  constructor(address, provider, multicallAddress) {
    this.address = address;
    this.provider = provider;
    this.multicallAddress = multicallAddress;
    this.multicall = new Multicall2Factory(multicallAddress, provider);
    this.contract = connect$8(address, provider);
    this.batchRead = BatchReadWithErrors(this.multicall)(this.contract);
    this.poolState = new PoolState(this.batchRead, this.contract, address);
  }
  async read(latestBlock) {
    return this.poolState.read(latestBlock);
  }
}
function validateWithdraw(pool, user, lpTokenAmount) {
  const l1TokensToReturn = ethers$1.BigNumber.from(lpTokenAmount).mul(pool.exchangeRateCurrent).div(fixedPointAdjustment);
  assert(ethers$1.BigNumber.from(l1TokensToReturn).gt("0"), "Must withdraw amount greater than 0");
  assert(ethers$1.BigNumber.from(pool.liquidReserves).gte(l1TokensToReturn.add(pool.pendingReserves)), "Utilization too high to remove that amount, try lowering withdraw amount");
  assert(ethers$1.BigNumber.from(lpTokenAmount).lte(user.lpTokens), "You cannot withdraw more than you have");
  return {
    lpTokenAmount,
    l1TokensToReturn: l1TokensToReturn.toString()
  };
}
class Client {
  constructor(config, deps, emit) {
    this.config = config;
    this.deps = deps;
    this.emit = emit;
    this.poolContracts = {};
    this.transactionManagers = {};
    this.state = {
      pools: {},
      users: {},
      transactions: {}
    };
    this.poolEvents = {};
    this.intervalStarted = false;
    this.multicall = new Multicall2Factory(config.multicall2Address, deps.provider);
    this.batchRead = BatchReadWithErrors(this.multicall);
    this.rateModelInstance = connect$9(config.rateModelStoreAddress || ADDRESSES.RateModel, deps.provider);
  }
  getOrCreatePoolContract(address) {
    if (this.poolContracts[address]) return this.poolContracts[address];
    const contract = connect$8(address, this.deps.provider);
    this.poolContracts[address] = contract;
    return contract;
  }
  getOrCreatePoolEvents(poolAddress) {
    if (this.poolEvents[poolAddress]) return this.poolEvents[poolAddress];
    this.poolEvents[poolAddress] = new PoolEventState(this.getOrCreatePoolContract(poolAddress));
    return this.poolEvents[poolAddress];
  }
  getOrCreateTransactionManager(signer, address) {
    if (this.transactionManagers[address]) return this.transactionManagers[address];
    const txman = TransactionManager({
      confirmations: this.config.confirmations
    }, signer, (event, id, data) => {
      if (event === "submitted") {
        this.state.transactions[id].state = event;
        this.state.transactions[id].hash = data;
        this.emit(["transactions", id], {
          ...this.state.transactions[id]
        });
      }
      if (event === "mined") {
        const txReceipt = data;
        this.state.transactions[id].state = event;
        this.state.transactions[id].receipt = txReceipt;
        this.emit(["transactions", id], {
          ...this.state.transactions[id]
        });
        // trigger pool and user update for a known mined transaction
        const tx = this.state.transactions[id];
        this.updatePool(tx.toAddress).then(() => {
          return this.updateUserWithTransaction(tx.fromAddress, tx.toAddress, txReceipt);
        }).catch(err => {
          this.emit(["error"], err);
        });
      }
      if (event === "error") {
        this.state.transactions[id].state = event;
        this.state.transactions[id].error = data;
        this.emit(["transactions", id], {
          ...this.state.transactions[id]
        });
      }
    });
    this.transactionManagers[address] = txman;
    return txman;
  }
  async addEthLiquidity(signer, pool, l1TokenAmount, overrides = {}) {
    const userAddress = await signer.getAddress();
    const contract = this.getOrCreatePoolContract(pool);
    const txman = this.getOrCreateTransactionManager(signer, userAddress);
    // dont allow override value here
    const request = await contract.populateTransaction.addLiquidity(l1TokenAmount, {
      ...overrides,
      value: l1TokenAmount
    });
    const id = await txman.request(request);
    this.state.transactions[id] = {
      id,
      state: "requested",
      toAddress: pool,
      fromAddress: userAddress,
      type: "Add Liquidity",
      description: `Adding ETH to pool`,
      request
    };
    this.emit(["transactions", id], {
      ...this.state.transactions[id]
    });
    await txman.update();
    return id;
  }
  async addTokenLiquidity(signer, pool, l1TokenAmount, overrides = {}) {
    const userAddress = await signer.getAddress();
    const contract = this.getOrCreatePoolContract(pool);
    const txman = this.getOrCreateTransactionManager(signer, userAddress);
    const request = await contract.populateTransaction.addLiquidity(l1TokenAmount, overrides);
    const id = await txman.request(request);
    this.state.transactions[id] = {
      id,
      state: "requested",
      toAddress: pool,
      fromAddress: userAddress,
      type: "Add Liquidity",
      description: `Adding Tokens to pool`,
      request
    };
    this.emit(["transactions", id], {
      ...this.state.transactions[id]
    });
    await txman.update();
    return id;
  }
  async validateWithdraw(poolAddress, userAddress, lpAmount) {
    if (!this.hasPool(poolAddress)) {
      await this.updatePool(poolAddress);
    }
    const poolState = this.getPool(poolAddress);
    if (!this.hasUser(poolAddress, userAddress)) {
      await this.updateUser(poolAddress, userAddress);
    }
    const userState = this.getUser(poolAddress, userAddress);
    return validateWithdraw(poolState, userState, lpAmount);
  }
  async removeTokenLiquidity(signer, pool, lpTokenAmount, overrides = {}) {
    const userAddress = await signer.getAddress();
    await this.validateWithdraw(pool, userAddress, lpTokenAmount);
    const contract = this.getOrCreatePoolContract(pool);
    const txman = this.getOrCreateTransactionManager(signer, userAddress);
    const request = await contract.populateTransaction.removeLiquidity(lpTokenAmount, false, overrides);
    const id = await txman.request(request);
    this.state.transactions[id] = {
      id,
      state: "requested",
      toAddress: pool,
      fromAddress: userAddress,
      type: "Remove Liquidity",
      description: `Withdrawing Tokens from pool`,
      request
    };
    this.emit(["transactions", id], {
      ...this.state.transactions[id]
    });
    await txman.update();
    return id;
  }
  async removeEthliquidity(signer, pool, lpTokenAmount, overrides = {}) {
    const userAddress = await signer.getAddress();
    await this.validateWithdraw(pool, userAddress, lpTokenAmount);
    const contract = this.getOrCreatePoolContract(pool);
    const txman = this.getOrCreateTransactionManager(signer, userAddress);
    const request = await contract.populateTransaction.removeLiquidity(lpTokenAmount, true, overrides);
    const id = await txman.request(request);
    this.state.transactions[id] = {
      id,
      state: "requested",
      toAddress: pool,
      fromAddress: userAddress,
      type: "Remove Liquidity",
      description: `Withdrawing Eth from pool`,
      request
    };
    this.emit(["transactions", id], {
      ...this.state.transactions[id]
    });
    await txman.update();
    return id;
  }
  getPool(poolAddress) {
    return this.state.pools[poolAddress];
  }
  hasPool(poolAddress) {
    return Boolean(this.state.pools[poolAddress]);
  }
  getUser(poolAddress, userAddress) {
    return get(this.state, ["users", userAddress, poolAddress]);
  }
  hasUser(poolAddress, userAddress) {
    return has(this.state, ["users", userAddress, poolAddress]);
  }
  hasTx(id) {
    return has(this.state, ["transactions", id]);
  }
  getTx(id) {
    return get(this.state, ["transactions", id]);
  }
  async updateUserWithTransaction(userAddress, poolAddress, txReceipt) {
    const contract = this.getOrCreatePoolContract(poolAddress);
    if (!this.hasPool(poolAddress)) {
      await this.updatePool(poolAddress);
    }
    const poolState = this.getPool(poolAddress);
    const getUserState = new UserState(contract);
    const getPoolEventState = this.getOrCreatePoolEvents(poolAddress);
    const userState = await getUserState.read(userAddress);
    const eventState = await getPoolEventState.readTxReceipt(txReceipt);
    set(this.state, ["users", userAddress, poolAddress], joinUserState(poolState, eventState, userState));
    this.emit(["users", userAddress, poolAddress], this.state.users[userAddress][poolAddress]);
  }
  async updateUser(userAddress, poolAddress) {
    const contract = this.getOrCreatePoolContract(poolAddress);
    if (!this.hasPool(poolAddress)) {
      await this.updatePool(poolAddress);
    }
    const poolState = this.getPool(poolAddress);
    const latestBlock = (await this.deps.provider.getBlock("latest")).number;
    const getUserState = new UserState(contract);
    const getPoolEventState = this.getOrCreatePoolEvents(poolAddress);
    const userState = await getUserState.read(userAddress);
    const eventState = await getPoolEventState.read(latestBlock, userAddress);
    set(this.state, ["users", userAddress, poolAddress], joinUserState(poolState, eventState, userState));
    this.emit(["users", userAddress, poolAddress], this.state.users[userAddress][poolAddress]);
  }
  async updatePool(poolAddress) {
    // default to 100 block delta unless specified otherwise in config
    const {
      blockDelta = DEFAULT_BLOCK_DELTA
    } = this.config;
    const contract = this.getOrCreatePoolContract(poolAddress);
    const pool = new PoolState(this.batchRead(contract), contract, poolAddress);
    const latestBlock = await this.deps.provider.getBlock("latest");
    const previousBlock = await this.deps.provider.getBlock(latestBlock.number - blockDelta);
    const state = await pool.read(latestBlock.number, previousBlock.number);
    let rateModel = undefined;
    try {
      const rateModelRaw = await this.rateModelInstance.callStatic.l1TokenRateModels(state.l1Token);
      rateModel = parseAndReturnRateModelFromString(rateModelRaw);
    } catch (err) {
      // we could swallow this error or just log it since getting the rate model is optional,
      // but we will just emit it to the caller and let them decide what to do with it.
      this.emit(["error"], err);
    }
    this.state.pools[poolAddress] = joinPoolState(state, latestBlock, previousBlock, rateModel);
    this.emit(["pools", poolAddress], this.state.pools[poolAddress]);
  }
  async updateTransactions() {
    for (const txMan of Object.values(this.transactionManagers)) {
      try {
        await txMan.update();
      } catch (err) {
        this.emit(["error"], err);
      }
    }
  }
  // starts transaction checking intervals, defaults to 30 seconds
  async startInterval(delayMs = 30000) {
    assert(!this.intervalStarted, "Interval already started, try stopping first");
    this.intervalStarted = true;
    loop(async () => {
      assert(this.intervalStarted, "Bridgepool Interval Stopped");
      await this.updateTransactions();
    }, delayMs).catch(err => {
      this.emit(["error"], err);
    });
  }
  // starts transaction checking intervals
  async stopInterval() {
    this.intervalStarted = false;
  }
}

var bridgePool = {
  __proto__: null,
  PoolEventState: PoolEventState,
  calculateRemoval: calculateRemoval,
  previewRemoval: previewRemoval,
  ReadPoolClient: ReadPoolClient,
  validateWithdraw: validateWithdraw,
  Client: Client
};

const l1Contracts = {
  Proxy__OVM_L1StandardBridge: {
    1: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1",
    42: "0x22F24361D548e5FaAfb36d1437839f080363982B"
  }
};
class OptimismBridgeClient {
  constructor() {
    // Gas limit for the L2 transaction initiated by the Sequencer
    this.L2_DEPOSIT_GAS_LIMIT = 2000000;
  }
  getL1BridgeAddress(chainId) {
    const l1StandardBridgeAddress = l1Contracts.Proxy__OVM_L1StandardBridge[chainId];
    assert(typeof l1StandardBridgeAddress === "string", "Chain not supported");
    return l1StandardBridgeAddress;
  }
  /**
   * Create a transaction to deposit ERC20 tokens to Optimism
   * @param l1Signer The L1 wallet provider (signer)
   * @param l1Erc20Address The L1 token address
   * @param l2Erc20Address The L2 token address
   * @param amount The amount to be deposited in wei
   * @returns The submitted transaction
   */
  async depositERC20(l1Signer, l1Erc20Address, l2Erc20Address, amount) {
    const chainId = await l1Signer.getChainId();
    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);
    const l1StandardBridge = rateModelStore.OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);
    const l1_ERC20 = rateModelStore.ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
    return l1StandardBridge.depositERC20(l1_ERC20.address, l2Erc20Address, amount, this.L2_DEPOSIT_GAS_LIMIT, "0x");
  }
  /**
   * Create transaction to deposit ETH to Optimism
   * @param l1Signer The L1 wallet provider (signer)
   * @param amount The amount to be deposited in wei
   * @returns The submitted transaction
   */
  async depositEth(l1Signer, amount) {
    const chainId = await l1Signer.getChainId();
    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);
    const l1StandardBridge = rateModelStore.OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);
    return l1StandardBridge.depositETH(this.L2_DEPOSIT_GAS_LIMIT, "0x", {
      value: amount
    });
  }
  /**
   * Wait a L1 transaction to be relayed by the L1 Cross Domain Messenger
   * @param tx The L1 -> L2 transaction
   * @param l1RpcProvider Layer 1 RPC provider
   * @param l2RpcProvider Layer 2 RPC provider
   * @returns The transaction receipt
   */
  async waitRelayToL2(tx, l1RpcProvider, l2RpcProvider) {
    const l2Messenger = new ethers$1.Contract(contracts.predeploys.L2CrossDomainMessenger, contracts.getContractInterface("L2CrossDomainMessenger"), l2RpcProvider);
    const l1Messenger = new ethers$1.Contract(await l2Messenger.l1CrossDomainMessenger(), contracts.getContractInterface("L1CrossDomainMessenger"), l1RpcProvider);
    // Watch for messages to be relayed between L1 and L2.
    const watcher = new coreUtils.Watcher({
      l1: {
        provider: l1RpcProvider,
        messengerAddress: l1Messenger.address
      },
      l2: {
        provider: l2RpcProvider,
        messengerAddress: l2Messenger.address
      }
    });
    // Wait for the message to be relayed to L2
    const [msgHash1] = await watcher.getMessageHashesFromL1Tx(tx.hash);
    return watcher.getL2TransactionReceipt(msgHash1, true);
  }
  async checkAllowance(l1Signer, l1Erc20Address) {
    const chainId = await l1Signer.getChainId();
    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);
    const l1_ERC20 = rateModelStore.ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
    return l1_ERC20.allowance(await l1Signer.getAddress(), l1StandardBridgeAddress);
  }
  async approve(l1Signer, l1Erc20Address, amount) {
    const chainId = await l1Signer.getChainId();
    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);
    const l1_ERC20 = rateModelStore.ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
    return l1_ERC20.approve(l1StandardBridgeAddress, amount);
  }
}

var optimismBridge = {
  __proto__: null,
  l1Contracts: l1Contracts,
  OptimismBridgeClient: OptimismBridgeClient
};

const l1Contracts$1 = {
  ADDRESS_MANAGER_ADDRESS: {
    // mainnet
    1: "0x8376ac6C3f73a25Dd994E0b0669ca7ee0C02F089",
    // rinkeby
    4: "0x93A96D6A5beb1F661cf052722A1424CDDA3e9418"
  }
};
class BobaBridgeClient {
  constructor() {
    // Gas limit for the L2 transaction initiated by the Sequencer
    this.L2_DEPOSIT_GAS_LIMIT = 1300000;
  }
  async getL1BridgeAddress(chainId, l1Provider) {
    const addressManagerAddress = l1Contracts$1.ADDRESS_MANAGER_ADDRESS[chainId];
    assert(typeof addressManagerAddress === "string", "Chain not supported");
    const addressManager = rateModelStore.BobaAddressManagerEthers__factory.connect(addressManagerAddress, l1Provider);
    const l1StandardBridgeAddress = await addressManager.getAddress("Proxy__OVM_L1StandardBridge");
    return l1StandardBridgeAddress;
  }
  /**
   * Create a transaction to deposit ERC20 tokens to Boba. Mainnet and Rinkeby are currently supported
   * @param l1Signer The L1 wallet provider (signer)
   * @param l1Erc20Address The L1 token address
   * @param l2Erc20Address The L2 token address
   * @param amount The amount to be deposited in wei
   * @returns The submitted transaction
   */
  async depositERC20(l1Signer, l1Erc20Address, l2Erc20Address, amount) {
    const chainId = await l1Signer.getChainId();
    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);
    const l1StandardBridge = rateModelStore.OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);
    const l1_ERC20 = rateModelStore.ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
    return l1StandardBridge.depositERC20(l1_ERC20.address, l2Erc20Address, amount, this.L2_DEPOSIT_GAS_LIMIT, ethers$1.ethers.utils.formatBytes32String(new Date().getTime().toString()));
  }
  /**
   * Create transaction to deposit ETH to Boba
   * @param l1Signer The L1 wallet provider (signer)
   * @param amount The amount to be deposited in wei
   * @returns The submitted transaction
   */
  async depositEth(l1Signer, amount) {
    const chainId = await l1Signer.getChainId();
    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);
    const l1StandardBridge = rateModelStore.OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);
    return l1StandardBridge.depositETH(this.L2_DEPOSIT_GAS_LIMIT, ethers$1.ethers.utils.formatBytes32String(new Date().getTime().toString()), {
      value: amount
    });
  }
  /**
   * Wait a L1 transaction to be relayed by the L1 Cross Domain Messenger
   * @param tx The L1 -> L2 transaction
   * @param l1RpcProvider Layer 1 RPC provider
   * @param l2RpcProvider Layer 2 RPC provider
   * @returns The transaction receipt
   */
  async waitRelayToL2(tx, l1RpcProvider, l2RpcProvider) {
    const chainId = (await l1RpcProvider.getNetwork()).chainId;
    const addressManagerAddress = l1Contracts$1.ADDRESS_MANAGER_ADDRESS[chainId];
    assert(typeof addressManagerAddress === "string", "Chain not supported");
    const addressManager = rateModelStore.BobaAddressManagerEthers__factory.connect(addressManagerAddress, l1RpcProvider);
    const proxyL1CrossDomainMessengerAddress = await addressManager.getAddress("Proxy__L1CrossDomainMessenger");
    const l2CrossDomainMessenger = await addressManager.getAddress("L2CrossDomainMessenger");
    // Watch for messages to be relayed between L1 and L2.
    const watcher = new coreUtils.Watcher({
      l1: {
        provider: l1RpcProvider,
        messengerAddress: proxyL1CrossDomainMessengerAddress
      },
      l2: {
        provider: l2RpcProvider,
        messengerAddress: l2CrossDomainMessenger
      }
    });
    // Wait for the message to be relayed to L2
    const [msgHash] = await watcher.getMessageHashesFromL1Tx(tx.hash);
    return watcher.getL2TransactionReceipt(msgHash, true);
  }
  async checkAllowance(l1Signer, l1Erc20Address) {
    const chainId = await l1Signer.getChainId();
    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);
    const l1_ERC20 = rateModelStore.ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
    return l1_ERC20.allowance(await l1Signer.getAddress(), l1StandardBridgeAddress);
  }
  async approve(l1Signer, l1Erc20Address, amount) {
    const chainId = await l1Signer.getChainId();
    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);
    const l1_ERC20 = rateModelStore.ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);
    return l1_ERC20.approve(l1StandardBridgeAddress, amount);
  }
}

var bobaBridge = {
  __proto__: null,
  l1Contracts: l1Contracts$1,
  BobaBridgeClient: BobaBridgeClient
};



var index$l = {
  __proto__: null,
  bridgePool: bridgePool,
  optimismBridge: optimismBridge,
  bobaBridge: bobaBridge
};



var index$m = {
  __proto__: null,
  feeCalculator: feeCalculator,
  rateModel: rateModel,
  gasFeeCalculator: gasFeeCalculator,
  utils: utils$1,
  constants: constants,
  clients: index$l,
  LpFeeCalculator: LpFeeCalculator,
  TransactionManager: TransactionManager
};

// This error should be thrown if an expected value does not exist
class ExistenceError extends Error {
  constructor(message = "") {
    super(message);
    this.name = "ExistenceError";
    // if this isnt included, we cannot use instanceof to check the type
    Object.setPrototypeOf(this, ExistenceError.prototype);
  }
}
// Special assert which checks for existence and throw existence error
function assertExists(condition, message = "") {
  if (!exists(condition)) throw new ExistenceError(message);
}
// Ignore only existence errors. If thrown properly this can be used to convert a non existent value to undefined.
function ignoreExistenceError(call) {
  try {
    return call();
  } catch (err) {
    if (err instanceof ExistenceError) return undefined;
    throw err;
  }
}
// same function but for async calls
async function ignoreExistenceErrorAsync(call) {
  try {
    return await call();
  } catch (err) {
    if (err instanceof ExistenceError) return undefined;
    throw err;
  }
}

var errors = {
  __proto__: null,
  ExistenceError: ExistenceError,
  assertExists: assertExists,
  ignoreExistenceError: ignoreExistenceError,
  ignoreExistenceErrorAsync: ignoreExistenceErrorAsync
};

var OracleType;
(function (OracleType) {
  OracleType["Optimistic"] = "Optimistic";
  OracleType["Skinny"] = "Skinny";
  OracleType["OptimisticV2"] = "OptimisticV2";
})(OracleType || (OracleType = {}));
var Flag;
(function (Flag) {
  Flag["MissingRequest"] = "MissingRequest";
  Flag["MissingUser"] = "MissingUser";
  Flag["WrongChain"] = "WrongChain";
  Flag["CanPropose"] = "CanPropose";
  Flag["CanDispute"] = "CanDispute";
  Flag["CanSettle"] = "CanSettle";
  Flag["InDvmVote"] = "InDvmVote";
  Flag["RequestSettled"] = "RequestSettled";
  Flag["InsufficientBalance"] = "InsufficientBalance";
  Flag["InsufficientApproval"] = "InsufficientApproval";
  Flag["ChainChangeInProgress"] = "ChainChangeInProgress";
  Flag["ProposalTxInProgress"] = "ProposalTxInProgress";
  Flag["ApprovalTxInProgress"] = "ApprovalTxInProgress";
  Flag["DisputeTxInProgress"] = "DisputeTxInProgress";
})(Flag || (Flag = {}));

var state = {
  __proto__: null,
  get OracleType () { return OracleType; },
  get Flag () { return Flag; },
  get RequestState () { return RequestState; }
};

var ContextType;
(function (ContextType) {
  ContextType["setUser"] = "setUser";
  ContextType["setActiveRequest"] = "setActiveRequest";
  ContextType["approve"] = "approve";
  ContextType["clearUser"] = "clearUser";
  ContextType["disputePrice"] = "disputePrice";
  ContextType["proposePrice"] = "proposePrice";
  ContextType["switchOrAddChain"] = "switchOrAddChain";
  ContextType["pollActiveRequest"] = "pollActiveRequest";
  ContextType["pollActiveUser"] = "pollActiveUser";
  ContextType["fetchPastEvents"] = "fetchPastEvents";
  ContextType["pollNewEvents"] = "pollNewEvents";
  ContextType["setActiveRequestByTransaction"] = "setActiveRequestByTransaction";
  ContextType["settle"] = "settle";
  ContextType["updateActiveRequest"] = "updateActiveRequest";
  ContextType["fetchEventBased"] = "fetchEventBased";
})(ContextType || (ContextType = {}));

var statemachine = {
  __proto__: null,
  get ContextType () { return ContextType; }
};

const getAddress = ethers$1.ethers.utils.getAddress;
const hexValue = ethers$1.ethers.utils.hexValue;
function initFlags() {
  return {
    [Flag.MissingRequest]: false,
    [Flag.MissingUser]: false,
    [Flag.WrongChain]: false,
    [Flag.CanPropose]: false,
    [Flag.CanDispute]: false,
    [Flag.CanSettle]: false,
    [Flag.InDvmVote]: false,
    [Flag.RequestSettled]: false,
    [Flag.InsufficientBalance]: false,
    [Flag.InsufficientApproval]: false,
    [Flag.ProposalTxInProgress]: false,
    [Flag.ApprovalTxInProgress]: false,
    [Flag.DisputeTxInProgress]: false,
    [Flag.ChainChangeInProgress]: false
  };
}
const nowS = (now = Date.now()) => Math.floor(now / 1000);
// reduce global state into important UI boolean states. this should never throw errors.
function getFlags(state) {
  const read = new Read(state);
  const flags = initFlags();
  const signer = ignoreExistenceError(read.signer);
  flags[Flag.MissingUser] = signer ? false : true;
  const inputRequest = ignoreExistenceError(read.inputRequest);
  flags[Flag.MissingRequest] = inputRequest ? false : true;
  const userChainId = ignoreExistenceError(read.userChainId);
  const requestChainId = ignoreExistenceError(read.requestChainId);
  flags[Flag.WrongChain] = userChainId && requestChainId ? userChainId !== requestChainId : false;
  const request = ignoreExistenceError(read.request);
  // these are a bit redundant with request state, but just an alternate way to see current request state
  flags[Flag.CanPropose] = (request == null ? void 0 : request.state) === RequestState.Requested;
  flags[Flag.CanDispute] = (request == null ? void 0 : request.state) === RequestState.Proposed;
  flags[Flag.CanSettle] = (request == null ? void 0 : request.state) === RequestState.Resolved || (request == null ? void 0 : request.state) === RequestState.Expired;
  flags[Flag.InDvmVote] = (request == null ? void 0 : request.state) === RequestState.Disputed;
  flags[Flag.RequestSettled] = (request == null ? void 0 : request.state) === RequestState.Settled;
  if (request && request.bond && request.finalFee) {
    const totalBond = request.bond.add(request.finalFee);
    const userCollateralBalance = ignoreExistenceError(read.userCollateralBalance);
    const userCollateralAllowance = ignoreExistenceError(read.userCollateralAllowance);
    flags[Flag.InsufficientBalance] = userCollateralBalance ? userCollateralBalance.lt(totalBond) : false;
    flags[Flag.InsufficientApproval] = userCollateralAllowance ? userCollateralAllowance.lt(totalBond) : false;
  }
  const userAddress = ignoreExistenceError(read.userAddress);
  const commands = ignoreExistenceError(() => read.filterCommands({
    done: false,
    user: userAddress
  }));
  if (userAddress && commands) {
    commands.forEach(command => {
      if (!flags[Flag.ProposalTxInProgress] && command.type === ContextType.proposePrice) {
        flags[Flag.ProposalTxInProgress] = true;
      }
      if (!flags[Flag.DisputeTxInProgress] && command.type === ContextType.disputePrice) {
        flags[Flag.DisputeTxInProgress] = true;
      }
      if (!flags[Flag.ApprovalTxInProgress] && command.type === ContextType.approve) {
        flags[Flag.ApprovalTxInProgress] = true;
      }
      if (!flags[Flag.ChainChangeInProgress] && command.type === ContextType.switchOrAddChain) {
        flags[Flag.ChainChangeInProgress] = true;
      }
    });
  }
  return flags;
}
function getMulticall2Address(chainId) {
  switch (chainId.toString()) {
    case "1":
      return getAddress("0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696");
    case "4":
      return getAddress("0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696");
    case "5":
      return getAddress("0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696");
    case "42":
      return getAddress("0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696");
    default:
      throw new Error(`No address found for deployment Multicall2 on chainId ${chainId}`);
  }
}
const DefaultChainConfig = ({
  getMulticall2Address
}) => (chainId, chainConfig) => {
  let multicall2Address = chainConfig.multicall2Address;
  try {
    multicall2Address = multicall2Address || getMulticall2Address(chainId);
  } catch (err) {
    // ignore, multicall optional
  }
  const checkTxIntervalSec = chainConfig.checkTxIntervalSec || 5;
  return {
    ...chainConfig,
    chainId,
    multicall2Address,
    checkTxIntervalSec
  };
};
const DefaultConfig = getters => (config, oracleType) => {
  return Object.entries(config.chains).reduce((config, [chainId, chainConfig]) => {
    config.chains[Number(chainId)] = DefaultChainConfig(getters)(Number(chainId), chainConfig);
    return config;
  }, {
    ...config,
    chains: {},
    oracleType
  });
};
class TransactionConfirmer {
  constructor(provider) {
    this.provider = provider;
  }
  async getReceipt(hash) {
    return this.provider.getTransactionReceipt(hash);
  }
  async isConfirmed(hash, confirmations = 1) {
    try {
      const receipt = await this.getReceipt(hash);
      if (receipt.confirmations >= confirmations) return receipt;
    } catch (err) {
      // do nothing
    }
    return false;
  }
}
function chainConfigToChainMetadata(config) {
  const {
    // remove extra fields
    checkTxIntervalSec,
    multicall2Address,
    optimisticOracleAddress,
    earliestBlockNumber,
    maxEventRangeQuery,
    ...chainMetadata
  } = config;
  return chainMetadata;
}
/**
 * rangeStart. This starts a new range query and sets defaults for state.  Use this as the first call before starting your queries
 *
 * @param {Pick} state
 * @returns {RangeState}
 */
function rangeStart(state) {
  const {
    startBlock,
    endBlock,
    multiplier = 2
  } = state;
  if (state.maxRange && state.maxRange > 0) {
    const range = endBlock - startBlock;
    assert(range > 0, "End block must be higher than start block");
    const currentRange = Math.min(state.maxRange, range);
    const currentStart = endBlock - currentRange;
    const currentEnd = endBlock;
    return {
      done: false,
      startBlock,
      endBlock,
      maxRange: state.maxRange,
      currentRange,
      currentStart,
      currentEnd,
      multiplier
    };
  } else {
    // the largest range we can have, since this is the users query for start and end
    const maxRange = endBlock - startBlock;
    assert(maxRange > 0, "End block must be higher than start block");
    const currentStart = startBlock;
    const currentEnd = endBlock;
    const currentRange = maxRange;
    return {
      done: false,
      startBlock,
      endBlock,
      maxRange,
      currentRange,
      currentStart,
      currentEnd,
      multiplier
    };
  }
}
/**
 * rangeSuccessDescending. We have 2 ways of querying events, from oldest to newest, or newest to oldest. Typically we want them in order, from
 * oldest to newest, but for this particular case we want them newest to oldest, ie descending ( larger timestamp to smaller timestamp).
 * This function will increase the range between start/end block and return a new start/end to use since by calling this you are signalling
 * that the last range ended in a successful query.
 *
 * @param {RangeState} state
 * @returns {RangeState}
 */
function rangeSuccessDescending(state) {
  const {
    startBlock,
    currentStart,
    maxRange,
    currentRange,
    multiplier = 2
  } = state;
  // we are done if we succeeded querying where the currentStart matches are initial start block
  const done = currentStart <= startBlock;
  // increase range up to max range for every successful query
  const nextRange = Math.min(Math.ceil(currentRange * multiplier), maxRange);
  // move our end point to the previously successful start, ie moving from newest to oldest
  const nextEnd = currentStart;
  // move our start block to the next range down
  const nextStart = Math.max(nextEnd - nextRange, startBlock);
  return {
    ...state,
    currentStart: nextStart,
    currentEnd: nextEnd,
    currentRange: nextRange,
    done
  };
}
/**
 * rangeFailureDescending. Like the previous function, this will decrease the range between start/end for your query, because you are signalling
 * that the last query failed. It will also keep the end of your range the same, while moving the start range up. This is why
 * its considered descending, it will attempt to move from end to start, rather than start to end.
 *
 * @param {RangeState} state
 * @returns {RangeState}
 */
function rangeFailureDescending(state) {
  const {
    startBlock,
    currentEnd,
    currentRange,
    multiplier = 2
  } = state;
  const nextRange = Math.floor(currentRange / multiplier);
  // this will eventually throw an error if you keep calling this function, which protects us against re-querying a broken api in a loop
  assert(nextRange > 0, "Range must be above 0");
  // we stay at the same end block
  const nextEnd = currentEnd;
  // move our start block closer to the end block, shrinking the range
  const nextStart = Math.max(nextEnd - nextRange, startBlock);
  return {
    ...state,
    currentStart: nextStart,
    currentEnd: nextEnd,
    currentRange: nextRange
  };
}
/**
 * eventKey. Make a unique and sortable identifier string for an event
 *
 * @param {Event} event
 * @returns {string} - the unique id
 */
function eventKey(event) {
  var _event$logIndex;
  return [
  // we pad these because numbers of varying lengths will not sort correctly, ie "10" will incorrectly sort before "9", but "09" will be correct.
  event.blockNumber.toString().padStart(16, "0"), event.transactionIndex.toString().padStart(16, "0"), (_event$logIndex = event.logIndex) == null ? void 0 : _event$logIndex.toString().padStart(16, "0")].join("~");
}
/**
 * insertOrdered. Inserts items in an array maintaining sorted order, in this case lowest to highest. Does not check duplicates.
 * Mainly used for caching all known events, in order of oldest to newest.
 *
 * @param {T[]} array
 * @param {T} element
 * @param {Function} orderBy
 */
function insertOrderedAscending(array, element, orderBy) {
  const index = sortedLastIndexBy(array, element, orderBy);
  array.splice(index, 0, element);
  return array;
}
function isUnique(array, element, id) {
  const elementId = id(element);
  const found = array.find(next => {
    return id(next) === elementId;
  });
  return found === undefined;
}
function isSupportedOracleType(oracleType) {
  return oracleType in OracleType;
}

var utils$2 = {
  __proto__: null,
  getAddress: getAddress,
  hexValue: hexValue,
  initFlags: initFlags,
  nowS: nowS,
  getFlags: getFlags,
  getMulticall2Address: getMulticall2Address,
  DefaultChainConfig: DefaultChainConfig,
  DefaultConfig: DefaultConfig,
  TransactionConfirmer: TransactionConfirmer,
  chainConfigToChainMetadata: chainConfigToChainMetadata,
  rangeStart: rangeStart,
  rangeSuccessDescending: rangeSuccessDescending,
  rangeFailureDescending: rangeFailureDescending,
  eventKey: eventKey,
  insertOrderedAscending: insertOrderedAscending,
  isUnique: isUnique,
  isSupportedOracleType: isSupportedOracleType,
  requestId: requestId
};

const batchProps = [["symbol"], ["name"], ["decimals"], ["totalSupply"]];
class Erc20 {
  constructor(provider, address) {
    this.provider = provider;
    this.address = address;
    this.contract = connect$2(address, provider);
  }
  async approve(signer, spender, amount) {
    const contract = connect$2(this.address, signer);
    return contract.approve(spender, amount);
  }
  async getProps() {
    const {
      contract
    } = this;
    return {
      address: this.address,
      symbol: await contract.callStatic.symbol(),
      name: await contract.callStatic.name(),
      decimals: await contract.callStatic.decimals(),
      totalSupply: await contract.callStatic.totalSupply()
    };
  }
}
class Erc20Multicall extends Erc20 {
  constructor(provider, address, multicall2) {
    super(provider, address);
    this.multicall2 = multicall2;
    this.batchRead = BatchReadWithErrors(multicall2)(this.contract);
  }
  async getProps() {
    return {
      ...(await this.batchRead(batchProps)),
      address: this.address
    };
  }
}
function factory(provider, address, multicall2) {
  if (!multicall2) return new Erc20(provider, address);
  return new Erc20Multicall(provider, address, multicall2);
}

var erc20 = {
  __proto__: null,
  Erc20: Erc20,
  Erc20Multicall: Erc20Multicall,
  factory: factory
};

// This file contains composable and type safe state writers which mirror the state in types/state.
// Each component takes in 1 parameters, state and you can include any number of functions to operate on the state.
// Some things to consider:
// 1. State can be nested, but it should strictly one direction, each class should ideally only operate on its direct state object.
// 2. The parent can return new components, but its responsible for initializing the state for the child.
// 3. You can modify this.state in the component thanks to immer, but you cannot set this.state to a new object, only its properties.
class User {
  constructor(state) {
    this.state = state;
  }
  set(data) {
    // note that this is done because we cannot replace this.state = data or immer loses visibility to the change.
    if (data.chainId) this.chainId(data.chainId);
    if (data.address) this.address(data.address);
    if (data.signer) this.signer(data.signer);
    if (data.provider) this.provider(data.provider);
  }
  clear() {
    delete this.state.chainId;
    delete this.state.address;
    delete this.state.signer;
    delete this.state.provider;
  }
  chainId(chainId) {
    this.state.chainId = chainId;
  }
  address(address) {
    this.state.address = address;
  }
  signer(signer) {
    this.state.signer = signer;
  }
  provider(provider) {
    this.state.provider = provider;
  }
}
class Balances$1 {
  constructor(state) {
    this.state = state;
  }
  set(address, amount) {
    this.state[address] = amount;
  }
}
class Erc20$1 {
  constructor(state) {
    this.state = state;
  }
  props(data) {
    this.state.props = data;
  }
  balance(account, amount) {
    if (!this.state.balances) this.state.balances = {};
    new Balances$1(this.state.balances).set(account, amount);
  }
  allowance(account, spender, amount) {
    if (!this.state.allowances) this.state.allowances = {};
    if (!this.state.allowances[spender]) this.state.allowances[spender] = {};
    new Balances$1(this.state.allowances[spender]).set(account, amount);
  }
}
class OptimisticOracle {
  constructor(state) {
    this.state = state;
  }
  address(address) {
    this.state.address = address;
  }
  request(request) {
    const id = requestId(request);
    if (!this.state.requests) this.state.requests = {};
    // merge data in rather than replace
    this.state.requests[id] = {
      ...this.state.requests[id],
      ...request
    };
  }
  defaultLiveness(defaultLiveness) {
    this.state.defaultLiveness = defaultLiveness;
  }
}
class Chain {
  constructor(state) {
    this.state = state;
  }
  erc20s(address) {
    var _this$state, _this$state$erc20s;
    if (!((_this$state = this.state) != null && _this$state.erc20s)) this.state.erc20s = {};
    if (!((_this$state$erc20s = this.state.erc20s) != null && _this$state$erc20s[address])) this.state.erc20s[address] = {};
    return new Erc20$1(this.state.erc20s[address]);
  }
  optimisticOracle() {
    var _this$state2;
    if (!((_this$state2 = this.state) != null && _this$state2.optimisticOracle)) this.state.optimisticOracle = {};
    return new OptimisticOracle(this.state.optimisticOracle);
  }
  currentTime(currentTime) {
    this.state.currentTime = currentTime;
  }
}
class Inputs {
  constructor(state) {
    this.state = state;
  }
  request(params) {
    this.state.request = params;
  }
  user() {
    if (!this.state.user) this.state.user = {};
    return new User(this.state.user);
  }
}
class Services {
  constructor(state) {
    this.state = state;
  }
  provider(provider) {
    this.state.provider = provider;
  }
  erc20s(address) {
    var _this$state3, _this$state4, _this$state5;
    if (!((_this$state3 = this.state) != null && _this$state3.provider)) return;
    if (!((_this$state4 = this.state) != null && _this$state4.erc20s)) this.state.erc20s = {};
    // only add this once
    if ((_this$state5 = this.state) != null && _this$state5.erc20s[address]) return;
    this.state.erc20s[address] = factory(this.state.provider, address, this.state.multicall2);
  }
  optimisticOracle(optimisticOracle) {
    if (this.state.optimisticOracle) return;
    this.state.optimisticOracle = optimisticOracle;
  }
  multicall2(multicall2Address) {
    if (!multicall2Address) return;
    if (this.state.multicall2) return;
    if (!this.state.provider) return;
    this.state.multicall2 = new Multicall2Factory(multicall2Address, this.state.provider);
  }
}
/**
 * Write. The main writer class for this applications global state object. Composes classes that initialize, validate
 * and simplify changes to the global state. This class modifies state directly, and really is only useful in combination with immer.
 */
class Write {
  constructor(state) {
    this.state = state;
  }
  chains(chainId) {
    var _this$state6, _this$state7, _this$state7$chains;
    if (!((_this$state6 = this.state) != null && _this$state6.chains)) this.state.chains = {};
    if (!((_this$state7 = this.state) != null && (_this$state7$chains = _this$state7.chains) != null && _this$state7$chains[chainId])) this.state.chains[chainId] = {};
    return new Chain(this.state.chains[chainId]);
  }
  inputs() {
    if (!this.state.inputs) this.state.inputs = {};
    return new Inputs(this.state.inputs);
  }
  config(config) {
    this.state.config = config;
  }
  services(chainId) {
    if (!this.state.services) this.state.services = {};
    if (!this.state.services.chains) this.state.services.chains = {};
    if (!this.state.services.chains[chainId]) this.state.services.chains[chainId] = {};
    return new Services(this.state.services.chains[chainId]);
  }
  error(error) {
    this.state.error = error;
  }
  command(context) {
    if (!this.state.commands) this.state.commands = {};
    this.state.commands[context.id] = context;
  }
  sortedRequestsService(sortedRequests) {
    var _this$state8, _this$state8$services;
    if ((_this$state8 = this.state) != null && (_this$state8$services = _this$state8.services) != null && _this$state8$services.sortedRequests) return;
    // only want to add this once
    this.state.services = {
      sortedRequests
    };
  }
  descendingRequests(sortedRequests) {
    this.state.descendingRequests = sortedRequests;
  }
}

// This is a typescript compatible way of pulling out values from the global state object, essentially
// forming a basic API. Most calls are parameterless, requiring first setting state which determines, the
// user/chain, etc of the query.
class Read {
  constructor(state) {
    this.state = state;
    this.chainConfig = optionalChainId => {
      var _this$state, _this$state$config, _this$state$config$ch;
      const chainId = optionalChainId || this.requestChainId();
      const config = (_this$state = this.state) == null ? void 0 : (_this$state$config = _this$state.config) == null ? void 0 : (_this$state$config$ch = _this$state$config.chains) == null ? void 0 : _this$state$config$ch[chainId];
      assertExists(config, "No config set for chain: " + chainId);
      return config;
    };
    this.oracleType = () => {
      var _this$state2, _this$state2$config;
      const source = (_this$state2 = this.state) == null ? void 0 : (_this$state2$config = _this$state2.config) == null ? void 0 : _this$state2$config.oracleType;
      assertExists(source, "No oracle name set on config");
      return source;
    };
    this.requestChainId = () => {
      var _this$state3, _this$state3$inputs, _this$state3$inputs$r;
      const chainId = (_this$state3 = this.state) == null ? void 0 : (_this$state3$inputs = _this$state3.inputs) == null ? void 0 : (_this$state3$inputs$r = _this$state3$inputs.request) == null ? void 0 : _this$state3$inputs$r.chainId;
      assertExists(chainId, "ChainId is not set on request");
      return chainId;
    };
    this.user = () => {
      var _this$state4, _this$state4$inputs;
      const result = (_this$state4 = this.state) == null ? void 0 : (_this$state4$inputs = _this$state4.inputs) == null ? void 0 : _this$state4$inputs.user;
      assertExists(result, "user not set");
      return result;
    };
    this.userChainId = () => {
      var _this$state5, _this$state5$inputs, _this$state5$inputs$u;
      const chainId = (_this$state5 = this.state) == null ? void 0 : (_this$state5$inputs = _this$state5.inputs) == null ? void 0 : (_this$state5$inputs$u = _this$state5$inputs.user) == null ? void 0 : _this$state5$inputs$u.chainId;
      assertExists(chainId, "ChainId is not set");
      return chainId;
    };
    this.requestChain = optionalChainId => {
      var _this$state6, _this$state6$chains;
      const chainId = optionalChainId || this.requestChainId();
      const chain = (_this$state6 = this.state) == null ? void 0 : (_this$state6$chains = _this$state6.chains) == null ? void 0 : _this$state6$chains[chainId];
      assertExists(chain, "Chain not set");
      return chain;
    };
    this.userAddress = () => {
      var _this$state7, _this$state7$inputs, _this$state7$inputs$u;
      const address = (_this$state7 = this.state) == null ? void 0 : (_this$state7$inputs = _this$state7.inputs) == null ? void 0 : (_this$state7$inputs$u = _this$state7$inputs.user) == null ? void 0 : _this$state7$inputs$u.address;
      assertExists(address, "User address is not set");
      return address;
    };
    this.oracleAddress = optionalChainId => {
      var _chain$optimisticOrac;
      const chain = this.requestChain(optionalChainId);
      const address = chain == null ? void 0 : (_chain$optimisticOrac = chain.optimisticOracle) == null ? void 0 : _chain$optimisticOrac.address;
      assertExists(address, "Optimistic oracle address not set");
      return address;
    };
    this.signer = () => {
      var _this$state8, _this$state8$inputs, _this$state8$inputs$u;
      const signer = (_this$state8 = this.state) == null ? void 0 : (_this$state8$inputs = _this$state8.inputs) == null ? void 0 : (_this$state8$inputs$u = _this$state8$inputs.user) == null ? void 0 : _this$state8$inputs$u.signer;
      assertExists(signer, "Signer is not set");
      return signer;
    };
    this.inputRequest = () => {
      var _this$state9, _this$state9$inputs;
      const input = (_this$state9 = this.state) == null ? void 0 : (_this$state9$inputs = _this$state9.inputs) == null ? void 0 : _this$state9$inputs.request;
      assertExists(input, "Input request is not set");
      return input;
    };
    this.defaultLiveness = () => {
      var _chain$optimisticOrac2;
      const chain = this.requestChain();
      const liveness = chain == null ? void 0 : (_chain$optimisticOrac2 = chain.optimisticOracle) == null ? void 0 : _chain$optimisticOrac2.defaultLiveness;
      assertExists(liveness, "Optimistic oracle defaultLiveness set");
      return liveness;
    };
    this.request = () => {
      var _chain$optimisticOrac3, _chain$optimisticOrac4;
      const chain = this.requestChain();
      const input = this.inputRequest();
      const id = requestId(input);
      const request = chain == null ? void 0 : (_chain$optimisticOrac3 = chain.optimisticOracle) == null ? void 0 : (_chain$optimisticOrac4 = _chain$optimisticOrac3.requests) == null ? void 0 : _chain$optimisticOrac4[id];
      assertExists(request, "Request has not been fetched");
      return request;
    };
    this.collateralProps = () => {
      var _chain$erc20s, _chain$erc20s$request;
      const request = this.request();
      assertExists(request.currency, "Request currency not set");
      const chain = this.requestChain();
      const props = (_chain$erc20s = chain.erc20s) == null ? void 0 : (_chain$erc20s$request = _chain$erc20s[request.currency]) == null ? void 0 : _chain$erc20s$request.props;
      assertExists(props, "Props not set on collateral token");
      return props;
    };
    this.userCollateralBalance = () => {
      var _chain$erc20s2, _chain$erc20s2$reques, _chain$erc20s2$reques2;
      const request = this.request();
      assertExists(request.currency, "Request currency not set");
      const chain = this.requestChain();
      const user = this.userAddress();
      const balance = chain == null ? void 0 : (_chain$erc20s2 = chain.erc20s) == null ? void 0 : (_chain$erc20s2$reques = _chain$erc20s2[request.currency]) == null ? void 0 : (_chain$erc20s2$reques2 = _chain$erc20s2$reques.balances) == null ? void 0 : _chain$erc20s2$reques2[user];
      assertExists(balance, "Balance not set on collateral token for user");
      return balance;
    };
    this.userCollateralAllowance = () => {
      var _chain$erc20s3, _chain$erc20s3$reques, _chain$erc20s3$reques2, _chain$erc20s3$reques3;
      const request = this.request();
      assertExists(request.currency, "Request currency not set");
      const chain = this.requestChain();
      const user = this.userAddress();
      const oracle = this.oracleAddress();
      const allowance = chain == null ? void 0 : (_chain$erc20s3 = chain.erc20s) == null ? void 0 : (_chain$erc20s3$reques = _chain$erc20s3[request.currency]) == null ? void 0 : (_chain$erc20s3$reques2 = _chain$erc20s3$reques.allowances) == null ? void 0 : (_chain$erc20s3$reques3 = _chain$erc20s3$reques2[oracle]) == null ? void 0 : _chain$erc20s3$reques3[user];
      assertExists(allowance, "Allowance not set on user on collateral token for oracle");
      return allowance;
    };
    this.oracleService = optionalChainId => {
      var _this$state10, _this$state10$service, _this$state10$service2, _this$state10$service3;
      const chainId = optionalChainId || this.requestChainId();
      const result = (_this$state10 = this.state) == null ? void 0 : (_this$state10$service = _this$state10.services) == null ? void 0 : (_this$state10$service2 = _this$state10$service.chains) == null ? void 0 : (_this$state10$service3 = _this$state10$service2[chainId]) == null ? void 0 : _this$state10$service3.optimisticOracle;
      assertExists(result, "Optimistic Oracle Not found on chain " + chainId);
      return result;
    };
    this.collateralService = () => {
      var _this$state11, _this$state11$service, _this$state11$service2, _this$state11$service3, _this$state11$service4;
      const chainId = this.requestChainId();
      const request = this.request();
      assertExists(request.currency, "Request currency not set");
      const result = (_this$state11 = this.state) == null ? void 0 : (_this$state11$service = _this$state11.services) == null ? void 0 : (_this$state11$service2 = _this$state11$service.chains) == null ? void 0 : (_this$state11$service3 = _this$state11$service2[chainId]) == null ? void 0 : (_this$state11$service4 = _this$state11$service3.erc20s) == null ? void 0 : _this$state11$service4[request.currency];
      assertExists(result, "Token not supported on chain " + chainId);
      return result;
    };
    this.command = id => {
      var _this$state12, _this$state12$command;
      const result = (_this$state12 = this.state) == null ? void 0 : (_this$state12$command = _this$state12.commands) == null ? void 0 : _this$state12$command[id];
      assertExists(result, "Unable to find command " + id);
      return result;
    };
    this.tokenService = (chainId, address) => {
      var _this$state13, _this$state13$service, _this$state13$service2, _this$state13$service3, _this$state13$service4;
      const result = (_this$state13 = this.state) == null ? void 0 : (_this$state13$service = _this$state13.services) == null ? void 0 : (_this$state13$service2 = _this$state13$service.chains) == null ? void 0 : (_this$state13$service3 = _this$state13$service2[chainId]) == null ? void 0 : (_this$state13$service4 = _this$state13$service3.erc20s) == null ? void 0 : _this$state13$service4[address];
      assertExists(result, "Token service not found: " + [chainId, address].join("."));
      return result;
    };
    this.provider = chainId => {
      var _this$state14, _this$state14$service, _this$state14$service2, _this$state14$service3;
      const result = (_this$state14 = this.state) == null ? void 0 : (_this$state14$service = _this$state14.services) == null ? void 0 : (_this$state14$service2 = _this$state14$service.chains) == null ? void 0 : (_this$state14$service3 = _this$state14$service2[chainId]) == null ? void 0 : _this$state14$service3.provider;
      assertExists(result, "Provider not found on chainid: " + chainId);
      return result;
    };
    this.transactionService = chainId => {
      const provider = this.provider(chainId);
      return new TransactionConfirmer(provider);
    };
    this.listCommands = () => {
      var _this$state15;
      return Object.values(((_this$state15 = this.state) == null ? void 0 : _this$state15.commands) || []);
    };
    this.filterCommands = search => {
      return filter(this.listCommands(), search);
    };
    this.chain = optionalChainId => {
      var _this$state16, _this$state16$chains;
      const chainId = optionalChainId || this.requestChainId();
      const chain = (_this$state16 = this.state) == null ? void 0 : (_this$state16$chains = _this$state16.chains) == null ? void 0 : _this$state16$chains[chainId];
      assertExists(chain, "No chain for chainId: " + chainId);
      return chain;
    };
    this.currentTime = optionalChainId => {
      const chainId = optionalChainId || this.requestChainId();
      const chain = this.chain(chainId);
      const time = chain == null ? void 0 : chain.currentTime;
      assertExists(time, "Current time not available on chain: " + chainId);
      return time;
    };
    this.sortedRequestsService = () => {
      var _this$state17, _this$state17$service;
      const result = (_this$state17 = this.state) == null ? void 0 : (_this$state17$service = _this$state17.services) == null ? void 0 : _this$state17$service.sortedRequests;
      assertExists(result, "Sorted request service not set");
      return result;
    };
    this.listChains = () => {
      var _this$state18;
      return Object.keys(((_this$state18 = this.state) == null ? void 0 : _this$state18.chains) || {}).map(Number);
    };
    this.descendingRequests = () => {
      return this.state.descendingRequests || [];
    };
    this.filterRequests = query => {
      return filter(this.descendingRequests(), query);
    };
  }
}

// return true only if value is not null or undefined
// This class checks for existence for values you could potentially read. It mirrors the read interface but returns bools from functions.
class Has {
  constructor(state) {
    this.state = state;
    this.inputRequest = () => {
      // the rule about reads is they will only throw errors if it cant return the value you request.
      // If no errors are thrown the read was successful.
      // Reads will never not return a value without throwing an error, enforced by TS.
      return exists(ignoreExistenceError(this.read.inputRequest));
    };
    this.sortedRequestsService = () => {
      return exists(ignoreExistenceError(this.read.sortedRequestsService));
    };
    this.requestChainId = () => {
      return exists(ignoreExistenceError(this.read.requestChainId));
    };
    this.userAddress = () => {
      return exists(ignoreExistenceError(this.read.userAddress));
    };
    this.request = () => {
      return exists(ignoreExistenceError(this.read.request));
    };
    this.collateralProps = () => {
      return exists(ignoreExistenceError(this.read.collateralProps));
    };
    this.defaultLiveness = () => {
      return exists(ignoreExistenceError(this.read.defaultLiveness));
    };
    this.currentTime = () => {
      return exists(ignoreExistenceError(this.read.currentTime));
    };
    // by design, reads do not mutate or cause side effects
    this.read = new Read(state);
  }
}

/**
 * Store. The store is meant to provide a global state that conforms to the type in types/state and
 * allow you to read/write and watch for change events. This uses immer, which manages how the nested
 * object gets updated to allow shallow change detection through nested paths.
 */
class Store {
  /**
   * constructor.
   *
   * @param {Emit} emit - Change callback, passes you the current and previous state any time theres a state change.
   * @param {State} state - The full state type which conforms to the state object.
   */
  constructor(emit, state) {
    this.emit = emit;
    this.state = state;
  }
  /**
   * write. Allows caller to write to state. This wraps the state in "immer" which manages nested updates to state
   * through a proxy interface. When write is complete, an event is emitted with the current and previous state.
   *
   * @param {WriteCallback} cb
   */
  write(cb) {
    const prevState = this.state;
    // immer's produce method, takes an object, and passes a draft of that object to the callback. Any changes to the draft
    // will be returned as the new state at the end of the callback. Changes to this object are optimized to be used in state
    // for React or other front-end state managers.
    this.state = produce(this.state, cb);
    // Once state is changed, an event is emitted, this is how we get changes out of the client and also allow for change detection.
    this.emit(this.state, prevState);
  }
  // same as write
  async writeAsync(cb) {
    const prevState = this.state;
    this.state = await produce(this.state, cb);
    this.emit(this.state, prevState);
  }
  read() {
    return this.state;
  }
}

/**
 * OracleStore. Wraps the store with a specific state shape and passes the Write client through to end user.
 */
class OracleStore {
  constructor(emit = () => undefined, state = {}) {
    this.emit = emit;
    this.state = state;
    /**
     * write - Function for updating state.
     *
     * @param {WriteCallback} cb - Sends a write client to the caller for safer and easier state mutations rather than the raw object.
     */
    this.write = cb => {
      this.store.write(state => cb(new Write(state), state));
    };
    /**
     * read - Function for reading from state. Returns a read client to the user.
     *
     * @returns {Read}
     */
    this.read = () => {
      return new Read(this.store.read());
    };
    /**
     * get - Function for getting access to the raw state object, not wrapped by the reader class.
     * State should not be modified directly and treated as read only.
     *
     * @returns {State}
     */
    this.get = () => {
      return this.store.read();
    };
    /**
     * has. Checks for existence. Mirrors the read interface, but instead of reading values returns true or false.
     *
     * @returns {Has}
     */
    this.has = () => {
      return new Has(this.store.read());
    };
    this.store = new Store(emit, state);
  }
}

var index$n = {
  __proto__: null,
  Write: Write,
  Store: Store,
  Read: Read,
  Has: Has,
  'default': OracleStore
};

class Update {
  constructor(store) {
    this.store = store;
    this.all = async () => {
      await this.oracle();
      await this.request();
      await this.collateralProps();
      await this.userCollateralBalance();
      await this.oracleAllowance();
    };
    this.request = async params => {
      const request = params || this.read().inputRequest();
      const chainId = request.chainId;
      const oo = this.read().oracleService(chainId);
      // // pull in data from contract on chain
      const contractRequest = await oo.fetchRequest(request);
      this.write(write => {
        // create the erc20 service to handle currency
        if (contractRequest.currency) {
          write.services(chainId).erc20s(contractRequest.currency);
        }
        write.chains(chainId).optimisticOracle()
        // update request object with all the data we have about it. order is important,
        // we want to prioritize latest state pulled from contract.
        .request({
          ...contractRequest
        });
      });
      this.sortedRequests(chainId);
    };
    this.oracle = async () => {
      const chainId = this.read().requestChainId();
      const oo = this.read().oracleService();
      const {
        defaultLiveness
      } = await oo.getProps();
      this.write(write => write.chains(chainId).optimisticOracle().defaultLiveness(defaultLiveness));
    };
    this.userCollateralBalance = async () => {
      const chainId = this.read().requestChainId();
      const account = this.read().userAddress();
      const token = this.read().collateralService();
      const result = await token.contract.balanceOf(account);
      this.write(write => write.chains(chainId).erc20s(token.address).balance(account, result));
    };
    this.collateralProps = async () => {
      const chainId = this.read().requestChainId();
      const token = this.read().collateralService();
      const props = await token.getProps();
      this.write(write => write.chains(chainId).erc20s(token.address).props(props));
    };
    this.oracleAllowance = async () => {
      const chainId = this.read().requestChainId();
      const account = this.read().userAddress();
      const oracleAddress = this.read().oracleAddress();
      const token = this.read().collateralService();
      const result = await token.contract.allowance(account, oracleAddress);
      this.write(write => write.chains(chainId).erc20s(token.address).allowance(account, oracleAddress, result));
    };
    this.balance = async (chainId, token, account) => {
      const tokenService = this.read().tokenService(chainId, token);
      const result = await tokenService.contract.balanceOf(account);
      this.write(write => write.chains(chainId).erc20s(token).balance(account, result));
    };
    this.allowance = async (chainId, token, account, spender) => {
      const tokenService = this.read().tokenService(chainId, token);
      const result = await tokenService.contract.allowance(account, spender);
      this.write(write => write.chains(chainId).erc20s(token).allowance(account, spender, result));
    };
    this.isConfirmed = async (chainId, hash, confirmations) => {
      const txService = this.read().transactionService(chainId);
      return txService.isConfirmed(hash, confirmations);
    };
    // update new events from this range query, will accumulate new events
    this.oracleEvents = async (chainId, startBlock = 0, endBlock) => {
      const provider = this.read().provider(chainId);
      const oracle = this.read().oracleService(chainId);
      endBlock = endBlock || (await provider.getBlockNumber());
      await oracle.update(startBlock, endBlock);
    };
    // takes all known events, decodes them into requests and puts them into a sorted table. then updates the sorted list.
    this.sortedRequests = chainId => {
      const sortedRequestsService = this.read().sortedRequestsService();
      const oracle = this.read().oracleService(chainId);
      const requests = oracle.listRequests();
      const oracleType = this.read().oracleType();
      Object.values(requests).forEach(value => {
        // chains can have colliding keys ( mainly testnet forks), so we always need to append chain to to keep key unique across chains otherwise
        // collisions will cause overwrites, removing ability to list identical requests across chains.
        sortedRequestsService.setByRequest({
          ...value,
          oracleType
        });
      });
      // query all known requests and update our state with the entire list.
      // this is expensive, consider optimizing after proven detrimental.
      const descendingRequests = sortedRequestsService.descending();
      this.write(w => {
        w.descendingRequests(descendingRequests);
      });
    };
    // this updates the current active request object used in the details page, as new properties might come in from events
    // current request needs access to things like transation hash, only available through events.
    this.activeRequestFromEvents = params => {
      const request = params || this.read().inputRequest();
      const chainId = request.chainId;
      // pull in request data generated from events
      const requestIndexData = this.read().oracleService().getRequest(request);
      // we really only care about a handful of props from event based requests. We also dont want to override
      // any properties that might overlap with the data queried from the contract.
      const {
        requestTx,
        proposeTx,
        disputeTx,
        settleTx,
        requestBlockNumber,
        proposeBlockNumber,
        disputeBlockNumber,
        settleBlockNumber
      } = requestIndexData;
      const update = {
        ...request,
        requestTx,
        proposeTx,
        disputeTx,
        settleTx,
        requestBlockNumber,
        proposeBlockNumber,
        disputeBlockNumber,
        settleBlockNumber
      };
      this.write(write => {
        write.chains(chainId).optimisticOracle().request(update);
      });
    };
    this.read = store.read;
    this.write = store.write;
  }
}

function initMemory() {
  return undefined;
}
function Handlers(store) {
  const update = new Update(store);
  return {
    async start(params) {
      store.write(write => write.inputs().user().set(params));
      // ignore erorrs caused by data not existing on reads, pass through other errors
      await ignoreExistenceErrorAsync(update.userCollateralBalance);
      await ignoreExistenceErrorAsync(update.oracleAllowance);
      return "done";
    }
  };
}

var setUser = {
  __proto__: null,
  initMemory: initMemory,
  Handlers: Handlers
};

function initMemory$1() {
  return undefined;
}
function Handlers$1(store) {
  return {
    async start() {
      store.write(write => {
        write.inputs().user().clear();
      });
      return "done";
    }
  };
}

var clearUser = {
  __proto__: null,
  initMemory: initMemory$1,
  Handlers: Handlers$1
};

function initMemory$2() {
  return undefined;
}
function Handlers$2(store) {
  return {
    async start(params) {
      store.write(write => write.inputs().request(params));
      return "done";
    }
  };
}

var setActiveRequest = {
  __proto__: null,
  initMemory: initMemory$2,
  Handlers: Handlers$2
};

function initMemory$3() {
  return {};
}
function Handlers$3(store) {
  const update = new Update(store);
  return {
    async start(params, memory) {
      const {
        chainId,
        currency,
        spender,
        amount,
        account,
        signer
      } = params;
      assert(chainId === (await signer.getChainId()), "Signer on wrong chainid");
      assert(account === (await signer.getAddress()), "Signer on wrong account");
      // create service if it does not exist
      store.write(w => w.services(chainId).erc20s(currency));
      const erc20 = store.read().tokenService(chainId, currency);
      const tx = await erc20.approve(signer, spender, amount);
      memory.hash = tx.hash;
      return "confirm";
    },
    async confirm(params, memory, context) {
      const {
        chainId,
        confirmations,
        checkTxIntervalSec
      } = params;
      const {
        hash
      } = memory;
      assert(hash, "requires hash");
      if (await update.isConfirmed(chainId, hash, confirmations)) {
        return "update";
      }
      // wait x seconds before running this state again
      return context.sleep(checkTxIntervalSec * 1000);
    },
    async update(params) {
      const {
        chainId,
        currency,
        spender,
        account
      } = params;
      await update.balance(chainId, currency, account);
      await update.allowance(chainId, currency, account, spender);
      return "done";
    }
  };
}

var approve = {
  __proto__: null,
  initMemory: initMemory$3,
  Handlers: Handlers$3
};

function initMemory$4() {
  return {};
}
function Handlers$4(store) {
  const update = new Update(store);
  return {
    async start(params, memory) {
      const {
        requester,
        identifier,
        timestamp,
        ancillaryData,
        chainId,
        signer
      } = params;
      assert(chainId === (await signer.getChainId()), "Signer on wrong chainid");
      const oracle = store.read().oracleService(chainId);
      const tx = await oracle.disputePrice(signer, {
        requester,
        identifier,
        timestamp,
        ancillaryData
      });
      memory.hash = tx.hash;
      return "confirm";
    },
    async confirm(params, memory, context) {
      const {
        chainId,
        confirmations,
        checkTxIntervalSec
      } = params;
      const {
        hash
      } = memory;
      assert(hash, "requires hash");
      const receipt = await update.isConfirmed(chainId, hash, confirmations);
      if (receipt) {
        memory.receipt = receipt;
        return "update";
      }
      // wait x seconds before running this state again
      return context.sleep(checkTxIntervalSec * 1000);
    },
    async update(params, memory) {
      const {
        chainId,
        currency,
        account
      } = params;
      const {
        receipt
      } = memory;
      const oracle = store.read().oracleService(chainId);
      await update.balance(chainId, currency, account);
      if (receipt) {
        oracle.updateFromTransactionReceipt(receipt);
      }
      store.write(w => {
        w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));
      });
      update.sortedRequests(chainId);
      return "done";
    }
  };
}

var disputePrice = {
  __proto__: null,
  initMemory: initMemory$4,
  Handlers: Handlers$4
};

function initMemory$5() {
  return {};
}
function Handlers$5(store) {
  const update = new Update(store);
  return {
    async start(params, memory) {
      const {
        requester,
        identifier,
        timestamp,
        ancillaryData,
        chainId,
        signer,
        proposedPrice
      } = params;
      assert(chainId === (await signer.getChainId()), "Signer on wrong chainid");
      const oracle = store.read().oracleService(chainId);
      const tx = await oracle.proposePrice(signer, {
        requester,
        identifier,
        timestamp,
        ancillaryData
      }, proposedPrice);
      memory.hash = tx.hash;
      return "confirm";
    },
    async confirm(params, memory, context) {
      const {
        chainId,
        confirmations,
        checkTxIntervalSec
      } = params;
      const {
        hash
      } = memory;
      assert(hash, "requires hash");
      const receipt = await update.isConfirmed(chainId, hash, confirmations);
      if (receipt) {
        memory.receipt = receipt;
        return "update";
      }
      // wait x seconds before running this state again
      return context.sleep(checkTxIntervalSec * 1000);
    },
    async update(params, memory) {
      const {
        chainId,
        currency,
        account
      } = params;
      const {
        receipt
      } = memory;
      const oracle = store.read().oracleService(chainId);
      await update.balance(chainId, currency, account);
      if (receipt) {
        oracle.updateFromTransactionReceipt(receipt);
      }
      store.write(w => {
        w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));
      });
      await update.sortedRequests(chainId);
      return "done";
    }
  };
}

var proposePrice = {
  __proto__: null,
  initMemory: initMemory$5,
  Handlers: Handlers$5
};

function initMemory$6() {
  return undefined;
}
function Handlers$6(store) {
  return {
    async start(params) {
      const {
        provider,
        chainId
      } = params;
      try {
        await provider.send("wallet_switchEthereumChain", [{
          chainId: hexValue(chainId)
        }]);
        return "done";
      } catch (err) {
        const error = err;
        if (error.code === -32603 || error.code === 4902) {
          return "addAndSwitch";
        }
        throw error;
      }
    },
    async addAndSwitch(params) {
      const {
        chainId,
        provider
      } = params;
      const config = store.read().chainConfig(chainId);
      const chainMetadata = chainConfigToChainMetadata(config);
      await provider.send("wallet_addEthereumChain", [{
        ...chainMetadata,
        chainId: hexValue(chainId)
      }]);
      await provider.send("wallet_switchEthereumChain", [{
        chainId: hexValue(chainId)
      }]);
      return "done";
    }
  };
}

var switchOrAddChain = {
  __proto__: null,
  initMemory: initMemory$6,
  Handlers: Handlers$6
};

// this should only run as a single instance, will continue updating the active request as needed.
function initMemory$7() {
  return {
    iterations: 0
  };
}
function Handlers$7(store) {
  const update = new Update(store);
  return {
    async start(params, memory, ctx) {
      const request = await ignoreExistenceErrorAsync(store.read().request);
      // requests can change externally if not already in one of these states
      const shouldUpdate = request && request.state !== RequestState.Invalid && request.state !== RequestState.Settled;
      if (shouldUpdate) {
        await update.request();
        // count how many times we have updated this request as a sanity check
        memory.iterations++;
      }
      const {
        checkTxIntervalSec = 30
      } = (await ignoreExistenceErrorAsync(store.read().chainConfig)) || {};
      return ctx.sleep(checkTxIntervalSec * 1000);
    }
  };
}

var pollActiveRequest = {
  __proto__: null,
  initMemory: initMemory$7,
  Handlers: Handlers$7
};

function initMemory$8() {
  return {
    iterations: 0
  };
}
function Handlers$8(store) {
  const update = new Update(store);
  return {
    async start(params, memory, ctx) {
      var _memory$state;
      const provider = store.read().provider(params.chainId);
      const {
        chainId,
        startBlock = 0,
        endBlock = await provider.getBlockNumber(),
        maxRange
      } = params;
      memory.error = undefined;
      // we use this wierd range thing because in the case we cant query the entire block range due to provider error
      // we want to move start block closer to endblock to reduce the range until it stops erroring. These range functions
      // will do that for us.
      const rangeState = memory.state || rangeStart({
        startBlock,
        endBlock,
        maxRange
      });
      const {
        currentStart,
        currentEnd
      } = rangeState;
      try {
        // this just queries events between start and end
        await update.oracleEvents(chainId, currentStart, currentEnd);
        // reprocess all known events and create a table of requests from it
        await update.sortedRequests(chainId);
        // try to update the active request by event data
        await ignoreExistenceErrorAsync(update.activeRequestFromEvents);
        // we signal that the current range was a success, now move currentStart, currentEnd accordingly
        // we set multiplier to 1 so we dont grow the range on success, this tends to create more errors and slow down querying
        memory.state = rangeSuccessDescending({
          ...rangeState,
          multiplier: 1
        });
      } catch (err) {
        memory.error = err;
        // the provider threw an error so we will reduce our range by moving startblock closer to endblock next iteration
        memory.state = rangeFailureDescending(rangeState);
      }
      memory.iterations++;
      // the range functions will tell us when we have successfully queried the entire range of blocks.
      if (memory != null && (_memory$state = memory.state) != null && _memory$state.done) return "done";
      // sleep to let other contexts run, but just resume right after.
      return ctx.sleep(100);
    }
  };
}

var fetchPastEvents = {
  __proto__: null,
  initMemory: initMemory$8,
  Handlers: Handlers$8
};

function initMemory$9() {
  return {
    iterations: 0
  };
}
function Handlers$9(store) {
  const update = new Update(store);
  return {
    async start(params, memory, ctx) {
      // start at the latest block, we have other command to get historical events
      const {
        chainId,
        startBlock,
        pollRateSec = 50
      } = params;
      const provider = store.read().provider(chainId);
      const latestBlock = await provider.getBlockNumber();
      // our current block is the start block, or last known block we have queried up to
      const currentBlock = memory.lastBlock || startBlock || latestBlock;
      memory.error = undefined;
      try {
        // dont worry about querying if latest and current are the same. This optimization causes wierd effects
        // during testing, as block number rarely changes unless user moves it manually, giving the impression that events are missed.
        if (latestBlock !== currentBlock) {
          // this pulls all events from current to latest block
          await update.oracleEvents(chainId, currentBlock, latestBlock);
          // we can just try to update the current active request, we dont care if it fails, active request might not be set
          await ignoreExistenceErrorAsync(update.activeRequestFromEvents);
          // reset our last block seen to the latest (end) block
          memory.lastBlock = latestBlock;
          // just count how many successful iterations we do as a kind of sanity check
          memory.iterations++;
        } else {
          // if we dont have a lastblock set, set it to our current block
          memory.lastBlock = memory.lastBlock || currentBlock;
        }
      } catch (err) {
        // store an error for an iteration if we need to debug. we want to keep polling though.
        memory.error = err;
      }
      // update our request table list with all known events
      // this needs to be done outside the block sorted requests holds requests across different clients
      await update.sortedRequests(chainId);
      // we dont need to poll these events very fast, so just set to once a min
      return ctx.sleep(pollRateSec * 1000);
    }
  };
}

var pollNewEvents = {
  __proto__: null,
  initMemory: initMemory$9,
  Handlers: Handlers$9
};

function initMemory$a() {
  return undefined;
}
function Handlers$a(store) {
  return {
    async start(params) {
      const {
        chainId,
        transactionHash,
        eventIndex = 0
      } = params;
      // search all known requests first
      const filteredRequests = store.read().descendingRequests().filter(request => {
        var _request$requestTx, _request$proposeTx, _request$disputeTx, _request$settleTx, _request$requestLogIn, _request$proposeLogIn, _request$disputeLogIn, _request$settleLogInd;
        if (request.chainId.toString() !== chainId.toString()) return false;
        if (![request == null ? void 0 : (_request$requestTx = request.requestTx) == null ? void 0 : _request$requestTx.toLowerCase(), request == null ? void 0 : (_request$proposeTx = request.proposeTx) == null ? void 0 : _request$proposeTx.toLowerCase(), request == null ? void 0 : (_request$disputeTx = request.disputeTx) == null ? void 0 : _request$disputeTx.toLowerCase(), request == null ? void 0 : (_request$settleTx = request.settleTx) == null ? void 0 : _request$settleTx.toLowerCase()].includes(transactionHash.toLowerCase())) return false;
        return [request == null ? void 0 : (_request$requestLogIn = request.requestLogIndex) == null ? void 0 : _request$requestLogIn.toString(), request == null ? void 0 : (_request$proposeLogIn = request.proposeLogIndex) == null ? void 0 : _request$proposeLogIn.toString(), request == null ? void 0 : (_request$disputeLogIn = request.disputeLogIndex) == null ? void 0 : _request$disputeLogIn.toString(), request == null ? void 0 : (_request$settleLogInd = request.settleLogIndex) == null ? void 0 : _request$settleLogInd.toString()].includes(eventIndex.toString());
      });
      // if we found a request from known requests, then set it as our selected request
      if (filteredRequests.length === 1) {
        const [found] = filteredRequests;
        // we can parse out the necessary params to kick off fetching the state of the request
        const requestInput = {
          timestamp: found.timestamp,
          requester: found.requester,
          ancillaryData: found.ancillaryData,
          identifier: found.identifier,
          chainId
        };
        store.write(write => write.inputs().request(requestInput));
        return "done";
      }
      // have to do all of this to fetch the identifier, ancData, requester and timestamp from the request
      const provider = store.read().provider(chainId);
      const receipt = await provider.getTransactionReceipt(transactionHash);
      assert(receipt, "Unable to find transaction receipt from hash: " + transactionHash);
      const oracle = store.read().oracleService(chainId);
      const oracleAddress = store.read().oracleAddress(chainId);
      // filter out logs that originate from oracle contract
      const oracleLogs = receipt.logs.filter(log => log.address.toLowerCase() === oracleAddress.toLowerCase());
      // decode logs using abi
      const decodedLogs = oracleLogs.map(log => oracle.parseLog(log));
      // this is the event we care about, we index into the appropriate oracle event generated from this tx
      // we want to keep backwards compatibility with previous links which were indexed by an array index and not logIndex
      const log = decodedLogs.find(log => {
        var _log$logIndex;
        return (log == null ? void 0 : (_log$logIndex = log.logIndex) == null ? void 0 : _log$logIndex.toString()) === eventIndex.toString();
      }) || decodedLogs[eventIndex] || decodedLogs[0];
      // we dont actually know the type of the log, so we need to do some validation before continuing
      assert(log, `Unable to find optimistic oracle event at ${transactionHash} eventIndex ${eventIndex}`);
      assert(log.args, `Unable to find optimistic oracle event args at ${transactionHash} eventIndex ${eventIndex}`);
      assert(log.args.timestamp, `Unable to find optimistic oracle event.timestamp at ${transactionHash} eventIndex ${eventIndex}`);
      assert(log.args.requester, `Unable to find optimistic oracle event.requester at ${transactionHash} eventIndex ${eventIndex}`);
      assert(log.args.ancillaryData, `Unable to find optimistic oracle event.ancillaryData at ${transactionHash} eventIndex ${eventIndex}`);
      assert(log.args.identifier, `Unable to find optimistic oracle event.identifier at ${transactionHash} eventIndex ${eventIndex}`);
      // we can parse out the necessary params to kick off fetching the state of the request
      const requestInput = {
        timestamp: log.args.timestamp,
        requester: log.args.requester,
        ancillaryData: log.args.ancillaryData,
        identifier: log.args.identifier,
        chainId
      };
      store.write(write => write.inputs().request(requestInput));
      return "done";
    }
  };
}

var setActiveRequestByTransaction = {
  __proto__: null,
  initMemory: initMemory$a,
  Handlers: Handlers$a
};

function initMemory$b() {
  return {};
}
function Handlers$b(store) {
  const update = new Update(store);
  return {
    async start(params, memory) {
      const {
        requester,
        identifier,
        timestamp,
        ancillaryData,
        chainId,
        signer
      } = params;
      assert(chainId === (await signer.getChainId()), "Signer on wrong chainid");
      const oracle = store.read().oracleService(chainId);
      const tx = await oracle.settle(signer, {
        requester,
        identifier,
        timestamp,
        ancillaryData
      });
      memory.hash = tx.hash;
      return "confirm";
    },
    async confirm(params, memory, context) {
      const {
        chainId,
        confirmations,
        checkTxIntervalSec
      } = params;
      const {
        hash
      } = memory;
      assert(hash, "requires hash");
      if (await update.isConfirmed(chainId, hash, confirmations)) {
        return "update";
      }
      // wait x seconds before running this state again
      return context.sleep(checkTxIntervalSec * 1000);
    },
    async update(params) {
      const {
        chainId,
        currency,
        account
      } = params;
      const oracle = store.read().oracleService(chainId);
      await update.balance(chainId, currency, account);
      store.write(w => {
        w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));
      });
      update.sortedRequests(chainId);
      return "done";
    }
  };
}

var settle = {
  __proto__: null,
  initMemory: initMemory$b,
  Handlers: Handlers$b
};

function initMemory$c() {
  return undefined;
}
function Handlers$c(store) {
  const update = new Update(store);
  return {
    async start(params, memory, ctx) {
      const {
        chainId,
        pollRateSec = 15,
        concurrency = 5
      } = params;
      const oracle = store.read().oracleService(chainId);
      const requests = oracle.listRequests();
      const requestsToFetch = requests.filter(request => request.eventBased === undefined);
      await bluebird.map(requestsToFetch, request => update.request(request), {
        concurrency
      });
      return ctx.sleep(pollRateSec * 1000);
    }
  };
}

var fetchEventBased = {
  __proto__: null,
  initMemory: initMemory$c,
  Handlers: Handlers$c
};

// client to pass into handlers to allow them to modify context
class ContextClient {
  constructor(context) {
    this.context = context;
  }
  sleep(ms) {
    this.context.sleep = ms;
  }
}
const Step = handlers => async (context, now) => {
  assert(!context.done, "Context has ended");
  assert(handlers[context.state], "No handler for state: " + context.state);
  // conext is read only for some reason, have to copy it
  const copy = Object.assign({}, context);
  try {
    // remove sleep, assume it should be reset if needed
    if (copy.sleep) copy.sleep = undefined;
    const handler = handlers[copy.state];
    // have to copy this out because memory becomes read only for some reason?
    const memory = Object.assign({}, copy.memory);
    // handlers take in params and return a new state or nothin
    const state = await handler(copy.params, memory, new ContextClient(copy));
    copy.memory = memory;
    // update context state
    if (state) copy.state = state;
    // check for done
    if (state === "done") copy.done = true;
  } catch (err) {
    return {
      ...copy,
      error: err,
      state: "error",
      done: true,
      updated: now
    };
  }
  copy.updated = now;
  return copy;
};
function shouldStep(context, now) {
  if (!context) return false;
  if (context.done) return false;
  if (context.updated === undefined) return true;
  if (!(context != null && context.sleep)) return true;
  return now - context.updated >= context.sleep;
}
function create(type, params, memory, override = {}, now = Date.now()) {
  const context = {
    id: uid(type + "_"),
    state: "start",
    done: false,
    updated: undefined,
    created: now,
    type,
    // override any part of the context, not recommended for most cases
    ...override,
    params,
    memory
  };
  return context;
}
class ContextManager {
  constructor(type, handlers, initMemory, emit) {
    this.type = type;
    this.handlers = handlers;
    this.initMemory = initMemory;
    this.emit = emit;
    this.create = (params, user) => {
      const context = create(this.type, params, this.initMemory(params), {
        user
      });
      this.emit(context);
      return context.id;
    };
  }
  // this step function will keep looping until either the state machine is done transitioning, or sleep has been specified
  async step(context, now = Date.now(), iterations = 10) {
    const step = Step(this.handlers);
    let next = context;
    while (shouldStep(next, now)) {
      assert(iterations >= 0, "Infinite loop detected in state machine, make sure it each state transitions to done: " + context.type);
      next = await step(next, now);
      iterations--;
    }
    return next;
  }
}

function initMemory$d() {
  return {
    iterations: 0
  };
}
function Handlers$d(store) {
  const update = new Update(store);
  return {
    async start(params, memory, ctx) {
      await ignoreExistenceErrorAsync(update.userCollateralBalance);
      await ignoreExistenceErrorAsync(update.oracleAllowance);
      memory.iterations++;
      // this is set differently for every chain
      const {
        checkTxIntervalSec = 30
      } = (await ignoreExistenceErrorAsync(store.read().chainConfig)) || {};
      return ctx.sleep(checkTxIntervalSec * 1000);
    }
  };
}

function initMemory$e() {
  return undefined;
}
function Handlers$e(store) {
  const update = new Update(store);
  return {
    async start() {
      const has = store.has();
      // we can ignore errors where reads fail, but all other errors will propogate
      // this will rerun when user is set.
      if (!has.defaultLiveness()) {
        await ignoreExistenceErrorAsync(update.oracle);
      }
      await ignoreExistenceErrorAsync(update.request);
      if (!has.collateralProps()) {
        await ignoreExistenceErrorAsync(update.collateralProps);
      }
      return "done";
    }
  };
}

/**
 * StateMachine. This class will be used to handle all change requests by the user, including setting state which
 * may require triggering fetching data from chain, or initiating transactions that require tracking.
 *
 * This class is meant to step through states of a Context object. This object can have variable
 * parameters and memory. There are several concepts to understand before using this class:
 *
 * 1. Handlers - This is the state machine state handlers, it is an objected keyed by each state, with a function handler.
 * 2. Params - These are common parameters set by the caller, passed into each handler function.
 * 3. Memory - This is a writing space within the state machine handlers that accumulates through states.
 * 4. Context - This is the sum of all data needed to transition through the state machine states. It includes params, memory and metadata about the runtime.
 * 5. Context.done - This is a special property on context.done which represents that the state machine is done transitioning this context.
 * 6. Context.state = "done" - This is a reserved state on context.state, if set to "done" its the same thing as done = true.
 * 7. Context.state = "error" - This is a reserved state on context.state, if set to "error" it means the context is done, but also there is an context.error object.
 * 8. Interval - This is a property on the context which specifies the maximum rate in MS this context will transition, based on the current timestamp.
 */
class StateMachine {
  constructor(store) {
    this.store = store;
    this.pending = [];
    this.handleCreate = context => {
      this.push(context);
      this.saveContext(context);
    };
    /**
     * tick. Process all pending contexts, move them to done if needed
     *
     * @param {} now - Specify the timestamp this tick is running on.
     * @returns {Promise<boolean>} - Returns if there are still any pending contexts to run.
     */
    this.tick = async (now = Date.now()) => {
      const context = this.shift();
      // if this cant step, then push it to back of queue
      if (!shouldStep(context, now)) {
        context && !context.done && this.push(context);
        // if we can step, then step it and push result into queue
      } else {
        let next;
        switch (context.type) {
          // need to update this function with the new context processor
          case ContextType.setUser:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.clearUser:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.setActiveRequest:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.approve:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.disputePrice:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.proposePrice:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.switchOrAddChain:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.pollActiveRequest:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.pollActiveUser:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.fetchPastEvents:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.pollNewEvents:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.setActiveRequestByTransaction:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.settle:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.updateActiveRequest:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          case ContextType.fetchEventBased:
            {
              next = await this.types[context.type].step(context, now);
              break;
            }
          default:
            {
              throw new Error("Unable to handle type: " + context.type);
            }
        }
        if (!next.done) {
          this.push(next);
        }
        this.saveContext(next);
      }
      return this.size() > 0;
    };
    // need to initizlie state types here manually for each new context type
    this.types = {
      [ContextType.setUser]: new ContextManager(ContextType.setUser, Handlers(store), initMemory, this.handleCreate),
      [ContextType.clearUser]: new ContextManager(ContextType.clearUser, Handlers$1(store), initMemory$1, this.handleCreate),
      [ContextType.setActiveRequest]: new ContextManager(ContextType.setActiveRequest, Handlers$2(store), initMemory$2, this.handleCreate),
      [ContextType.approve]: new ContextManager(ContextType.approve, Handlers$3(store), initMemory$3, this.handleCreate),
      [ContextType.disputePrice]: new ContextManager(ContextType.disputePrice, Handlers$4(store), initMemory$4, this.handleCreate),
      [ContextType.proposePrice]: new ContextManager(ContextType.proposePrice, Handlers$5(store), initMemory$5, this.handleCreate),
      [ContextType.switchOrAddChain]: new ContextManager(ContextType.switchOrAddChain, Handlers$6(store), initMemory$6, this.handleCreate),
      [ContextType.pollActiveRequest]: new ContextManager(ContextType.pollActiveRequest, Handlers$7(store), initMemory$7, this.handleCreate),
      [ContextType.pollActiveUser]: new ContextManager(ContextType.pollActiveUser, Handlers$d(store), initMemory$d, this.handleCreate),
      [ContextType.fetchPastEvents]: new ContextManager(ContextType.fetchPastEvents, Handlers$8(store), initMemory$8, this.handleCreate),
      [ContextType.pollNewEvents]: new ContextManager(ContextType.pollNewEvents, Handlers$9(store), initMemory$9, this.handleCreate),
      [ContextType.setActiveRequestByTransaction]: new ContextManager(ContextType.setActiveRequestByTransaction, Handlers$a(store), initMemory$a, this.handleCreate),
      [ContextType.settle]: new ContextManager(ContextType.settle, Handlers$b(store), initMemory$b, this.handleCreate),
      [ContextType.updateActiveRequest]: new ContextManager(ContextType.updateActiveRequest, Handlers$e(store), initMemory$e, this.handleCreate),
      [ContextType.fetchEventBased]: new ContextManager(ContextType.fetchEventBased, Handlers$c(store), initMemory$c, this.handleCreate)
    };
  }
  saveContext(context) {
    this.store.write(w => w.command(context));
  }
  // remove element from front of queue
  shift() {
    return this.pending.shift();
  }
  // remove element from back of queue
  pop() {
    return this.pending.pop();
  }
  size() {
    return this.pending.length;
  }
  push(context) {
    this.pending.push(context);
  }
}



var index$o = {
  __proto__: null,
  setUser: setUser,
  clearUser: clearUser,
  setActiveRequest: setActiveRequest,
  approve: approve,
  disputePrice: disputePrice,
  proposePrice: proposePrice,
  switchOrAddChain: switchOrAddChain,
  pollActiveRequest: pollActiveRequest,
  fetchPastEvents: fetchPastEvents,
  pollNewEvents: pollNewEvents,
  setActiveRequestByTransaction: setActiveRequestByTransaction,
  settle: settle,
  fetchEventBased: fetchEventBased,
  StateMachine: StateMachine,
  ContextClient: ContextClient,
  Step: Step,
  shouldStep: shouldStep,
  create: create,
  ContextManager: ContextManager
};

class Client$1 {
  constructor(store, update, sm, poller) {
    this.store = store;
    this.update = update;
    this.sm = sm;
    this.poller = poller;
    this.intervalStarted = false;
  }
  setUser(params) {
    const address = params.address && ethers$1.ethers.utils.getAddress(params.address);
    return this.sm.types.setUser.create({
      ...params,
      address
    });
  }
  clearUser() {
    return this.sm.types.clearUser.create(undefined);
  }
  setActiveRequest(params) {
    const requester = ethers$1.ethers.utils.getAddress(params.requester);
    // these are case and number senstive
    const ancillaryData = params.ancillaryData.toLowerCase();
    const identifier = params.identifier.toLowerCase();
    const chainId = Number(params.chainId);
    const timestamp = Number(params.timestamp);
    const result = this.sm.types.setActiveRequest.create({
      requester,
      ancillaryData,
      identifier,
      chainId,
      timestamp
    });
    this.sm.types.updateActiveRequest.create(undefined);
    return result;
  }
  setActiveRequestByTransaction(params) {
    const result = this.sm.types.setActiveRequestByTransaction.create(params);
    this.sm.types.updateActiveRequest.create(undefined);
    return result;
  }
  approveCollateral() {
    const {
      checkTxIntervalSec
    } = this.store.read().chainConfig();
    const request = this.store.read().request();
    const inputRequest = this.store.read().inputRequest();
    const user = this.store.read().user();
    const oracleAddress = this.store.read().oracleAddress();
    assert(user.address, "requires a user account address");
    assert(user.signer, "requires a user signer");
    assert(user.chainId === inputRequest.chainId, "On wrong chain");
    assert(request.currency, "Request currency is unknown");
    return this.sm.types.approve.create({
      currency: request.currency,
      account: user.address,
      chainId: inputRequest.chainId,
      signer: user.signer,
      spender: oracleAddress,
      amount: ethers$1.ethers.constants.MaxUint256.toString(),
      confirmations: 1,
      checkTxIntervalSec
    }, user.address);
  }
  proposePrice(proposedPriceDecimals) {
    const {
      checkTxIntervalSec
    } = this.store.read().chainConfig();
    const proposedPrice = toWei(proposedPriceDecimals);
    const inputRequest = this.store.read().inputRequest();
    const request = this.store.read().request();
    const user = this.store.read().user();
    assert(user.address, "requires a user account address");
    assert(user.signer, "requires a user signer");
    assert(user.chainId === inputRequest.chainId, "On wrong chain");
    assert(request.currency, "Request currency is unknown");
    return this.sm.types.proposePrice.create({
      ...inputRequest,
      proposedPrice,
      signer: user.signer,
      account: user.address,
      currency: request.currency,
      confirmations: 1,
      checkTxIntervalSec
    }, user.address);
  }
  disputePrice() {
    const {
      checkTxIntervalSec
    } = this.store.read().chainConfig();
    const inputRequest = this.store.read().inputRequest();
    const user = this.store.read().user();
    const request = this.store.read().request();
    assert(user.address, "requires a user account address");
    assert(user.signer, "requires a user signer");
    assert(user.chainId === inputRequest.chainId, "On wrong chain");
    assert(request.currency, "Request currency is unknown");
    return this.sm.types.disputePrice.create({
      ...inputRequest,
      confirmations: 1,
      signer: user.signer,
      account: user.address,
      currency: request.currency,
      checkTxIntervalSec
    }, user.address);
  }
  settle() {
    const {
      checkTxIntervalSec
    } = this.store.read().chainConfig();
    const inputRequest = this.store.read().inputRequest();
    const user = this.store.read().user();
    const request = this.store.read().request();
    assert(user.address, "requires a user account address");
    assert(user.signer, "requires a user signer");
    assert(user.chainId === inputRequest.chainId, "On wrong chain");
    assert(request.currency, "Request currency is unknown");
    return this.sm.types.settle.create({
      ...inputRequest,
      confirmations: 1,
      signer: user.signer,
      account: user.address,
      currency: request.currency,
      checkTxIntervalSec
    }, user.address);
  }
  switchOrAddChain() {
    const inputRequest = this.store.read().inputRequest();
    const user = this.store.read().user();
    assert(user.provider, "requires user provider");
    assert(user.address, "requires user address");
    assert(inputRequest.chainId, "requires active request chainId");
    return this.sm.types.switchOrAddChain.create({
      chainId: inputRequest.chainId,
      provider: user.provider
    }, user.address);
  }
  // runs statemachine step loop pretty fast by default.
  startInterval(delayMs = 1) {
    assert(!this.intervalStarted, "Interval already started, try stopping first");
    this.intervalStarted = true;
    loop(async () => {
      assert(this.intervalStarted, "Interval Stopped");
      // it turns out since these 2 state machines share the same immer state, they need to be run serially and
      // cant be run concurrently or you get wierd state oscillations. For now keep them in the same timing loop.
      await this.sm.tick();
      await this.poller.tick();
    }, delayMs).catch(err => {
      console.error(err);
      this.intervalStarted = false;
      this.store.write(w => w.error(err));
    });
  }
  stopInterval() {
    assert(!this.intervalStarted, "Interval already stopped");
    this.intervalStarted = false;
  }
}
function makeProvider(rpcUrls) {
  const providers = rpcUrls.map(url => {
    const provider = ethers$1.ethers.getDefaultProvider(url);
    // turn off all polling, we will poll manually
    provider.polling = false;
    return provider;
  });
  const provider = new ethers$1.ethers.providers.FallbackProvider(providers, 1);
  // turn off all polling, we will poll manually
  provider.polling = false;
  return provider;
}
function factory$1(config, emit, OptimisticOracle, sortedRequests) {
  const store = new OracleStore(emit);
  store.write(write => {
    write.config(config);
    // maintains queryable ordered list of requests across all chains
    write.sortedRequestsService(sortedRequests);
    for (const chain of Object.values(config.chains)) {
      const provider = makeProvider(chain.rpcUrls);
      write.chains(chain.chainId).optimisticOracle().address(chain.optimisticOracleAddress);
      write.services(chain.chainId).provider(provider);
      write.services(chain.chainId).multicall2(chain.multicall2Address);
      write.services(chain.chainId).optimisticOracle(new OptimisticOracle(provider, chain.optimisticOracleAddress, chain.chainId));
    }
  });
  const update = new Update(store);
  // this first state machine is for user actions
  const sm = new StateMachine(store);
  // this one is system actions used for long running commands independent of the user
  const poller = new StateMachine(store);
  // start the request list checkers
  for (const [chainId, chainConfig] of Object.entries(config.chains)) {
    poller.types.fetchPastEvents.create({
      chainId: Number(chainId),
      startBlock: chainConfig.earliestBlockNumber,
      maxRange: chainConfig.maxEventRangeQuery
    }, "poller");
    // long running poller which only looks for new events
    poller.types.pollNewEvents.create({
      chainId: Number(chainId),
      pollRateSec: chainConfig.checkTxIntervalSec
    }, "poller");
    // updates event based data on all requests
    if (!chainConfig.disableFetchEventBased) poller.types.fetchEventBased.create({
      chainId: Number(chainId)
    }, "poller");
  }
  // create active request poller for all chains. Should only have one of these
  poller.types.pollActiveRequest.create(undefined, "poller");
  // polls user for balances/approvals on the current chain, in case it changes external to app
  poller.types.pollActiveUser.create(undefined, "poller");
  return new Client$1(store, update, sm, poller);
}

var client = {
  __proto__: null,
  Client: Client$1,
  factory: factory$1
};

class OptimisticOracle$1 {
  constructor(provider, address, chainId) {
    this.provider = provider;
    this.address = address;
    this.chainId = chainId;
    this.events = [];
    this.requests = {};
    this.upsertRequest = request => {
      const id = requestId(request);
      const cachedRequest = this.requests[id] || {};
      const update = {
        ...cachedRequest,
        ...request,
        chainId: this.chainId,
        eventBased: false
      };
      this.requests[id] = update;
      return update;
    };
    this.parseLog = log => {
      const description = this.contract.interface.parseLog(log);
      return {
        ...log,
        ...description,
        event: description.name,
        eventSignature: description.signature
      };
    };
    this.updateFromEvents = events => {
      events.forEach(event => {
        if (isUnique(this.events, event, eventKey)) {
          insertOrderedAscending(this.events, event, eventKey);
        }
      });
      const {
        requests = {}
      } = getEventState$7(this.events);
      Object.values(requests).map(request => this.upsertRequest(request));
    };
    this.contract = connect$a(address, provider);
  }
  setDisputeHash({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, hash) {
    return this.upsertRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData,
      disputeTx: hash
    });
  }
  setProposeHash({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, hash) {
    return this.upsertRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData,
      proposeTx: hash
    });
  }
  setSettleHash({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, hash) {
    return this.upsertRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData,
      settleTx: hash
    });
  }
  async fetchRequest({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }) {
    const request = await this.contract.callStatic.getRequest(requester, identifier, timestamp, ancillaryData);
    const state = await this.contract.callStatic.getState(requester, identifier, timestamp, ancillaryData);
    return this.upsertRequest({
      ...request,
      state,
      requester,
      identifier,
      timestamp,
      ancillaryData
    });
  }
  getRequest(key) {
    const id = requestId(key);
    const request = this.requests[id] || key;
    return {
      ...request
    };
  }
  async disputePrice(signer, {
    requester,
    identifier,
    timestamp,
    ancillaryData
  }) {
    const contract = connect$a(this.address, signer);
    const tx = await contract.disputePrice(requester, identifier, timestamp, ancillaryData);
    this.setDisputeHash({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }, tx.hash);
    return tx;
  }
  async proposePrice(signer, {
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, price) {
    const contract = connect$a(this.address, signer);
    const tx = await contract.proposePrice(requester, identifier, timestamp, ancillaryData, price);
    this.setProposeHash({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }, tx.hash);
    return tx;
  }
  async settle(signer, {
    requester,
    identifier,
    timestamp,
    ancillaryData
  }) {
    const contract = connect$a(this.address, signer);
    const tx = await contract.settle(requester, identifier, timestamp, ancillaryData);
    this.setSettleHash({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }, tx.hash);
    return tx;
  }
  async update(startBlock = 0, endBlock = "latest") {
    const events = await this.contract.queryFilter({}, startBlock, endBlock);
    this.updateFromEvents(events);
  }
  async getProps() {
    return {
      defaultLiveness: await this.contract.defaultLiveness()
    };
  }
  updateFromTransactionReceipt(receipt) {
    const events = receipt.logs.map(log => this.parseLog(log));
    this.updateFromEvents(events);
  }
  listRequests() {
    return Object.values(this.requests);
  }
}

var optimisticOracle = {
  __proto__: null,
  OptimisticOracle: OptimisticOracle$1
};

// this is a special service that works across all oracles type, chains, etc, to give a combined
// this was copied out of store and made to be 1. a class, and 2. sync.  Could not modify old implementation since
// other services rely on this currently and it causes cascading refactors. This has been copied without modification to logic.
class SortedStore {
  constructor() {
    this.ids = [];
    this.map = new Map();
    this.getStart = (id, inclusive = true) => {
      if (inclusive) {
        return sortedIndex(this.ids, id);
      } else {
        return sortedLastIndex(this.ids, id);
      }
    };
    this.getEnd = (id, inclusive = false) => {
      return this.getStart(id, !inclusive);
    };
    this.del = id => {
      const index = sortedIndex(this.ids, id);
      this.ids.splice(index, 1);
      const result = this.map.get(id);
      this.map.delete(id);
      return result;
    };
    // keeps typescript from complaining that return values may be undefined
    this.getSafe = id => {
      const result = this.map.get(id);
      if (exists(result)) return result;
      throw new Error("Missing data for index: " + id);
    };
    this.has = id => {
      return this.map.has(id);
    };
    this.set = (id, data) => {
      if (this.map.has(id)) {
        this.map.set(id, data);
      } else {
        const index = sortedIndex(this.ids, id);
        this.ids.splice(index, 0, id);
        this.map.set(id, data);
      }
    };
    this.get = id => {
      return this.map.get(id);
    };
    this.values = () => {
      return this.ids.map(this.getSafe);
    };
    this.entries = () => {
      return this.ids.map(id => [id, this.getSafe(id)]);
    };
    this.keys = () => {
      return [...this.ids];
    };
    this.clear = () => {
      this.map.clear();
      this.ids.length = 0;
    };
    this.size = () => {
      return this.ids.length;
    };
    this.delete = id => {
      if (!this.map.has(id)) return;
      this.del(id);
    };
    // assume [a,b)
    this.between = (a, b) => {
      const start = this.getStart(a);
      const end = this.getEnd(b);
      return this.ids.slice(start, end).map(this.getSafe);
    };
    this.slice = (id, length) => {
      const start = this.getStart(id);
      return this.ids.slice(start, start + length).map(this.getSafe);
    };
  }
}
// this sorts requests across all chains and oracles
class SortedRequests extends SortedStore {
  setByRequest(value) {
    return this.set(this.id(value), value);
  }
  descending() {
    // sadly you cannot control lodash sorting descending, so reverse is necessary
    return this.values().reverse();
  }
  ascending() {
    return this.values();
  }
  getByRequest(request) {
    // always return at least the original query data
    return this.get(this.id(request)) || request;
  }
  id(request) {
    return requestId(request) + "!" + request.chainId + "!" + request.oracleType;
  }
}

var sortedRequests = {
  __proto__: null,
  SortedStore: SortedStore,
  SortedRequests: SortedRequests
};

function validateSolidityRequest(request) {
  assert(request.proposer, "Missing proposer");
  assert(request.disputer, "Missing disputer");
  assert(request.currency, "Missing currency");
  assert(request.settled, "Missing settled");
  assert(request.proposedPrice, "Missing proposedPrice");
  assert(request.resolvedPrice, "Missing resolvedPrice");
  assert(request.expirationTime, "Missing expirationTime");
  assert(request.reward, "Missing reward");
  assert(request.finalFee, "Missing finalFee");
  assert(request.bond, "Missing bond");
  assert(request.customLiveness, "Missing customLiveness");
  return {
    proposer: request.proposer,
    disputer: request.disputer,
    currency: request.currency,
    settled: request.settled,
    proposedPrice: request.proposedPrice,
    resolvedPrice: request.resolvedPrice,
    expirationTime: request.expirationTime,
    reward: request.reward,
    finalFee: request.finalFee,
    bond: request.bond,
    customLiveness: request.customLiveness
  };
}
class SkinnyOptimisticOracle {
  constructor(provider, address, chainId) {
    this.provider = provider;
    this.address = address;
    this.chainId = chainId;
    this.events = [];
    this.requests = {};
    this.upsertRequest = request => {
      const id = requestId(request);
      const cachedRequest = this.requests[id] || {};
      const update = {
        ...cachedRequest,
        ...request,
        chainId: this.chainId,
        eventBased: false
      };
      this.requests[id] = update;
      return update;
    };
    this.updateFromEvents = events => {
      events.forEach(event => {
        if (isUnique(this.events, event, eventKey)) {
          insertOrderedAscending(this.events, event, eventKey);
        }
      });
      const {
        requests = {}
      } = getEventState$8(this.events);
      Object.values(requests).map(request => this.upsertRequest(request));
    };
    this.parseLog = log => {
      const description = this.contract.interface.parseLog(log);
      return {
        ...log,
        ...description,
        event: description.name,
        eventSignature: description.signature
      };
    };
    this.contract = connect$b(address, provider);
  }
  setDisputeHash({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, hash) {
    return this.upsertRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData,
      disputeTx: hash
    });
  }
  setProposeHash({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, hash) {
    return this.upsertRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData,
      proposeTx: hash
    });
  }
  setSettleHash({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, hash) {
    return this.upsertRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData,
      settleTx: hash
    });
  }
  async fetchRequest(key) {
    // skinny oo does not have a way to query request data from contract, can only find this though events.
    return this.getRequest(key);
  }
  getRequest(key) {
    const id = requestId(key);
    const request = this.requests[id] || key;
    return {
      ...request
    };
  }
  async disputePrice(signer, {
    requester,
    identifier,
    timestamp,
    ancillaryData
  }) {
    const request = validateSolidityRequest(this.getRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }));
    const contract = connect$b(this.address, signer);
    const tx = await contract.disputePrice(requester, identifier, timestamp, ancillaryData, request);
    this.setDisputeHash({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }, tx.hash);
    return tx;
  }
  async proposePrice(signer, {
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, price) {
    const request = validateSolidityRequest(this.getRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }));
    const contract = connect$b(this.address, signer);
    const tx = await contract.proposePrice(requester, identifier, timestamp, ancillaryData, request, price);
    this.setProposeHash({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }, tx.hash);
    return tx;
  }
  async settle(signer, {
    requester,
    identifier,
    timestamp,
    ancillaryData
  }) {
    const request = validateSolidityRequest(this.getRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }));
    const contract = connect$b(this.address, signer);
    const tx = await contract.settle(requester, identifier, timestamp, ancillaryData, request);
    this.setSettleHash({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }, tx.hash);
    return tx;
  }
  async update(startBlock = 0, endBlock = "latest") {
    const events = await this.contract.queryFilter({}, startBlock, endBlock);
    this.updateFromEvents(events);
  }
  async getProps() {
    return {
      defaultLiveness: await this.contract.defaultLiveness()
    };
  }
  updateFromTransactionReceipt(receipt) {
    const events = receipt.logs.map(log => this.parseLog(log));
    this.updateFromEvents(events);
  }
  listRequests() {
    return Object.values(this.requests);
  }
}

var skinnyOptimisticOracle = {
  __proto__: null,
  SkinnyOptimisticOracle: SkinnyOptimisticOracle
};

class OptimisticOracleV2 {
  constructor(provider, address, chainId) {
    this.provider = provider;
    this.address = address;
    this.chainId = chainId;
    this.events = [];
    this.requests = {};
    this.upsertRequest = request => {
      const id = requestId(request);
      const cachedRequest = this.requests[id] || {};
      const update = {
        ...cachedRequest,
        ...request,
        ...(request.requestSettings || {}),
        chainId: this.chainId
      };
      this.requests[id] = update;
      return update;
    };
    this.updateFromEvents = events => {
      events.forEach(event => {
        if (isUnique(this.events, event, eventKey)) {
          insertOrderedAscending(this.events, event, eventKey);
        }
      });
      const {
        requests = {}
      } = getEventState$9(this.events);
      Object.values(requests).map(request => this.upsertRequest(request));
    };
    this.parseLog = log => {
      const description = this.contract.interface.parseLog(log);
      return {
        ...log,
        ...description,
        event: description.name,
        eventSignature: description.signature
      };
    };
    this.contract = connect$c(address, provider);
  }
  setDisputeHash({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, hash) {
    return this.upsertRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData,
      disputeTx: hash
    });
  }
  setProposeHash({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, hash) {
    return this.upsertRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData,
      proposeTx: hash
    });
  }
  setSettleHash({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, hash) {
    return this.upsertRequest({
      requester,
      identifier,
      timestamp,
      ancillaryData,
      settleTx: hash
    });
  }
  async fetchRequest({
    requester,
    identifier,
    timestamp,
    ancillaryData
  }) {
    const request = await this.contract.callStatic.getRequest(requester, identifier, timestamp, ancillaryData);
    const state = await this.contract.callStatic.getState(requester, identifier, timestamp, ancillaryData);
    return this.upsertRequest({
      ...request,
      state,
      requester,
      identifier,
      timestamp,
      ancillaryData
    });
  }
  getRequest(key) {
    const id = requestId(key);
    const request = this.requests[id] || key;
    return {
      ...request
    };
  }
  async disputePrice(signer, {
    requester,
    identifier,
    timestamp,
    ancillaryData
  }) {
    const contract = connect$c(this.address, signer);
    const tx = await contract.disputePrice(requester, identifier, timestamp, ancillaryData);
    this.setDisputeHash({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }, tx.hash);
    return tx;
  }
  async proposePrice(signer, {
    requester,
    identifier,
    timestamp,
    ancillaryData
  }, price) {
    const contract = connect$c(this.address, signer);
    const tx = await contract.proposePrice(requester, identifier, timestamp, ancillaryData, price);
    this.setProposeHash({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }, tx.hash);
    return tx;
  }
  async settle(signer, {
    requester,
    identifier,
    timestamp,
    ancillaryData
  }) {
    const contract = connect$c(this.address, signer);
    const tx = await contract.settle(requester, identifier, timestamp, ancillaryData);
    this.setSettleHash({
      requester,
      identifier,
      timestamp,
      ancillaryData
    }, tx.hash);
    return tx;
  }
  async update(startBlock = 0, endBlock = "latest") {
    const events = await this.contract.queryFilter({}, startBlock, endBlock);
    this.updateFromEvents(events);
  }
  async getProps() {
    return {
      defaultLiveness: await this.contract.defaultLiveness()
    };
  }
  updateFromTransactionReceipt(receipt) {
    const events = receipt.logs.map(log => this.parseLog(log));
    this.updateFromEvents(events);
  }
  listRequests() {
    return Object.values(this.requests);
  }
}

var optimisticOracleV2 = {
  __proto__: null,
  OptimisticOracleV2: OptimisticOracleV2
};



var index$p = {
  __proto__: null,
  erc20: erc20,
  optimisticOracle: optimisticOracle,
  statemachines: index$o,
  sortedRequests: sortedRequests,
  skinnyOptimisticOracle: skinnyOptimisticOracle,
  optimisticOracleV2: optimisticOracleV2
};



var ethers = {
  __proto__: null,
  Provider: providers.Provider,
  JsonRpcSigner: providers.JsonRpcSigner,
  JsonRpcProvider: providers.JsonRpcProvider,
  Web3Provider: providers.Web3Provider,
  FallbackProvider: providers.FallbackProvider
};



var misc = {
  __proto__: null
};



var interfaces = {
  __proto__: null,
  get RequestState () { return RequestState; }
};



var index$q = {
  __proto__: null,
  state: state,
  ethers: ethers,
  misc: misc,
  statemachine: statemachine,
  interfaces: interfaces
};

var SkinnyFactory = ((config, emit, sortedRequests = new SortedRequests()) => {
  const fullConfig = DefaultConfig({
    getMulticall2Address
  })({
    ...config
  }, OracleType.Skinny);
  return factory$1(fullConfig, emit, SkinnyOptimisticOracle, sortedRequests);
});

var OptimisticFactory = ((config, emit, sortedRequests = new SortedRequests()) => {
  const fullConfig = DefaultConfig({
    getMulticall2Address
  })({
    ...config
  }, OracleType.Optimistic);
  return factory$1(fullConfig, emit, OptimisticOracle$1, sortedRequests);
});

var OptimisticV2Factory = ((config, emit, sortedRequests = new SortedRequests()) => {
  const fullConfig = DefaultConfig({
    getMulticall2Address
  })({
    ...config
  }, OracleType.OptimisticV2);
  return factory$1(fullConfig, emit, OptimisticOracleV2, sortedRequests);
});

const EventHandler = (oracleType, publicEmit) => (state, prev) => publicEmit(oracleType, state, prev);
var factory$2 = ((configTable, emit) => {
  const sortedRequests = new SortedRequests();
  return Object.fromEntries(Object.entries(configTable).map(([oracleType, config]) => {
    assert(config, "requires config for type: " + oracleType);
    switch (oracleType) {
      case OracleType.Optimistic:
        return [oracleType, OptimisticFactory(config, EventHandler(oracleType, emit), sortedRequests)];
      case OracleType.Skinny:
        return [oracleType, SkinnyFactory(config, EventHandler(oracleType, emit), sortedRequests)];
      case OracleType.OptimisticV2:
        return [oracleType, OptimisticV2Factory(config, EventHandler(oracleType, emit), sortedRequests)];
      default:
        throw new Error("Unknown oracle type: " + oracleType);
    }
  }));
});



var index$r = {
  __proto__: null,
  client: client,
  services: index$p,
  types: index$q,
  store: index$n,
  utils: utils$2,
  errors: errors,
  skinnyFactory: SkinnyFactory,
  optimisticFactory: OptimisticFactory,
  factory: factory$2,
  optimisticV2Factory: OptimisticV2Factory
};

exports.BlockFinder = BlockFinder;
exports.Coingecko = Coingecko;
exports.Multicall = Factory$d;
exports.Multicall2 = Multicall2Factory;
exports.across = index$m;
exports.clients = index$e;
exports.oracle = index$r;
exports.stores = index$f;
exports.tables = index$k;
exports.utils = utils;
//# sourceMappingURL=index.cjs.development.js.map
