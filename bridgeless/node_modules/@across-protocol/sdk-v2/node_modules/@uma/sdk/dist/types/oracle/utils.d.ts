import { ethers } from "ethers";
export { requestId } from "../clients/optimisticOracle";
import { State, Flag, Flags, PartialChainConfig, ChainConfig, PartialConfig, ChainMetadata, Config, OracleType } from "./types/state";
import type { Provider, TransactionReceipt, BigNumberish } from "./types/ethers";
export declare const getAddress: typeof ethers.utils.getAddress;
export declare const hexValue: typeof ethers.utils.hexValue;
export declare function initFlags(): Flags;
export declare const nowS: (now?: number) => number;
export declare function getFlags(state: State): Record<Flag, boolean>;
export declare function getMulticall2Address(chainId: number): string;
declare type AddressGetter = (chainId: number) => string;
interface AddressGetters {
    getMulticall2Address: AddressGetter;
}
export declare const DefaultChainConfig: ({ getMulticall2Address }: AddressGetters) => (chainId: number, chainConfig: PartialChainConfig) => ChainConfig;
export declare const DefaultConfig: (getters: AddressGetters) => (config: PartialConfig, oracleType: OracleType) => Config;
export declare class TransactionConfirmer {
    private provider;
    constructor(provider: Provider);
    getReceipt(hash: string): Promise<TransactionReceipt>;
    isConfirmed(hash: string, confirmations?: number): Promise<false | TransactionReceipt>;
}
export declare function chainConfigToChainMetadata(config: ChainConfig): ChainMetadata;
export declare type RangeState = {
    startBlock: number;
    endBlock: number;
    maxRange: number;
    currentRange: number;
    currentStart: number;
    currentEnd: number;
    done: boolean;
    multiplier?: number;
};
/**
 * rangeStart. This starts a new range query and sets defaults for state.  Use this as the first call before starting your queries
 *
 * @param {Pick} state
 * @returns {RangeState}
 */
export declare function rangeStart(state: Pick<RangeState, "startBlock" | "endBlock" | "multiplier"> & {
    maxRange?: number;
}): RangeState;
/**
 * rangeSuccessDescending. We have 2 ways of querying events, from oldest to newest, or newest to oldest. Typically we want them in order, from
 * oldest to newest, but for this particular case we want them newest to oldest, ie descending ( larger timestamp to smaller timestamp).
 * This function will increase the range between start/end block and return a new start/end to use since by calling this you are signalling
 * that the last range ended in a successful query.
 *
 * @param {RangeState} state
 * @returns {RangeState}
 */
export declare function rangeSuccessDescending(state: RangeState): RangeState;
/**
 * rangeFailureDescending. Like the previous function, this will decrease the range between start/end for your query, because you are signalling
 * that the last query failed. It will also keep the end of your range the same, while moving the start range up. This is why
 * its considered descending, it will attempt to move from end to start, rather than start to end.
 *
 * @param {RangeState} state
 * @returns {RangeState}
 */
export declare function rangeFailureDescending(state: RangeState): RangeState;
/**
 * eventKey. Make a unique and sortable identifier string for an event
 *
 * @param {Event} event
 * @returns {string} - the unique id
 */
export declare function eventKey(event: {
    blockNumber: BigNumberish;
    transactionIndex: BigNumberish;
    logIndex: BigNumberish;
}): string;
/**
 * insertOrdered. Inserts items in an array maintaining sorted order, in this case lowest to highest. Does not check duplicates.
 * Mainly used for caching all known events, in order of oldest to newest.
 *
 * @param {T[]} array
 * @param {T} element
 * @param {Function} orderBy
 */
export declare function insertOrderedAscending<T>(array: T[], element: T, orderBy: (element: T) => string | number): T[];
export declare function isUnique<T>(array: T[], element: T, id: (element: T) => string | number): boolean;
export declare function isSupportedOracleType(oracleType: string): oracleType is OracleType;
