"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t=require("@uma/contracts-node"),s=e(require("assert")),r=require("ethers"),a=e(require("lodash/zip")),n=require("lodash"),i=e(require("axios")),o=e(require("lodash/get")),c=e(require("highland")),u=e(require("decimal.js")),l=e(require("lodash/sortedIndexBy")),d=e(require("lodash/clamp")),h=require("@ethersproject/providers"),p=e(require("lodash/set")),m=e(require("lodash/has")),g=require("@eth-optimism/contracts"),f=require("@eth-optimism/core-utils"),v=e(require("lodash/sortedLastIndexBy")),y=e(require("lodash/filter")),w=e(require("immer")),q=e(require("bluebird")),b=e(require("lodash/uniqueId")),_=e(require("lodash/sortedIndex")),S=e(require("lodash/sortedLastIndex"));const R=t.RegistryEthers__factory;function k(e={},t){switch(t.event){case"NewContractRegistered":{const s=t,{contractAddress:r}=s.args,a=(null==e?void 0:e.contracts)||{};return{...e,contracts:{...a,[r]:s}}}}return e}var I={__proto__:null,getAddress:t.getRegistryAddress,getAbi:t.getRegistryAddress,connect:function(e,t){return R.connect(e,t)},reduceEvents:k,getEventState:function(e){return e.reduce(k,{})}};function C(e){return null!=e}function E(e={}){function t(e,t="0"){return s(!a(e),"balance already exists"),n(e,t)}function a(t){return C(e[t])}function n(t,s){return e[t]=s,s}function i(t){return s(a(t),"balance does not exist"),e[t]}function o(e){return a(e)?i(e):t(e)}return{create:t,add:function(e,t){return n(e,r.BigNumber.from(t).add(o(e)).toString())},sub:function(e,t){return n(e,r.BigNumber.from(o(e)).sub(t).toString())},get:i,balances:e,set:n,has:a,getOrCreate:o}}const A=(e,t)=>(s(e>=0,"requires fromDecimals as an integer >= 0"),s(t>=0,"requires toDecimals as an integer >= 0"),a=>{if(s(C(a),"must provide an amount to convert"),(a=r.BigNumber.from(a)).isZero())return a.toString();const n=e-t;return 0==n?a.toString():n>0?a.div(r.BigNumber.from("10").pow(n)).toString():a.mul(r.BigNumber.from("10").pow(-1*n)).toString()}),T=(e=0)=>new Promise(t=>setTimeout(t,e));async function x(e,t,...s){for(;;)await e(...s),await T(t)}const P=e=>t=>async s=>{const r=await e.batch(t,s.map(([e,...t])=>({method:e,args:t}))).readWithErrors();return Object.fromEntries(a(s,r).map(([e,t])=>{if(null==e)return[];const[s]=e;return null!=t&&t.result?[s,t.result[0]||t.result]:[s,void 0]}))};async function D(e){switch(e){case 10:case 42161:return.5;case 288:return 150;case 137:return 2.5;case 1:default:return 12}}async function B(e,t=0,s){const r=t+1,a=await D(s);return Math.floor(e*r/a)}var M={__proto__:null,exists:C,Balances:E,ConvertDecimals:A,sleep:T,loop:x,BatchReadWithErrors:P,averageBlockTimeSeconds:D,estimateBlocksElapsed:B};const O=t.ExpiringMultiPartyEthers__factory;function L(e={},t){switch(t.event){case"RequestTransferPositionExecuted":{const s=t,{oldSponsor:r,newSponsor:a}=s.args,n=E(e.tokens||{}),i=E(e.collateral||{}),o=i.get(r);i.set(r,"0"),i.set(a,o);const c=n.get(r);return n.set(r,"0"),n.set(a,c.toString()),{...e,collateral:i.balances,tokens:n.balances}}case"PositionCreated":{const s=t,{sponsor:r,collateralAmount:a,tokenAmount:n}=s.args,i=E(e.tokens||{}),o=E(e.collateral||{});return o.add(r,a.toString()),i.add(r,n.toString()),{...e,collateral:o.balances,tokens:i.balances}}case"NewSponsor":{const s=t,{sponsor:r}=s.args,a=new Set(e.sponsors||[]);return a.add(r),{...e,sponsors:Array.from(a.values())}}case"SettleExpiredPosition":{const s=t,{caller:r,collateralReturned:a,tokensBurned:n}=s.args,i=E(e.tokens||{}),o=E(e.collateral||{});return o.sub(r,a.toString()),i.sub(r,n.toString()),{...e,expired:!0,collateral:o.balances,tokens:i.balances}}case"Redeem":{const s=t,{sponsor:r,collateralAmount:a,tokenAmount:n}=s.args,i=E(e.tokens||{}),o=E(e.collateral||{});return o.sub(r,a.toString()),i.sub(r,n.toString()),{...e,collateral:o.balances,tokens:i.balances}}case"LiquidationCreated":{const s=t,{sponsor:r,tokensOutstanding:a,liquidatedCollateral:n}=s.args,i=E(e.tokens||{}),o=E(e.collateral||{});return o.sub(r,n.toString()),i.sub(r,a.toString()),{...e,collateral:o.balances,tokens:i.balances}}case"Withdrawal":case"RequestWithdrawalExecuted":{const s=t,{sponsor:r,collateralAmount:a}=s.args,n=E(e.collateral||{});return n.sub(r,a.toString()),{...e,collateral:n.balances}}case"ContractExpired":return{...e,expired:!0}}return e}var N={__proto__:null,connect:function(e,t){return O.connect(e,t)},reduceEvents:L,getEventState:function(e,t={}){return e.reduce(L,t)}};const F=t.ERC20Ethers__factory;function U(e,t){return F.connect(e,t)}function H(e={},t){switch(t.event){case"Transfer":{const s=t,{from:r,to:a,value:n}=s.args,i=E(e.balances||{});return i.sub(r,n),i.add(a,n),{...e,balances:i.balances}}case"Approval":{const s=t,{owner:r,spender:a,value:i}=s.args;return n.set(e,["approvalsByOwner",r,a],i.toString()),n.set(e,["approvalsBySpender",a,r],i.toString()),{...e}}}return e}var j={__proto__:null,connect:U,reduceEvents:H,getEventState:function(e,t={}){return e.reduce(H,t)}};const W=t.MulticallEthers__factory;function $(e,t){return W.connect(e,t)}var z={__proto__:null,connect:$};const G=t.Multicall2Ethers__factory;function V(e,t){return G.connect(e,t)}var J={__proto__:null,connect:V};const K=t.LongShortPairCreatorEthers__factory;function Q(e,t){switch(t.event){case"CreatedLongShortPair":{const s=t,r=(null==e?void 0:e.contracts)||{};return{...e,contracts:{...r,[s.args.longShortPair]:s}}}}return e}var Y={__proto__:null,getAddress:t.getLongShortPairCreatorAddress,getAbi:t.getLongShortPairCreatorAbi,connect:function(e,t){return K.connect(e,t)},reduceEvents:Q,getEventState:function(e,t={}){return e.reduce(Q,t)}};const Z=t.LongShortPairEthers__factory;function X(e,t){switch(t.event){case"TokensCreated":{const s=t,{sponsor:r,collateralUsed:a,tokensMinted:n}=s.args,i=new Set(e.sponsors||[]),o=E(e.longs||{}),c=E(e.shorts||{}),u=E(e.collateral||{});return i.add(r),o.add(r,n),c.add(r,n),u.add(r,a),{...e,collateral:u.balances,shorts:c.balances,longs:o.balances,sponsors:Array.from(i.values())}}case"TokensRedeemed":{const s=t,{sponsor:r,collateralReturned:a,tokensRedeemed:n}=s.args,i=E(e.longs||{}),o=E(e.shorts||{}),c=E(e.collateral||{});return i.sub(r,n),o.sub(r,n),c.sub(r,a),{...e,collateral:c.balances,shorts:o.balances,longs:i.balances}}case"ContractExpired":{const s=t,{caller:r}=s.args;return{...e,expired:!0,expiredBy:r}}case"PositionSettled":{const s=t,{sponsor:r,collateralReturned:a,longTokens:n,shortTokens:i}=s.args,o=E(e.longs||{}),c=E(e.shorts||{}),u=E(e.collateral||{});return o.sub(r,n),c.sub(r,i),u.sub(r,a),{...e,collateral:u.balances,shorts:c.balances,longs:o.balances}}}return e}var ee={__proto__:null,connect:function(e,t){return Z.connect(e,t)},reduceEvents:X,getEventState:function(e,t={}){return e.reduce(X,t)}};const te=t.BridgeDepositBoxEthers__factory;function se(e,t){switch(t.event){case"SetMinimumBridgingDelay":{const s=t,{newMinimumBridgingDelay:r}=s.args;return{...e,minimumBridgingDelay:r.toString()}}case"WhitelistToken":{const s=t,{l1Token:r,l2Token:a,lastBridgeTime:n,bridgePool:i}=s.args;return{...e,whitelistedTokens:{...e.whitelistedTokens,[a]:{l1Token:r,l2Token:a,lastBridgeTime:n,bridgePool:i}}}}case"DepositsEnabled":{const s=t,{l2Token:r,depositsEnabled:a}=s.args;return{...e,depositsEnabled:{...e.depositsEnabled,[r]:a}}}case"FundsDeposited":{const s=t,{chainId:r,depositId:a,l1Recipient:n,l2Sender:i,l1Token:o,amount:c,slowRelayFeePct:u,instantRelayFeePct:l,quoteTimestamp:d}=s.args;return{...e,deposits:{...e.deposits,[a.toString()]:{chainId:r,depositId:a,l1Recipient:n,l2Sender:i,l1Token:o,amount:c,slowRelayFeePct:u,instantRelayFeePct:l,quoteTimestamp:d}}}}}return e}var re={__proto__:null,connect:function(e,t){return te.connect(e,t)},reduceEvents:se,getEventState:function(e,t={}){return e.reduce(se,t)}};const ae=t.BridgePoolEthers__factory;function ne(e,t){return ae.connect(e,t)}function ie(e,t){switch(t.event){case"LiquidityAdded":{const s=t,{amount:r,lpTokensMinted:a,liquidityProvider:n}=s.args,i=E(e.tokens||{}),o=E(e.lpTokens||{});return i.add(n,r.toString()),o.add(n,a.toString()),{...e,tokens:{...i.balances},lpTokens:{...o.balances}}}case"LiquidityRemoved":{const s=t,{amount:r,lpTokensBurnt:a,liquidityProvider:n}=s.args,i=E(e.tokens||{}),o=E(e.lpTokens||{});return i.sub(n,r.toString()),o.sub(n,a.toString()),{...e,tokens:{...i.balances},lpTokens:{...o.balances}}}case"DepositRelayed":{const s=t,{depositHash:r,depositData:a,relay:n,relayAncillaryDataHash:i}=s.args;return{...e,relays:{...e.relays,[i]:n},deposits:{...e.deposits,[r]:a}}}case"RelaySpedUp":{const s=t,{depositHash:r,instantRelayer:a}=s.args;return{...e,instantRelays:{...e.instantRelays||{},[r]:a}}}case"RelayDisputed":case"RelayCanceled":case"RelaySettled":return e;case"BridgePoolAdminTransferred":{const s=t,{oldAdmin:r,newAdmin:a}=s.args;return{...e,oldAdmin:r,newAdmin:a}}}return e}function oe(e,t={tokens:{},lpTokens:{},deposits:{},relays:{},instantRelays:{}}){return e.reduce(ie,t)}var ce={__proto__:null,Factory:ae,connect:ne,attach:function(e){return(new ae).attach(e)},eventStateDefaults:function(){return{tokens:{},lpTokens:{},deposits:{},relays:{},instantRelays:{}}},reduceEvents:ie,getEventState:oe};class ue{constructor(e="https://www.etherchain.org/api"){this.url=e}async getGasPrice(){try{const e=this.url+"/gasPriceOracle";return(await i.get(e)).data}catch(e){const t=o(e,"response.data.error",o(e,"response.statusText","Unknown Coingecko Error"));throw new Error(t)}}}var le={__proto__:null,Etherchain:ue};const de=t.RateModelStoreEthers__factory;function he(e,t){return de.connect(e,t)}var pe={__proto__:null,Factory:de,getAddress:t.getRateModelStoreAddress,connect:he,attach:function(e){return(new de).attach(e)}};const me=t.OptimisticOracleInterfaceEthers__factory;function ge(e,t){return me.connect(e,t)}const fe=new r.utils.Interface(t.getOptimisticOracleInterfaceAbi());var ve;function ye(e){return[e.timestamp.toString(),e.identifier,e.requester,e.ancillaryData].join("!")}function we(e,t){switch(t.event){case"RequestPrice":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,currency:o,reward:c,finalFee:u}=s.args,l=ye(s.args);e.requests||(e.requests={}),e.requests[l]={...e.requests[l]||{requester:r,identifier:a,timestamp:n,ancillaryData:i},currency:o,reward:c,finalFee:u,state:ve.Requested,requestTx:t.transactionHash,requestBlockNumber:t.blockNumber,requestLogIndex:t.logIndex};break}case"ProposePrice":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,proposer:o,proposedPrice:c,expirationTimestamp:u,currency:l}=s.args,d=ye(s.args);e.requests||(e.requests={}),e.requests[d]={...e.requests[d]||{requester:r,identifier:a,timestamp:n,ancillaryData:i},currency:l,proposer:o,proposedPrice:c,expirationTime:u,state:ve.Proposed,proposeTx:t.transactionHash,proposeBlockNumber:t.blockNumber,proposeLogIndex:t.logIndex};break}case"DisputePrice":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,proposer:o,disputer:c,proposedPrice:u}=s.args,l=ye(s.args);e.requests||(e.requests={}),e.requests[l]={...e.requests[l]||{requester:r,identifier:a,timestamp:n,ancillaryData:i},proposer:o,disputer:c,proposedPrice:u,state:ve.Disputed,disputeTx:t.transactionHash,disputeBlockNumber:t.blockNumber,disputeLogIndex:t.logIndex};break}case"Settle":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,proposer:o,disputer:c,price:u,payout:l}=s.args,d=ye(s.args);e.requests||(e.requests={}),e.requests[d]={...e.requests[d]||{requester:r,identifier:a,timestamp:n,ancillaryData:i},requester:r,proposer:o,disputer:c,price:u,payout:l,state:ve.Settled,settleTx:t.transactionHash,settleBlockNumber:t.blockNumber,settleLogIndex:t.logIndex};break}}return e}function qe(e,t={}){return e.reduce(we,t)}!function(e){e[e.Invalid=0]="Invalid",e[e.Requested=1]="Requested",e[e.Proposed=2]="Proposed",e[e.Expired=3]="Expired",e[e.Disputed=4]="Disputed",e[e.Resolved=5]="Resolved",e[e.Settled=6]="Settled"}(ve||(ve={}));var be={__proto__:null,connect:ge,contractInterface:fe,get RequestState(){return ve},requestId:ye,reduceEvents:we,getEventState:qe};const _e=t.SkinnyOptimisticOracleEthers__factory;function Se(e,t){return _e.connect(e,t)}const Re=new r.utils.Interface(t.getSkinnyOptimisticOracleAbi());var ke;function Ie(e){return[e.timestamp.toString(),e.identifier,e.requester,e.ancillaryData].join("!")}function Ce(e,t){switch(t.event){case"RequestPrice":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,request:o}=s.args,c=Ie(s.args);e.requests||(e.requests={}),e.requests[c]={...e.requests[c],...o,requester:r,identifier:a,timestamp:n,ancillaryData:i,state:ke.Requested,requestTx:t.transactionHash,requestBlockNumber:t.blockNumber,requestLogIndex:t.logIndex};break}case"ProposePrice":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,request:o}=s.args,c=Ie(s.args);e.requests||(e.requests={}),e.requests[c]={...e.requests[c],...o,requester:r,identifier:a,timestamp:n,ancillaryData:i,state:ke.Proposed,proposeTx:t.transactionHash,proposeBlockNumber:t.blockNumber,proposeLogIndex:t.logIndex};break}case"DisputePrice":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,request:o}=s.args,c=Ie(s.args);e.requests||(e.requests={}),e.requests[c]={...e.requests[c],...o,requester:r,identifier:a,timestamp:n,ancillaryData:i,state:ke.Disputed,disputeTx:t.transactionHash,disputeBlockNumber:t.blockNumber,disputeLogIndex:t.logIndex};break}case"Settle":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,request:o}=s.args,c=Ie(s.args);e.requests||(e.requests={}),e.requests[c]={...e.requests[c],...o,requester:r,identifier:a,timestamp:n,ancillaryData:i,state:ke.Settled,settleTx:t.transactionHash,settleBlockNumber:t.blockNumber,settleLogIndex:t.logIndex};break}}return e}function Ee(e,t={}){return e.reduce(Ce,t)}!function(e){e[e.Invalid=0]="Invalid",e[e.Requested=1]="Requested",e[e.Proposed=2]="Proposed",e[e.Expired=3]="Expired",e[e.Disputed=4]="Disputed",e[e.Resolved=5]="Resolved",e[e.Settled=6]="Settled"}(ke||(ke={}));var Ae={__proto__:null,connect:Se,contractInterface:Re,get RequestState(){return ke},requestId:Ie,reduceEvents:Ce,getEventState:Ee};const Te=t.OptimisticOracleV2InterfaceEthers__factory;function xe(e,t){return Te.connect(e,t)}const Pe=new r.utils.Interface(t.getOptimisticOracleV2InterfaceAbi());var De;function Be(e){return[e.timestamp.toString(),e.identifier,e.requester,e.ancillaryData].join("!")}function Me(e,t){switch(t.event){case"RequestPrice":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,currency:o,reward:c,finalFee:u}=s.args,l=Be(s.args);e.requests||(e.requests={}),e.requests[l]={...e.requests[l]||{requester:r,identifier:a,timestamp:n,ancillaryData:i},currency:o,reward:c,finalFee:u,state:De.Requested,requestTx:t.transactionHash,requestBlockNumber:t.blockNumber,requestLogIndex:t.logIndex};break}case"ProposePrice":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,proposer:o,proposedPrice:c,expirationTimestamp:u,currency:l}=s.args,d=Be(s.args);e.requests||(e.requests={}),e.requests[d]={...e.requests[d]||{requester:r,identifier:a,timestamp:n,ancillaryData:i},currency:l,proposer:o,proposedPrice:c,expirationTime:u,state:De.Proposed,proposeTx:t.transactionHash,proposeBlockNumber:t.blockNumber,proposeLogIndex:t.logIndex};break}case"DisputePrice":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,proposer:o,disputer:c,proposedPrice:u}=s.args,l=Be(s.args);e.requests||(e.requests={}),e.requests[l]={...e.requests[l]||{requester:r,identifier:a,timestamp:n,ancillaryData:i},proposer:o,disputer:c,proposedPrice:u,state:De.Disputed,disputeTx:t.transactionHash,disputeBlockNumber:t.blockNumber,disputeLogIndex:t.logIndex};break}case"Settle":{const s=t,{requester:r,identifier:a,timestamp:n,ancillaryData:i,proposer:o,disputer:c,price:u,payout:l}=s.args,d=Be(s.args);e.requests||(e.requests={}),e.requests[d]={...e.requests[d]||{requester:r,identifier:a,timestamp:n,ancillaryData:i},requester:r,proposer:o,disputer:c,price:u,payout:l,state:De.Settled,settleTx:t.transactionHash,settleBlockNumber:t.blockNumber,settleLogIndex:t.logIndex};break}}return e}function Oe(e,t={}){return e.reduce(Me,t)}!function(e){e[e.Invalid=0]="Invalid",e[e.Requested=1]="Requested",e[e.Proposed=2]="Proposed",e[e.Expired=3]="Expired",e[e.Disputed=4]="Disputed",e[e.Resolved=5]="Resolved",e[e.Settled=6]="Settled"}(De||(De={}));var Le={__proto__:null,registry:I,emp:N,erc20:j,multicall:z,multicall2:J,lspCreator:Y,lsp:ee,bridgeDepositBox:re,bridgePool:ce,etherchain:le,rateModelStore:pe,optimisticOracle:be,skinnyOptimisticOracle:Ae,optimisticOracleV2:{__proto__:null,connect:xe,contractInterface:Pe,get RequestState(){return De},requestId:Be,reduceEvents:Me,getEventState:Oe}};function Ne(e=new Map){return{get:async function(t){return e.get(t)},set:async function(t,s){e.set(t,s)},has:async function(t){return e.has(t)},delete:async function(t){e.delete(t)},entries:async function(){return Array.from(e.entries())},values:async function(){return Array.from(e.values())},keys:async function(){return Array.from(e.keys())},size:async function(){return e.size},clear:async function(){e.clear()}}}function Fe(){const e=[],t=new Map;function s(t,s=!0){return s?n.sortedIndex(e,t):n.sortedLastIndex(e,t)}function r(e){const s=t.get(e);if(C(s))return s;throw new Error("Missing data for index: "+e)}return{has:async e=>t.has(e),async set(s,r){if(t.has(s))t.set(s,r);else{const a=n.sortedIndex(e,s);e.splice(a,0,s),t.set(s,r)}},get:async e=>t.get(e),values:async()=>e.map(r),entries:async()=>e.map(e=>[e,r(e)]),keys:async()=>[...e],async clear(){t.clear(),e.length=0},size:async()=>e.length,async delete(s){t.has(s)&&function(s){const r=n.sortedIndex(e,s);e.splice(r,1),t.get(s),t.delete(s)}(s)},async between(t,a){const n=s(t),i=function(e,t=!1){return s(e,!t)}(a);return e.slice(n,i).map(r)},async slice(t,a){const n=s(t);return e.slice(n,n+a).map(r)}}}var Ue={__proto__:null,JsMap:Ne,SortedJsMap:Fe,GoogleDatastore:function(e,t,s=[]){function r(s){return t.key([e,s])}async function a(e){try{const[s]=await t.get(r(e));return s}catch(e){return}}return{get:a,set:async function(e,a){await t.save({key:r(e),data:a,excludeFromIndexes:s})},has:async function(e){return C(await a(e))},delete:async function(e){await t.delete(r(e))},entries:async function(){const[s]=await t.createQuery(e).run();return s.map(e=>[e[t.KEY].name,e])},values:async function(){const[s]=await t.createQuery(e).run();return s},keys:async function(){const[s]=await t.createQuery(e).select("__key__").run();return s.map(e=>e[t.KEY].name)},size:async function(){throw new Error("size not supported in google store")},clear:async function(){await c(t.createQuery(e).runStream()).map(e=>e[t.KEY]).batch(500).map(async e=>t.delete(e)).flatMap(c).collect().toPromise(Promise)},between:async function(s,a){const[n]=await t.createQuery(e).filter("__key__",">=",r(s)).filter("__key__","<",r(a)).run();return n},slice:async function(s,a){const[n]=await t.createQuery(e).filter("__key__",">=",r(s)).limit(a).run();return n}}}};function He(e,t){const{makeId:r,type:a}=e;async function n(e){return await t.set(e.id,{...e}),e}async function i(e){return s(await t.has(e),a+" does not exist"),await t.get(e)}async function o(e){return t.has(e)}return{...t,create:async function(e){const t=C(e.id)?e.id:r(e);return s(!await o(t),a+" exists: "+t),n({id:t,...e})},set:n,get:i,has:o,update:async function(e,t){return n({...await i(e),...t})},makeId:r,type:a}}function je(e){return e.number}function We(e){return e.address}function $e(e){return e.timestamp.toString().padStart(24,"0")}function ze(e){return e.address}var Ge={__proto__:null,blocks:{__proto__:null,Table:(e="Block",t=Ne())=>{const s=He({type:e,makeId:je},t);return{...s,prune:async function(e){const t=await s.values(),r=[];for(const n of t){var a;n.timestamp<e&&(await s.delete(null!=(a=n.id)?a:n.number),r.push(n))}return r}}},makeId:je},emps:{__proto__:null,Table:(e="Emp",t=Ne())=>{const s=He({type:e,makeId:We},t);return{...s,addSponsors:async function(e,t){const r=await s.get(e),a=new Set([...r.sponsors||[],...t]);return s.update(e,{sponsors:Array.from(a.values())})},setCreatedTimestamp:async function(e,t){return s.update(e,{createdTimestamp:t})}}},makeId:We},historicalPrices:{__proto__:null,Table:(e="Historical Price",t=Fe())=>{const s=He({type:e,makeId:$e},t);return{...s,betweenByTimestamp:function(e,t){return s.between($e({timestamp:e}),$e({timestamp:t}))},sliceByTimestamp:function(e,t){return s.slice($e({timestamp:e}),t)},hasByTimestamp:function(e){return s.has($e({timestamp:e}))},getByTimestamp:function(e){return s.get($e({timestamp:e}))}}},makeId:$e},erc20s:{__proto__:null,Table:(e="Token",t=Ne())=>{const s=He({type:e,makeId:ze},t);async function r(e){return await s.has(ze({address:e}))?s.get(ze({address:e})):s.create({address:e})}return{...s,getOrCreate:r,upsert:async function(e,t){return await r(e),s.update(e,t)}}},makeId:ze},base:He};const Ve=e=>r.BigNumber.from(e.toString()),Je=(e,t)=>r.ethers.utils.parseUnits(e.toString(),t),Ke=(e,t)=>Je(e,t).toString(),Qe=(e,t)=>r.ethers.utils.formatUnits(e.toString(),t);function Ye(e,t){const s=Ve(e),r=Ve(t);return s.lte(r)?s:r}function Ze(e,t){const s=Ve(e),r=Ve(t);return s.gte(r)?s:r}const Xe=Je("1");function et(e,t=1,s=18){const r=Je(t),a=Je(e).div(r);return A(18,s)(a)}const tt=(e,t)=>r.BigNumber.from(e).mul(t);function st(e,t,s=1,r=18){return et(tt(e,t),s,r)}function rt(e,t){return Xe.mul(e).div(t)}const at=(e,t,s,r)=>{const a=new u(r),n=new u(t),i=new u(e),o=new u(r).div(s),c=new u(1);return a.mul(n.div(i).pow(c.div(a.div(o))).sub(c)).toString()},nt=(e,t,s,r)=>new u(t).sub(e).div(e).mul(r).div(s).toString();var it={__proto__:null,toBN:Ve,toBNWei:Je,toWei:Ke,fromWei:Qe,min:Ye,max:Ze,fixedPointAdjustment:Xe,ethToToken:et,gasToEth:tt,calculateGasFees:st,percent:rt,calcContinuousCompoundInterest:(e,t,s,r)=>{const a=new u(r).div(s);return new u(t).div(e).ln().div(a).toString()},calcPeriodicCompoundInterest:at,calcApr:nt};function ot(e,t){const s=Ye(t,e.UBar).mul(e.R1).div(e.UBar),r=Ze(Ve("0"),Ve(t).sub(e.UBar)).mul(e.R2).div(Je("1").sub(e.UBar));return Ve(e.R0).add(s).add(r)}function ct(e,t){const s=Ye(t,e.UBar),r=s.mul(e.R0).div(Xe),a=Je("0.5").mul(ot(e,s).sub(e.R0)).mul(s).div(Xe).div(Xe),n=Ze(Ve("0"),t.sub(e.UBar)),i=n.mul(Ve(e.R0).add(e.R1)).div(Xe),o=Je("0.5").mul(ot(e,t).sub(Ve(e.R0).add(e.R1))).mul(n).div(Xe).div(Xe);return r.add(a).add(i).add(o)}function ut(e,t,s){if(t.eq(s))throw new Error("Deposit cant have zero size");const r=ct(e,t),a=ct(e,s).sub(r),n=s.sub(t);return a.mul(Xe).div(n)}function lt(e,t,s){return function(e){const t=u.pow(new u("1").plus(Qe(e)),new u("1").dividedBy(new u("52"))).minus(new u("1"));return Ve(t.times(Xe.toString()).floor().toString())}(ut(e,Ve(t),Ve(s)))}var dt={__proto__:null,calculateInstantaneousRate:ot,calculateApyFromUtilization:ut,calculateRealizedLpFeePct:lt};const ht=["UBar","R0","R1","R2"],pt=r.ethers.constants.AddressZero,mt={ETH:pt,UMA:"0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828",WETH:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",USDC:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",RateModel:"0xd18fFeb5fdd1F2e122251eA7Bf357D8Af0B60B50"},gt=10;var ft={__proto__:null,SLOW_ETH_GAS:243177,SLOW_ERC_GAS:250939,SLOW_UMA_GAS:273955,FAST_ETH_GAS:273519,FAST_ERC_GAS:281242,FAST_UMA_GAS:305572,SPEED_UP_ETH_GAS:195288,SPEED_UP_ERC_GAS:203011,SPEED_UP_UMA_GAS:227341,DEFAULT_GAS_DISCOUNT:25,expectedRateModelKeys:ht,L2_STATE_COMMITMENT_DELAY_BLOCKS:25e3,AddressZero:pt,ADDRESSES:mt,SECONDS_PER_YEAR:31557600,DEFAULT_BLOCK_DELTA:gt};const vt=e=>{const t=JSON.parse(e);for(const e of ht)if(!Object.keys(t).includes(e))throw new Error(`Rate model does not contain all expected keys. Expected keys: [${ht}], actual keys: [${Object.keys(t)}]`);for(const e of Object.keys(t))if(!ht.includes(e))throw new Error(`Rate model contains unexpected keys. Expected keys: [${ht}], actual keys: [${Object.keys(t)}]`);return{UBar:t.UBar,R0:t.R0,R1:t.R1,R2:t.R2}};var yt={__proto__:null,RateModelDictionary:class{constructor(){this.rateModelDictionary={}}_throwIfNotInitialized(){if(0==Object.keys(this.rateModelDictionary).length)throw new Error("RateModelUtility method called before updating rate model dictionary!")}updateWithEvents(e){this.rateModelDictionary=(e=>{const t={};e.sort((e,t)=>e.blockNumber!==t.blockNumber?e.blockNumber-t.blockNumber:e.transactionIndex!==t.transactionIndex?e.transactionIndex-t.transactionIndex:e.logIndex-t.logIndex);for(const s of e){const e=r.ethers.utils.getAddress(s.l1Token);t[e]||(t[e]=[]),t[e].push({blockNumber:s.blockNumber,rateModel:s.rateModel})}return t})(e)}getRateModelForBlockNumber(e,t){this._throwIfNotInitialized();const s=r.ethers.utils.getAddress(e);if(!this.rateModelDictionary[s]||0===this.rateModelDictionary[s].length)throw new Error("No updated rate model events for L1 token: "+s);if(t){const e=this.rateModelDictionary[s][0].blockNumber;if(t<e)throw new Error(`Block number #${t} is before first UpdatedRateModel event block ${e}`);const r=this.rateModelDictionary[s].slice().reverse().find(e=>e.blockNumber<=t);if(!r)throw new Error(`No updated rate model events before block #${t} for L1 token: ${s}`);return vt(null==r?void 0:r.rateModel)}return vt(this.rateModelDictionary[s].slice(-1)[0].rateModel)}getL1TokensFromRateModel(e){return this._throwIfNotInitialized(),Object.keys(this.rateModelDictionary).map(t=>{const s=r.ethers.utils.getAddress(t);return!e||this.rateModelDictionary[s].find(t=>t.blockNumber<=e)?r.ethers.utils.getAddress(t):null}).filter(C)}},parseAndReturnRateModelFromString:vt};class wt{constructor(e,t=[],r=1){this.requestBlock=e,this.blocks=t,this.chainId=r,s(e,"requestBlock function must be provided")}async getBlockForTimestamp(e){if(e=Number(e),s(null!=e,"timestamp must be provided"),0===this.blocks.length||this.blocks[this.blocks.length-1].timestamp<e){const t=await this.getLatestBlock();if(e>=t.timestamp)return t}if(this.blocks[0].timestamp>e){const t=this.blocks[0],r=1,a=Math.max(await B(t.timestamp-e,r,this.chainId),1);for(let r=1;;r++){const n=Math.max(0,t.number-r*a);if((await this.getBlock(n)).timestamp<=e)break;s(n>0,"timestamp is before block 0")}}const t=l(this.blocks,{timestamp:e},"timestamp");return this.findBlock(this.blocks[t-1],this.blocks[t],e)}async getLatestBlock(){var e;const t=await this.requestBlock("latest"),s=l(this.blocks,t,"number");return(null==(e=this.blocks[s])?void 0:e.number)!==t.number&&this.blocks.splice(s,0,t),this.blocks[s]}async getBlock(e){var t,s;let r=l(this.blocks,{number:e},"number");if((null==(t=this.blocks[r])?void 0:t.number)===e)return this.blocks[r];const a=await this.requestBlock(e);return r=l(this.blocks,{number:e},"number"),(null==(s=this.blocks[r])?void 0:s.number)===e?this.blocks[r]:(this.blocks.splice(r,0,a),a)}async findBlock(e,t,r){const[a,n]=[e,t];if(n.timestamp===r)return n;if(n.number===a.number+1)return a;s(n.number!==a.number,"startBlock cannot equal endBlock"),s(r<n.timestamp&&r>a.timestamp,"timestamp not in between start and end blocks");const i=a.number+Math.round((r-a.timestamp)/(n.timestamp-a.timestamp)*(n.number-a.number)),o=await this.getBlock(d(i,a.number+1,n.number-1));return o.timestamp<r?this.findBlock(o,n,r):this.findBlock(a,o,r)}}class qt{constructor(e="https://api.coingecko.com/api/v3"){this.host=e}async getHistoricContractPrices(e,t,r,a="usd"){s(e,"requires contract address"),s(a,"requires currency symbol"),s(t,"requires from timestamp"),s(r,"requires to timestamp"),t=Math.floor(t/1e3),r=Math.floor(r/1e3);const n=await this.call(`coins/ethereum/contract/${e.toLowerCase()}/market_chart/range/?vs_currency=${a}&from=${t}&to=${r}`);if(n.prices)return n.prices;throw new Error("Something went wrong fetching coingecko prices!")}async getContractDetails(e,t="ethereum"){return this.call(`coins/${t}/contract/${e.toLowerCase()}`)}async getCurrentPriceByContract(e,t="usd",r="ethereum"){const a=await this.getContractDetails(e,r),i=n.get(a,["market_data","current_price",t],null);return s(null!==i,"No current price available for: "+e),[a.last_updated,i]}async getContractPrices(e,t="usd",r="ethereum"){const a=Array.from(new Set(e.filter(e=>e).values()));s(a.length>0,"Must supply at least 1 contract address");const n=Object.fromEntries(a.map(e=>[e.toLowerCase(),e])),i=await this.call(`simple/token_price/${r}?contract_addresses=${a.join("%2C")}&vs_currencies=${t}&include_last_updated_at=true`);return Object.entries(i).map(([e,s])=>({address:n[e],timestamp:s.last_updated_at,price:s[t]}))}async getPlatforms(){return this.call("asset_platforms")}async call(e){try{const{host:t}=this,s=`${t}/${e}`;return(await i(s)).data}catch(e){const t=n.get(e,"response.data.error",n.get(e,"response.statusText","Unknown Coingecko Error"));throw new Error(t)}}}async function bt(e,t,s=mt.ETH){const{baseFeePerGas:r}=await e.getBlock("latest");let a;if(r){const e=(await(new ue).getGasPrice()).fastest,t=Ke(e,9);a=r.add(t)}else a=await e.getGasPrice();if(s===mt.ETH)return st(t,a);const n=new qt,[,i]=await n.getCurrentPriceByContract(s,"eth"),o=U(s,e);return st(t,a,i,await o.decimals())}function _t(){return{[mt.UMA]:273955,[mt.ETH]:243177,[mt.WETH]:243177,DEFAULT:250939}}function St(){return{[mt.UMA]:31617,[mt.ETH]:30342,[mt.WETH]:30342,DEFAULT:30303}}const Rt=e=>t=>C(e[t])?e[t]:e.DEFAULT,kt=Rt(St()),It=Rt(_t());async function Ct(e,t,r=mt.ETH,a=25){s(a>=0&&a<=100,"discountPercent must be between 0 and 100 percent");const n=It(r),i=Math.floor((1-a/100)*n),o=await bt(e,i,r),c=kt(r),u=Math.floor((1-a/100)*c),l=await bt(e,u,r);return{slowPct:rt(o,t).toString(),instantPct:rt(l,t).toString()}}var Et={__proto__:null,getGasFee:bt,getInstantGasByAddress:kt,getSlowGasByAddress:It,getDepositFees:Ct,getDepositFeesDetails:async function(e,t,a=mt.ETH,n,i=25){const{slowPct:o,instantPct:c}=await Ct(e,t,a,i),u=r.BigNumber.from(o).mul(t).div(Xe).toString(),l=r.BigNumber.from(c).mul(t).div(Xe).toString();let d=!1;return n&&(s(n>=0&&n<=100,"feeLimitPercent must be between 0 and 100 percent"),d=r.BigNumber.from(o).add(c).gt(Je(n/100))),{amountToRelay:t.toString(),discountPercent:i,feeLimitPercent:n,tokenAddress:a,instant:{pct:c,total:l},slow:{pct:o,total:u},isAmountTooLow:d}}};class At{constructor(e){this.requests=[...e.requests],this.multicallClient=e.multicallClient}push(e,t){this.requests.push({contractInstance:e,call:t})}encodeRequest(e){const{contractInstance:t,call:s}=e;return{target:t.address,callData:t.interface.encodeFunctionData(s.method,s.args)}}decodeResponse(e,t){const{contractInstance:s,call:r}=e;return s.interface.decodeFunctionResult(r.method,t)}add(e,t){const s=new At(this);return s.push(e,t),s}batch(e,t){const s=new At(this);return t.forEach(t=>{s.push(e,t)}),s}async read(e=this.requests){const t=e.map(e=>this.encodeRequest(e)),{returnData:s}=await this.multicallClient.callStatic.aggregate(t);return a(e,s).map(([e,t])=>{if(e&&t)return this.decodeResponse(e,t);throw new Error("Unable to decode contract response")})}}class Tt extends At{constructor(e){super(e)}async readWithErrors(e=this.requests){const t=e.map(e=>this.encodeRequest(e)),[,,s]=await this.multicallClient.callStatic.tryBlockAndAggregate(!1,t);return a(e,s).map(([e,t])=>{if(e&&t)return{success:t.success,result:t.success?this.decodeResponse(e,t.returnData):void 0};throw new Error("Unable to decode contract response")})}add(e,t){return new Tt(super.add(e,t))}batch(e,t){return new Tt(super.batch(e,t))}}class xt extends Tt{constructor(e,t){super({multicallClient:V(e,t),requests:[]})}}var Pt=(e,t,r=(()=>null))=>{s(t.provider,"signer requires a provider, use signer.connect(provider)");const{confirmations:a=3}=e,n=new Map,i=new Map,o=new Map;async function c(e){const a=n.get(e);s(a,"invalid request"),n.delete(e);try{const s=await t.sendTransaction(a);i.set(e,s.hash),r("submitted",e,s.hash)}catch(t){r("error",e,t)}}async function u(e){const n=i.get(e);s(n,"invalid submission"),s(t.provider,"signer requires a provider, use signer.connect(provider)");const c=await t.provider.getTransactionReceipt(n).catch(()=>{});null!=c&&(c.confirmations<a||(i.delete(e),o.set(e,c),r("mined",e,c)))}return{request:function(e){const t=e,r=JSON.stringify(Object.entries(t).map(([e,t])=>[e,(t||"").toString()]));return s(!n.has(r),"Transaction already in progress"),n.set(r,t),r},isMined:async function(e){return o.get(e)},update:async function(){for(const e of n.keys())await c(e);for(const e of i.keys())await u(e)}}};class Dt{constructor(e,t,s){this.batchRead=e,this.contract=t,this.address=s,this.l1Token=void 0}async read(e,t){void 0===this.l1Token&&(this.l1Token=await this.contract.l1Token());const s=await this.contract.callStatic.exchangeRateCurrent({blockTag:t||e-1});return{address:this.address,l1Token:this.l1Token,exchangeRatePrevious:s,...await this.batchRead([["exchangeRateCurrent"],["liquidityUtilizationCurrent"],["liquidReserves"],["pendingReserves"],["utilizedReserves"]])}}}class Bt{constructor(e,t=0,s={tokens:{},lpTokens:{},deposits:{},relays:{},instantRelays:{}}){this.contract=e,this.startBlock=t,this.state=s,this.seen=new Set,this.filterSeen=e=>{const t=this.hasEvent(e);return t||this.addEvent(e),!t},this.iface=new r.ethers.utils.Interface(ae.abi)}makeId(e){return[e.blockNumber,e.transactionIndex,e.logIndex].join("!")}hasEvent(e){return this.seen.has(this.makeId(e))}addEvent(e){return this.seen.add(this.makeId(e))}async read(e,t){if(e<=this.startBlock)return this.state;const s=(await Promise.all([...await this.contract.queryFilter(this.contract.filters.LiquidityAdded(void 0,void 0,t),this.startBlock,e),...await this.contract.queryFilter(this.contract.filters.LiquidityRemoved(void 0,void 0,t),this.startBlock,e)])).filter(this.filterSeen).sort((e,t)=>e.blockNumber!==t.blockNumber?e.blockNumber-t.blockNumber:e.transactionIndex!==t.transactionIndex?e.transactionIndex-t.transactionIndex:-1);return this.startBlock=e+1,this.state=oe(s,this.state),this.state}makeEventFromLog(e){const t=this.iface.parseLog(e);return{...e,...t,event:t.name,eventSignature:t.signature}}readTxReceipt(e){const t=e.logs.map(e=>{try{return this.makeEventFromLog(e)}catch(e){return}}).filter(C).filter(this.filterSeen);return this.state=oe(t,this.state),this.state}}class Mt{constructor(e){this.contract=e}async read(e){return{address:e,balanceOf:await this.contract.balanceOf(e)}}}function Ot(e,t){const s=e.mul(t).div(Xe),r=e.sub(s);return{recieve:s.toString(),remain:r.toString()}}function Lt(e,t,s){const a=r.BigNumber.from(e.exchangeRateCurrent).mul(s.balanceOf).div(Xe),n=r.BigNumber.from(t.tokens[s.address]||"0"),i=a.sub(n);return{address:s.address,poolAddress:e.address,lpTokens:s.balanceOf.toString(),positionValue:a.toString(),totalDeposited:n.toString(),feesEarned:i.toString()}}function Nt(e,t,a){const n=r.BigNumber.from(a).mul(e.exchangeRateCurrent).div(Xe);return s(r.BigNumber.from(n).gt("0"),"Must withdraw amount greater than 0"),s(r.BigNumber.from(e.liquidReserves).gte(n.add(e.pendingReserves)),"Utilization too high to remove that amount, try lowering withdraw amount"),s(r.BigNumber.from(a).lte(t.lpTokens),"You cannot withdraw more than you have"),{lpTokenAmount:a,l1TokensToReturn:n.toString()}}var Ft={__proto__:null,PoolEventState:Bt,calculateRemoval:Ot,previewRemoval:function(e,t){const s=Je(t);return{position:{...Ot(r.BigNumber.from(e.totalDeposited),s)},fees:{...Ot(r.BigNumber.from(e.feesEarned),s)},total:{...Ot(r.BigNumber.from(e.positionValue),s)}}},ReadPoolClient:class{constructor(e,t,s){this.address=e,this.provider=t,this.multicallAddress=s,this.multicall=new xt(s,t),this.contract=ne(e,t),this.batchRead=P(this.multicall)(this.contract),this.poolState=new Dt(this.batchRead,this.contract,e)}async read(e){return this.poolState.read(e)}},validateWithdraw:Nt,Client:class{constructor(e,t,s){this.config=e,this.deps=t,this.emit=s,this.poolContracts={},this.transactionManagers={},this.state={pools:{},users:{},transactions:{}},this.poolEvents={},this.intervalStarted=!1,this.multicall=new xt(e.multicall2Address,t.provider),this.batchRead=P(this.multicall),this.rateModelInstance=he(e.rateModelStoreAddress||mt.RateModel,t.provider)}getOrCreatePoolContract(e){if(this.poolContracts[e])return this.poolContracts[e];const t=ne(e,this.deps.provider);return this.poolContracts[e]=t,t}getOrCreatePoolEvents(e){return this.poolEvents[e]||(this.poolEvents[e]=new Bt(this.getOrCreatePoolContract(e))),this.poolEvents[e]}getOrCreateTransactionManager(e,t){if(this.transactionManagers[t])return this.transactionManagers[t];const s=Pt({confirmations:this.config.confirmations},e,(e,t,s)=>{if("submitted"===e&&(this.state.transactions[t].state=e,this.state.transactions[t].hash=s,this.emit(["transactions",t],{...this.state.transactions[t]})),"mined"===e){const r=s;this.state.transactions[t].state=e,this.state.transactions[t].receipt=r,this.emit(["transactions",t],{...this.state.transactions[t]});const a=this.state.transactions[t];this.updatePool(a.toAddress).then(()=>this.updateUserWithTransaction(a.fromAddress,a.toAddress,r)).catch(e=>{this.emit(["error"],e)})}"error"===e&&(this.state.transactions[t].state=e,this.state.transactions[t].error=s,this.emit(["transactions",t],{...this.state.transactions[t]}))});return this.transactionManagers[t]=s,s}async addEthLiquidity(e,t,s,r={}){const a=await e.getAddress(),n=this.getOrCreatePoolContract(t),i=this.getOrCreateTransactionManager(e,a),o=await n.populateTransaction.addLiquidity(s,{...r,value:s}),c=await i.request(o);return this.state.transactions[c]={id:c,state:"requested",toAddress:t,fromAddress:a,type:"Add Liquidity",description:"Adding ETH to pool",request:o},this.emit(["transactions",c],{...this.state.transactions[c]}),await i.update(),c}async addTokenLiquidity(e,t,s,r={}){const a=await e.getAddress(),n=this.getOrCreatePoolContract(t),i=this.getOrCreateTransactionManager(e,a),o=await n.populateTransaction.addLiquidity(s,r),c=await i.request(o);return this.state.transactions[c]={id:c,state:"requested",toAddress:t,fromAddress:a,type:"Add Liquidity",description:"Adding Tokens to pool",request:o},this.emit(["transactions",c],{...this.state.transactions[c]}),await i.update(),c}async validateWithdraw(e,t,s){this.hasPool(e)||await this.updatePool(e);const r=this.getPool(e);return this.hasUser(e,t)||await this.updateUser(e,t),Nt(r,this.getUser(e,t),s)}async removeTokenLiquidity(e,t,s,r={}){const a=await e.getAddress();await this.validateWithdraw(t,a,s);const n=this.getOrCreatePoolContract(t),i=this.getOrCreateTransactionManager(e,a),o=await n.populateTransaction.removeLiquidity(s,!1,r),c=await i.request(o);return this.state.transactions[c]={id:c,state:"requested",toAddress:t,fromAddress:a,type:"Remove Liquidity",description:"Withdrawing Tokens from pool",request:o},this.emit(["transactions",c],{...this.state.transactions[c]}),await i.update(),c}async removeEthliquidity(e,t,s,r={}){const a=await e.getAddress();await this.validateWithdraw(t,a,s);const n=this.getOrCreatePoolContract(t),i=this.getOrCreateTransactionManager(e,a),o=await n.populateTransaction.removeLiquidity(s,!0,r),c=await i.request(o);return this.state.transactions[c]={id:c,state:"requested",toAddress:t,fromAddress:a,type:"Remove Liquidity",description:"Withdrawing Eth from pool",request:o},this.emit(["transactions",c],{...this.state.transactions[c]}),await i.update(),c}getPool(e){return this.state.pools[e]}hasPool(e){return Boolean(this.state.pools[e])}getUser(e,t){return o(this.state,["users",t,e])}hasUser(e,t){return m(this.state,["users",t,e])}hasTx(e){return m(this.state,["transactions",e])}getTx(e){return o(this.state,["transactions",e])}async updateUserWithTransaction(e,t,s){const r=this.getOrCreatePoolContract(t);this.hasPool(t)||await this.updatePool(t);const a=this.getPool(t),n=new Mt(r),i=this.getOrCreatePoolEvents(t),o=await n.read(e),c=await i.readTxReceipt(s);p(this.state,["users",e,t],Lt(a,c,o)),this.emit(["users",e,t],this.state.users[e][t])}async updateUser(e,t){const s=this.getOrCreatePoolContract(t);this.hasPool(t)||await this.updatePool(t);const r=this.getPool(t),a=(await this.deps.provider.getBlock("latest")).number,n=new Mt(s),i=this.getOrCreatePoolEvents(t),o=await n.read(e),c=await i.read(a,e);p(this.state,["users",e,t],Lt(r,c,o)),this.emit(["users",e,t],this.state.users[e][t])}async updatePool(e){const{blockDelta:t=gt}=this.config,s=this.getOrCreatePoolContract(e),r=new Dt(this.batchRead(s),s,e),a=await this.deps.provider.getBlock("latest"),n=await this.deps.provider.getBlock(a.number-t),i=await r.read(a.number,n.number);let o=void 0;try{const e=await this.rateModelInstance.callStatic.l1TokenRateModels(i.l1Token);o=vt(e)}catch(e){this.emit(["error"],e)}this.state.pools[e]=function(e,t,s,r){const a=e.liquidReserves.add(e.utilizedReserves),n=t.timestamp-s.timestamp,i=t.number-s.number,o=e.exchangeRatePrevious.toString(),c=e.exchangeRateCurrent.toString(),u=at(o,c,n,31557600),l=nt(o,c,n,31557600);let d="";return r&&(d=Qe(ot(r,e.liquidityUtilizationCurrent).mul(e.liquidityUtilizationCurrent).div(Xe))),{address:e.address,totalPoolSize:a.toString(),l1Token:e.l1Token,liquidReserves:e.liquidReserves.toString(),pendingReserves:e.pendingReserves.toString(),exchangeRateCurrent:e.exchangeRateCurrent.toString(),exchangeRatePrevious:e.exchangeRatePrevious.toString(),estimatedApy:u,estimatedApr:l,blocksElapsed:i,secondsElapsed:n,liquidityUtilizationCurrent:e.liquidityUtilizationCurrent.toString(),projectedApr:d,utilizedReserves:e.utilizedReserves.toString()}}(i,a,n,o),this.emit(["pools",e],this.state.pools[e])}async updateTransactions(){for(const e of Object.values(this.transactionManagers))try{await e.update()}catch(e){this.emit(["error"],e)}}async startInterval(e=3e4){s(!this.intervalStarted,"Interval already started, try stopping first"),this.intervalStarted=!0,x(async()=>{s(this.intervalStarted,"Bridgepool Interval Stopped"),await this.updateTransactions()},e).catch(e=>{this.emit(["error"],e)})}async stopInterval(){this.intervalStarted=!1}}};const Ut={Proxy__OVM_L1StandardBridge:{1:"0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1",42:"0x22F24361D548e5FaAfb36d1437839f080363982B"}},Ht={ADDRESS_MANAGER_ADDRESS:{1:"0x8376ac6C3f73a25Dd994E0b0669ca7ee0C02F089",4:"0x93A96D6A5beb1F661cf052722A1424CDDA3e9418"}};var jt={__proto__:null,feeCalculator:dt,rateModel:yt,gasFeeCalculator:Et,utils:it,constants:ft,clients:{__proto__:null,bridgePool:Ft,optimismBridge:{__proto__:null,l1Contracts:Ut,OptimismBridgeClient:class{constructor(){this.L2_DEPOSIT_GAS_LIMIT=2e6}getL1BridgeAddress(e){const t=Ut.Proxy__OVM_L1StandardBridge[e];return s("string"==typeof t,"Chain not supported"),t}async depositERC20(e,s,r,a){const n=await e.getChainId(),i=this.getL1BridgeAddress(n),o=t.OptimismL1StandardBridgeEthers__factory.connect(i,e),c=t.ERC20Ethers__factory.connect(s,e);return o.depositERC20(c.address,r,a,this.L2_DEPOSIT_GAS_LIMIT,"0x")}async depositEth(e,s){const r=await e.getChainId(),a=this.getL1BridgeAddress(r);return t.OptimismL1StandardBridgeEthers__factory.connect(a,e).depositETH(this.L2_DEPOSIT_GAS_LIMIT,"0x",{value:s})}async waitRelayToL2(e,t,s){const a=new r.Contract(g.predeploys.L2CrossDomainMessenger,g.getContractInterface("L2CrossDomainMessenger"),s),n=new r.Contract(await a.l1CrossDomainMessenger(),g.getContractInterface("L1CrossDomainMessenger"),t),i=new f.Watcher({l1:{provider:t,messengerAddress:n.address},l2:{provider:s,messengerAddress:a.address}}),[o]=await i.getMessageHashesFromL1Tx(e.hash);return i.getL2TransactionReceipt(o,!0)}async checkAllowance(e,s){const r=await e.getChainId(),a=this.getL1BridgeAddress(r);return t.ERC20Ethers__factory.connect(s,e).allowance(await e.getAddress(),a)}async approve(e,s,r){const a=await e.getChainId(),n=this.getL1BridgeAddress(a);return t.ERC20Ethers__factory.connect(s,e).approve(n,r)}}},bobaBridge:{__proto__:null,l1Contracts:Ht,BobaBridgeClient:class{constructor(){this.L2_DEPOSIT_GAS_LIMIT=13e5}async getL1BridgeAddress(e,r){const a=Ht.ADDRESS_MANAGER_ADDRESS[e];s("string"==typeof a,"Chain not supported");const n=t.BobaAddressManagerEthers__factory.connect(a,r);return await n.getAddress("Proxy__OVM_L1StandardBridge")}async depositERC20(e,s,a,n){const i=await e.getChainId(),o=await this.getL1BridgeAddress(i,e),c=t.OptimismL1StandardBridgeEthers__factory.connect(o,e),u=t.ERC20Ethers__factory.connect(s,e);return c.depositERC20(u.address,a,n,this.L2_DEPOSIT_GAS_LIMIT,r.ethers.utils.formatBytes32String((new Date).getTime().toString()))}async depositEth(e,s){const a=await e.getChainId(),n=await this.getL1BridgeAddress(a,e);return t.OptimismL1StandardBridgeEthers__factory.connect(n,e).depositETH(this.L2_DEPOSIT_GAS_LIMIT,r.ethers.utils.formatBytes32String((new Date).getTime().toString()),{value:s})}async waitRelayToL2(e,r,a){const n=(await r.getNetwork()).chainId,i=Ht.ADDRESS_MANAGER_ADDRESS[n];s("string"==typeof i,"Chain not supported");const o=t.BobaAddressManagerEthers__factory.connect(i,r),c=await o.getAddress("Proxy__L1CrossDomainMessenger"),u=await o.getAddress("L2CrossDomainMessenger"),l=new f.Watcher({l1:{provider:r,messengerAddress:c},l2:{provider:a,messengerAddress:u}}),[d]=await l.getMessageHashesFromL1Tx(e.hash);return l.getL2TransactionReceipt(d,!0)}async checkAllowance(e,s){const r=await e.getChainId(),a=await this.getL1BridgeAddress(r,e);return t.ERC20Ethers__factory.connect(s,e).allowance(await e.getAddress(),a)}async approve(e,s,r){const a=await e.getChainId(),n=await this.getL1BridgeAddress(a,e);return t.ERC20Ethers__factory.connect(s,e).approve(n,r)}}}},LpFeeCalculator:class{constructor(e){this.provider=e,this.blockFinder=new wt(e.getBlock.bind(e))}async getLpFeePct(e,a,n,i){n=r.BigNumber.from(n),s(n.gt(0),"Amount must be greater than 0");const{blockFinder:o,provider:c}=this,u=ne(a,c),l=he(await t.getRateModelStoreAddress(await(await this.provider.getNetwork()).chainId),c),d=C(i)?await o.getBlockForTimestamp(i):await c.getBlock("latest");s(C(d),"Unable to find target block for timestamp: "+i||"latest");const h=d.number,[p,m,g]=await Promise.all([u.callStatic.liquidityUtilizationCurrent({blockTag:h}),u.callStatic.liquidityUtilizationPostRelay(n,{blockTag:h}),l.callStatic.l1TokenRateModels(e,{blockTag:h})]);return lt(vt(g),p,m)}},TransactionManager:Pt};class Wt extends Error{constructor(e=""){super(e),this.name="ExistenceError",Object.setPrototypeOf(this,Wt.prototype)}}function $t(e,t=""){if(!C(e))throw new Wt(t)}function zt(e){try{return e()}catch(e){if(e instanceof Wt)return;throw e}}async function Gt(e){try{return await e()}catch(e){if(e instanceof Wt)return;throw e}}var Vt,Jt,Kt={__proto__:null,ExistenceError:Wt,assertExists:$t,ignoreExistenceError:zt,ignoreExistenceErrorAsync:Gt};!function(e){e.Optimistic="Optimistic",e.Skinny="Skinny",e.OptimisticV2="OptimisticV2"}(Vt||(Vt={})),function(e){e.MissingRequest="MissingRequest",e.MissingUser="MissingUser",e.WrongChain="WrongChain",e.CanPropose="CanPropose",e.CanDispute="CanDispute",e.CanSettle="CanSettle",e.InDvmVote="InDvmVote",e.RequestSettled="RequestSettled",e.InsufficientBalance="InsufficientBalance",e.InsufficientApproval="InsufficientApproval",e.ChainChangeInProgress="ChainChangeInProgress",e.ProposalTxInProgress="ProposalTxInProgress",e.ApprovalTxInProgress="ApprovalTxInProgress",e.DisputeTxInProgress="DisputeTxInProgress"}(Jt||(Jt={}));var Qt,Yt={__proto__:null,get OracleType(){return Vt},get Flag(){return Jt},get RequestState(){return ve}};!function(e){e.setUser="setUser",e.setActiveRequest="setActiveRequest",e.approve="approve",e.clearUser="clearUser",e.disputePrice="disputePrice",e.proposePrice="proposePrice",e.switchOrAddChain="switchOrAddChain",e.pollActiveRequest="pollActiveRequest",e.pollActiveUser="pollActiveUser",e.fetchPastEvents="fetchPastEvents",e.pollNewEvents="pollNewEvents",e.setActiveRequestByTransaction="setActiveRequestByTransaction",e.settle="settle",e.updateActiveRequest="updateActiveRequest",e.fetchEventBased="fetchEventBased"}(Qt||(Qt={}));var Zt={__proto__:null,get ContextType(){return Qt}};const Xt=r.ethers.utils.getAddress,es=r.ethers.utils.hexValue;function ts(){return{[Jt.MissingRequest]:!1,[Jt.MissingUser]:!1,[Jt.WrongChain]:!1,[Jt.CanPropose]:!1,[Jt.CanDispute]:!1,[Jt.CanSettle]:!1,[Jt.InDvmVote]:!1,[Jt.RequestSettled]:!1,[Jt.InsufficientBalance]:!1,[Jt.InsufficientApproval]:!1,[Jt.ProposalTxInProgress]:!1,[Jt.ApprovalTxInProgress]:!1,[Jt.DisputeTxInProgress]:!1,[Jt.ChainChangeInProgress]:!1}}function ss(e){switch(e.toString()){case"1":case"4":case"5":case"42":return Xt("0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696");default:throw new Error("No address found for deployment Multicall2 on chainId "+e)}}const rs=({getMulticall2Address:e})=>(t,s)=>{let r=s.multicall2Address;try{r=r||e(t)}catch(e){}const a=s.checkTxIntervalSec||5;return{...s,chainId:t,multicall2Address:r,checkTxIntervalSec:a}},as=e=>(t,s)=>Object.entries(t.chains).reduce((t,[s,r])=>(t.chains[Number(s)]=rs(e)(Number(s),r),t),{...t,chains:{},oracleType:s});class ns{constructor(e){this.provider=e}async getReceipt(e){return this.provider.getTransactionReceipt(e)}async isConfirmed(e,t=1){try{const s=await this.getReceipt(e);if(s.confirmations>=t)return s}catch(e){}return!1}}function is(e){const{...t}=e;return t}function os(e){const{startBlock:t,endBlock:r,multiplier:a=2}=e;if(e.maxRange&&e.maxRange>0){const n=r-t;s(n>0,"End block must be higher than start block");const i=Math.min(e.maxRange,n);return{done:!1,startBlock:t,endBlock:r,maxRange:e.maxRange,currentRange:i,currentStart:r-i,currentEnd:r,multiplier:a}}{const e=r-t;return s(e>0,"End block must be higher than start block"),{done:!1,startBlock:t,endBlock:r,maxRange:e,currentRange:e,currentStart:t,currentEnd:r,multiplier:a}}}function cs(e){const{startBlock:t,currentStart:s,maxRange:r,currentRange:a,multiplier:n=2}=e,i=s<=t,o=Math.min(Math.ceil(a*n),r),c=s,u=Math.max(c-o,t);return{...e,currentStart:u,currentEnd:c,currentRange:o,done:i}}function us(e){const{startBlock:t,currentEnd:r,currentRange:a,multiplier:n=2}=e,i=Math.floor(a/n);s(i>0,"Range must be above 0");const o=r,c=Math.max(o-i,t);return{...e,currentStart:c,currentEnd:o,currentRange:i}}function ls(e){var t;return[e.blockNumber.toString().padStart(16,"0"),e.transactionIndex.toString().padStart(16,"0"),null==(t=e.logIndex)?void 0:t.toString().padStart(16,"0")].join("~")}function ds(e,t,s){const r=v(e,t,s);return e.splice(r,0,t),e}function hs(e,t,s){const r=s(t);return void 0===e.find(e=>s(e)===r)}var ps={__proto__:null,getAddress:Xt,hexValue:es,initFlags:ts,nowS:(e=Date.now())=>Math.floor(e/1e3),getFlags:function(e){const t=new Cs(e),s=ts(),r=zt(t.signer);s[Jt.MissingUser]=!r;const a=zt(t.inputRequest);s[Jt.MissingRequest]=!a;const n=zt(t.userChainId),i=zt(t.requestChainId);s[Jt.WrongChain]=!(!n||!i)&&n!==i;const o=zt(t.request);if(s[Jt.CanPropose]=(null==o?void 0:o.state)===ve.Requested,s[Jt.CanDispute]=(null==o?void 0:o.state)===ve.Proposed,s[Jt.CanSettle]=(null==o?void 0:o.state)===ve.Resolved||(null==o?void 0:o.state)===ve.Expired,s[Jt.InDvmVote]=(null==o?void 0:o.state)===ve.Disputed,s[Jt.RequestSettled]=(null==o?void 0:o.state)===ve.Settled,o&&o.bond&&o.finalFee){const e=o.bond.add(o.finalFee),r=zt(t.userCollateralBalance),a=zt(t.userCollateralAllowance);s[Jt.InsufficientBalance]=!!r&&r.lt(e),s[Jt.InsufficientApproval]=!!a&&a.lt(e)}const c=zt(t.userAddress),u=zt(()=>t.filterCommands({done:!1,user:c}));return c&&u&&u.forEach(e=>{s[Jt.ProposalTxInProgress]||e.type!==Qt.proposePrice||(s[Jt.ProposalTxInProgress]=!0),s[Jt.DisputeTxInProgress]||e.type!==Qt.disputePrice||(s[Jt.DisputeTxInProgress]=!0),s[Jt.ApprovalTxInProgress]||e.type!==Qt.approve||(s[Jt.ApprovalTxInProgress]=!0),s[Jt.ChainChangeInProgress]||e.type!==Qt.switchOrAddChain||(s[Jt.ChainChangeInProgress]=!0)}),s},getMulticall2Address:ss,DefaultChainConfig:rs,DefaultConfig:as,TransactionConfirmer:ns,chainConfigToChainMetadata:is,rangeStart:os,rangeSuccessDescending:cs,rangeFailureDescending:us,eventKey:ls,insertOrderedAscending:ds,isUnique:hs,isSupportedOracleType:function(e){return e in Vt},requestId:ye};const ms=[["symbol"],["name"],["decimals"],["totalSupply"]];class gs{constructor(e,t){this.provider=e,this.address=t,this.contract=U(t,e)}async approve(e,t,s){return U(this.address,e).approve(t,s)}async getProps(){const{contract:e}=this;return{address:this.address,symbol:await e.callStatic.symbol(),name:await e.callStatic.name(),decimals:await e.callStatic.decimals(),totalSupply:await e.callStatic.totalSupply()}}}class fs extends gs{constructor(e,t,s){super(e,t),this.multicall2=s,this.batchRead=P(s)(this.contract)}async getProps(){return{...await this.batchRead(ms),address:this.address}}}function vs(e,t,s){return s?new fs(e,t,s):new gs(e,t)}var ys={__proto__:null,Erc20:gs,Erc20Multicall:fs,factory:vs};class ws{constructor(e){this.state=e}set(e){e.chainId&&this.chainId(e.chainId),e.address&&this.address(e.address),e.signer&&this.signer(e.signer),e.provider&&this.provider(e.provider)}clear(){delete this.state.chainId,delete this.state.address,delete this.state.signer,delete this.state.provider}chainId(e){this.state.chainId=e}address(e){this.state.address=e}signer(e){this.state.signer=e}provider(e){this.state.provider=e}}class qs{constructor(e){this.state=e}set(e,t){this.state[e]=t}}class bs{constructor(e){this.state=e}props(e){this.state.props=e}balance(e,t){this.state.balances||(this.state.balances={}),new qs(this.state.balances).set(e,t)}allowance(e,t,s){this.state.allowances||(this.state.allowances={}),this.state.allowances[t]||(this.state.allowances[t]={}),new qs(this.state.allowances[t]).set(e,s)}}class _s{constructor(e){this.state=e}address(e){this.state.address=e}request(e){const t=ye(e);this.state.requests||(this.state.requests={}),this.state.requests[t]={...this.state.requests[t],...e}}defaultLiveness(e){this.state.defaultLiveness=e}}class Ss{constructor(e){this.state=e}erc20s(e){var t,s;return null!=(t=this.state)&&t.erc20s||(this.state.erc20s={}),null!=(s=this.state.erc20s)&&s[e]||(this.state.erc20s[e]={}),new bs(this.state.erc20s[e])}optimisticOracle(){var e;return null!=(e=this.state)&&e.optimisticOracle||(this.state.optimisticOracle={}),new _s(this.state.optimisticOracle)}currentTime(e){this.state.currentTime=e}}class Rs{constructor(e){this.state=e}request(e){this.state.request=e}user(){return this.state.user||(this.state.user={}),new ws(this.state.user)}}class ks{constructor(e){this.state=e}provider(e){this.state.provider=e}erc20s(e){var t,s,r;null!=(t=this.state)&&t.provider&&(null!=(s=this.state)&&s.erc20s||(this.state.erc20s={}),null!=(r=this.state)&&r.erc20s[e]||(this.state.erc20s[e]=vs(this.state.provider,e,this.state.multicall2)))}optimisticOracle(e){this.state.optimisticOracle||(this.state.optimisticOracle=e)}multicall2(e){e&&(this.state.multicall2||this.state.provider&&(this.state.multicall2=new xt(e,this.state.provider)))}}class Is{constructor(e){this.state=e}chains(e){var t,s,r;return null!=(t=this.state)&&t.chains||(this.state.chains={}),null!=(s=this.state)&&null!=(r=s.chains)&&r[e]||(this.state.chains[e]={}),new Ss(this.state.chains[e])}inputs(){return this.state.inputs||(this.state.inputs={}),new Rs(this.state.inputs)}config(e){this.state.config=e}services(e){return this.state.services||(this.state.services={}),this.state.services.chains||(this.state.services.chains={}),this.state.services.chains[e]||(this.state.services.chains[e]={}),new ks(this.state.services.chains[e])}error(e){this.state.error=e}command(e){this.state.commands||(this.state.commands={}),this.state.commands[e.id]=e}sortedRequestsService(e){var t,s;null!=(t=this.state)&&null!=(s=t.services)&&s.sortedRequests||(this.state.services={sortedRequests:e})}descendingRequests(e){this.state.descendingRequests=e}}class Cs{constructor(e){this.state=e,this.chainConfig=e=>{var t,s,r;const a=e||this.requestChainId(),n=null==(t=this.state)||null==(s=t.config)||null==(r=s.chains)?void 0:r[a];return $t(n,"No config set for chain: "+a),n},this.oracleType=()=>{var e,t;const s=null==(e=this.state)||null==(t=e.config)?void 0:t.oracleType;return $t(s,"No oracle name set on config"),s},this.requestChainId=()=>{var e,t,s;const r=null==(e=this.state)||null==(t=e.inputs)||null==(s=t.request)?void 0:s.chainId;return $t(r,"ChainId is not set on request"),r},this.user=()=>{var e,t;const s=null==(e=this.state)||null==(t=e.inputs)?void 0:t.user;return $t(s,"user not set"),s},this.userChainId=()=>{var e,t,s;const r=null==(e=this.state)||null==(t=e.inputs)||null==(s=t.user)?void 0:s.chainId;return $t(r,"ChainId is not set"),r},this.requestChain=e=>{var t,s;const r=e||this.requestChainId(),a=null==(t=this.state)||null==(s=t.chains)?void 0:s[r];return $t(a,"Chain not set"),a},this.userAddress=()=>{var e,t,s;const r=null==(e=this.state)||null==(t=e.inputs)||null==(s=t.user)?void 0:s.address;return $t(r,"User address is not set"),r},this.oracleAddress=e=>{var t;const s=this.requestChain(e),r=null==s||null==(t=s.optimisticOracle)?void 0:t.address;return $t(r,"Optimistic oracle address not set"),r},this.signer=()=>{var e,t,s;const r=null==(e=this.state)||null==(t=e.inputs)||null==(s=t.user)?void 0:s.signer;return $t(r,"Signer is not set"),r},this.inputRequest=()=>{var e,t;const s=null==(e=this.state)||null==(t=e.inputs)?void 0:t.request;return $t(s,"Input request is not set"),s},this.defaultLiveness=()=>{var e;const t=this.requestChain(),s=null==t||null==(e=t.optimisticOracle)?void 0:e.defaultLiveness;return $t(s,"Optimistic oracle defaultLiveness set"),s},this.request=()=>{var e,t;const s=this.requestChain(),r=ye(this.inputRequest()),a=null==s||null==(e=s.optimisticOracle)||null==(t=e.requests)?void 0:t[r];return $t(a,"Request has not been fetched"),a},this.collateralProps=()=>{var e,t;const s=this.request();$t(s.currency,"Request currency not set");const r=null==(e=this.requestChain().erc20s)||null==(t=e[s.currency])?void 0:t.props;return $t(r,"Props not set on collateral token"),r},this.userCollateralBalance=()=>{var e,t,s;const r=this.request();$t(r.currency,"Request currency not set");const a=this.requestChain(),n=this.userAddress(),i=null==a||null==(e=a.erc20s)||null==(t=e[r.currency])||null==(s=t.balances)?void 0:s[n];return $t(i,"Balance not set on collateral token for user"),i},this.userCollateralAllowance=()=>{var e,t,s,r;const a=this.request();$t(a.currency,"Request currency not set");const n=this.requestChain(),i=this.userAddress(),o=this.oracleAddress(),c=null==n||null==(e=n.erc20s)||null==(t=e[a.currency])||null==(s=t.allowances)||null==(r=s[o])?void 0:r[i];return $t(c,"Allowance not set on user on collateral token for oracle"),c},this.oracleService=e=>{var t,s,r,a;const n=e||this.requestChainId(),i=null==(t=this.state)||null==(s=t.services)||null==(r=s.chains)||null==(a=r[n])?void 0:a.optimisticOracle;return $t(i,"Optimistic Oracle Not found on chain "+n),i},this.collateralService=()=>{var e,t,s,r,a;const n=this.requestChainId(),i=this.request();$t(i.currency,"Request currency not set");const o=null==(e=this.state)||null==(t=e.services)||null==(s=t.chains)||null==(r=s[n])||null==(a=r.erc20s)?void 0:a[i.currency];return $t(o,"Token not supported on chain "+n),o},this.command=e=>{var t,s;const r=null==(t=this.state)||null==(s=t.commands)?void 0:s[e];return $t(r,"Unable to find command "+e),r},this.tokenService=(e,t)=>{var s,r,a,n,i;const o=null==(s=this.state)||null==(r=s.services)||null==(a=r.chains)||null==(n=a[e])||null==(i=n.erc20s)?void 0:i[t];return $t(o,"Token service not found: "+[e,t].join(".")),o},this.provider=e=>{var t,s,r,a;const n=null==(t=this.state)||null==(s=t.services)||null==(r=s.chains)||null==(a=r[e])?void 0:a.provider;return $t(n,"Provider not found on chainid: "+e),n},this.transactionService=e=>{const t=this.provider(e);return new ns(t)},this.listCommands=()=>{var e;return Object.values((null==(e=this.state)?void 0:e.commands)||[])},this.filterCommands=e=>y(this.listCommands(),e),this.chain=e=>{var t,s;const r=e||this.requestChainId(),a=null==(t=this.state)||null==(s=t.chains)?void 0:s[r];return $t(a,"No chain for chainId: "+r),a},this.currentTime=e=>{const t=e||this.requestChainId(),s=this.chain(t),r=null==s?void 0:s.currentTime;return $t(r,"Current time not available on chain: "+t),r},this.sortedRequestsService=()=>{var e,t;const s=null==(e=this.state)||null==(t=e.services)?void 0:t.sortedRequests;return $t(s,"Sorted request service not set"),s},this.listChains=()=>{var e;return Object.keys((null==(e=this.state)?void 0:e.chains)||{}).map(Number)},this.descendingRequests=()=>this.state.descendingRequests||[],this.filterRequests=e=>y(this.descendingRequests(),e)}}class Es{constructor(e){this.state=e,this.inputRequest=()=>C(zt(this.read.inputRequest)),this.sortedRequestsService=()=>C(zt(this.read.sortedRequestsService)),this.requestChainId=()=>C(zt(this.read.requestChainId)),this.userAddress=()=>C(zt(this.read.userAddress)),this.request=()=>C(zt(this.read.request)),this.collateralProps=()=>C(zt(this.read.collateralProps)),this.defaultLiveness=()=>C(zt(this.read.defaultLiveness)),this.currentTime=()=>C(zt(this.read.currentTime)),this.read=new Cs(e)}}class As{constructor(e,t){this.emit=e,this.state=t}write(e){const t=this.state;this.state=w(this.state,e),this.emit(this.state,t)}async writeAsync(e){const t=this.state;this.state=await w(this.state,e),this.emit(this.state,t)}read(){return this.state}}class Ts{constructor(e=(()=>{}),t={}){this.emit=e,this.state=t,this.write=e=>{this.store.write(t=>e(new Is(t),t))},this.read=()=>new Cs(this.store.read()),this.get=()=>this.store.read(),this.has=()=>new Es(this.store.read()),this.store=new As(e,t)}}var xs={__proto__:null,Write:Is,Store:As,Read:Cs,Has:Es,default:Ts};class Ps{constructor(e){this.store=e,this.all=async()=>{await this.oracle(),await this.request(),await this.collateralProps(),await this.userCollateralBalance(),await this.oracleAllowance()},this.request=async e=>{const t=e||this.read().inputRequest(),s=t.chainId,r=this.read().oracleService(s),a=await r.fetchRequest(t);this.write(e=>{a.currency&&e.services(s).erc20s(a.currency),e.chains(s).optimisticOracle().request({...a})}),this.sortedRequests(s)},this.oracle=async()=>{const e=this.read().requestChainId(),t=this.read().oracleService(),{defaultLiveness:s}=await t.getProps();this.write(t=>t.chains(e).optimisticOracle().defaultLiveness(s))},this.userCollateralBalance=async()=>{const e=this.read().requestChainId(),t=this.read().userAddress(),s=this.read().collateralService(),r=await s.contract.balanceOf(t);this.write(a=>a.chains(e).erc20s(s.address).balance(t,r))},this.collateralProps=async()=>{const e=this.read().requestChainId(),t=this.read().collateralService(),s=await t.getProps();this.write(r=>r.chains(e).erc20s(t.address).props(s))},this.oracleAllowance=async()=>{const e=this.read().requestChainId(),t=this.read().userAddress(),s=this.read().oracleAddress(),r=this.read().collateralService(),a=await r.contract.allowance(t,s);this.write(n=>n.chains(e).erc20s(r.address).allowance(t,s,a))},this.balance=async(e,t,s)=>{const r=this.read().tokenService(e,t),a=await r.contract.balanceOf(s);this.write(r=>r.chains(e).erc20s(t).balance(s,a))},this.allowance=async(e,t,s,r)=>{const a=this.read().tokenService(e,t),n=await a.contract.allowance(s,r);this.write(a=>a.chains(e).erc20s(t).allowance(s,r,n))},this.isConfirmed=async(e,t,s)=>this.read().transactionService(e).isConfirmed(t,s),this.oracleEvents=async(e,t=0,s)=>{const r=this.read().provider(e),a=this.read().oracleService(e);s=s||await r.getBlockNumber(),await a.update(t,s)},this.sortedRequests=e=>{const t=this.read().sortedRequestsService(),s=this.read().oracleService(e).listRequests(),r=this.read().oracleType();Object.values(s).forEach(e=>{t.setByRequest({...e,oracleType:r})});const a=t.descending();this.write(e=>{e.descendingRequests(a)})},this.activeRequestFromEvents=e=>{const t=e||this.read().inputRequest(),s=t.chainId,r=this.read().oracleService().getRequest(t),{requestTx:a,proposeTx:n,disputeTx:i,settleTx:o,requestBlockNumber:c,proposeBlockNumber:u,disputeBlockNumber:l,settleBlockNumber:d}=r,h={...t,requestTx:a,proposeTx:n,disputeTx:i,settleTx:o,requestBlockNumber:c,proposeBlockNumber:u,disputeBlockNumber:l,settleBlockNumber:d};this.write(e=>{e.chains(s).optimisticOracle().request(h)})},this.read=e.read,this.write=e.write}}function Ds(){}function Bs(e){const t=new Ps(e);return{start:async s=>(e.write(e=>e.inputs().user().set(s)),await Gt(t.userCollateralBalance),await Gt(t.oracleAllowance),"done")}}var Ms={__proto__:null,initMemory:Ds,Handlers:Bs};function Os(){}function Ls(e){return{start:async()=>(e.write(e=>{e.inputs().user().clear()}),"done")}}var Ns={__proto__:null,initMemory:Os,Handlers:Ls};function Fs(){}function Us(e){return{start:async t=>(e.write(e=>e.inputs().request(t)),"done")}}var Hs={__proto__:null,initMemory:Fs,Handlers:Us};function js(){return{}}function Ws(e){const t=new Ps(e);return{async start(t,r){const{chainId:a,currency:n,spender:i,amount:o,account:c,signer:u}=t;s(a===await u.getChainId(),"Signer on wrong chainid"),s(c===await u.getAddress(),"Signer on wrong account"),e.write(e=>e.services(a).erc20s(n));const l=e.read().tokenService(a,n),d=await l.approve(u,i,o);return r.hash=d.hash,"confirm"},async confirm(e,r,a){const{chainId:n,confirmations:i,checkTxIntervalSec:o}=e,{hash:c}=r;return s(c,"requires hash"),await t.isConfirmed(n,c,i)?"update":a.sleep(1e3*o)},async update(e){const{chainId:s,currency:r,spender:a,account:n}=e;return await t.balance(s,r,n),await t.allowance(s,r,n,a),"done"}}}var $s={__proto__:null,initMemory:js,Handlers:Ws};function zs(){return{}}function Gs(e){const t=new Ps(e);return{async start(t,r){const{requester:a,identifier:n,timestamp:i,ancillaryData:o,chainId:c,signer:u}=t;s(c===await u.getChainId(),"Signer on wrong chainid");const l=e.read().oracleService(c),d=await l.disputePrice(u,{requester:a,identifier:n,timestamp:i,ancillaryData:o});return r.hash=d.hash,"confirm"},async confirm(e,r,a){const{chainId:n,confirmations:i,checkTxIntervalSec:o}=e,{hash:c}=r;s(c,"requires hash");const u=await t.isConfirmed(n,c,i);return u?(r.receipt=u,"update"):a.sleep(1e3*o)},async update(s,r){const{chainId:a,currency:n,account:i}=s,{receipt:o}=r,c=e.read().oracleService(a);return await t.balance(a,n,i),o&&c.updateFromTransactionReceipt(o),e.write(e=>{e.chains(a).optimisticOracle().request(c.getRequest(s))}),t.sortedRequests(a),"done"}}}var Vs={__proto__:null,initMemory:zs,Handlers:Gs};function Js(){return{}}function Ks(e){const t=new Ps(e);return{async start(t,r){const{requester:a,identifier:n,timestamp:i,ancillaryData:o,chainId:c,signer:u,proposedPrice:l}=t;s(c===await u.getChainId(),"Signer on wrong chainid");const d=e.read().oracleService(c),h=await d.proposePrice(u,{requester:a,identifier:n,timestamp:i,ancillaryData:o},l);return r.hash=h.hash,"confirm"},async confirm(e,r,a){const{chainId:n,confirmations:i,checkTxIntervalSec:o}=e,{hash:c}=r;s(c,"requires hash");const u=await t.isConfirmed(n,c,i);return u?(r.receipt=u,"update"):a.sleep(1e3*o)},async update(s,r){const{chainId:a,currency:n,account:i}=s,{receipt:o}=r,c=e.read().oracleService(a);return await t.balance(a,n,i),o&&c.updateFromTransactionReceipt(o),e.write(e=>{e.chains(a).optimisticOracle().request(c.getRequest(s))}),await t.sortedRequests(a),"done"}}}var Qs={__proto__:null,initMemory:Js,Handlers:Ks};function Ys(){}function Zs(e){return{async start(e){const{provider:t,chainId:s}=e;try{return await t.send("wallet_switchEthereumChain",[{chainId:es(s)}]),"done"}catch(e){const t=e;if(-32603===t.code||4902===t.code)return"addAndSwitch";throw t}},async addAndSwitch(t){const{chainId:s,provider:r}=t,a=is(e.read().chainConfig(s));return await r.send("wallet_addEthereumChain",[{...a,chainId:es(s)}]),await r.send("wallet_switchEthereumChain",[{chainId:es(s)}]),"done"}}}var Xs={__proto__:null,initMemory:Ys,Handlers:Zs};function er(){return{iterations:0}}function tr(e){const t=new Ps(e);return{async start(s,r,a){const n=await Gt(e.read().request);n&&n.state!==ve.Invalid&&n.state!==ve.Settled&&(await t.request(),r.iterations++);const{checkTxIntervalSec:i=30}=await Gt(e.read().chainConfig)||{};return a.sleep(1e3*i)}}}var sr={__proto__:null,initMemory:er,Handlers:tr};function rr(){return{iterations:0}}function ar(e){const t=new Ps(e);return{async start(s,r,a){var n;const i=e.read().provider(s.chainId),{chainId:o,startBlock:c=0,endBlock:u=await i.getBlockNumber(),maxRange:l}=s;r.error=void 0;const d=r.state||os({startBlock:c,endBlock:u,maxRange:l}),{currentStart:h,currentEnd:p}=d;try{await t.oracleEvents(o,h,p),await t.sortedRequests(o),await Gt(t.activeRequestFromEvents),r.state=cs({...d,multiplier:1})}catch(e){r.error=e,r.state=us(d)}return r.iterations++,null!=r&&null!=(n=r.state)&&n.done?"done":a.sleep(100)}}}var nr={__proto__:null,initMemory:rr,Handlers:ar};function ir(){return{iterations:0}}function or(e){const t=new Ps(e);return{async start(s,r,a){const{chainId:n,startBlock:i,pollRateSec:o=50}=s,c=e.read().provider(n),u=await c.getBlockNumber(),l=r.lastBlock||i||u;r.error=void 0;try{u!==l?(await t.oracleEvents(n,l,u),await Gt(t.activeRequestFromEvents),r.lastBlock=u,r.iterations++):r.lastBlock=r.lastBlock||l}catch(e){r.error=e}return await t.sortedRequests(n),a.sleep(1e3*o)}}}var cr={__proto__:null,initMemory:ir,Handlers:or};function ur(){}function lr(e){return{async start(t){const{chainId:r,transactionHash:a,eventIndex:n=0}=t,i=e.read().descendingRequests().filter(e=>{var t,s,i,o,c,u,l,d;return e.chainId.toString()===r.toString()&&!![null==e||null==(t=e.requestTx)?void 0:t.toLowerCase(),null==e||null==(s=e.proposeTx)?void 0:s.toLowerCase(),null==e||null==(i=e.disputeTx)?void 0:i.toLowerCase(),null==e||null==(o=e.settleTx)?void 0:o.toLowerCase()].includes(a.toLowerCase())&&[null==e||null==(c=e.requestLogIndex)?void 0:c.toString(),null==e||null==(u=e.proposeLogIndex)?void 0:u.toString(),null==e||null==(l=e.disputeLogIndex)?void 0:l.toString(),null==e||null==(d=e.settleLogIndex)?void 0:d.toString()].includes(n.toString())});if(1===i.length){const[t]=i,s={timestamp:t.timestamp,requester:t.requester,ancillaryData:t.ancillaryData,identifier:t.identifier,chainId:r};return e.write(e=>e.inputs().request(s)),"done"}const o=e.read().provider(r),c=await o.getTransactionReceipt(a);s(c,"Unable to find transaction receipt from hash: "+a);const u=e.read().oracleService(r),l=e.read().oracleAddress(r),d=c.logs.filter(e=>e.address.toLowerCase()===l.toLowerCase()).map(e=>u.parseLog(e)),h=d.find(e=>{var t;return(null==e||null==(t=e.logIndex)?void 0:t.toString())===n.toString()})||d[n]||d[0];s(h,`Unable to find optimistic oracle event at ${a} eventIndex ${n}`),s(h.args,`Unable to find optimistic oracle event args at ${a} eventIndex ${n}`),s(h.args.timestamp,`Unable to find optimistic oracle event.timestamp at ${a} eventIndex ${n}`),s(h.args.requester,`Unable to find optimistic oracle event.requester at ${a} eventIndex ${n}`),s(h.args.ancillaryData,`Unable to find optimistic oracle event.ancillaryData at ${a} eventIndex ${n}`),s(h.args.identifier,`Unable to find optimistic oracle event.identifier at ${a} eventIndex ${n}`);const p={timestamp:h.args.timestamp,requester:h.args.requester,ancillaryData:h.args.ancillaryData,identifier:h.args.identifier,chainId:r};return e.write(e=>e.inputs().request(p)),"done"}}}var dr={__proto__:null,initMemory:ur,Handlers:lr};function hr(){return{}}function pr(e){const t=new Ps(e);return{async start(t,r){const{requester:a,identifier:n,timestamp:i,ancillaryData:o,chainId:c,signer:u}=t;s(c===await u.getChainId(),"Signer on wrong chainid");const l=e.read().oracleService(c),d=await l.settle(u,{requester:a,identifier:n,timestamp:i,ancillaryData:o});return r.hash=d.hash,"confirm"},async confirm(e,r,a){const{chainId:n,confirmations:i,checkTxIntervalSec:o}=e,{hash:c}=r;return s(c,"requires hash"),await t.isConfirmed(n,c,i)?"update":a.sleep(1e3*o)},async update(s){const{chainId:r,currency:a,account:n}=s,i=e.read().oracleService(r);return await t.balance(r,a,n),e.write(e=>{e.chains(r).optimisticOracle().request(i.getRequest(s))}),t.sortedRequests(r),"done"}}}var mr={__proto__:null,initMemory:hr,Handlers:pr};function gr(){}function fr(e){const t=new Ps(e);return{async start(s,r,a){const{chainId:n,pollRateSec:i=15,concurrency:o=5}=s,c=e.read().oracleService(n).listRequests().filter(e=>void 0===e.eventBased);return await q.map(c,e=>t.request(e),{concurrency:o}),a.sleep(1e3*i)}}}var vr={__proto__:null,initMemory:gr,Handlers:fr};class yr{constructor(e){this.context=e}sleep(e){this.context.sleep=e}}const wr=e=>async(t,r)=>{s(!t.done,"Context has ended"),s(e[t.state],"No handler for state: "+t.state);const a=Object.assign({},t);try{a.sleep&&(a.sleep=void 0);const t=e[a.state],s=Object.assign({},a.memory),r=await t(a.params,s,new yr(a));a.memory=s,r&&(a.state=r),"done"===r&&(a.done=!0)}catch(e){return{...a,error:e,state:"error",done:!0,updated:r}}return a.updated=r,a};function qr(e,t){return!!e&&!e.done&&(void 0===e.updated||null==e||!e.sleep||t-e.updated>=e.sleep)}function br(e,t,s,r={},a=Date.now()){return{id:b(e+"_"),state:"start",done:!1,updated:void 0,created:a,type:e,...r,params:t,memory:s}}class _r{constructor(e,t,s,r){this.type=e,this.handlers=t,this.initMemory=s,this.emit=r,this.create=(e,t)=>{const s=br(this.type,e,this.initMemory(e),{user:t});return this.emit(s),s.id}}async step(e,t=Date.now(),r=10){const a=wr(this.handlers);let n=e;for(;qr(n,t);)s(r>=0,"Infinite loop detected in state machine, make sure it each state transitions to done: "+e.type),n=await a(n,t),r--;return n}}function Sr(){return{iterations:0}}function Rr(e){const t=new Ps(e);return{async start(s,r,a){await Gt(t.userCollateralBalance),await Gt(t.oracleAllowance),r.iterations++;const{checkTxIntervalSec:n=30}=await Gt(e.read().chainConfig)||{};return a.sleep(1e3*n)}}}function kr(){}function Ir(e){const t=new Ps(e);return{async start(){const s=e.has();return s.defaultLiveness()||await Gt(t.oracle),await Gt(t.request),s.collateralProps()||await Gt(t.collateralProps),"done"}}}class Cr{constructor(e){this.store=e,this.pending=[],this.handleCreate=e=>{this.push(e),this.saveContext(e)},this.tick=async(e=Date.now())=>{const t=this.shift();if(qr(t,e)){let s;switch(t.type){case Qt.setUser:case Qt.clearUser:case Qt.setActiveRequest:case Qt.approve:case Qt.disputePrice:case Qt.proposePrice:case Qt.switchOrAddChain:case Qt.pollActiveRequest:case Qt.pollActiveUser:case Qt.fetchPastEvents:case Qt.pollNewEvents:case Qt.setActiveRequestByTransaction:case Qt.settle:case Qt.updateActiveRequest:case Qt.fetchEventBased:s=await this.types[t.type].step(t,e);break;default:throw new Error("Unable to handle type: "+t.type)}s.done||this.push(s),this.saveContext(s)}else t&&!t.done&&this.push(t);return this.size()>0},this.types={[Qt.setUser]:new _r(Qt.setUser,Bs(e),Ds,this.handleCreate),[Qt.clearUser]:new _r(Qt.clearUser,Ls(e),Os,this.handleCreate),[Qt.setActiveRequest]:new _r(Qt.setActiveRequest,Us(e),Fs,this.handleCreate),[Qt.approve]:new _r(Qt.approve,Ws(e),js,this.handleCreate),[Qt.disputePrice]:new _r(Qt.disputePrice,Gs(e),zs,this.handleCreate),[Qt.proposePrice]:new _r(Qt.proposePrice,Ks(e),Js,this.handleCreate),[Qt.switchOrAddChain]:new _r(Qt.switchOrAddChain,Zs(e),Ys,this.handleCreate),[Qt.pollActiveRequest]:new _r(Qt.pollActiveRequest,tr(e),er,this.handleCreate),[Qt.pollActiveUser]:new _r(Qt.pollActiveUser,Rr(e),Sr,this.handleCreate),[Qt.fetchPastEvents]:new _r(Qt.fetchPastEvents,ar(e),rr,this.handleCreate),[Qt.pollNewEvents]:new _r(Qt.pollNewEvents,or(e),ir,this.handleCreate),[Qt.setActiveRequestByTransaction]:new _r(Qt.setActiveRequestByTransaction,lr(e),ur,this.handleCreate),[Qt.settle]:new _r(Qt.settle,pr(e),hr,this.handleCreate),[Qt.updateActiveRequest]:new _r(Qt.updateActiveRequest,Ir(e),kr,this.handleCreate),[Qt.fetchEventBased]:new _r(Qt.fetchEventBased,fr(e),gr,this.handleCreate)}}saveContext(e){this.store.write(t=>t.command(e))}shift(){return this.pending.shift()}pop(){return this.pending.pop()}size(){return this.pending.length}push(e){this.pending.push(e)}}var Er={__proto__:null,setUser:Ms,clearUser:Ns,setActiveRequest:Hs,approve:$s,disputePrice:Vs,proposePrice:Qs,switchOrAddChain:Xs,pollActiveRequest:sr,fetchPastEvents:nr,pollNewEvents:cr,setActiveRequestByTransaction:dr,settle:mr,fetchEventBased:vr,StateMachine:Cr,ContextClient:yr,Step:wr,shouldStep:qr,create:br,ContextManager:_r};class Ar{constructor(e,t,s,r){this.store=e,this.update=t,this.sm=s,this.poller=r,this.intervalStarted=!1}setUser(e){const t=e.address&&r.ethers.utils.getAddress(e.address);return this.sm.types.setUser.create({...e,address:t})}clearUser(){return this.sm.types.clearUser.create(void 0)}setActiveRequest(e){const t=r.ethers.utils.getAddress(e.requester),s=e.ancillaryData.toLowerCase(),a=e.identifier.toLowerCase(),n=Number(e.chainId),i=Number(e.timestamp),o=this.sm.types.setActiveRequest.create({requester:t,ancillaryData:s,identifier:a,chainId:n,timestamp:i});return this.sm.types.updateActiveRequest.create(void 0),o}setActiveRequestByTransaction(e){const t=this.sm.types.setActiveRequestByTransaction.create(e);return this.sm.types.updateActiveRequest.create(void 0),t}approveCollateral(){const{checkTxIntervalSec:e}=this.store.read().chainConfig(),t=this.store.read().request(),a=this.store.read().inputRequest(),n=this.store.read().user(),i=this.store.read().oracleAddress();return s(n.address,"requires a user account address"),s(n.signer,"requires a user signer"),s(n.chainId===a.chainId,"On wrong chain"),s(t.currency,"Request currency is unknown"),this.sm.types.approve.create({currency:t.currency,account:n.address,chainId:a.chainId,signer:n.signer,spender:i,amount:r.ethers.constants.MaxUint256.toString(),confirmations:1,checkTxIntervalSec:e},n.address)}proposePrice(e){const{checkTxIntervalSec:t}=this.store.read().chainConfig(),r=Ke(e),a=this.store.read().inputRequest(),n=this.store.read().request(),i=this.store.read().user();return s(i.address,"requires a user account address"),s(i.signer,"requires a user signer"),s(i.chainId===a.chainId,"On wrong chain"),s(n.currency,"Request currency is unknown"),this.sm.types.proposePrice.create({...a,proposedPrice:r,signer:i.signer,account:i.address,currency:n.currency,confirmations:1,checkTxIntervalSec:t},i.address)}disputePrice(){const{checkTxIntervalSec:e}=this.store.read().chainConfig(),t=this.store.read().inputRequest(),r=this.store.read().user(),a=this.store.read().request();return s(r.address,"requires a user account address"),s(r.signer,"requires a user signer"),s(r.chainId===t.chainId,"On wrong chain"),s(a.currency,"Request currency is unknown"),this.sm.types.disputePrice.create({...t,confirmations:1,signer:r.signer,account:r.address,currency:a.currency,checkTxIntervalSec:e},r.address)}settle(){const{checkTxIntervalSec:e}=this.store.read().chainConfig(),t=this.store.read().inputRequest(),r=this.store.read().user(),a=this.store.read().request();return s(r.address,"requires a user account address"),s(r.signer,"requires a user signer"),s(r.chainId===t.chainId,"On wrong chain"),s(a.currency,"Request currency is unknown"),this.sm.types.settle.create({...t,confirmations:1,signer:r.signer,account:r.address,currency:a.currency,checkTxIntervalSec:e},r.address)}switchOrAddChain(){const e=this.store.read().inputRequest(),t=this.store.read().user();return s(t.provider,"requires user provider"),s(t.address,"requires user address"),s(e.chainId,"requires active request chainId"),this.sm.types.switchOrAddChain.create({chainId:e.chainId,provider:t.provider},t.address)}startInterval(e=1){s(!this.intervalStarted,"Interval already started, try stopping first"),this.intervalStarted=!0,x(async()=>{s(this.intervalStarted,"Interval Stopped"),await this.sm.tick(),await this.poller.tick()},e).catch(e=>{console.error(e),this.intervalStarted=!1,this.store.write(t=>t.error(e))})}stopInterval(){s(!this.intervalStarted,"Interval already stopped"),this.intervalStarted=!1}}function Tr(e){const t=e.map(e=>{const t=r.ethers.getDefaultProvider(e);return t.polling=!1,t}),s=new r.ethers.providers.FallbackProvider(t,1);return s.polling=!1,s}function xr(e,t,s,r){const a=new Ts(t);a.write(t=>{t.config(e),t.sortedRequestsService(r);for(const r of Object.values(e.chains)){const e=Tr(r.rpcUrls);t.chains(r.chainId).optimisticOracle().address(r.optimisticOracleAddress),t.services(r.chainId).provider(e),t.services(r.chainId).multicall2(r.multicall2Address),t.services(r.chainId).optimisticOracle(new s(e,r.optimisticOracleAddress,r.chainId))}});const n=new Ps(a),i=new Cr(a),o=new Cr(a);for(const[t,s]of Object.entries(e.chains))o.types.fetchPastEvents.create({chainId:Number(t),startBlock:s.earliestBlockNumber,maxRange:s.maxEventRangeQuery},"poller"),o.types.pollNewEvents.create({chainId:Number(t),pollRateSec:s.checkTxIntervalSec},"poller"),s.disableFetchEventBased||o.types.fetchEventBased.create({chainId:Number(t)},"poller");return o.types.pollActiveRequest.create(void 0,"poller"),o.types.pollActiveUser.create(void 0,"poller"),new Ar(a,n,i,o)}var Pr={__proto__:null,Client:Ar,factory:xr};class Dr{constructor(e,t,s){this.provider=e,this.address=t,this.chainId=s,this.events=[],this.requests={},this.upsertRequest=e=>{const t=ye(e),s={...this.requests[t]||{},...e,chainId:this.chainId,eventBased:!1};return this.requests[t]=s,s},this.parseLog=e=>{const t=this.contract.interface.parseLog(e);return{...e,...t,event:t.name,eventSignature:t.signature}},this.updateFromEvents=e=>{e.forEach(e=>{hs(this.events,e,ls)&&ds(this.events,e,ls)});const{requests:t={}}=qe(this.events);Object.values(t).map(e=>this.upsertRequest(e))},this.contract=ge(t,e)}setDisputeHash({requester:e,identifier:t,timestamp:s,ancillaryData:r},a){return this.upsertRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r,disputeTx:a})}setProposeHash({requester:e,identifier:t,timestamp:s,ancillaryData:r},a){return this.upsertRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r,proposeTx:a})}setSettleHash({requester:e,identifier:t,timestamp:s,ancillaryData:r},a){return this.upsertRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r,settleTx:a})}async fetchRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r}){const a=await this.contract.callStatic.getRequest(e,t,s,r),n=await this.contract.callStatic.getState(e,t,s,r);return this.upsertRequest({...a,state:n,requester:e,identifier:t,timestamp:s,ancillaryData:r})}getRequest(e){const t=ye(e);return{...this.requests[t]||e}}async disputePrice(e,{requester:t,identifier:s,timestamp:r,ancillaryData:a}){const n=ge(this.address,e),i=await n.disputePrice(t,s,r,a);return this.setDisputeHash({requester:t,identifier:s,timestamp:r,ancillaryData:a},i.hash),i}async proposePrice(e,{requester:t,identifier:s,timestamp:r,ancillaryData:a},n){const i=ge(this.address,e),o=await i.proposePrice(t,s,r,a,n);return this.setProposeHash({requester:t,identifier:s,timestamp:r,ancillaryData:a},o.hash),o}async settle(e,{requester:t,identifier:s,timestamp:r,ancillaryData:a}){const n=ge(this.address,e),i=await n.settle(t,s,r,a);return this.setSettleHash({requester:t,identifier:s,timestamp:r,ancillaryData:a},i.hash),i}async update(e=0,t="latest"){const s=await this.contract.queryFilter({},e,t);this.updateFromEvents(s)}async getProps(){return{defaultLiveness:await this.contract.defaultLiveness()}}updateFromTransactionReceipt(e){const t=e.logs.map(e=>this.parseLog(e));this.updateFromEvents(t)}listRequests(){return Object.values(this.requests)}}var Br={__proto__:null,OptimisticOracle:Dr};class Mr{constructor(){this.ids=[],this.map=new Map,this.getStart=(e,t=!0)=>t?_(this.ids,e):S(this.ids,e),this.getEnd=(e,t=!1)=>this.getStart(e,!t),this.del=e=>{const t=_(this.ids,e);this.ids.splice(t,1);const s=this.map.get(e);return this.map.delete(e),s},this.getSafe=e=>{const t=this.map.get(e);if(C(t))return t;throw new Error("Missing data for index: "+e)},this.has=e=>this.map.has(e),this.set=(e,t)=>{if(this.map.has(e))this.map.set(e,t);else{const s=_(this.ids,e);this.ids.splice(s,0,e),this.map.set(e,t)}},this.get=e=>this.map.get(e),this.values=()=>this.ids.map(this.getSafe),this.entries=()=>this.ids.map(e=>[e,this.getSafe(e)]),this.keys=()=>[...this.ids],this.clear=()=>{this.map.clear(),this.ids.length=0},this.size=()=>this.ids.length,this.delete=e=>{this.map.has(e)&&this.del(e)},this.between=(e,t)=>{const s=this.getStart(e),r=this.getEnd(t);return this.ids.slice(s,r).map(this.getSafe)},this.slice=(e,t)=>{const s=this.getStart(e);return this.ids.slice(s,s+t).map(this.getSafe)}}}class Or extends Mr{setByRequest(e){return this.set(this.id(e),e)}descending(){return this.values().reverse()}ascending(){return this.values()}getByRequest(e){return this.get(this.id(e))||e}id(e){return ye(e)+"!"+e.chainId+"!"+e.oracleType}}var Lr={__proto__:null,SortedStore:Mr,SortedRequests:Or};function Nr(e){return s(e.proposer,"Missing proposer"),s(e.disputer,"Missing disputer"),s(e.currency,"Missing currency"),s(e.settled,"Missing settled"),s(e.proposedPrice,"Missing proposedPrice"),s(e.resolvedPrice,"Missing resolvedPrice"),s(e.expirationTime,"Missing expirationTime"),s(e.reward,"Missing reward"),s(e.finalFee,"Missing finalFee"),s(e.bond,"Missing bond"),s(e.customLiveness,"Missing customLiveness"),{proposer:e.proposer,disputer:e.disputer,currency:e.currency,settled:e.settled,proposedPrice:e.proposedPrice,resolvedPrice:e.resolvedPrice,expirationTime:e.expirationTime,reward:e.reward,finalFee:e.finalFee,bond:e.bond,customLiveness:e.customLiveness}}class Fr{constructor(e,t,s){this.provider=e,this.address=t,this.chainId=s,this.events=[],this.requests={},this.upsertRequest=e=>{const t=ye(e),s={...this.requests[t]||{},...e,chainId:this.chainId,eventBased:!1};return this.requests[t]=s,s},this.updateFromEvents=e=>{e.forEach(e=>{hs(this.events,e,ls)&&ds(this.events,e,ls)});const{requests:t={}}=Ee(this.events);Object.values(t).map(e=>this.upsertRequest(e))},this.parseLog=e=>{const t=this.contract.interface.parseLog(e);return{...e,...t,event:t.name,eventSignature:t.signature}},this.contract=Se(t,e)}setDisputeHash({requester:e,identifier:t,timestamp:s,ancillaryData:r},a){return this.upsertRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r,disputeTx:a})}setProposeHash({requester:e,identifier:t,timestamp:s,ancillaryData:r},a){return this.upsertRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r,proposeTx:a})}setSettleHash({requester:e,identifier:t,timestamp:s,ancillaryData:r},a){return this.upsertRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r,settleTx:a})}async fetchRequest(e){return this.getRequest(e)}getRequest(e){const t=ye(e);return{...this.requests[t]||e}}async disputePrice(e,{requester:t,identifier:s,timestamp:r,ancillaryData:a}){const n=Nr(this.getRequest({requester:t,identifier:s,timestamp:r,ancillaryData:a})),i=Se(this.address,e),o=await i.disputePrice(t,s,r,a,n);return this.setDisputeHash({requester:t,identifier:s,timestamp:r,ancillaryData:a},o.hash),o}async proposePrice(e,{requester:t,identifier:s,timestamp:r,ancillaryData:a},n){const i=Nr(this.getRequest({requester:t,identifier:s,timestamp:r,ancillaryData:a})),o=Se(this.address,e),c=await o.proposePrice(t,s,r,a,i,n);return this.setProposeHash({requester:t,identifier:s,timestamp:r,ancillaryData:a},c.hash),c}async settle(e,{requester:t,identifier:s,timestamp:r,ancillaryData:a}){const n=Nr(this.getRequest({requester:t,identifier:s,timestamp:r,ancillaryData:a})),i=Se(this.address,e),o=await i.settle(t,s,r,a,n);return this.setSettleHash({requester:t,identifier:s,timestamp:r,ancillaryData:a},o.hash),o}async update(e=0,t="latest"){const s=await this.contract.queryFilter({},e,t);this.updateFromEvents(s)}async getProps(){return{defaultLiveness:await this.contract.defaultLiveness()}}updateFromTransactionReceipt(e){const t=e.logs.map(e=>this.parseLog(e));this.updateFromEvents(t)}listRequests(){return Object.values(this.requests)}}var Ur={__proto__:null,SkinnyOptimisticOracle:Fr};class Hr{constructor(e,t,s){this.provider=e,this.address=t,this.chainId=s,this.events=[],this.requests={},this.upsertRequest=e=>{const t=ye(e),s={...this.requests[t]||{},...e,...e.requestSettings||{},chainId:this.chainId};return this.requests[t]=s,s},this.updateFromEvents=e=>{e.forEach(e=>{hs(this.events,e,ls)&&ds(this.events,e,ls)});const{requests:t={}}=Oe(this.events);Object.values(t).map(e=>this.upsertRequest(e))},this.parseLog=e=>{const t=this.contract.interface.parseLog(e);return{...e,...t,event:t.name,eventSignature:t.signature}},this.contract=xe(t,e)}setDisputeHash({requester:e,identifier:t,timestamp:s,ancillaryData:r},a){return this.upsertRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r,disputeTx:a})}setProposeHash({requester:e,identifier:t,timestamp:s,ancillaryData:r},a){return this.upsertRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r,proposeTx:a})}setSettleHash({requester:e,identifier:t,timestamp:s,ancillaryData:r},a){return this.upsertRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r,settleTx:a})}async fetchRequest({requester:e,identifier:t,timestamp:s,ancillaryData:r}){const a=await this.contract.callStatic.getRequest(e,t,s,r),n=await this.contract.callStatic.getState(e,t,s,r);return this.upsertRequest({...a,state:n,requester:e,identifier:t,timestamp:s,ancillaryData:r})}getRequest(e){const t=ye(e);return{...this.requests[t]||e}}async disputePrice(e,{requester:t,identifier:s,timestamp:r,ancillaryData:a}){const n=xe(this.address,e),i=await n.disputePrice(t,s,r,a);return this.setDisputeHash({requester:t,identifier:s,timestamp:r,ancillaryData:a},i.hash),i}async proposePrice(e,{requester:t,identifier:s,timestamp:r,ancillaryData:a},n){const i=xe(this.address,e),o=await i.proposePrice(t,s,r,a,n);return this.setProposeHash({requester:t,identifier:s,timestamp:r,ancillaryData:a},o.hash),o}async settle(e,{requester:t,identifier:s,timestamp:r,ancillaryData:a}){const n=xe(this.address,e),i=await n.settle(t,s,r,a);return this.setSettleHash({requester:t,identifier:s,timestamp:r,ancillaryData:a},i.hash),i}async update(e=0,t="latest"){const s=await this.contract.queryFilter({},e,t);this.updateFromEvents(s)}async getProps(){return{defaultLiveness:await this.contract.defaultLiveness()}}updateFromTransactionReceipt(e){const t=e.logs.map(e=>this.parseLog(e));this.updateFromEvents(t)}listRequests(){return Object.values(this.requests)}}var jr=(e,t,s=new Or)=>xr(as({getMulticall2Address:ss})({...e},Vt.Skinny),t,Fr,s),Wr=(e,t,s=new Or)=>xr(as({getMulticall2Address:ss})({...e},Vt.Optimistic),t,Dr,s),$r=(e,t,s=new Or)=>xr(as({getMulticall2Address:ss})({...e},Vt.OptimisticV2),t,Hr,s);const zr=(e,t)=>(s,r)=>t(e,s,r);var Gr={__proto__:null,client:Pr,services:{__proto__:null,erc20:ys,optimisticOracle:Br,statemachines:Er,sortedRequests:Lr,skinnyOptimisticOracle:Ur,optimisticOracleV2:{__proto__:null,OptimisticOracleV2:Hr}},types:{__proto__:null,state:Yt,ethers:{__proto__:null,Provider:h.Provider,JsonRpcSigner:h.JsonRpcSigner,JsonRpcProvider:h.JsonRpcProvider,Web3Provider:h.Web3Provider,FallbackProvider:h.FallbackProvider},misc:{__proto__:null},statemachine:Zt,interfaces:{__proto__:null,get RequestState(){return ve}}},store:xs,utils:ps,errors:Kt,skinnyFactory:jr,optimisticFactory:Wr,factory:(e,t)=>{const r=new Or;return Object.fromEntries(Object.entries(e).map(([e,a])=>{switch(s(a,"requires config for type: "+e),e){case Vt.Optimistic:return[e,Wr(a,zr(e,t),r)];case Vt.Skinny:return[e,jr(a,zr(e,t),r)];case Vt.OptimisticV2:return[e,$r(a,zr(e,t),r)];default:throw new Error("Unknown oracle type: "+e)}}))},optimisticV2Factory:$r};exports.BlockFinder=wt,exports.Coingecko=qt,exports.Multicall=class extends At{constructor(e,t){super({multicallClient:$(e,t),requests:[]})}},exports.Multicall2=xt,exports.across=jt,exports.clients=Le,exports.oracle=Gr,exports.stores=Ue,exports.tables=Ge,exports.utils=M;
//# sourceMappingURL=index.cjs.production.min.js.map
