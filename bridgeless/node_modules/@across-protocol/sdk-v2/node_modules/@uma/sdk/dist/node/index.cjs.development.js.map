{"version":3,"file":"index.cjs.development.js","sources":["../src/clients/registry/client.ts","../src/utils.ts","../src/clients/emp/client.ts","../src/clients/erc20/client.ts","../src/clients/multicall/client.ts","../src/clients/multicall2/client.ts","../src/clients/lsp-creator/client.ts","../src/clients/lsp/client.ts","../src/clients/bridgeDepositBox/client.ts","../src/clients/bridgePool/client.ts","../src/clients/etherchain/client.ts","../src/clients/rateModelStore/client.ts","../src/clients/optimisticOracle/client.ts","../src/clients/skinnyOptimisticOracle/client.ts","../src/clients/optimisticOracleV2/client.ts","../src/stores/js-map/store.ts","../src/stores/sorted-js-map/store.ts","../src/stores/google-datastore/store.ts","../src/tables/base/table.ts","../src/tables/blocks/utils.ts","../src/tables/blocks/table.ts","../src/tables/emps/utils.ts","../src/tables/emps/table.ts","../src/tables/historical-prices/utils.ts","../src/tables/historical-prices/table.ts","../src/tables/erc20s/utils.ts","../src/tables/erc20s/table.ts","../src/across/utils.ts","../src/across/feeCalculator.ts","../src/across/constants.ts","../src/across/rateModel.ts","../src/blockFinder.ts","../src/across/lpFeeCalculator.ts","../src/coingecko/coingecko.ts","../src/across/gasFeeCalculator.ts","../src/multicall.ts","../src/multicall2.ts","../src/across/transactionManager.ts","../src/across/clients/bridgePool.ts","../src/across/clients/optimismBridge.ts","../src/across/clients/bobaBridge.ts","../src/oracle/errors.ts","../src/oracle/types/state.ts","../src/oracle/types/statemachine.ts","../src/oracle/utils.ts","../src/oracle/services/erc20.ts","../src/oracle/store/write.ts","../src/oracle/store/read.ts","../src/oracle/store/has.ts","../src/oracle/store/store.ts","../src/oracle/store/index.ts","../src/oracle/services/update.ts","../src/oracle/services/statemachines/setUser.ts","../src/oracle/services/statemachines/clearUser.ts","../src/oracle/services/statemachines/setActiveRequest.ts","../src/oracle/services/statemachines/approve.ts","../src/oracle/services/statemachines/disputePrice.ts","../src/oracle/services/statemachines/proposePrice.ts","../src/oracle/services/statemachines/switchOrAddChain.ts","../src/oracle/services/statemachines/pollActiveRequest.ts","../src/oracle/services/statemachines/fetchPastEvents.ts","../src/oracle/services/statemachines/pollNewEvents.ts","../src/oracle/services/statemachines/setActiveRequestByTransaction.ts","../src/oracle/services/statemachines/settle.ts","../src/oracle/services/statemachines/fetchEventBased.ts","../src/oracle/services/statemachines/utils.ts","../src/oracle/services/statemachines/pollActiveUser.ts","../src/oracle/services/statemachines/updateActiveRequest.ts","../src/oracle/services/statemachines/statemachine.ts","../src/oracle/client.ts","../src/oracle/services/optimisticOracle.ts","../src/oracle/services/sortedRequests.ts","../src/oracle/services/skinnyOptimisticOracle.ts","../src/oracle/services/optimisticOracleV2.ts","../src/oracle/skinnyFactory.ts","../src/oracle/optimisticFactory.ts","../src/oracle/optimisticV2Factory.ts","../src/oracle/factory.ts"],"sourcesContent":["import {\n  RegistryEthers,\n  RegistryEthers__factory,\n  getRegistryAddress as getAbi,\n  getRegistryAddress as getAddress,\n} from \"@uma/contracts-node\";\n\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\n\nexport type Instance = RegistryEthers;\nconst Factory = RegistryEthers__factory;\n\nexport type Network = string | number;\n\nexport { getAddress, getAbi };\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport interface EventState {\n  contracts?: { [key: string]: NewContractRegistered };\n}\n\nexport type NewContractRegistered = GetEventType<Instance, \"NewContractRegistered\">;\n\n// experimenting with a generalized way of handling events and returning state, inspired from react style reducers\nexport function reduceEvents(state: EventState = {}, event: Event): EventState {\n  switch (event.event) {\n    case \"NewContractRegistered\": {\n      const typedEvent = event as NewContractRegistered;\n      const { contractAddress } = typedEvent.args;\n      const contracts = state?.contracts || {};\n      return {\n        ...state,\n        contracts: {\n          ...contracts,\n          [contractAddress]: typedEvent,\n        },\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[]): EventState {\n  return events.reduce(reduceEvents, {});\n}\n","import assert from \"assert\";\nimport { BigNumber, Contract } from \"ethers\";\nimport type Multicall2 from \"./multicall2\";\nimport zip from \"lodash/zip\";\n\nexport type BigNumberish = number | string | BigNumber;\n// check if a value is not null or undefined, useful for numbers which could be 0.\n// \"is\" syntax: https://stackoverflow.com/questions/40081332/what-does-the-is-keyword-do-in-typescript\n/* eslint-disable-next-line @typescript-eslint/ban-types */\nexport function exists<T>(value: T | null | undefined): value is NonNullable<T> {\n  return value !== null && value !== undefined;\n}\n\n// useful for maintaining balances from events\nexport type Balances = { [key: string]: string };\nexport function Balances(balances: Balances = {}) {\n  function create(id: string, amount = \"0\") {\n    assert(!has(id), \"balance already exists\");\n    return set(id, amount);\n  }\n  function has(id: string) {\n    return exists(balances[id]);\n  }\n  function set(id: string, amount: string) {\n    balances[id] = amount;\n    return amount;\n  }\n  function add(id: string, amount: BigNumberish) {\n    return set(id, BigNumber.from(amount).add(getOrCreate(id)).toString());\n  }\n  function sub(id: string, amount: BigNumberish) {\n    return set(id, BigNumber.from(getOrCreate(id)).sub(amount).toString());\n  }\n  function get(id: string) {\n    assert(has(id), \"balance does not exist\");\n    return balances[id];\n  }\n  function getOrCreate(id: string) {\n    if (has(id)) return get(id);\n    return create(id);\n  }\n  return { create, add, sub, get, balances, set, has, getOrCreate };\n}\n\n// Copied from common, but modified for ethers Bignumber\nexport const ConvertDecimals = (fromDecimals: number, toDecimals: number) => {\n  assert(fromDecimals >= 0, \"requires fromDecimals as an integer >= 0\");\n  assert(toDecimals >= 0, \"requires toDecimals as an integer >= 0\");\n  // amount: string, BN, number - integer amount in fromDecimals smallest unit that want to convert toDecimals\n  // returns: string with toDecimals in smallest unit\n  return (amount: BigNumberish): string => {\n    assert(exists(amount), \"must provide an amount to convert\");\n    amount = BigNumber.from(amount);\n    if (amount.isZero()) return amount.toString();\n    const diff = fromDecimals - toDecimals;\n    if (diff == 0) return amount.toString();\n    if (diff > 0) return amount.div(BigNumber.from(\"10\").pow(diff)).toString();\n    return amount.mul(BigNumber.from(\"10\").pow(-1 * diff)).toString();\n  };\n};\n\n// async sleep\nexport const sleep = (delay = 0) => new Promise((res) => setTimeout(res, delay));\n\n// Loop forever but wait until execution is finished before starting next timer. Throw an error to break this\n// or add another utlity function if you need it to end on condition.\nexport async function loop(fn: (...args: any[]) => any, delay: number, ...args: any[]) {\n  do {\n    await fn(...args);\n    await sleep(delay);\n    /* eslint-disable-next-line no-constant-condition */\n  } while (true);\n}\n\nexport type Call = [string, ...BigNumberish[]];\nexport type Calls = Call[];\nexport type BatchReadWithErrorsType = ReturnType<ReturnType<typeof BatchReadWithErrors>>;\nexport const BatchReadWithErrors = (multicall2: Multicall2) => (contract: Contract) => async <R>(\n  calls: Calls\n): Promise<R> => {\n  // multicall batch takes array of {method} objects\n  const results = await multicall2\n    .batch(\n      contract,\n      calls.map(([method, ...args]) => ({ method, args }))\n    )\n    .readWithErrors();\n  // convert results of multicall, an array of responses, into an object keyed by contract method\n  return Object.fromEntries(\n    zip(calls, results).map(([call, result]) => {\n      if (call == null) return [];\n      const [method] = call;\n      if (!result?.result) return [method, undefined];\n      return [method, result.result[0] || result.result];\n    })\n  );\n};\n\n/**\n * @notice Return average block-time for a period.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function averageBlockTimeSeconds(chainId?: number): Promise<number> {\n  // TODO: Call an external API to get this data. Currently this value is a hard-coded estimate\n  // based on the data from https://etherscan.io/chart/blocktime. ~13.5 seconds has been the average\n  // since April 2016, although this value seems to spike periodically for a relatively short period of time.\n  const defaultBlockTimeSeconds = 12;\n  if (!defaultBlockTimeSeconds) {\n    throw \"Missing default block time value\";\n  }\n\n  switch (chainId) {\n    // Source: https://polygonscan.com/chart/blocktime\n    case 10:\n      return 0.5;\n    case 42161:\n      return 0.5;\n    case 288:\n      return 150;\n    case 137:\n      return 2.5;\n    case 1:\n      return defaultBlockTimeSeconds;\n    default:\n      return defaultBlockTimeSeconds;\n  }\n}\n\nexport async function estimateBlocksElapsed(\n  seconds: number,\n  cushionPercentage = 0.0,\n  chainId?: number\n): Promise<number> {\n  const cushionMultiplier = cushionPercentage + 1.0;\n  const averageBlockTime = await averageBlockTimeSeconds(chainId);\n  return Math.floor((seconds * cushionMultiplier) / averageBlockTime);\n}\n","import { ExpiringMultiPartyEthers, ExpiringMultiPartyEthers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\nimport { Balances } from \"../../utils\";\n\nexport type Instance = ExpiringMultiPartyEthers;\nconst Factory = ExpiringMultiPartyEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport interface EventState {\n  // any address that created a position, regardless of if they have closed it\n  sponsors?: string[];\n  tokens?: Balances;\n  collateral?: Balances;\n  expired?: boolean;\n}\n\nexport type RequestTransferPositionExecuted = GetEventType<Instance, \"RequestTransferPositionExecuted\">;\nexport type PositionCreated = GetEventType<Instance, \"PositionCreated\">;\nexport type NewSponsor = GetEventType<Instance, \"NewSponsor\">;\nexport type SettleExpiredPosition = GetEventType<Instance, \"SettleExpiredPosition\">;\nexport type Redeem = GetEventType<Instance, \"Redeem\">;\nexport type Withdrawal = GetEventType<Instance, \"Withdrawal\">;\nexport type LiquidationCreated = GetEventType<Instance, \"LiquidationCreated\">;\n\n// experimenting with a generalized way of handling events and returning state, inspired from react style reducers\nexport function reduceEvents(state: EventState = {}, event: Event): EventState {\n  switch (event.event) {\n    case \"RequestTransferPositionExecuted\": {\n      const typedEvent = event as RequestTransferPositionExecuted;\n      const { oldSponsor, newSponsor } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      const collateralBalance = collateral.get(oldSponsor);\n      collateral.set(oldSponsor, \"0\");\n      collateral.set(newSponsor, collateralBalance);\n      const tokenBalance = tokens.get(oldSponsor);\n      tokens.set(oldSponsor, \"0\");\n      tokens.set(newSponsor, tokenBalance.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    case \"PositionCreated\": {\n      const typedEvent = event as PositionCreated;\n      const { sponsor, collateralAmount, tokenAmount } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      collateral.add(sponsor, collateralAmount.toString());\n      tokens.add(sponsor, tokenAmount.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    case \"NewSponsor\": {\n      const typedEvent = event as NewSponsor;\n      const { sponsor } = typedEvent.args;\n      const sponsors = new Set(state.sponsors || []);\n      sponsors.add(sponsor);\n      return {\n        ...state,\n        sponsors: Array.from(sponsors.values()),\n      };\n    }\n    case \"SettleExpiredPosition\": {\n      const typedEvent = event as SettleExpiredPosition;\n      const { caller, collateralReturned, tokensBurned } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      collateral.sub(caller, collateralReturned.toString());\n      tokens.sub(caller, tokensBurned.toString());\n      return {\n        ...state,\n        expired: true,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    case \"Redeem\": {\n      const typedEvent = event as Redeem;\n      const { sponsor, collateralAmount, tokenAmount } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      collateral.sub(sponsor, collateralAmount.toString());\n      tokens.sub(sponsor, tokenAmount.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    case \"LiquidationCreated\": {\n      const typedEvent = event as LiquidationCreated;\n      const { sponsor, tokensOutstanding, liquidatedCollateral } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const collateral = Balances(state.collateral || {});\n      collateral.sub(sponsor, liquidatedCollateral.toString());\n      tokens.sub(sponsor, tokensOutstanding.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n        tokens: tokens.balances,\n      };\n    }\n    // these 2 are the same\n    case \"Withdrawal\":\n    case \"RequestWithdrawalExecuted\": {\n      const typedEvent = event as Withdrawal;\n      const { sponsor, collateralAmount } = typedEvent.args;\n      const collateral = Balances(state.collateral || {});\n      collateral.sub(sponsor, collateralAmount.toString());\n      return {\n        ...state,\n        collateral: collateral.balances,\n      };\n    }\n    case \"ContractExpired\": {\n      return {\n        ...state,\n        expired: true,\n      };\n    }\n  }\n  return state;\n}\n\nexport function getEventState(events: Event[], initialState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, initialState);\n}\n","import { ERC20Ethers, ERC20Ethers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\nimport { Balances } from \"../../utils\";\nimport { set } from \"lodash\";\n\nexport type Instance = ERC20Ethers;\nconst Factory = ERC20Ethers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport interface EventState {\n  // any address that created a position, regardless of if they have closed it\n  balances?: Balances;\n  // approvals are keyed both ways here for ease of lookup by either owner or spender\n  approvalsByOwner?: {\n    [owner: string]: {\n      [spender: string]: {\n        amount: string;\n      };\n    };\n  };\n  approvalsBySpender?: {\n    [spender: string]: {\n      [owner: string]: {\n        amount: string;\n      };\n    };\n  };\n}\n\nexport type Transfer = GetEventType<Instance, \"Transfer\">;\nexport type Approval = GetEventType<Instance, \"Approval\">;\n\n// takes all events and returns user balances and approvals\nexport function reduceEvents(state: EventState = {}, event: Event): EventState {\n  switch (event.event) {\n    case \"Transfer\": {\n      const typedEvent = event as Transfer;\n      const { from, to, value } = typedEvent.args;\n      const balances = Balances(state.balances || {});\n      balances.sub(from, value);\n      balances.add(to, value);\n      return {\n        ...state,\n        balances: balances.balances,\n      };\n    }\n    case \"Approval\": {\n      const typedEvent = event as Approval;\n      const { owner, spender, value } = typedEvent.args;\n      set(state, [\"approvalsByOwner\", owner, spender], value.toString());\n      set(state, [\"approvalsBySpender\", spender, owner], value.toString());\n      return {\n        ...state,\n      };\n    }\n  }\n  return state;\n}\n\nexport function getEventState(events: Event[], initialState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, initialState);\n}\n","import { MulticallEthers, MulticallEthers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider } from \"../..\";\n\nexport type Instance = MulticallEthers;\nconst Factory = MulticallEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n","import { Multicall2Ethers, Multicall2Ethers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider } from \"../..\";\n\nexport type Instance = Multicall2Ethers;\nconst Factory = Multicall2Ethers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n","import {\n  LongShortPairCreatorEthers,\n  LongShortPairCreatorEthers__factory,\n  getLongShortPairCreatorAbi as getAbi,\n  getLongShortPairCreatorAddress as getAddress,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\n\n// exporting Registry type in case its needed\nexport type Instance = LongShortPairCreatorEthers;\nconst Factory = LongShortPairCreatorEthers__factory;\n\nexport type Network = string | number;\n\nexport { getAddress, getAbi };\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport type CreatedLongShortPair = GetEventType<Instance, \"CreatedLongShortPair\">;\n\nexport interface EventState {\n  contracts?: {\n    [lspAddress: string]: CreatedLongShortPair;\n  };\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"CreatedLongShortPair\": {\n      const typedEvent = event as CreatedLongShortPair;\n      const contracts = state?.contracts || {};\n      return {\n        ...state,\n        contracts: {\n          ...contracts,\n          [typedEvent.args.longShortPair]: typedEvent,\n        },\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import { LongShortPairEthers, LongShortPairEthers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event } from \"ethers\";\nimport { Balances } from \"../../utils\";\n\nexport type Instance = LongShortPairEthers;\nconst Factory = LongShortPairEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport type TokensCreated = GetEventType<Instance, \"TokensCreated\">;\nexport type TokensRedeemed = GetEventType<Instance, \"TokensRedeemed\">;\nexport type ContractExpired = GetEventType<Instance, \"ContractExpired\">;\nexport type PositionSettled = GetEventType<Instance, \"PositionSettled\">;\n\nexport interface EventState {\n  sponsors?: string[];\n  longs?: Balances;\n  shorts?: Balances;\n  collateral?: Balances;\n  expired?: boolean;\n  expiredBy?: string;\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"TokensCreated\": {\n      const typedEvent = event as TokensCreated;\n      const { sponsor, collateralUsed, tokensMinted } = typedEvent.args;\n\n      const sponsors = new Set(state.sponsors || []);\n      const longs = Balances(state.longs || {});\n      const shorts = Balances(state.shorts || {});\n      const collateral = Balances(state.collateral || {});\n\n      sponsors.add(sponsor);\n      longs.add(sponsor, tokensMinted);\n      shorts.add(sponsor, tokensMinted);\n      collateral.add(sponsor, collateralUsed);\n\n      return {\n        ...state,\n        collateral: collateral.balances,\n        shorts: shorts.balances,\n        longs: longs.balances,\n        sponsors: Array.from(sponsors.values()),\n      };\n    }\n    case \"TokensRedeemed\": {\n      const typedEvent = event as TokensRedeemed;\n      const { sponsor, collateralReturned, tokensRedeemed } = typedEvent.args;\n\n      const longs = Balances(state.longs || {});\n      const shorts = Balances(state.shorts || {});\n      const collateral = Balances(state.collateral || {});\n\n      longs.sub(sponsor, tokensRedeemed);\n      shorts.sub(sponsor, tokensRedeemed);\n      collateral.sub(sponsor, collateralReturned);\n\n      return {\n        ...state,\n        collateral: collateral.balances,\n        shorts: shorts.balances,\n        longs: longs.balances,\n      };\n    }\n    case \"ContractExpired\": {\n      const typedEvent = event as ContractExpired;\n      const { caller } = typedEvent.args;\n\n      return {\n        ...state,\n        expired: true,\n        expiredBy: caller,\n      };\n    }\n    case \"PositionSettled\": {\n      const typedEvent = event as PositionSettled;\n      const { sponsor, collateralReturned, longTokens, shortTokens } = typedEvent.args;\n\n      const longs = Balances(state.longs || {});\n      const shorts = Balances(state.shorts || {});\n      const collateral = Balances(state.collateral || {});\n\n      longs.sub(sponsor, longTokens);\n      shorts.sub(sponsor, shortTokens);\n      collateral.sub(sponsor, collateralReturned);\n\n      return {\n        ...state,\n        collateral: collateral.balances,\n        shorts: shorts.balances,\n        longs: longs.balances,\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import { BridgeDepositBoxEthers, BridgeDepositBoxEthers__factory } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event, BigNumber } from \"ethers\";\n\nexport type Instance = BridgeDepositBoxEthers;\nconst Factory = BridgeDepositBoxEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport type SetMinimumBridgingDelay = GetEventType<Instance, \"SetMinimumBridgingDelay\">;\nexport type WhitelistToken = GetEventType<Instance, \"WhitelistToken\">;\nexport type DepositsEnabled = GetEventType<Instance, \"DepositsEnabled\">;\nexport type FundsDeposited = GetEventType<Instance, \"FundsDeposited\">;\nexport type TokensBridged = GetEventType<Instance, \"TokensBridged\">;\n\nexport type Deposit = {\n  chainId: BigNumber;\n  depositId: BigNumber;\n  l1Recipient: string;\n  l2Sender: string;\n  l1Token: string;\n  amount: BigNumber;\n  slowRelayFeePct: BigNumber;\n  instantRelayFeePct: BigNumber;\n  quoteTimestamp: BigNumber;\n};\nexport type Whitelist = {\n  l1Token: string;\n  l2Token: string;\n  lastBridgeTime: BigNumber;\n  bridgePool: string;\n};\nexport interface EventState {\n  minimumBridgingDelay?: string;\n  whitelistedTokens?: Record<string, Whitelist>;\n  depositsEnabled?: Record<string, boolean>;\n  deposits?: Record<string, Deposit>;\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"SetMinimumBridgingDelay\": {\n      const typedEvent = event as SetMinimumBridgingDelay;\n      const { newMinimumBridgingDelay } = typedEvent.args;\n      return {\n        ...state,\n        minimumBridgingDelay: newMinimumBridgingDelay.toString(),\n      };\n    }\n    case \"WhitelistToken\": {\n      const typedEvent = event as WhitelistToken;\n      const { l1Token, l2Token, lastBridgeTime, bridgePool } = typedEvent.args;\n      return {\n        ...state,\n        whitelistedTokens: {\n          ...state.whitelistedTokens,\n          [l2Token]: { l1Token, l2Token, lastBridgeTime, bridgePool },\n        },\n      };\n    }\n    case \"DepositsEnabled\": {\n      const typedEvent = event as DepositsEnabled;\n      const { l2Token, depositsEnabled } = typedEvent.args;\n      return {\n        ...state,\n        depositsEnabled: {\n          ...state.depositsEnabled,\n          [l2Token]: depositsEnabled,\n        },\n      };\n    }\n    case \"FundsDeposited\": {\n      const typedEvent = event as FundsDeposited;\n      const {\n        chainId,\n        depositId,\n        l1Recipient,\n        l2Sender,\n        l1Token,\n        amount,\n        slowRelayFeePct,\n        instantRelayFeePct,\n        quoteTimestamp,\n      } = typedEvent.args;\n\n      return {\n        ...state,\n        deposits: {\n          ...state.deposits,\n          [depositId.toString()]: {\n            chainId,\n            depositId,\n            l1Recipient,\n            l2Sender,\n            l1Token,\n            amount,\n            slowRelayFeePct,\n            instantRelayFeePct,\n            quoteTimestamp,\n          },\n        },\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import { BridgePoolEthers, BridgePoolEthers__factory, BridgePoolInterfaceEthers } from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType, SerializableEvent } from \"../..\";\nimport { BigNumber } from \"ethers\";\nimport { Balances } from \"../../utils\";\n\nexport type Instance = BridgePoolEthers;\nexport const Factory = BridgePoolEthers__factory;\nexport type Interface = BridgePoolInterfaceEthers;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\nexport function attach(address: string): Instance {\n  return new Factory().attach(address);\n}\n\nexport type LiquidityAdded = GetEventType<Instance, \"LiquidityAdded\">;\nexport type LiquidityRemoved = GetEventType<Instance, \"LiquidityRemoved\">;\nexport type DepositRelayed = GetEventType<Instance, \"DepositRelayed\">;\nexport type RelaySpedUp = GetEventType<Instance, \"RelaySpedUp\">;\nexport type RelayDisputed = GetEventType<Instance, \"RelayDisputed\">;\nexport type RelayCanceled = GetEventType<Instance, \"RelayCanceled\">;\nexport type RelaySettled = GetEventType<Instance, \"RelaySettled\">;\nexport type BridgePoolAdminTransferred = GetEventType<Instance, \"BridgePoolAdminTransferred\">;\n\nexport type DepositData = {\n  chainId: BigNumber;\n  depositId: BigNumber;\n  l1Recipient: string;\n  l2Sender: string;\n  amount: BigNumber;\n  slowRelayFeePct: BigNumber;\n  instantRelayFeePct: BigNumber;\n  quoteTimestamp: number;\n};\nexport type RelayData = {\n  relayState: number;\n  slowRelayer: string;\n  relayId: number;\n  realizedLpFeePct: BigNumber;\n  priceRequestTime: number;\n  proposerBond: BigNumber;\n  finalFee: BigNumber;\n};\nexport interface EventState {\n  oldAdmin?: string;\n  newAdmin?: string;\n  tokens: Balances;\n  lpTokens: Balances;\n  deposits: Record<string, DepositData>;\n  relays: Record<string, RelayData>;\n  instantRelays: Record<string, string>;\n}\n\nexport function eventStateDefaults() {\n  return {\n    tokens: {},\n    lpTokens: {},\n    deposits: {},\n    relays: {},\n    instantRelays: {},\n  };\n}\n\nexport function reduceEvents(state: EventState, event: SerializableEvent): EventState {\n  switch (event.event) {\n    // event LiquidityAdded(address indexed token, uint256 amount, uint256 lpTokensMinted, address liquidityProvider);\n    case \"LiquidityAdded\": {\n      const typedEvent = event as LiquidityAdded;\n      const { amount, lpTokensMinted, liquidityProvider } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const lpTokens = Balances(state.lpTokens || {});\n      tokens.add(liquidityProvider, amount.toString());\n      lpTokens.add(liquidityProvider, lpTokensMinted.toString());\n      return {\n        ...state,\n        tokens: {\n          ...tokens.balances,\n        },\n        lpTokens: {\n          ...lpTokens.balances,\n        },\n      };\n    }\n    // event LiquidityRemoved(address indexed token, uint256 amount, uint256 lpTokensBurnt, address liquidityProvider);\n    case \"LiquidityRemoved\": {\n      const typedEvent = event as LiquidityRemoved;\n      const { amount, lpTokensBurnt, liquidityProvider } = typedEvent.args;\n      const tokens = Balances(state.tokens || {});\n      const lpTokens = Balances(state.lpTokens || {});\n      tokens.sub(liquidityProvider, amount.toString());\n      lpTokens.sub(liquidityProvider, lpTokensBurnt.toString());\n      return {\n        ...state,\n        tokens: {\n          ...tokens.balances,\n        },\n        lpTokens: {\n          ...lpTokens.balances,\n        },\n      };\n    }\n    // event DepositRelayed( bytes32 indexed depositHash, DepositData depositData, address l1Token, RelayData relay, bytes32 relayAncillaryDataHash);\n    case \"DepositRelayed\": {\n      const typedEvent = event as DepositRelayed;\n      const { depositHash, depositData, relay, relayAncillaryDataHash } = typedEvent.args;\n      return {\n        ...state,\n        relays: {\n          ...state.relays,\n          [relayAncillaryDataHash]: relay,\n        },\n        deposits: {\n          ...state.deposits,\n          [depositHash]: depositData,\n        },\n      };\n    }\n    // event RelaySpedUp(bytes32 indexed depositHash, address indexed instantRelayer, RelayData relay);\n    case \"RelaySpedUp\": {\n      const typedEvent = event as RelaySpedUp;\n      const { depositHash, instantRelayer } = typedEvent.args;\n      return {\n        ...state,\n        instantRelays: {\n          ...(state.instantRelays || {}),\n          [depositHash]: instantRelayer,\n        },\n      };\n    }\n    // event RelayDisputed(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);\n    case \"RelayDisputed\": {\n      // TODO: finish implementation\n      // const typedEvent = event as RelayDisputed;\n      // const { depositHash, relayHash, disputer } = typedEvent.args;\n      return state;\n    }\n    // event RelayCanceled(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);\n    case \"RelayCanceled\": {\n      // TODO: finish implementation\n      // const typedEvent = event as RelayCanceled;\n      // const { depositHash, relayHash, disputer } = typedEvent.args;\n      return state;\n    }\n    // event RelaySettled(bytes32 indexed depositHash, address indexed caller, RelayData relay);\n    case \"RelaySettled\": {\n      // TODO: finish implementation\n      // const typedEvent = event as RelaySettled;\n      // const { depositHash, caller, relay } = typedEvent.args;\n      return state;\n    }\n    // event BridgePoolAdminTransferred(address oldAdmin, address newAdmin);\n    case \"BridgePoolAdminTransferred\": {\n      const typedEvent = event as BridgePoolAdminTransferred;\n      const { oldAdmin, newAdmin } = typedEvent.args;\n      return {\n        ...state,\n        oldAdmin,\n        newAdmin,\n      };\n    }\n  }\n  return state;\n}\nexport function getEventState(events: SerializableEvent[], eventState: EventState = eventStateDefaults()): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import axios from \"axios\";\nimport get from \"lodash/get\";\n\ntype GasPrice = {\n  safeLow: number;\n  standard: number;\n  fast: number;\n  fastest: number;\n  currentBaseFee: number;\n  recommendedBaseFee: number;\n};\n\nexport class Etherchain {\n  constructor(private url = \"https://www.etherchain.org/api\") {}\n\n  public async getGasPrice(): Promise<GasPrice> {\n    try {\n      const endpoint = this.url + \"/gasPriceOracle\";\n      const result = await axios.get(endpoint);\n      return result.data;\n    } catch (err) {\n      const msg = get(err, \"response.data.error\", get(err, \"response.statusText\", \"Unknown Coingecko Error\"));\n      throw new Error(msg);\n    }\n  }\n}\n","import {\n  RateModelStoreEthers,\n  RateModelStoreEthers__factory,\n  getRateModelStoreAddress as getAddress,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider } from \"../..\";\n\nexport type Instance = RateModelStoreEthers;\nexport const Factory = RateModelStoreEthers__factory;\n\nexport { getAddress };\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\nexport function attach(address: string): Instance {\n  return new Factory().attach(address);\n}\n","import {\n  OptimisticOracleInterfaceEthers,\n  OptimisticOracleInterfaceEthers__factory,\n  getOptimisticOracleInterfaceAbi,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event, BigNumberish, utils, BigNumber } from \"ethers\";\n\nexport type Instance = OptimisticOracleInterfaceEthers;\nconst Factory = OptimisticOracleInterfaceEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport const contractInterface = new utils.Interface(getOptimisticOracleInterfaceAbi());\n\nexport type RequestPrice = GetEventType<Instance, \"RequestPrice\">;\nexport type ProposePrice = GetEventType<Instance, \"ProposePrice\">;\nexport type DisputePrice = GetEventType<Instance, \"DisputePrice\">;\nexport type Settle = GetEventType<Instance, \"Settle\">;\n\nexport enum RequestState {\n  Invalid = 0, // Never requested.\n  Requested, // Requested, no other actions taken.\n  Proposed, // Proposed, but not expired or disputed yet.\n  Expired, // Proposed, not disputed, past liveness.\n  Disputed, // Disputed, but no DVM price returned yet.\n  Resolved, // Disputed and DVM price is available.\n  Settled, // Final price has been set in the contract (can get here from Expired or Resolved).\n}\n\n// all events have these values\nexport type RequestKey = {\n  requester: string;\n  identifier: string;\n  timestamp: number;\n  ancillaryData: string;\n};\nexport type Request = RequestKey &\n  // this is partial since we dont know what events we have to populate parts of this\n  Partial<{\n    proposer: string;\n    disputer: string;\n    currency: string;\n    settled: boolean;\n    refundOnDispute: boolean;\n    proposedPrice: BigNumber;\n    resolvedPrice: BigNumber;\n    expirationTime: BigNumber;\n    reward: BigNumber;\n    finalFee: BigNumber;\n    bond: BigNumber;\n    customLiveness: BigNumber;\n    price: BigNumber;\n    payout: BigNumber;\n    state: RequestState;\n    // metadata about the transaction that triggered the state changes\n    requestTx: string;\n    proposeTx: string;\n    disputeTx: string;\n    settleTx: string;\n    requestBlockNumber: number;\n    proposeBlockNumber: number;\n    disputeBlockNumber: number;\n    settleBlockNumber: number;\n    requestLogIndex: number;\n    proposeLogIndex: number;\n    disputeLogIndex: number;\n    settleLogIndex: number;\n  }>;\n\nexport interface EventState {\n  requests?: Record<string, Request>;\n}\n\nexport function requestId(request: Omit<RequestKey, \"timestamp\"> & { timestamp: BigNumberish }): string {\n  // if enabling sorting, put timestamp first\n  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join(\"!\");\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"RequestPrice\": {\n      const typedEvent = event as RequestPrice;\n      const { requester, identifier, timestamp, ancillaryData, currency, reward, finalFee } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        currency,\n        reward,\n        finalFee,\n        state: RequestState.Requested,\n        requestTx: event.transactionHash,\n        requestBlockNumber: event.blockNumber,\n        requestLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"ProposePrice\": {\n      const typedEvent = event as ProposePrice;\n      const {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        proposer,\n        proposedPrice,\n        expirationTimestamp,\n        currency,\n      } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        currency,\n        proposer,\n        proposedPrice,\n        expirationTime: expirationTimestamp,\n        state: RequestState.Proposed,\n        proposeTx: event.transactionHash,\n        proposeBlockNumber: event.blockNumber,\n        proposeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"DisputePrice\": {\n      const typedEvent = event as DisputePrice;\n      const { requester, identifier, timestamp, ancillaryData, proposer, disputer, proposedPrice } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        proposer,\n        disputer,\n        proposedPrice,\n        state: RequestState.Disputed,\n        disputeTx: event.transactionHash,\n        disputeBlockNumber: event.blockNumber,\n        disputeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"Settle\": {\n      const typedEvent = event as Settle;\n      const { requester, identifier, timestamp, ancillaryData, proposer, disputer, price, payout } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        requester,\n        proposer,\n        disputer,\n        price,\n        payout,\n        state: RequestState.Settled,\n        settleTx: event.transactionHash,\n        settleBlockNumber: event.blockNumber,\n        settleLogIndex: event.logIndex,\n      };\n      break;\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import {\n  SkinnyOptimisticOracleEthers,\n  SkinnyOptimisticOracleEthers__factory,\n  getSkinnyOptimisticOracleAbi,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event, BigNumberish, utils, BigNumber } from \"ethers\";\n\nexport type Instance = SkinnyOptimisticOracleEthers;\nconst Factory = SkinnyOptimisticOracleEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport const contractInterface = new utils.Interface(getSkinnyOptimisticOracleAbi());\n\nexport type RequestPrice = GetEventType<Instance, \"RequestPrice\">;\nexport type ProposePrice = GetEventType<Instance, \"ProposePrice\">;\nexport type DisputePrice = GetEventType<Instance, \"DisputePrice\">;\nexport type Settle = GetEventType<Instance, \"Settle\">;\n\nexport enum RequestState {\n  Invalid = 0, // Never requested.\n  Requested, // Requested, no other actions taken.\n  Proposed, // Proposed, but not expired or disputed yet.\n  Expired, // Proposed, not disputed, past liveness.\n  Disputed, // Disputed, but no DVM price returned yet.\n  Resolved, // Disputed and DVM price is available.\n  Settled, // Final price has been set in the contract (can get here from Expired or Resolved).\n}\n\nexport interface SolidityRequest {\n  proposer: string; // Address of the proposer.\n  disputer: string; // Address of the disputer.\n  currency: string; // ERC20 token used to pay rewards and fees.\n  settled: boolean; // True if the request is settled.\n  proposedPrice: BigNumber; // Price that the proposer submitted.\n  resolvedPrice: BigNumber; // Price resolved once the request is settled.\n  expirationTime: BigNumber; // Time at which the request auto-settles without a dispute.\n  reward: BigNumber; // Amount of the currency to pay to the proposer on settlement.\n  finalFee: BigNumber; // Final fee to pay to the Store upon request to the DVM.\n  bond: BigNumber; // Bond that the proposer and disputer must pay on top of the final fee.\n  customLiveness: BigNumber; // Custom liveness value set by the requester.\n}\n\n// all events have these values\nexport type RequestKey = {\n  requester: string;\n  identifier: string;\n  timestamp: number;\n  ancillaryData: string;\n};\nexport type Request = RequestKey &\n  SolidityRequest &\n  // this is partial since we dont know what events we have to populate parts of this\n  Partial<{\n    refundOnDispute: boolean;\n    state: RequestState;\n    // metadata about the transaction that triggered the state changes\n    requestTx: string;\n    proposeTx: string;\n    disputeTx: string;\n    settleTx: string;\n    requestBlockNumber: number;\n    proposeBlockNumber: number;\n    disputeBlockNumber: number;\n    settleBlockNumber: number;\n    requestLogIndex: number;\n    proposeLogIndex: number;\n    disputeLogIndex: number;\n    settleLogIndex: number;\n  }>;\n\nexport interface EventState {\n  requests?: Record<string, Request>;\n}\n\nexport function requestId(request: Omit<RequestKey, \"timestamp\"> & { timestamp: BigNumberish }): string {\n  // if enabling sorting, put timestamp first\n  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join(\"!\");\n}\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"RequestPrice\": {\n      const typedEvent = event as RequestPrice;\n      const { requester, identifier, timestamp, ancillaryData, request } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      state.requests[id] = {\n        // need to maintain previous state in case it exists\n        ...state.requests[id],\n        ...request,\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        state: RequestState.Requested,\n        requestTx: event.transactionHash,\n        requestBlockNumber: event.blockNumber,\n        requestLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"ProposePrice\": {\n      const typedEvent = event as ProposePrice;\n      const { requester, identifier, timestamp, ancillaryData, request } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      state.requests[id] = {\n        ...state.requests[id],\n        ...request,\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        state: RequestState.Proposed,\n        proposeTx: event.transactionHash,\n        proposeBlockNumber: event.blockNumber,\n        proposeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"DisputePrice\": {\n      const typedEvent = event as DisputePrice;\n      const { requester, identifier, timestamp, ancillaryData, request } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      state.requests[id] = {\n        ...state.requests[id],\n        ...request,\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        state: RequestState.Disputed,\n        disputeTx: event.transactionHash,\n        disputeBlockNumber: event.blockNumber,\n        disputeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"Settle\": {\n      const typedEvent = event as Settle;\n      const { requester, identifier, timestamp, ancillaryData, request } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      state.requests[id] = {\n        ...state.requests[id],\n        ...request,\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        state: RequestState.Settled,\n        settleTx: event.transactionHash,\n        settleBlockNumber: event.blockNumber,\n        settleLogIndex: event.logIndex,\n      };\n      break;\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import {\n  OptimisticOracleV2InterfaceEthers,\n  OptimisticOracleV2InterfaceEthers__factory,\n  getOptimisticOracleV2InterfaceAbi,\n} from \"@uma/contracts-node\";\nimport type { SignerOrProvider, GetEventType } from \"../..\";\nimport { Event, BigNumberish, utils, BigNumber } from \"ethers\";\n\nexport type Instance = OptimisticOracleV2InterfaceEthers;\nconst Factory = OptimisticOracleV2InterfaceEthers__factory;\n\nexport function connect(address: string, provider: SignerOrProvider): Instance {\n  return Factory.connect(address, provider);\n}\n\nexport const contractInterface = new utils.Interface(getOptimisticOracleV2InterfaceAbi());\n\nexport type RequestPrice = GetEventType<Instance, \"RequestPrice\">;\nexport type ProposePrice = GetEventType<Instance, \"ProposePrice\">;\nexport type DisputePrice = GetEventType<Instance, \"DisputePrice\">;\nexport type Settle = GetEventType<Instance, \"Settle\">;\n\nexport enum RequestState {\n  Invalid = 0, // Never requested.\n  Requested, // Requested, no other actions taken.\n  Proposed, // Proposed, but not expired or disputed yet.\n  Expired, // Proposed, not disputed, past liveness.\n  Disputed, // Disputed, but no DVM price returned yet.\n  Resolved, // Disputed and DVM price is available.\n  Settled, // Final price has been set in the contract (can get here from Expired or Resolved).\n}\n\n// all events have these values\nexport type RequestKey = {\n  requester: string;\n  identifier: string;\n  timestamp: number;\n  ancillaryData: string;\n};\nexport type RequestSettings = {\n  eventBased: boolean; // True if the request is set to be event-based.\n  refundOnDispute: boolean; // True if the requester should be refunded their reward on dispute.\n  callbackOnPriceProposed: boolean; // True if callbackOnPriceProposed callback is required.\n  callbackOnPriceDisputed: boolean; // True if callbackOnPriceDisputed callback is required.\n  callbackOnPriceSettled: boolean; // True if callbackOnPriceSettled callback is required.\n  bond: BigNumber; // Bond that the proposer and disputer must pay on top of the final fee.\n  customLiveness: BigNumber; // Custom liveness value set by the requester.\n};\nexport type Request = RequestKey &\n  // this is partial since we dont know what events we have to populate parts of this\n  Partial<{\n    proposer: string;\n    disputer: string;\n    currency: string;\n    settled: boolean;\n    refundOnDispute: boolean;\n    proposedPrice: BigNumber;\n    resolvedPrice: BigNumber;\n    expirationTime: BigNumber;\n    reward: BigNumber;\n    finalFee: BigNumber;\n    price: BigNumber;\n    payout: BigNumber;\n    state: RequestState;\n    // metadata about the transaction that triggered the state changes\n    requestTx: string;\n    proposeTx: string;\n    disputeTx: string;\n    settleTx: string;\n    requestBlockNumber: number;\n    proposeBlockNumber: number;\n    disputeBlockNumber: number;\n    settleBlockNumber: number;\n    requestLogIndex: number;\n    proposeLogIndex: number;\n    disputeLogIndex: number;\n    settleLogIndex: number;\n    requestSettings: RequestSettings;\n  }>;\n\nexport interface EventState {\n  requests?: Record<string, Request>;\n}\n\nexport function requestId(request: Omit<RequestKey, \"timestamp\"> & { timestamp: BigNumberish }): string {\n  // if enabling sorting, put timestamp first\n  return [request.timestamp.toString(), request.identifier, request.requester, request.ancillaryData].join(\"!\");\n}\n\nexport function reduceEvents(state: EventState, event: Event): EventState {\n  switch (event.event) {\n    case \"RequestPrice\": {\n      const typedEvent = event as RequestPrice;\n      const { requester, identifier, timestamp, ancillaryData, currency, reward, finalFee } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        currency,\n        reward,\n        finalFee,\n        state: RequestState.Requested,\n        requestTx: event.transactionHash,\n        requestBlockNumber: event.blockNumber,\n        requestLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"ProposePrice\": {\n      const typedEvent = event as ProposePrice;\n      const {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n        proposer,\n        proposedPrice,\n        expirationTimestamp,\n        currency,\n      } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        currency,\n        proposer,\n        proposedPrice,\n        expirationTime: expirationTimestamp,\n        state: RequestState.Proposed,\n        proposeTx: event.transactionHash,\n        proposeBlockNumber: event.blockNumber,\n        proposeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"DisputePrice\": {\n      const typedEvent = event as DisputePrice;\n      const { requester, identifier, timestamp, ancillaryData, proposer, disputer, proposedPrice } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        proposer,\n        disputer,\n        proposedPrice,\n        state: RequestState.Disputed,\n        disputeTx: event.transactionHash,\n        disputeBlockNumber: event.blockNumber,\n        disputeLogIndex: event.logIndex,\n      };\n      break;\n    }\n    case \"Settle\": {\n      const typedEvent = event as Settle;\n      const { requester, identifier, timestamp, ancillaryData, proposer, disputer, price, payout } = typedEvent.args;\n      const id = requestId(typedEvent.args);\n      if (!state.requests) state.requests = {};\n      const request: Request = state.requests[id] || {\n        requester,\n        identifier,\n        timestamp,\n        ancillaryData,\n      };\n      state.requests[id] = {\n        ...request,\n        requester,\n        proposer,\n        disputer,\n        price,\n        payout,\n        state: RequestState.Settled,\n        settleTx: event.transactionHash,\n        settleBlockNumber: event.blockNumber,\n        settleLogIndex: event.logIndex,\n      };\n      break;\n    }\n  }\n  return state;\n}\nexport function getEventState(events: Event[], eventState: EventState = {}): EventState {\n  return events.reduce(reduceEvents, eventState);\n}\n","import type { Store } from \"../index\";\n\nexport default function <I, D>(map: Map<I, D> = new Map<I, D>()): Store<I, D> {\n  async function get(id: I) {\n    return map.get(id);\n  }\n  async function set(id: I, data: D) {\n    map.set(id, data);\n  }\n  async function has(id: I) {\n    return map.has(id);\n  }\n  async function del(id: I) {\n    map.delete(id);\n  }\n  async function entries() {\n    return Array.from(map.entries());\n  }\n  async function values() {\n    return Array.from(map.values());\n  }\n  async function keys() {\n    return Array.from(map.keys());\n  }\n  async function size() {\n    return map.size;\n  }\n  async function clear() {\n    map.clear();\n  }\n  return {\n    get,\n    set,\n    has,\n    delete: del,\n    entries,\n    values,\n    keys,\n    size,\n    clear,\n  };\n}\n","import { sortedIndex, sortedLastIndex } from \"lodash\";\nimport type { SortedStore } from \"../index\";\nimport { exists } from \"../../utils\";\n\n// this class will basically give you similar functionality to a sorted key value store this is really useful for\n// time series data, and JS does not have a native way to do this, but comes for free with most NoSql databases.\nexport default function <Id, Data>(): SortedStore<Id, Data> {\n  const ids: Id[] = [];\n  const map = new Map<Id, Data>();\n\n  function getStart(id: Id, inclusive = true) {\n    if (inclusive) {\n      return sortedIndex(ids, id);\n    } else {\n      return sortedLastIndex(ids, id);\n    }\n  }\n  function getEnd(id: Id, inclusive = false) {\n    return getStart(id, !inclusive);\n  }\n  function del(id: Id) {\n    const index = sortedIndex(ids, id);\n    ids.splice(index, 1);\n    const result = map.get(id);\n    map.delete(id);\n    return result;\n  }\n  // keeps typescript from complaining that return values may be undefined\n  function getSafe(id: Id) {\n    const result = map.get(id);\n    if (exists(result)) return result;\n    throw new Error(\"Missing data for index: \" + id);\n  }\n\n  return {\n    async has(id: Id) {\n      return map.has(id);\n    },\n    async set(id: Id, data: Data) {\n      if (map.has(id)) {\n        map.set(id, data);\n      } else {\n        const index = sortedIndex(ids, id);\n        ids.splice(index, 0, id);\n        map.set(id, data);\n      }\n    },\n    async get(id: Id) {\n      return map.get(id);\n    },\n    async values() {\n      return ids.map(getSafe);\n    },\n    async entries() {\n      return ids.map((id) => [id, getSafe(id)]);\n    },\n    async keys() {\n      return [...ids];\n    },\n    async clear() {\n      map.clear();\n      ids.length = 0;\n    },\n    async size() {\n      return ids.length;\n    },\n    async delete(id: Id) {\n      if (!map.has(id)) return;\n      del(id);\n    },\n    // assume [a,b)\n    async between(a: Id, b: Id) {\n      const start = getStart(a);\n      const end = getEnd(b);\n      return ids.slice(start, end).map(getSafe);\n    },\n    async slice(id: Id, length: number) {\n      const start = getStart(id);\n      return ids.slice(start, start + length).map(getSafe);\n    },\n  };\n}\n","import { exists } from \"../../utils\";\nimport type { SortedStore } from \"..\";\nimport { Datastore, Key } from \"@google-cloud/datastore\";\nimport highland from \"highland\";\n\n//-\n// Use an array, `excludeFromIndexes`, to exclude properties from indexing.\n// This will allow storing string values larger than 1500 bytes.\n// Example:\n// [\n//   'description',\n//   'embeddedEntity.description',\n//   'arrayValue[]',\n//   'arrayValue[].description'\n// ]\n//-\nexport default function <I extends string | number, D>(\n  kind: string,\n  store: Datastore,\n  excludeFromIndexes: string[] = []\n): SortedStore<I, D> {\n  function makeKey(id: I): Key {\n    return store.key([kind, id]);\n  }\n  // return value or undefined if it doesnt exist\n  async function get(id: I) {\n    try {\n      const [result] = await store.get(makeKey(id));\n      return result;\n    } catch (err) {\n      return;\n    }\n  }\n  async function set(id: I, data: D) {\n    await store.save({\n      key: makeKey(id),\n      data,\n      excludeFromIndexes,\n    });\n  }\n  async function has(id: I) {\n    // horribly ineficient to actually query data to see if it exists, but cannot find a better way\n    return exists(await get(id));\n  }\n  async function del(id: I) {\n    await store.delete(makeKey(id));\n  }\n  async function entries() {\n    const [results] = await store.createQuery(kind).run();\n    return results.map((result) => {\n      return [result[store.KEY].name, result];\n    }) as [I, D][];\n  }\n  async function values() {\n    const [results] = await store.createQuery(kind).run();\n    return results;\n  }\n  // all this does is map over full entries to return the id of the entry. have not found a better way to query this.\n  async function keys() {\n    const [results] = await store.createQuery(kind).select(\"__key__\").run();\n    return results.map((result) => {\n      return result[store.KEY].name;\n    }) as I[];\n  }\n  // theres no way to really do built into the store client. Google recommends managing a size entry yourself.\n  async function size(): Promise<number> {\n    throw new Error(\"size not supported in google store\");\n  }\n  // this actually queries all values, then batches them to delete N at a time. This is a horrible way\n  // to do this, but I could not find a better way to \"drop\" all kinds from the table.\n  async function clear() {\n    await highland(store.createQuery(kind).runStream())\n      .map((val: any) => {\n        return val[store.KEY];\n      })\n      .batch(500)\n      .map(async (keys) => {\n        return store.delete(keys);\n      })\n      .flatMap(highland)\n      .collect()\n      .toPromise(Promise);\n  }\n  async function slice(id: I, length: number) {\n    const [result] = await store.createQuery(kind).filter(\"__key__\", \">=\", makeKey(id)).limit(length).run();\n    return result;\n  }\n  async function between(a: I, b: I) {\n    const [result] = await store\n      .createQuery(kind)\n      .filter(\"__key__\", \">=\", makeKey(a))\n      .filter(\"__key__\", \"<\", makeKey(b))\n      .run();\n    return result;\n  }\n\n  return {\n    get,\n    set,\n    has,\n    delete: del,\n    entries,\n    values,\n    keys,\n    size,\n    clear,\n    between,\n    slice,\n  };\n}\n","import assert from \"assert\";\nimport { exists } from \"../../utils\";\nimport type { stores, MakeId, MaybeId, HasId } from \"../..\";\n\n// This interface has to be implemented manually in order to have control over the types of the \"overloaded\" functions\ninterface KnownReturnMembers<I, D> {\n  create: (data: D & MaybeId<I>) => Promise<D & HasId<I>>;\n  set: (data: D & HasId<I>) => Promise<D & HasId<I>>;\n  get: (id: I) => Promise<D & { id: I }>;\n  has: (id: I) => Promise<boolean>;\n  update: (id: I, data: Partial<D>) => Promise<D & HasId<I>>;\n}\n\n// The final type composes the types defined explicitly and those from the implemented interface\ntype TableReturnType<I, D, S> = KnownReturnMembers<I, D> & Omit<S, keyof KnownReturnMembers<I, D>>;\n\nexport default function Table<I, D, S extends stores.Store<I, D>>(\n  config: { makeId: MakeId<I, D>; type: string },\n  store: S\n): TableReturnType<I, D, S> {\n  const { makeId, type } = config;\n  async function create(data: D & MaybeId<I>) {\n    const id = exists(data.id) ? data.id : makeId(data);\n    assert(!(await has(id)), `${type} exists: ` + id);\n    return set({ id, ...data });\n  }\n  async function set(data: D & HasId<I>) {\n    await store.set(data.id, { ...data });\n    return data;\n  }\n  async function get(id: I) {\n    assert(await store.has(id), `${type} does not exist`);\n    return ((await store.get(id)) as unknown) as D & { id: I };\n  }\n  async function has(id: I) {\n    return store.has(id);\n  }\n  async function update(id: I, data: Partial<D>) {\n    const got = await get(id);\n    return set({ ...got, ...data });\n  }\n  return {\n    ...store,\n    create,\n    set,\n    get,\n    has,\n    update,\n    makeId,\n    type,\n  };\n}\n","export function makeId(data: Pick<Data, \"number\">) {\n  return data.number;\n}\n\nexport type Data = {\n  id?: number;\n  number: number;\n  hash: string;\n  // block time is in seconds\n  timestamp: number;\n};\n","import { Data, makeId } from \"./utils\";\nimport BaseTable from \"../base\";\nimport { JsMap } from \"../../stores\";\nimport type { Store } from \"../../stores\";\n\n// personally dont like to have this as a named export, but cannot export both function and type as default\nexport const Table = (type = \"Block\", store: Store<number, Data> = JsMap<number, Data>()) => {\n  const table = BaseTable<number, Data, Store<number, Data>>({ type, makeId }, store);\n\n  // delete blocks older than timestamp\n  async function prune(timestamp: number) {\n    const blocks = await table.values();\n    const deleted: Data[] = [];\n    // normally would use a map or filter, but dont want to include bluebird as a dependency\n    for (const block of blocks) {\n      if (block.timestamp < timestamp) {\n        await table.delete(block.id ?? block.number);\n        deleted.push(block);\n      }\n    }\n    return deleted;\n  }\n\n  return {\n    ...table,\n    prune,\n  };\n};\nexport type Table = ReturnType<typeof Table>;\n","export function makeId(data: Pick<Data, \"address\">) {\n  return data.address;\n}\n\nexport type Data = {\n  id?: string;\n  name?: string | null;\n  address: string;\n  priceIdentifier?: string | null;\n  expirationTimestamp?: string | null;\n  withdrawalLiveness?: string | null;\n  tokenCurrency?: string | null;\n  collateralCurrency?: string | null;\n  collateralRequirement?: string | null;\n  disputeBondPercentage?: string | null;\n  sponsorDisputeRewardPercentage?: string | null;\n  disputerDisputeRewardPercentage?: string | null;\n  cumulativeFeeMultiplier?: string | null;\n  tokenDecimals?: number | null;\n  collateralDecimals?: number | null;\n  totalTokensOutstanding?: string | null;\n  totalPositionCollateral?: string | null;\n  minSponsorTokens?: string | null;\n  expiryPrice?: string | null;\n  sponsors?: string[] | null;\n  gcr?: string | null;\n  expired?: boolean | null;\n  createdTimestamp?: number | null;\n};\n","import { Data, makeId } from \"./utils\";\nimport BaseTable from \"../base\";\nimport type { Store } from \"../../stores\";\nimport { JsMap } from \"../../stores\";\n\nexport const Table = (type = \"Emp\", store: Store<string, Data> = JsMap()) => {\n  const table = BaseTable<string, Data, Store<string, Data>>({ type, makeId }, store);\n\n  async function addSponsors(id: string, sponsors: string[]) {\n    const data = await table.get(id);\n    // keep sponsors unique\n    const set = new Set([...(data.sponsors || []), ...sponsors]);\n    return table.update(id, { sponsors: Array.from(set.values()) });\n  }\n\n  async function setCreatedTimestamp(id: string, timestamp: number) {\n    return table.update(id, { createdTimestamp: timestamp });\n  }\n\n  return {\n    ...table,\n    addSponsors,\n    setCreatedTimestamp,\n  };\n};\n// want to export the type as the same name\nexport type Table = ReturnType<typeof Table>;\n","export function makeId(data: Pick<Data, \"timestamp\">) {\n  return data.timestamp.toString().padStart(24, \"0\");\n}\n\nexport type Data = {\n  id?: string;\n  timestamp: number;\n  price: string;\n};\n","import { Data, makeId } from \"./utils\";\nimport BaseTable from \"../base\";\nimport { SortedJsMap } from \"../../stores\";\nimport type { SortedStore } from \"../../stores\";\n\nexport const Table = (type = \"Historical Price\", store: SortedStore<string, Data> = SortedJsMap()) => {\n  const table = BaseTable<string, Data, SortedStore<string, Data>>({ type, makeId }, store);\n  function betweenByTimestamp(a: number, b: number) {\n    return table.between(makeId({ timestamp: a }), makeId({ timestamp: b }));\n  }\n  function sliceByTimestamp(timestamp: number, length: number) {\n    return table.slice(makeId({ timestamp }), length);\n  }\n  function hasByTimestamp(timestamp: number) {\n    return table.has(makeId({ timestamp }));\n  }\n  function getByTimestamp(timestamp: number) {\n    return table.get(makeId({ timestamp }));\n  }\n  return {\n    ...table,\n    betweenByTimestamp,\n    sliceByTimestamp,\n    hasByTimestamp,\n    getByTimestamp,\n  };\n};\nexport type Table = ReturnType<typeof Table>;\n","export function makeId(data: Pick<Data, \"address\">) {\n  return data.address;\n}\n\nexport type Data = {\n  id?: string;\n  address: string;\n  decimals?: number;\n  name?: string;\n  totalSupply?: string;\n  symbol?: string;\n};\n","import { Data, makeId } from \"./utils\";\nimport BaseTable from \"../base\";\nimport { JsMap } from \"../../stores\";\nimport type { Store } from \"../../stores\";\n\nexport const Table = (type = \"Token\", store: Store<string, Data> = JsMap()) => {\n  const table = BaseTable<string, Data, Store<string, Data>>({ type, makeId }, store);\n  async function getOrCreate(address: string) {\n    if (!(await table.has(makeId({ address })))) return table.create({ address });\n    return table.get(makeId({ address }));\n  }\n  async function upsert(address: string, data: Partial<Data>) {\n    await getOrCreate(address);\n    return table.update(address, data);\n  }\n  return {\n    ...table,\n    getOrCreate,\n    upsert,\n  };\n};\nexport type Table = ReturnType<typeof Table>;\n","import { BigNumber, ethers } from \"ethers\";\nimport { ConvertDecimals } from \"../utils\";\nimport Decimal from \"decimal.js\";\n\nexport type BigNumberish = string | number | BigNumber;\nexport type BN = BigNumber;\nexport type Decimalish = string | number | Decimal;\n\n/**\n * toBN.\n *\n * @param {BigNumberish} num\n * @returns {BN}\n */\nexport const toBN = (num: BigNumberish): BN => BigNumber.from(num.toString());\n/**\n * toBNWei.\n *\n * @param {BigNumberish} num\n * @param {number} decimals\n * @returns {BN}\n */\nexport const toBNWei = (num: BigNumberish, decimals?: number): BN => ethers.utils.parseUnits(num.toString(), decimals);\n/**\n * toWei.\n *\n * @param {BigNumberish} num\n * @param {number} decimals\n * @returns {string}\n */\nexport const toWei = (num: BigNumberish, decimals?: number): string => toBNWei(num, decimals).toString();\n/**\n * fromWei.\n *\n * @param {BigNumberish} num\n * @param {number} decimals\n * @returns {string}\n */\nexport const fromWei = (num: BigNumberish, decimals?: number): string =>\n  ethers.utils.formatUnits(num.toString(), decimals);\n\n/**\n * min.\n *\n * @param {BigNumberish} a\n * @param {BigNumberish} b\n * @returns {BN}\n */\nexport function min(a: BigNumberish, b: BigNumberish): BN {\n  const bna = toBN(a);\n  const bnb = toBN(b);\n  return bna.lte(bnb) ? bna : bnb;\n}\n/**\n * max.\n *\n * @param {BigNumberish} a\n * @param {BigNumberish} b\n * @returns {BN}\n */\nexport function max(a: BigNumberish, b: BigNumberish): BN {\n  const bna = toBN(a);\n  const bnb = toBN(b);\n  return bna.gte(bnb) ? bna : bnb;\n}\n\nexport const fixedPointAdjustment = toBNWei(\"1\");\n\n/**\n * Convert an amount of eth into a token given price and token decimals.\n *\n * @param {BigNumberish} fromAmount - Amount of eth to convert.\n * @param {string | number} [ price=1 ] - The price as eth per token, ie how much eth can 1 token buy.\n * @param {} [ toDecimals=18 ] - Number of decimals for the token currency.\n * @returns {string} The number of tokens denominated in token decimals in the smallest unit (wei).\n */\nexport function ethToToken(fromAmount: BigNumberish, price: string | number = 1, toDecimals = 18): string {\n  const priceWei = toBNWei(price);\n  const toAmount = toBNWei(fromAmount).div(priceWei);\n  return ConvertDecimals(18, toDecimals)(toAmount);\n}\n\n/**\n * Convert a gas amount and gas price to wei.\n *\n * @param {number} gas - gas amount.\n * @param {BigNumberish} gasPrice - gas price in gwei.\n * @returns {BigNumber} - total fees in wei.\n */\nexport const gasToEth = (gas: number, gasPrice: BigNumberish): BigNumber => {\n  return BigNumber.from(gas).mul(gasPrice);\n};\n\n/**\n * getGasFees. Low level pure function call to calculate gas fees.\n *\n * @param {number} gas - The gast cost for transfer, use constants defined in file.\n * @param {BigNumberish} gasPrice - Estimated gas price in wei.\n * @param {string | number} [price = 1] - The price of the token in eth, how much eth can 1 token buy.\n * @param {number} [decimals=18] - Number of decimals of token.\n * @returns {string} - The value of fees native to the token/eth provided, in its smallest unit.\n */\nexport function calculateGasFees(\n  gas: number,\n  gasPrice: BigNumberish,\n  price: string | number = 1,\n  decimals = 18\n): string {\n  const amountEth = gasToEth(gas, gasPrice);\n  return ethToToken(amountEth, price, decimals);\n}\n\n/**\n * percent.\n *\n * @param {BigNumberish} numerator\n * @param {BigNumberish} denominator\n * @returns {BN}\n */\nexport function percent(numerator: BigNumberish, denominator: BigNumberish): BN {\n  return fixedPointAdjustment.mul(numerator).div(denominator);\n}\n\n/**\n * calcContinuousCompoundInterest. From https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=0&t=1&given_data_last=find_r&action=solve\n * Returns a yearly interest rate if start/end amount had been continuously compounded over the period elapsed. Multiply result by 100 for a %.\n *\n * @param {string} startAmount\n * @param {string} endAmount\n * @param {string} periodsElapsed\n * @param {string} periodsPerYear\n */\nexport const calcContinuousCompoundInterest = (\n  startAmount: Decimalish,\n  endAmount: Decimalish,\n  periodsElapsed: Decimalish,\n  periodsPerYear: Decimalish\n): string => {\n  const years = new Decimal(periodsPerYear).div(periodsElapsed);\n  return new Decimal(endAmount).div(startAmount).ln().div(years).toString();\n};\n/**\n * calcPeriodicCompoundInterest. Taken from https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=365&t=1&given_data_last=find_r&action=solve\n * This will return a periodically compounded interest rate for 1 year. Multiply result by 100 for a %.\n *\n * @param {string} startAmount - Starting amount or price\n * @param {string} endAmount - Ending amount or price\n * @param {string} periodsElapsed - How many periods elapsed for the start and end amount.\n * @param {string} periodsPerYear - How many periods in 1 year.\n */\nexport const calcPeriodicCompoundInterest = (\n  startAmount: Decimalish,\n  endAmount: Decimalish,\n  periodsElapsed: Decimalish,\n  periodsPerYear: Decimalish\n): string => {\n  const n = new Decimal(periodsPerYear);\n  const A = new Decimal(endAmount);\n  const P = new Decimal(startAmount);\n  const t = new Decimal(periodsPerYear).div(periodsElapsed);\n  const one = new Decimal(1);\n  return n\n    .mul(\n      A.div(P)\n        .pow(one.div(n.div(t)))\n        .sub(one)\n    )\n    .toString();\n};\n\n/**\n * calcApr. Simple apr calculation based on extrapolating the difference for a short period over a year.\n *\n * @param {Decimalish} startAmount - Starting amount or price\n * @param {Decimalish} endAmount - Ending amount or price\n * @param {Decimalish} periodsElapsed - periods elapsed from start to end\n * @param {Decimalish} periodsPerYear - periods per year\n */\nexport const calcApr = (\n  startAmount: Decimalish,\n  endAmount: Decimalish,\n  periodsElapsed: Decimalish,\n  periodsPerYear: Decimalish\n): string => {\n  return new Decimal(endAmount).sub(startAmount).div(startAmount).mul(periodsPerYear).div(periodsElapsed).toString();\n};\n","// This Util calculates the across realized LP fees. See https://gist.github.com/chrismaree/a713725e4fe96c531c42ed7b629d4a85\n// gist for a python implementation of the logic in this file. This implementation is designed to work with both web3.js\n// and ethers BNs in the main entry point function calculateRealizedLpFeePct.\n\nimport Decimal from \"decimal.js\";\nimport { BigNumberish, BN, toBN, toBNWei, fromWei, min, max, fixedPointAdjustment } from \"./utils\";\n\n// note a similar type exists in the constants file, but are strings only. This is a bit more permissive to allow\n// backward compatibility for callers with a rate model defined with bignumbers and not strings.\nexport interface RateModel {\n  UBar: BigNumberish; // denote the utilization kink along the rate model where the slope of the interest rate model changes.\n  R0: BigNumberish; // is the interest rate charged at 0 utilization\n  R1: BigNumberish; // R_0+R_1 is the interest rate charged at UBar\n  R2: BigNumberish; // R_0+R_1+R_2 is the interest rate charged at 100% utilization\n}\n\n// Calculate the rate for a 0 sized deposit (infinitesimally small).\nexport function calculateInstantaneousRate(rateModel: RateModel, utilization: BigNumberish) {\n  const beforeKink = min(utilization, rateModel.UBar).mul(rateModel.R1).div(rateModel.UBar);\n  const afterKink = max(toBN(\"0\"), toBN(utilization).sub(rateModel.UBar))\n    .mul(rateModel.R2)\n    .div(toBNWei(\"1\").sub(rateModel.UBar));\n\n  return toBN(rateModel.R0).add(beforeKink).add(afterKink);\n}\n\n//  Compute area under curve of the piece-wise linear rate model.\nfunction calculateAreaUnderRateCurve(rateModel: RateModel, utilization: BN) {\n  // Area under first piecewise component\n  const utilizationBeforeKink = min(utilization, rateModel.UBar);\n  const rectangle1Area = utilizationBeforeKink.mul(rateModel.R0).div(fixedPointAdjustment);\n  const triangle1Area = toBNWei(\"0.5\")\n    .mul(calculateInstantaneousRate(rateModel, utilizationBeforeKink).sub(rateModel.R0))\n    .mul(utilizationBeforeKink)\n    .div(fixedPointAdjustment)\n    .div(fixedPointAdjustment);\n\n  // Area under second piecewise component\n  const utilizationAfter = max(toBN(\"0\"), utilization.sub(rateModel.UBar));\n  const rectangle2Area = utilizationAfter.mul(toBN(rateModel.R0).add(rateModel.R1)).div(fixedPointAdjustment);\n  const triangle2Area = toBNWei(\"0.5\")\n    .mul(calculateInstantaneousRate(rateModel, utilization).sub(toBN(rateModel.R0).add(rateModel.R1)))\n    .mul(utilizationAfter)\n    .div(fixedPointAdjustment)\n    .div(fixedPointAdjustment);\n\n  return rectangle1Area.add(triangle1Area).add(rectangle2Area).add(triangle2Area);\n}\n\n// converts an APY rate to a one week rate. Uses the Decimal library to take a fractional exponent\nfunction convertApyToWeeklyFee(apy: BN) {\n  // R_week = (1 + apy)^(1/52) - 1\n  const weeklyFeePct = Decimal.pow(\n    new Decimal(\"1\").plus(fromWei(apy)),\n    new Decimal(\"1\").dividedBy(new Decimal(\"52\"))\n  ).minus(new Decimal(\"1\"));\n\n  // Convert from decimal back to BN, scaled by 1e18.\n  return toBN(weeklyFeePct.times(fixedPointAdjustment.toString()).floor().toString());\n}\n\n// Calculate the realized yearly LP Fee APY Percent for a given rate model, utilization before and after the deposit.\nexport function calculateApyFromUtilization(\n  rateModel: RateModel,\n  utilizationBeforeDeposit: BN,\n  utilizationAfterDeposit: BN\n) {\n  if (utilizationBeforeDeposit.eq(utilizationAfterDeposit)) throw new Error(\"Deposit cant have zero size\");\n\n  // Get the area of [0, utilizationBeforeDeposit] and [0, utilizationAfterDeposit]\n  const areaBeforeDeposit = calculateAreaUnderRateCurve(rateModel, utilizationBeforeDeposit);\n  const areaAfterDeposit = calculateAreaUnderRateCurve(rateModel, utilizationAfterDeposit);\n\n  const numerator = areaAfterDeposit.sub(areaBeforeDeposit);\n  const denominator = utilizationAfterDeposit.sub(utilizationBeforeDeposit);\n  return numerator.mul(fixedPointAdjustment).div(denominator);\n}\n\nexport function calculateRealizedLpFeePct(\n  rateModel: RateModel,\n  utilizationBeforeDeposit: BigNumberish,\n  utilizationAfterDeposit: BigNumberish\n) {\n  const apy = calculateApyFromUtilization(rateModel, toBN(utilizationBeforeDeposit), toBN(utilizationAfterDeposit));\n  return convertApyToWeeklyFee(apy);\n}\n","import { ethers } from \"ethers\";\n// these gas costs are estimations, its possible to provide better estimations yourself when invoking getGasFees.\nexport const SLOW_ETH_GAS = 243177;\nexport const SLOW_ERC_GAS = 250939;\nexport const SLOW_UMA_GAS = 273955;\n\n// fast costs are slightly higher and include the slow cost\nexport const FAST_ETH_GAS = 273519;\nexport const FAST_ERC_GAS = 281242;\nexport const FAST_UMA_GAS = 305572;\n\nexport const SPEED_UP_ETH_GAS = 195288;\nexport const SPEED_UP_ERC_GAS = 203011;\nexport const SPEED_UP_UMA_GAS = 227341;\n\n// Bots incur lower than expected costs due to batching mulitple transactions, this roughly estimates the savings\nexport const DEFAULT_GAS_DISCOUNT = 25;\n\nexport const expectedRateModelKeys = [\"UBar\", \"R0\", \"R1\", \"R2\"];\n\n// Amount of blocks to wait following a `TokensBridged` L2 event until we check the L1 state commitment contracts. This\n// offset provides a buffer to allow for any time delay between L2 state changing and L1 state updating. For example,\n// Optimism has a several hour delay.\nexport const L2_STATE_COMMITMENT_DELAY_BLOCKS = 25000;\n\nexport interface RateModel {\n  UBar: string; // denote the utilization kink along the rate model where the slope of the interest rate model changes.\n  R0: string; // is the interest rate charged at 0 utilization\n  R1: string; // R_0+R_1 is the interest rate charged at UBar\n  R2: string; // R_0+R_1+R_2 is the interest rate charged at 100% utilization\n}\n\nexport const AddressZero = ethers.constants.AddressZero;\n// mainnet addresses, hard coded here for convenience, but theres probably a better pattern for this\nexport const ADDRESSES = {\n  ETH: AddressZero,\n  UMA: \"0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828\",\n  WETH: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n  USDC: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n  RateModel: \"0xd18fFeb5fdd1F2e122251eA7Bf357D8Af0B60B50\",\n};\n\nexport const SECONDS_PER_YEAR = 31557600; // based on 365.25 days per year\nexport const DEFAULT_BLOCK_DELTA = 10; // look exchange rate up based on 10 block difference by default\n","import { expectedRateModelKeys, RateModel } from \"./constants\";\nimport { exists } from \"../utils\";\nimport { ethers } from \"ethers\";\n\n// Each L1 token is mapped to an array of stringified rate models, ordered by the block height at which they were\n// published on-chain. This dictionary is used internally to fetch a rate model for a block height.\ntype RateModelEventsDictionary = {\n  [l1TokenAddress: string]: { blockNumber: number; rateModel: string }[];\n};\n\n// Events should be reformatted into this shape to be used as input into methods in this file.\nexport type RateModelEvent = {\n  blockNumber: number;\n  transactionIndex: number;\n  logIndex: number;\n  rateModel: string;\n  l1Token: string;\n};\n\nexport class RateModelDictionary {\n  public rateModelDictionary: RateModelEventsDictionary = {};\n\n  private _throwIfNotInitialized() {\n    if (Object.keys(this.rateModelDictionary).length == 0)\n      throw new Error(\"RateModelUtility method called before updating rate model dictionary!\");\n  }\n\n  updateWithEvents(rateModelEvents: RateModelEvent[]): void {\n    this.rateModelDictionary = createRateModelEventDictionary(rateModelEvents);\n  }\n\n  /**\n   * Return the rate model for L1 token set at the block height.\n   * @param l1Token L1 token address to get rate model for.\n   * @param blockNumber Block height to get rate model for.\n   * @returns Rate model object.\n   */\n  getRateModelForBlockNumber(l1Token: string, blockNumber?: number): RateModel {\n    this._throwIfNotInitialized();\n\n    const l1TokenNormalized = ethers.utils.getAddress(l1Token);\n\n    if (!this.rateModelDictionary[l1TokenNormalized] || this.rateModelDictionary[l1TokenNormalized].length === 0)\n      throw new Error(`No updated rate model events for L1 token: ${l1TokenNormalized}`);\n\n    if (!blockNumber) {\n      // If block number is undefined, use latest updated rate model.\n      return parseAndReturnRateModelFromString(this.rateModelDictionary[l1TokenNormalized].slice(-1)[0].rateModel);\n    } else {\n      const firstEventBlockNumber = this.rateModelDictionary[l1TokenNormalized][0].blockNumber;\n      if (blockNumber < firstEventBlockNumber) {\n        throw new Error(\n          `Block number #${blockNumber} is before first UpdatedRateModel event block ${firstEventBlockNumber}`\n        );\n      }\n\n      // We're looking for the latest rate model update that occurred at or before the block number.\n      // Rate model events are inserted into the array from oldest at index 0 to newest at index length-1, so we'll\n      // reverse the array so it goes from newest at index 0 to oldest at index length-1, and then find the first event\n      // who's block number is less than or equal to the target block number.\n      const rateModel = this.rateModelDictionary[l1TokenNormalized]\n        .slice()\n        .reverse() // reverse() modifies memory in place so create a copy first.\n        .find((event) => event.blockNumber <= blockNumber);\n\n      if (!rateModel)\n        throw new Error(`No updated rate model events before block #${blockNumber} for L1 token: ${l1TokenNormalized}`);\n      return parseAndReturnRateModelFromString(rateModel?.rateModel);\n    }\n  }\n\n  /**\n   * @notice Return all L1 tokens that had a rate model associated with it at the block number.\n   * @param blockNumber Returns l1 tokens that were mapped to a rate model at this block height. If undefined,\n   * this function will return all L1 tokens that have a block number as of the latest block height.\n   * @returns array of L1 token addresses.\n   */\n  getL1TokensFromRateModel(blockNumber: number | undefined = undefined): string[] {\n    this._throwIfNotInitialized();\n\n    return Object.keys(this.rateModelDictionary)\n      .map((l1Token) => {\n        const l1TokenNormalized = ethers.utils.getAddress(l1Token);\n\n        // Check that there is at least one UpdatedRateModel event before the provided block number, otherwise\n        // this L1 token didn't exist in the RateModel at the block height and we shouldn't include it in the returned\n        // array.\n        if (\n          !blockNumber ||\n          this.rateModelDictionary[l1TokenNormalized].find((event) => event.blockNumber <= blockNumber)\n        )\n          return ethers.utils.getAddress(l1Token);\n        else return null;\n      })\n      .filter(exists);\n  }\n}\n/**\n * Helper method that returns parsed rate model from string, or throws.\n * @param rateModelString Stringified rate model to parse.\n * @returns Rate model object. Must conform to `expectedRateModelKeys` format.\n */\n\nexport const parseAndReturnRateModelFromString = (rateModelString: string): RateModel => {\n  const rateModelFromEvent = JSON.parse(rateModelString);\n\n  // Rate model must contain the exact same keys in `expectedRateModelKeys`.\n  for (const key of expectedRateModelKeys) {\n    if (!Object.keys(rateModelFromEvent).includes(key)) {\n      throw new Error(\n        `Rate model does not contain all expected keys. Expected keys: [${expectedRateModelKeys}], actual keys: [${Object.keys(\n          rateModelFromEvent\n        )}]`\n      );\n    }\n  }\n  for (const key of Object.keys(rateModelFromEvent)) {\n    if (!expectedRateModelKeys.includes(key)) {\n      throw new Error(\n        `Rate model contains unexpected keys. Expected keys: [${expectedRateModelKeys}], actual keys: [${Object.keys(\n          rateModelFromEvent\n        )}]`\n      );\n    }\n  }\n\n  return {\n    UBar: rateModelFromEvent.UBar,\n    R0: rateModelFromEvent.R0,\n    R1: rateModelFromEvent.R1,\n    R2: rateModelFromEvent.R2,\n  };\n};\n\n/**\n * Given an unsorted array of updated rate model events, return a dictionary mapping token addresses to sorted\n * rate model events. This method is used internally to enforce chronological sorting of events and mapping rate models\n * to token addresses.\n * @param rateModelEvents Unsorted updated rate model events, each of which contains a token address, the stringified\n * rate model for that token, and the block height of the update.\n * @returns Dictionary mapping token addresses to chronologically sorted rate model updates.\n */\nconst createRateModelEventDictionary = (rateModelEvents: RateModelEvent[]): RateModelEventsDictionary => {\n  const updatedRateModelEventsForToken: RateModelEventsDictionary = {};\n\n  // Sort events in-place from oldest to newest:\n  rateModelEvents.sort((a, b) => {\n    if (a.blockNumber !== b.blockNumber) {\n      return a.blockNumber - b.blockNumber;\n    }\n\n    if (a.transactionIndex !== b.transactionIndex) {\n      return a.transactionIndex - b.transactionIndex;\n    }\n\n    return a.logIndex - b.logIndex;\n  });\n\n  for (const updatedRateModelEvent of rateModelEvents) {\n    // The contract enforces that all rate models are mapped to addresses, therefore we do not need to check that\n    // `l1Token` is a valid address.\n    const l1TokenNormalized = ethers.utils.getAddress(updatedRateModelEvent.l1Token);\n    if (!updatedRateModelEventsForToken[l1TokenNormalized]) updatedRateModelEventsForToken[l1TokenNormalized] = [];\n\n    // We assume that events are returned from oldest to newest, so we can simply push events into the array and\n    // and maintain their time order.\n    updatedRateModelEventsForToken[l1TokenNormalized].push({\n      blockNumber: updatedRateModelEvent.blockNumber,\n      rateModel: updatedRateModelEvent.rateModel,\n    });\n  }\n\n  return updatedRateModelEventsForToken;\n};\n","import assert from \"assert\";\nimport sortedIndexBy from \"lodash/sortedIndexBy\";\nimport clamp from \"lodash/clamp\";\nimport { estimateBlocksElapsed } from \"./utils\";\n\nexport type WithoutStringTimestamp<T extends { timestamp: number | string }> = T & { timestamp: number };\n\nexport default class BlockFinder<T extends { number: number; timestamp: number | string }> {\n  constructor(\n    private readonly requestBlock: (requestedBlock: string | number) => Promise<T>,\n    private readonly blocks: T[] = [],\n    private readonly chainId: number = 1\n  ) {\n    assert(requestBlock, \"requestBlock function must be provided\");\n  }\n\n  /**\n   * @notice Gets the latest block whose timestamp is <= the provided timestamp.\n   * @param {number} timestamp timestamp to search.\n   */\n  public async getBlockForTimestamp(timestamp: number | string): Promise<T> {\n    timestamp = Number(timestamp);\n    assert(timestamp !== undefined && timestamp !== null, \"timestamp must be provided\");\n    // If the last block we have stored is too early, grab the latest block.\n    if (this.blocks.length === 0 || this.blocks[this.blocks.length - 1].timestamp < timestamp) {\n      const block = await this.getLatestBlock();\n      if (timestamp >= block.timestamp) return block;\n    }\n\n    // Check the first block. If it's greater than our timestamp, we need to find an earlier block.\n    if (this.blocks[0].timestamp > timestamp) {\n      const initialBlock = this.blocks[0] as WithoutStringTimestamp<T>;\n      // We use a 2x cushion to reduce the number of iterations in the following loop and increase the chance\n      // that the first block we find sets a floor for the target timestamp. The loop converges on the correct block\n      // slower than the following incremental search performed by `findBlock`, so we want to minimize the number of\n      // loop iterations in favor of searching more blocks over the `findBlock` search.\n      const cushion = 1;\n      const incrementDistance = Math.max(\n        // Ensure the increment block distance is _at least_ a single block to prevent an infinite loop.\n        await estimateBlocksElapsed(initialBlock.timestamp - timestamp, cushion, this.chainId),\n        1\n      );\n\n      // Search backwards by a constant increment until we find a block before the timestamp or hit block 0.\n      for (let multiplier = 1; ; multiplier++) {\n        const distance = multiplier * incrementDistance;\n        const blockNumber = Math.max(0, initialBlock.number - distance);\n        const block = await this.getBlock(blockNumber);\n        if (block.timestamp <= timestamp) break; // Found an earlier block.\n        assert(blockNumber > 0, \"timestamp is before block 0\"); // Block 0 was not earlier than this timestamp. The row.\n      }\n    }\n\n    // Find the index where the block would be inserted and use that as the end block (since it is >= the timestamp).\n    const index = sortedIndexBy(this.blocks, { timestamp } as T, \"timestamp\");\n    return this.findBlock(this.blocks[index - 1], this.blocks[index], timestamp);\n  }\n\n  // Grabs the most recent block and caches it.\n  private async getLatestBlock() {\n    const block = await this.requestBlock(\"latest\");\n    const index = sortedIndexBy(this.blocks, block, \"number\");\n    if (this.blocks[index]?.number !== block.number) this.blocks.splice(index, 0, block);\n    return this.blocks[index];\n  }\n\n  // Grabs the block for a particular number and caches it.\n  private async getBlock(number: number) {\n    let index = sortedIndexBy(this.blocks, { number } as T, \"number\");\n    if (this.blocks[index]?.number === number) return this.blocks[index]; // Return early if block already exists.\n    const block = await this.requestBlock(number);\n\n    // Recompute the index after the async call since the state of this.blocks could have changed!\n    index = sortedIndexBy(this.blocks, { number } as T, \"number\");\n\n    // Rerun this check to avoid duplicate insertion.\n    if (this.blocks[index]?.number === number) return this.blocks[index];\n    this.blocks.splice(index, 0, block); // A simple insert at index.\n    return block;\n  }\n\n  // Return the latest block, between startBlock and endBlock, whose timestamp is <= timestamp.\n  // Effectively, this is an interpolation search algorithm to minimize block requests.\n  // Note: startBlock and endBlock _must_ be different blocks.\n  private async findBlock(_startBlock: T, _endBlock: T, timestamp: number): Promise<T> {\n    const [startBlock, endBlock] = [_startBlock, _endBlock] as WithoutStringTimestamp<T>[];\n    // In the case of equality, the endBlock is expected to be passed as the one whose timestamp === the requested\n    // timestamp.\n    if (endBlock.timestamp === timestamp) return endBlock;\n\n    // If there's no equality, but the blocks are adjacent, return the startBlock, since we want the returned block's\n    // timestamp to be <= the requested timestamp.\n    if (endBlock.number === startBlock.number + 1) return startBlock;\n\n    assert(endBlock.number !== startBlock.number, \"startBlock cannot equal endBlock\");\n    assert(\n      timestamp < endBlock.timestamp && timestamp > startBlock.timestamp,\n      \"timestamp not in between start and end blocks\"\n    );\n\n    // Interpolating the timestamp we're searching for to block numbers.\n    const totalTimeDifference = endBlock.timestamp - startBlock.timestamp;\n    const totalBlockDistance = endBlock.number - startBlock.number;\n    const blockPercentile = (timestamp - startBlock.timestamp) / totalTimeDifference;\n    const estimatedBlock = startBlock.number + Math.round(blockPercentile * totalBlockDistance);\n\n    // Clamp ensures the estimated block is strictly greater than the start block and strictly less than the end block.\n    const newBlock = await this.getBlock(clamp(estimatedBlock, startBlock.number + 1, endBlock.number - 1));\n\n    // Depending on whether the new block is below or above the timestamp, narrow the search space accordingly.\n    if (newBlock.timestamp < timestamp) {\n      return this.findBlock(newBlock, endBlock, timestamp);\n    } else {\n      return this.findBlock(startBlock, newBlock, timestamp);\n    }\n  }\n}\n","import assert from \"assert\";\nimport { Provider, Block } from \"@ethersproject/providers\";\nimport { BigNumber } from \"ethers\";\nimport { bridgePool, rateModelStore } from \"../clients\";\nimport { BigNumberish } from \"./utils\";\nimport { calculateRealizedLpFeePct } from \"./feeCalculator\";\nimport { parseAndReturnRateModelFromString } from \"./rateModel\";\nimport { exists } from \"../utils\";\nimport BlockFinder from \"../blockFinder\";\n\nexport default class LpFeeCalculator {\n  private blockFinder: BlockFinder<Block>;\n  constructor(private provider: Provider) {\n    this.blockFinder = new BlockFinder<Block>(provider.getBlock.bind(provider));\n  }\n  async getLpFeePct(tokenAddress: string, bridgePoolAddress: string, amount: BigNumberish, timestamp?: number) {\n    amount = BigNumber.from(amount);\n    assert(amount.gt(0), \"Amount must be greater than 0\");\n\n    const { blockFinder, provider } = this;\n\n    const bridgePoolInstance = bridgePool.connect(bridgePoolAddress, provider);\n    const rateModelStoreAddress = await rateModelStore.getAddress(await (await this.provider.getNetwork()).chainId);\n    const rateModelStoreInstance = rateModelStore.connect(rateModelStoreAddress, provider);\n\n    const targetBlock = exists(timestamp)\n      ? await blockFinder.getBlockForTimestamp(timestamp)\n      : await provider.getBlock(\"latest\");\n    assert(exists(targetBlock), \"Unable to find target block for timestamp: \" + timestamp || \"latest\");\n    const blockTag = targetBlock.number;\n\n    const [currentUt, nextUt, rateModelForBlockHeight] = await Promise.all([\n      bridgePoolInstance.callStatic.liquidityUtilizationCurrent({ blockTag } as any),\n      bridgePoolInstance.callStatic.liquidityUtilizationPostRelay(amount, { blockTag } as any),\n      rateModelStoreInstance.callStatic.l1TokenRateModels(tokenAddress, { blockTag } as any),\n    ]);\n\n    // Parsing stringified rate model will error if the rate model doesn't contain exactly the expected keys or isn't\n    // a JSON object.\n    const rateModel = parseAndReturnRateModelFromString(rateModelForBlockHeight);\n\n    return calculateRealizedLpFeePct(rateModel, currentUt, nextUt);\n  }\n}\n","import axios from \"axios\";\nimport assert from \"assert\";\nimport { get } from \"lodash\";\n\nexport function msToS(ms: number) {\n  return Math.floor(ms / 1000);\n}\n\ntype CoinGeckoAssetPlatform = {\n  id: string;\n  chain_identifier: number;\n  name: string;\n  shortname: string;\n};\n\ntype CoinGeckoPrice = {\n  address: string;\n  timestamp: number;\n  price: number;\n};\n\nclass Coingecko {\n  private host: string;\n  constructor(host = \"https://api.coingecko.com/api/v3\") {\n    this.host = host;\n  }\n  // Fetch historic prices for a `contract` denominated in `currency` between timestamp `from` and `to`. Note timestamps\n  // are assumed to be js timestamps and are converted to unixtimestamps by dividing by 1000.\n  async getHistoricContractPrices(contract: string, from: number, to: number, currency = \"usd\") {\n    assert(contract, \"requires contract address\");\n    assert(currency, \"requires currency symbol\");\n    assert(from, \"requires from timestamp\");\n    assert(to, \"requires to timestamp\");\n    from = Math.floor(from / 1000);\n    to = Math.floor(to / 1000);\n    const result = await this.call(\n      `coins/ethereum/contract/${contract.toLowerCase()}/market_chart/range/?vs_currency=${currency}&from=${from}&to=${to}`\n    );\n    // fyi timestamps are returned in ms in contrast to the current price endpoint\n    if (result.prices) return result.prices;\n    throw new Error(\"Something went wrong fetching coingecko prices!\");\n  }\n  async getContractDetails(contract_address: string, platform_id = \"ethereum\") {\n    return this.call(`coins/${platform_id}/contract/${contract_address.toLowerCase()}`);\n  }\n  async getCurrentPriceByContract(contract_address: string, currency = \"usd\", platform_id = \"ethereum\") {\n    const result = await this.getContractDetails(contract_address, platform_id);\n    const price = get(result, [\"market_data\", \"current_price\", currency], null);\n    assert(price !== null, \"No current price available for: \" + contract_address);\n    return [result.last_updated, price];\n  }\n  // Return an array of spot prices for an array of collateral addresses in one async call. Note we might in future\n  // This was adapted from packages/merkle-distributor/kpi-options-helpers/calculate-uma-tvl.ts\n  async getContractPrices(\n    addresses: Array<string>,\n    currency = \"usd\",\n    platform_id = \"ethereum\"\n  ): Promise<CoinGeckoPrice[]> {\n    // Generate a unique set with no repeated. join the set with the required coingecko delimiter.\n    const contract_addresses = Array.from(new Set(addresses.filter((n) => n).values()));\n    assert(contract_addresses.length > 0, \"Must supply at least 1 contract address\");\n    // coingecko returns lowercase addresses, so if you expect checksummed addresses, this lookup table will convert them back without having to add ethers as a dependency\n    const lookup = Object.fromEntries(\n      contract_addresses.map((address) => {\n        return [address.toLowerCase(), address];\n      })\n    );\n    // annoying, but have to type this to iterate over entries\n    type Result = {\n      [address: string]: {\n        [currency: string]: number; // usd, eth, ...\n        last_updated_at: number;\n      };\n    };\n    const result: Result = await this.call(\n      `simple/token_price/${platform_id}?contract_addresses=${contract_addresses.join(\n        \"%2C\"\n      )}&vs_currencies=${currency}&include_last_updated_at=true`\n    );\n    return Object.entries(result).map(([key, value]) => {\n      return { address: lookup[key], timestamp: value.last_updated_at, price: value[currency] };\n    });\n  }\n\n  async getPlatforms(): Promise<CoinGeckoAssetPlatform[]> {\n    return this.call(`asset_platforms`);\n  }\n\n  async call(path: string) {\n    try {\n      const { host } = this;\n      const url = `${host}/${path}`;\n      const result = await axios(url);\n      return result.data;\n    } catch (err) {\n      const msg = get(err, \"response.data.error\", get(err, \"response.statusText\", \"Unknown Coingecko Error\"));\n      throw new Error(msg);\n    }\n  }\n}\nexport default Coingecko;\n","import assert from \"assert\";\nimport { calculateGasFees, percent, BigNumberish, toBNWei, fixedPointAdjustment, toWei } from \"./utils\";\nimport { exists } from \"../utils\";\nimport { Provider } from \"@ethersproject/providers\";\nimport { connect as erc20Connect } from \"../clients/erc20\";\nimport { Etherchain } from \"../clients/etherchain\";\nimport Coingecko from \"../coingecko\";\nimport { ethers, BigNumber } from \"ethers\";\nimport * as constants from \"./constants\";\n\n/**\n * Function to estimate gas fees based on coingecko token price and ethers gasPrice. You must still\n * provide a gas amount estimation based on the usage pattern. See constants for current estimations. Returns\n * an amount of gas estimated in the token provided in wei.\n *\n * @param {Provider} ethers Provider\n * @param {BigNumberish} Total amount to be relayed, specified in smallest unit of currency.\n * @param {number} gas - The gas cost for transfer, use constants defined in constants file.\n * @param {string} [tokenAddress = constants.ADDRESSES.ETH] - Token address, for ETH, constants.ADDRESSES.ETH\n */\nexport async function getGasFee(\n  ethersProvider: Provider,\n  gas: number,\n  tokenAddress: string = constants.ADDRESSES.ETH\n): Promise<string> {\n  const { baseFeePerGas } = await ethersProvider.getBlock(\"latest\");\n  let gasPrice: ethers.BigNumber;\n\n  if (baseFeePerGas) {\n    const priorityFeePerGas = (await new Etherchain().getGasPrice()).fastest;\n    // transform priority fee from gwei (eg 4.1) to wei\n    const priorityFeePerGasWei = toWei(priorityFeePerGas, 9);\n    gasPrice = baseFeePerGas.add(priorityFeePerGasWei);\n  } else {\n    // fallback in case baseFeePerGas is undefined / null\n    gasPrice = await ethersProvider.getGasPrice();\n  }\n\n  // We treat ETH differently since we dont need a price conversion like other tokens and return early.\n  if (tokenAddress === constants.ADDRESSES.ETH) {\n    return calculateGasFees(gas, gasPrice);\n  }\n  const coingecko = new Coingecko();\n  const [, tokenPrice] = await coingecko.getCurrentPriceByContract(tokenAddress, \"eth\");\n  const erc20Client = erc20Connect(tokenAddress, ethersProvider);\n  const decimals = await erc20Client.decimals();\n  return calculateGasFees(gas, gasPrice, tokenPrice, decimals);\n}\n\ntype GasTable = Record<string, number> & { DEFAULT: number };\n// These tables are hard coded to mainnet\nfunction makeSlowGasTable(): GasTable {\n  return {\n    [constants.ADDRESSES.UMA]: constants.SLOW_UMA_GAS,\n    [constants.ADDRESSES.ETH]: constants.SLOW_ETH_GAS,\n    [constants.ADDRESSES.WETH]: constants.SLOW_ETH_GAS,\n    DEFAULT: constants.SLOW_ERC_GAS,\n  };\n}\n// instant gas is the amount of gas above slow gas\nfunction makeInstantGasTable(): GasTable {\n  return {\n    [constants.ADDRESSES.UMA]: constants.FAST_UMA_GAS - constants.SLOW_UMA_GAS,\n    [constants.ADDRESSES.ETH]: constants.FAST_ETH_GAS - constants.SLOW_ETH_GAS,\n    [constants.ADDRESSES.WETH]: constants.FAST_ETH_GAS - constants.SLOW_ETH_GAS,\n    DEFAULT: constants.FAST_ERC_GAS - constants.SLOW_ERC_GAS,\n  };\n}\n\nconst GetGasByAddress = (gasTable: GasTable) => (tokenAddress: string): number => {\n  if (exists(gasTable[tokenAddress])) return gasTable[tokenAddress];\n  return gasTable.DEFAULT;\n};\n\nexport const getInstantGasByAddress = GetGasByAddress(makeInstantGasTable());\nexport const getSlowGasByAddress = GetGasByAddress(makeSlowGasTable());\n\nexport type DepositFees = {\n  slowPct: string;\n  instantPct: string;\n};\n\n/**\n * getDepositFees. Returns to you appropriate values for calling the relay deposit function. Returns the slow gas fee\n * and the instant gas fee which is the amount additional to the slow fee as percentages in wei.\n *\n * @param {Provider} ethersProvider - Read provider on mainnet\n * @param {BigNumberish} amountToRelay - Amount in wei of token to relay\n * @param {string} tokenAddress = 0 - Mainnet address of token to relay. Defaults to ETH which is constants.ADDRESSES.ETH.\n * @param {string} discountPercent = DEFAULT_GAS_DISCOUNT- Percent as a value 0-100 of gas fee discount. 0 means no discount. Typically 25 for a 25% gas fee reduction.\n * No need to override this as the values are hardcoded in the sdk.\n * @returns {Promise<DepositFees>} - Returns the fee parameters to the deposit function on the deposit box contract.\n * These are percentages in wei. For example 50% is represented as 0.5 * 1e18.\n */\nexport async function getDepositFees(\n  ethersProvider: Provider,\n  amountToRelay: BigNumberish,\n  tokenAddress: string = constants.ADDRESSES.ETH,\n  discountPercent: number = constants.DEFAULT_GAS_DISCOUNT\n): Promise<DepositFees> {\n  assert(discountPercent >= 0 && discountPercent <= 100, \"discountPercent must be between 0 and 100 percent\");\n  const slowGas = getSlowGasByAddress(tokenAddress);\n  const slowGasDiscounted = Math.floor((1 - discountPercent / 100) * slowGas);\n  const slowGasFee = await getGasFee(ethersProvider, slowGasDiscounted, tokenAddress);\n\n  const instantGas = getInstantGasByAddress(tokenAddress);\n  const instantGasDiscounted = Math.floor((1 - discountPercent / 100) * instantGas);\n  const instantGasFee = await getGasFee(ethersProvider, instantGasDiscounted, tokenAddress);\n\n  return {\n    slowPct: percent(slowGasFee, amountToRelay).toString(),\n    instantPct: percent(instantGasFee, amountToRelay).toString(),\n  };\n}\n\nexport type DepositFeeDetails = {\n  tokenAddress: string;\n  amountToRelay: string;\n  discountPercent: number;\n  feeLimitPercent?: number;\n  instant: {\n    pct: string;\n    total: string;\n  };\n  slow: {\n    pct: string;\n    total: string;\n  };\n  isAmountTooLow: boolean;\n};\n/**\n * getDepositFeesDetails. Same as deposit fees, but returns more information, useful for a frontend display.\n *\n * @param {Provider} ethersProvider - Read provider on mainnet\n * @param {BigNumberish} amountToRelay - Amount in wei of token to relay\n * @param {string} tokenAddress = 0 - Mainnet address of token to relay, for ETH specify constants.ADDRESSES.ETH\n * @param {number} feeLimitPercent? - Optional, percent as a value 0-100 of how much to limit fees as a percentage of the total relayed. Typically 25 or 25% of fees are acceptable out of the total relay amount.\n * For instance 25 means fees can be up to 25% of the total amount to send, fees above this will cause isAmountTooLow to be true.\n * @param {string} discountPercent = DEFAULT_GAS_DISCOUNT - Percent as a value 0-100 of gas fee discount. 0 means no discount. Typically 25 for a 25% gas fee reduction.\n * No need to override this as the values are hardcoded in the sdk.\n * @returns {DepositFeeDetails}\n */\nexport async function getDepositFeesDetails(\n  ethersProvider: Provider,\n  amountToRelay: BigNumberish,\n  tokenAddress: string = constants.ADDRESSES.ETH,\n  feeLimitPercent?: number,\n  discountPercent: number = constants.DEFAULT_GAS_DISCOUNT\n): Promise<DepositFeeDetails> {\n  const { slowPct, instantPct } = await getDepositFees(ethersProvider, amountToRelay, tokenAddress, discountPercent);\n  const slowTotal = BigNumber.from(slowPct).mul(amountToRelay).div(fixedPointAdjustment).toString();\n  const instantTotal = BigNumber.from(instantPct).mul(amountToRelay).div(fixedPointAdjustment).toString();\n  let isAmountTooLow = false;\n\n  if (feeLimitPercent) {\n    assert(feeLimitPercent >= 0 && feeLimitPercent <= 100, \"feeLimitPercent must be between 0 and 100 percent\");\n    isAmountTooLow = BigNumber.from(slowPct)\n      .add(instantPct)\n      .gt(toBNWei(feeLimitPercent / 100));\n  }\n\n  return {\n    amountToRelay: amountToRelay.toString(),\n    discountPercent,\n    feeLimitPercent,\n    tokenAddress,\n    instant: {\n      pct: instantPct,\n      total: instantTotal,\n    },\n    slow: {\n      pct: slowPct,\n      total: slowTotal,\n    },\n    isAmountTooLow,\n  };\n}\n","import { multicall } from \"./clients\";\nimport { Contract } from \"ethers\";\nimport type { SignerOrProvider } from \".\";\nimport zip from \"lodash/zip\";\n\nexport type Call = {\n  method: string;\n  args?: any[];\n};\n\nexport type Request = {\n  contractInstance: Contract;\n  call: Call;\n};\nexport type EncodedResponse = string;\nexport type EncodedRequest = {\n  target: string;\n  callData: string;\n};\n\nexport interface State<MulticallType> {\n  requests: Request[];\n  multicallClient: MulticallType;\n}\n\n// Multicall class that exposes public functions to the user and recursively chains itself.  Acts immutable\n// if you store reference to the parent intsance. Children will contain mutated state.\nexport class Multicall<MulticallType extends multicall.Instance> implements State<multicall.Instance> {\n  public requests: Request[];\n  public multicallClient: MulticallType;\n  constructor(state: State<MulticallType>) {\n    // make a copy of this so we dont mutate the original\n    this.requests = [...state.requests];\n    this.multicallClient = state.multicallClient;\n  }\n\n  // internally add requests to queue. Only called by parent for chaining.\n  protected push(contractInstance: Contract, call: Call) {\n    this.requests.push({ contractInstance, call });\n  }\n\n  // encode requests to multicall contract\n  protected encodeRequest(request: Request) {\n    const { contractInstance, call } = request;\n    return {\n      target: contractInstance.address,\n      callData: contractInstance.interface.encodeFunctionData(call.method, call.args),\n    };\n  }\n\n  // decode response from multicall contract\n  protected decodeResponse(request: Request, response: EncodedResponse) {\n    const { contractInstance, call } = request;\n    return contractInstance.interface.decodeFunctionResult(call.method, response);\n  }\n\n  // adds a new request to the queue, to be executed when read is called. Returns an instance of this class so you can chain.\n  public add(contractInstance: Contract, call: Call) {\n    const child = new Multicall(this);\n    child.push(contractInstance, call);\n    return child;\n  }\n\n  // adds a list of requests to the queue, to be executed when read is called. Returns an instance of this class so you can chain.\n  public batch(contractInstance: Contract, calls: Call[]) {\n    const child = new Multicall(this);\n    calls.forEach((call: Call) => {\n      child.push(contractInstance, call);\n    });\n    return child;\n  }\n  // reads from the contract, returns the read results in order that requests were queued.\n  public async read(_requests: Request[] = this.requests) {\n    const encodedRequests = _requests.map((request) => this.encodeRequest(request));\n    const { returnData } = await this.multicallClient.callStatic.aggregate(encodedRequests);\n    const zipped = zip(_requests, returnData);\n    return zipped.map(([request, response]) => {\n      if (request && response) return this.decodeResponse(request, response);\n      throw new Error(\"Unable to decode contract response\");\n    });\n  }\n}\n\n// Factory that alters construction of multicall to be more friendly for end user\nexport default class Factory extends Multicall<multicall.Instance> {\n  constructor(address: string, provider: SignerOrProvider) {\n    const multicallClient = multicall.connect(address, provider);\n    super({ multicallClient, requests: [] });\n  }\n}\n","import { multicall2 } from \"./clients\";\nimport { Call, Multicall, Request, State } from \"./multicall\";\nimport zip from \"lodash/zip\";\nimport { SignerOrProvider } from \".\";\nimport { Contract } from \"ethers\";\n\nclass Multicall2 extends Multicall<multicall2.Instance> {\n  constructor(state: State<multicall2.Instance>) {\n    super(state);\n  }\n\n  // reads from the contract, returns the read and error results in order that requests were queued.\n  public async readWithErrors(_requests: Request[] = this.requests) {\n    const encodedRequests = _requests.map((request) => this.encodeRequest(request));\n    const [, , returnData] = await this.multicallClient.callStatic.tryBlockAndAggregate(false, encodedRequests);\n    const zipped = zip(_requests, returnData);\n    return zipped.map(([request, response]) => {\n      if (request && response) {\n        return {\n          success: response.success,\n          result: response.success ? this.decodeResponse(request, response.returnData) : undefined,\n        };\n      }\n      throw new Error(\"Unable to decode contract response\");\n    });\n  }\n\n  // adds a new request to the queue, to be executed when read is called. Returns an instance of this class so you can chain.\n  public add(contractInstance: Contract, call: Call) {\n    return new Multicall2(super.add(contractInstance, call));\n  }\n\n  // adds a list of requests to the queue, to be executed when read is called. Returns an instance of this class so you can chain.\n  public batch(contractInstance: Contract, calls: Call[]) {\n    return new Multicall2(super.batch(contractInstance, calls));\n  }\n}\n\n// Factory that alters construction of multicall2 to be more friendly for end user\nexport default class Multicall2Factory extends Multicall2 {\n  constructor(address: string, provider: SignerOrProvider) {\n    const multicallClient = multicall2.connect(address, provider);\n    super({ multicallClient, requests: [] });\n  }\n}\n","import assert from \"assert\";\nimport { Signer } from \"ethers\";\nimport { TransactionRequest, TransactionReceipt } from \"@ethersproject/abstract-provider\";\n\nfunction makeKey(tx: TransactionRequest) {\n  return JSON.stringify(\n    Object.entries(tx).map(([key, value]) => {\n      return [key, (value || \"\").toString()];\n    })\n  );\n}\n\ntype Config = {\n  confirmations?: number;\n};\nexport type Emit = (event: string, key: string, data: TransactionReceipt | string | TransactionRequest | Error) => void;\nexport default (config: Config, signer: Signer, emit: Emit = () => null) => {\n  assert(signer.provider, \"signer requires a provider, use signer.connect(provider)\");\n  const { confirmations = 3 } = config;\n  const requests = new Map<string, TransactionRequest>();\n  const submissions = new Map<string, string>();\n  const mined = new Map<string, TransactionReceipt>();\n  function request(unsignedTx: TransactionRequest) {\n    // this no longer calls signer.populateTransaction, to allow metamask to fill in missing details instead\n    // use overrides if you want to manually fill in other tx details, including the overrides.customData field.\n    const populated = unsignedTx;\n    const key = makeKey(populated);\n    assert(!requests.has(key), \"Transaction already in progress\");\n    requests.set(key, populated);\n    return key;\n  }\n  async function processRequest(key: string) {\n    const request = requests.get(key);\n    assert(request, \"invalid request\");\n    // always delete request, it should only be submitted once\n    requests.delete(key);\n    try {\n      const sent = await signer.sendTransaction(request);\n      submissions.set(key, sent.hash);\n      emit(\"submitted\", key, sent.hash);\n    } catch (err) {\n      emit(\"error\", key, err as Error);\n    }\n  }\n  async function processSubmission(key: string) {\n    const hash = submissions.get(key);\n    assert(hash, \"invalid submission\");\n    assert(signer.provider, \"signer requires a provider, use signer.connect(provider)\");\n    // we look for this transaction, but it may never find it if its sped up\n    const receipt = await signer.provider.getTransactionReceipt(hash).catch(() => undefined);\n    if (receipt == null) return;\n    if (receipt.confirmations < confirmations) return;\n    submissions.delete(key);\n    mined.set(key, receipt);\n    emit(\"mined\", key, receipt);\n  }\n  async function isMined(key: string) {\n    return mined.get(key);\n  }\n  async function update() {\n    for (const key of requests.keys()) {\n      await processRequest(key);\n    }\n    for (const key of submissions.keys()) {\n      await processSubmission(key);\n    }\n  }\n  return {\n    request,\n    isMined,\n    update,\n  };\n};\n","import assert from \"assert\";\nimport { bridgePool, rateModelStore } from \"../../clients\";\nimport { toBNWei, fixedPointAdjustment, calcPeriodicCompoundInterest, calcApr, BigNumberish, fromWei } from \"../utils\";\nimport { BatchReadWithErrors, loop, exists } from \"../../utils\";\nimport Multicall2 from \"../../multicall2\";\nimport TransactionManager from \"../transactionManager\";\nimport { ethers, Signer, BigNumber } from \"ethers\";\nimport type { Overrides } from \"@ethersproject/contracts\";\nimport { TransactionRequest, TransactionReceipt, Log } from \"@ethersproject/abstract-provider\";\nimport { Provider, Block } from \"@ethersproject/providers\";\nimport set from \"lodash/set\";\nimport get from \"lodash/get\";\nimport has from \"lodash/has\";\nimport { calculateInstantaneousRate } from \"../feeCalculator\";\nimport { SECONDS_PER_YEAR, DEFAULT_BLOCK_DELTA, RateModel, ADDRESSES } from \"../constants\";\nimport { parseAndReturnRateModelFromString } from \"../rateModel\";\n\nexport type { Provider };\nexport type BatchReadWithErrorsType = ReturnType<ReturnType<typeof BatchReadWithErrors>>;\n\nexport type Awaited<T> = T extends PromiseLike<infer U> ? U : T;\n\nexport type Config = {\n  multicall2Address: string;\n  rateModelStoreAddress?: string;\n  confirmations?: number;\n  blockDelta?: number;\n};\nexport type Dependencies = {\n  provider: Provider;\n};\nexport type Pool = {\n  address: string;\n  totalPoolSize: string;\n  l1Token: string;\n  liquidReserves: string;\n  pendingReserves: string;\n  exchangeRateCurrent: string;\n  exchangeRatePrevious: string;\n  estimatedApy: string;\n  estimatedApr: string;\n  blocksElapsed: number;\n  secondsElapsed: number;\n  liquidityUtilizationCurrent: string;\n  utilizedReserves: string;\n  projectedApr: string;\n};\nexport type User = {\n  address: string;\n  poolAddress: string;\n  lpTokens: string;\n  positionValue: string;\n  totalDeposited: string;\n  feesEarned: string;\n};\nexport type Transaction = {\n  id: string;\n  state: \"requested\" | \"submitted\" | \"mined\" | \"error\";\n  toAddress: string;\n  fromAddress: string;\n  type: \"Add Liquidity\" | \"Remove Liquidity\";\n  description: string;\n  request?: TransactionRequest;\n  hash?: string;\n  receipt?: TransactionReceipt;\n  error?: Error;\n};\nexport type Token = {\n  decimals: string;\n  symbol: string;\n  name: string;\n};\nexport type State = {\n  pools: Record<string, Pool>;\n  users: Record<string, Record<string, User>>;\n  transactions: Record<string, Transaction>;\n  error?: Error;\n};\nexport type EmitState = (path: string[], data: any) => void;\n\nclass PoolState {\n  private l1Token: string | undefined = undefined;\n  constructor(\n    private batchRead: BatchReadWithErrorsType,\n    private contract: bridgePool.Instance,\n    private address: string\n  ) {}\n  public async read(latestBlock: number, previousBlock?: number) {\n    if (this.l1Token === undefined) this.l1Token = await this.contract.l1Token();\n    // typechain does not have complete types for call options, so we have to cast blockTag to any\n    const exchangeRatePrevious = await this.contract.callStatic.exchangeRateCurrent({\n      blockTag: previousBlock || latestBlock - 1,\n    } as any);\n\n    return {\n      address: this.address,\n      l1Token: this.l1Token,\n      exchangeRatePrevious,\n      ...(await this.batchRead<{\n        exchangeRateCurrent: BigNumber;\n        liquidityUtilizationCurrent: BigNumber;\n        liquidReserves: BigNumber;\n        pendingReserves: BigNumber;\n        utilizedReserves: BigNumber;\n      }>([\n        // its important exchangeRateCurrent is called first, as it calls _sync under the hood which updates the contract\n        // and gives more accurate values for the following properties.\n        [\"exchangeRateCurrent\"],\n        [\"liquidityUtilizationCurrent\"],\n        [\"liquidReserves\"],\n        [\"pendingReserves\"],\n        [\"utilizedReserves\"],\n      ])),\n    };\n  }\n}\n\ntype EventIdParams = { blockNumber: number; transactionIndex: number; logIndex: number };\nexport class PoolEventState {\n  private seen = new Set<string>();\n  private iface: ethers.utils.Interface;\n  constructor(\n    private contract: bridgePool.Instance,\n    private startBlock = 0,\n    private state: bridgePool.EventState = bridgePool.eventStateDefaults()\n  ) {\n    this.iface = new ethers.utils.Interface(bridgePool.Factory.abi);\n  }\n  private makeId(params: EventIdParams) {\n    return [params.blockNumber, params.transactionIndex, params.logIndex].join(\"!\");\n  }\n  hasEvent(params: EventIdParams) {\n    return this.seen.has(this.makeId(params));\n  }\n  private addEvent(params: EventIdParams) {\n    return this.seen.add(this.makeId(params));\n  }\n  private filterSeen = (params: EventIdParams) => {\n    const seen = this.hasEvent(params);\n    if (!seen) this.addEvent(params);\n    return !seen;\n  };\n  public async read(endBlock: number, userAddress?: string) {\n    if (endBlock <= this.startBlock) return this.state;\n    const events = (\n      await Promise.all([\n        ...(await this.contract.queryFilter(\n          this.contract.filters.LiquidityAdded(undefined, undefined, userAddress),\n          this.startBlock,\n          endBlock\n        )),\n        ...(await this.contract.queryFilter(\n          this.contract.filters.LiquidityRemoved(undefined, undefined, userAddress),\n          this.startBlock,\n          endBlock\n        )),\n      ])\n    )\n      .filter(this.filterSeen)\n      .sort((a, b) => {\n        if (a.blockNumber !== b.blockNumber) return a.blockNumber - b.blockNumber;\n        if (a.transactionIndex !== b.transactionIndex) return a.transactionIndex - b.transactionIndex;\n        if (a.logIndex !== b.logIndex) a.logIndex - b.logIndex;\n        // if everything is the same, return a, ie maintain order of array\n        return -1;\n      });\n    // ethers queries are inclusive [start,end] unless start === end, then exclusive (start,end). we increment to make sure we dont see same event twice\n    this.startBlock = endBlock + 1;\n    this.state = bridgePool.getEventState(events, this.state);\n    return this.state;\n  }\n  makeEventFromLog(log: Log) {\n    const description = this.iface.parseLog(log);\n    return {\n      ...log,\n      ...description,\n      event: description.name,\n      eventSignature: description.signature,\n    };\n  }\n  readTxReceipt(receipt: TransactionReceipt) {\n    const events = receipt.logs\n      .map((log) => {\n        try {\n          return this.makeEventFromLog(log);\n        } catch (err) {\n          // return nothing, this throws a lot because logs from other contracts are included in receipt\n          return;\n        }\n      })\n      // filter out undefined\n      .filter(exists)\n      .filter(this.filterSeen);\n\n    this.state = bridgePool.getEventState(events, this.state);\n    return this.state;\n  }\n}\n\nclass UserState {\n  constructor(private contract: bridgePool.Instance) {}\n  public async read(user: string) {\n    return {\n      address: user,\n      balanceOf: await this.contract.balanceOf(user),\n    };\n  }\n}\n\nexport function calculateRemoval(amountWei: BigNumber, percentWei: BigNumber) {\n  const receive = amountWei.mul(percentWei).div(fixedPointAdjustment);\n  const remain = amountWei.sub(receive);\n  return {\n    recieve: receive.toString(),\n    remain: remain.toString(),\n  };\n}\n// params here mimic the user object type\nexport function previewRemoval(\n  values: { positionValue: BigNumberish; feesEarned: BigNumberish; totalDeposited: BigNumberish },\n  percentFloat: number\n) {\n  const percentWei = toBNWei(percentFloat);\n  return {\n    position: {\n      ...calculateRemoval(BigNumber.from(values.totalDeposited), percentWei),\n    },\n    fees: {\n      ...calculateRemoval(BigNumber.from(values.feesEarned), percentWei),\n    },\n    total: {\n      ...calculateRemoval(BigNumber.from(values.positionValue), percentWei),\n    },\n  };\n}\nfunction joinUserState(\n  poolState: Pool,\n  eventState: bridgePool.EventState,\n  userState: Awaited<ReturnType<UserState[\"read\"]>>\n): User {\n  const positionValue = BigNumber.from(poolState.exchangeRateCurrent)\n    .mul(userState.balanceOf)\n    .div(fixedPointAdjustment);\n  const totalDeposited = BigNumber.from(eventState.tokens[userState.address] || \"0\");\n  const feesEarned = positionValue.sub(totalDeposited);\n  return {\n    address: userState.address,\n    poolAddress: poolState.address,\n    lpTokens: userState.balanceOf.toString(),\n    positionValue: positionValue.toString(),\n    totalDeposited: totalDeposited.toString(),\n    feesEarned: feesEarned.toString(),\n  };\n}\nfunction joinPoolState(\n  poolState: Awaited<ReturnType<PoolState[\"read\"]>>,\n  latestBlock: Block,\n  previousBlock: Block,\n  rateModel?: RateModel\n): Pool {\n  const totalPoolSize = poolState.liquidReserves.add(poolState.utilizedReserves);\n  const secondsElapsed = latestBlock.timestamp - previousBlock.timestamp;\n  const blocksElapsed = latestBlock.number - previousBlock.number;\n  const exchangeRatePrevious = poolState.exchangeRatePrevious.toString();\n  const exchangeRateCurrent = poolState.exchangeRateCurrent.toString();\n\n  const estimatedApy = calcPeriodicCompoundInterest(\n    exchangeRatePrevious,\n    exchangeRateCurrent,\n    secondsElapsed,\n    SECONDS_PER_YEAR\n  );\n  const estimatedApr = calcApr(exchangeRatePrevious, exchangeRateCurrent, secondsElapsed, SECONDS_PER_YEAR);\n  let projectedApr = \"\";\n\n  if (rateModel) {\n    projectedApr = fromWei(\n      calculateInstantaneousRate(rateModel, poolState.liquidityUtilizationCurrent)\n        .mul(poolState.liquidityUtilizationCurrent)\n        .div(fixedPointAdjustment)\n    );\n  }\n\n  return {\n    address: poolState.address,\n    totalPoolSize: totalPoolSize.toString(),\n    l1Token: poolState.l1Token,\n    liquidReserves: poolState.liquidReserves.toString(),\n    pendingReserves: poolState.pendingReserves.toString(),\n    exchangeRateCurrent: poolState.exchangeRateCurrent.toString(),\n    exchangeRatePrevious: poolState.exchangeRatePrevious.toString(),\n    estimatedApy,\n    estimatedApr,\n    blocksElapsed,\n    secondsElapsed,\n    liquidityUtilizationCurrent: poolState.liquidityUtilizationCurrent.toString(),\n    projectedApr,\n    utilizedReserves: poolState.utilizedReserves.toString(),\n  };\n}\nexport class ReadPoolClient {\n  private poolState: PoolState;\n  private multicall: Multicall2;\n  private contract: bridgePool.Instance;\n  private batchRead: BatchReadWithErrorsType;\n  constructor(private address: string, private provider: Provider, private multicallAddress: string) {\n    this.multicall = new Multicall2(multicallAddress, provider);\n    this.contract = bridgePool.connect(address, provider);\n    this.batchRead = BatchReadWithErrors(this.multicall)(this.contract);\n    this.poolState = new PoolState(this.batchRead, this.contract, address);\n  }\n  public async read(latestBlock: number) {\n    return this.poolState.read(latestBlock);\n  }\n}\nexport function validateWithdraw(pool: Pool, user: User, lpTokenAmount: BigNumberish) {\n  const l1TokensToReturn = BigNumber.from(lpTokenAmount).mul(pool.exchangeRateCurrent).div(fixedPointAdjustment);\n  assert(BigNumber.from(l1TokensToReturn).gt(\"0\"), \"Must withdraw amount greater than 0\");\n  assert(\n    BigNumber.from(pool.liquidReserves).gte(l1TokensToReturn.add(pool.pendingReserves)),\n    \"Utilization too high to remove that amount, try lowering withdraw amount\"\n  );\n  assert(BigNumber.from(lpTokenAmount).lte(user.lpTokens), \"You cannot withdraw more than you have\");\n  return { lpTokenAmount, l1TokensToReturn: l1TokensToReturn.toString() };\n}\n\nexport class Client {\n  private poolContracts: Record<string, bridgePool.Instance> = {};\n  private multicall: Multicall2;\n  private transactionManagers: Record<string, ReturnType<typeof TransactionManager>> = {};\n  private state: State = { pools: {}, users: {}, transactions: {} };\n  private batchRead: ReturnType<typeof BatchReadWithErrors>;\n  private poolEvents: Record<string, PoolEventState> = {};\n  private intervalStarted = false;\n  private rateModelInstance: rateModelStore.Instance;\n  constructor(private config: Config, private deps: Dependencies, private emit: EmitState) {\n    this.multicall = new Multicall2(config.multicall2Address, deps.provider);\n    this.batchRead = BatchReadWithErrors(this.multicall);\n    this.rateModelInstance = rateModelStore.connect(config.rateModelStoreAddress || ADDRESSES.RateModel, deps.provider);\n  }\n  private getOrCreatePoolContract(address: string) {\n    if (this.poolContracts[address]) return this.poolContracts[address];\n    const contract = bridgePool.connect(address, this.deps.provider);\n    this.poolContracts[address] = contract;\n    return contract;\n  }\n  private getOrCreatePoolEvents(poolAddress: string) {\n    if (this.poolEvents[poolAddress]) return this.poolEvents[poolAddress];\n    this.poolEvents[poolAddress] = new PoolEventState(this.getOrCreatePoolContract(poolAddress));\n    return this.poolEvents[poolAddress];\n  }\n  private getOrCreateTransactionManager(signer: Signer, address: string) {\n    if (this.transactionManagers[address]) return this.transactionManagers[address];\n    const txman = TransactionManager({ confirmations: this.config.confirmations }, signer, (event, id, data) => {\n      if (event === \"submitted\") {\n        this.state.transactions[id].state = event;\n        this.state.transactions[id].hash = data as string;\n        this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n      }\n      if (event === \"mined\") {\n        const txReceipt = data as TransactionReceipt;\n        this.state.transactions[id].state = event;\n        this.state.transactions[id].receipt = txReceipt;\n        this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n        // trigger pool and user update for a known mined transaction\n        const tx = this.state.transactions[id];\n        this.updatePool(tx.toAddress)\n          .then(() => {\n            return this.updateUserWithTransaction(tx.fromAddress, tx.toAddress, txReceipt);\n          })\n          .catch((err) => {\n            this.emit([\"error\"], err);\n          });\n      }\n      if (event === \"error\") {\n        this.state.transactions[id].state = event;\n        this.state.transactions[id].error = data as Error;\n        this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n      }\n    });\n    this.transactionManagers[address] = txman;\n    return txman;\n  }\n  async addEthLiquidity(signer: Signer, pool: string, l1TokenAmount: BigNumberish, overrides: Overrides = {}) {\n    const userAddress = await signer.getAddress();\n    const contract = this.getOrCreatePoolContract(pool);\n    const txman = this.getOrCreateTransactionManager(signer, userAddress);\n\n    // dont allow override value here\n    const request = await contract.populateTransaction.addLiquidity(l1TokenAmount, {\n      ...overrides,\n      value: l1TokenAmount,\n    });\n    const id = await txman.request(request);\n\n    this.state.transactions[id] = {\n      id,\n      state: \"requested\",\n      toAddress: pool,\n      fromAddress: userAddress,\n      type: \"Add Liquidity\",\n      description: `Adding ETH to pool`,\n      request,\n    };\n    this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n    await txman.update();\n    return id;\n  }\n  async addTokenLiquidity(signer: Signer, pool: string, l1TokenAmount: BigNumberish, overrides: Overrides = {}) {\n    const userAddress = await signer.getAddress();\n    const contract = this.getOrCreatePoolContract(pool);\n    const txman = this.getOrCreateTransactionManager(signer, userAddress);\n\n    const request = await contract.populateTransaction.addLiquidity(l1TokenAmount, overrides);\n    const id = await txman.request(request);\n\n    this.state.transactions[id] = {\n      id,\n      state: \"requested\",\n      toAddress: pool,\n      fromAddress: userAddress,\n      type: \"Add Liquidity\",\n      description: `Adding Tokens to pool`,\n      request,\n    };\n\n    this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n    await txman.update();\n    return id;\n  }\n  async validateWithdraw(poolAddress: string, userAddress: string, lpAmount: BigNumberish) {\n    if (!this.hasPool(poolAddress)) {\n      await this.updatePool(poolAddress);\n    }\n    const poolState = this.getPool(poolAddress);\n    if (!this.hasUser(poolAddress, userAddress)) {\n      await this.updateUser(poolAddress, userAddress);\n    }\n    const userState = this.getUser(poolAddress, userAddress);\n    return validateWithdraw(poolState, userState, lpAmount);\n  }\n  async removeTokenLiquidity(signer: Signer, pool: string, lpTokenAmount: BigNumberish, overrides: Overrides = {}) {\n    const userAddress = await signer.getAddress();\n    await this.validateWithdraw(pool, userAddress, lpTokenAmount);\n    const contract = this.getOrCreatePoolContract(pool);\n    const txman = this.getOrCreateTransactionManager(signer, userAddress);\n\n    const request = await contract.populateTransaction.removeLiquidity(lpTokenAmount, false, overrides);\n    const id = await txman.request(request);\n\n    this.state.transactions[id] = {\n      id,\n      state: \"requested\",\n      toAddress: pool,\n      fromAddress: userAddress,\n      type: \"Remove Liquidity\",\n      description: `Withdrawing Tokens from pool`,\n      request,\n    };\n\n    this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n    await txman.update();\n    return id;\n  }\n  async removeEthliquidity(signer: Signer, pool: string, lpTokenAmount: BigNumberish, overrides: Overrides = {}) {\n    const userAddress = await signer.getAddress();\n    await this.validateWithdraw(pool, userAddress, lpTokenAmount);\n    const contract = this.getOrCreatePoolContract(pool);\n    const txman = this.getOrCreateTransactionManager(signer, userAddress);\n\n    const request = await contract.populateTransaction.removeLiquidity(lpTokenAmount, true, overrides);\n    const id = await txman.request(request);\n\n    this.state.transactions[id] = {\n      id,\n      state: \"requested\",\n      toAddress: pool,\n      fromAddress: userAddress,\n      type: \"Remove Liquidity\",\n      description: `Withdrawing Eth from pool`,\n      request,\n    };\n    this.emit([\"transactions\", id], { ...this.state.transactions[id] });\n    await txman.update();\n    return id;\n  }\n  getPool(poolAddress: string) {\n    return this.state.pools[poolAddress];\n  }\n  hasPool(poolAddress: string) {\n    return Boolean(this.state.pools[poolAddress]);\n  }\n  getUser(poolAddress: string, userAddress: string) {\n    return get(this.state, [\"users\", userAddress, poolAddress]);\n  }\n  hasUser(poolAddress: string, userAddress: string) {\n    return has(this.state, [\"users\", userAddress, poolAddress]);\n  }\n  hasTx(id: string) {\n    return has(this.state, [\"transactions\", id]);\n  }\n  getTx(id: string) {\n    return get(this.state, [\"transactions\", id]);\n  }\n  private async updateUserWithTransaction(userAddress: string, poolAddress: string, txReceipt: TransactionReceipt) {\n    const contract = this.getOrCreatePoolContract(poolAddress);\n    if (!this.hasPool(poolAddress)) {\n      await this.updatePool(poolAddress);\n    }\n    const poolState = this.getPool(poolAddress);\n    const getUserState = new UserState(contract);\n    const getPoolEventState = this.getOrCreatePoolEvents(poolAddress);\n    const userState = await getUserState.read(userAddress);\n    const eventState = await getPoolEventState.readTxReceipt(txReceipt);\n    set(this.state, [\"users\", userAddress, poolAddress], joinUserState(poolState, eventState, userState));\n    this.emit([\"users\", userAddress, poolAddress], this.state.users[userAddress][poolAddress]);\n  }\n  async updateUser(userAddress: string, poolAddress: string) {\n    const contract = this.getOrCreatePoolContract(poolAddress);\n    if (!this.hasPool(poolAddress)) {\n      await this.updatePool(poolAddress);\n    }\n    const poolState = this.getPool(poolAddress);\n    const latestBlock = (await this.deps.provider.getBlock(\"latest\")).number;\n    const getUserState = new UserState(contract);\n    const getPoolEventState = this.getOrCreatePoolEvents(poolAddress);\n    const userState = await getUserState.read(userAddress);\n    const eventState = await getPoolEventState.read(latestBlock, userAddress);\n    set(this.state, [\"users\", userAddress, poolAddress], joinUserState(poolState, eventState, userState));\n    this.emit([\"users\", userAddress, poolAddress], this.state.users[userAddress][poolAddress]);\n  }\n  async updatePool(poolAddress: string) {\n    // default to 100 block delta unless specified otherwise in config\n    const { blockDelta = DEFAULT_BLOCK_DELTA } = this.config;\n    const contract = this.getOrCreatePoolContract(poolAddress);\n    const pool = new PoolState(this.batchRead(contract), contract, poolAddress);\n    const latestBlock = await this.deps.provider.getBlock(\"latest\");\n    const previousBlock = await this.deps.provider.getBlock(latestBlock.number - blockDelta);\n    const state = await pool.read(latestBlock.number, previousBlock.number);\n\n    let rateModel: RateModel | undefined = undefined;\n    try {\n      const rateModelRaw = await this.rateModelInstance.callStatic.l1TokenRateModels(state.l1Token);\n      rateModel = parseAndReturnRateModelFromString(rateModelRaw);\n    } catch (err) {\n      // we could swallow this error or just log it since getting the rate model is optional,\n      // but we will just emit it to the caller and let them decide what to do with it.\n      this.emit([\"error\"], err);\n    }\n\n    this.state.pools[poolAddress] = joinPoolState(state, latestBlock, previousBlock, rateModel);\n    this.emit([\"pools\", poolAddress], this.state.pools[poolAddress]);\n  }\n  async updateTransactions() {\n    for (const txMan of Object.values(this.transactionManagers)) {\n      try {\n        await txMan.update();\n      } catch (err) {\n        this.emit([\"error\"], err);\n      }\n    }\n  }\n  // starts transaction checking intervals, defaults to 30 seconds\n  async startInterval(delayMs = 30000) {\n    assert(!this.intervalStarted, \"Interval already started, try stopping first\");\n    this.intervalStarted = true;\n    loop(async () => {\n      assert(this.intervalStarted, \"Bridgepool Interval Stopped\");\n      await this.updateTransactions();\n    }, delayMs).catch((err) => {\n      this.emit([\"error\"], err);\n    });\n  }\n  // starts transaction checking intervals\n  async stopInterval() {\n    this.intervalStarted = false;\n  }\n}\n","import assert from \"assert\";\nimport { Provider } from \"@ethersproject/providers\";\nimport { Contract, Signer, BigNumber, ContractTransaction } from \"ethers\";\nimport { predeploys, getContractInterface } from \"@eth-optimism/contracts\";\nimport { ERC20Ethers__factory, OptimismL1StandardBridgeEthers__factory } from \"@uma/contracts-node\";\nimport { Watcher } from \"@eth-optimism/core-utils\";\n\nexport const l1Contracts: { Proxy__OVM_L1StandardBridge: { [chainId: number]: string } } = {\n  Proxy__OVM_L1StandardBridge: {\n    1: \"0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1\",\n    42: \"0x22F24361D548e5FaAfb36d1437839f080363982B\",\n  },\n};\n\nexport class OptimismBridgeClient {\n  // Gas limit for the L2 transaction initiated by the Sequencer\n  public readonly L2_DEPOSIT_GAS_LIMIT = 2000000;\n\n  public getL1BridgeAddress(chainId: number): string {\n    const l1StandardBridgeAddress = l1Contracts.Proxy__OVM_L1StandardBridge[chainId];\n    assert(typeof l1StandardBridgeAddress === \"string\", \"Chain not supported\");\n    return l1StandardBridgeAddress;\n  }\n\n  /**\n   * Create a transaction to deposit ERC20 tokens to Optimism\n   * @param l1Signer The L1 wallet provider (signer)\n   * @param l1Erc20Address The L1 token address\n   * @param l2Erc20Address The L2 token address\n   * @param amount The amount to be deposited in wei\n   * @returns The submitted transaction\n   */\n  async depositERC20(l1Signer: Signer, l1Erc20Address: string, l2Erc20Address: string, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);\n    const l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1StandardBridge.depositERC20(l1_ERC20.address, l2Erc20Address, amount, this.L2_DEPOSIT_GAS_LIMIT, \"0x\");\n  }\n\n  /**\n   * Create transaction to deposit ETH to Optimism\n   * @param l1Signer The L1 wallet provider (signer)\n   * @param amount The amount to be deposited in wei\n   * @returns The submitted transaction\n   */\n  async depositEth(l1Signer: Signer, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);\n    const l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);\n    return l1StandardBridge.depositETH(this.L2_DEPOSIT_GAS_LIMIT, \"0x\", { value: amount });\n  }\n\n  /**\n   * Wait a L1 transaction to be relayed by the L1 Cross Domain Messenger\n   * @param tx The L1 -> L2 transaction\n   * @param l1RpcProvider Layer 1 RPC provider\n   * @param l2RpcProvider Layer 2 RPC provider\n   * @returns The transaction receipt\n   */\n  async waitRelayToL2(tx: ContractTransaction, l1RpcProvider: Provider, l2RpcProvider: Provider) {\n    const l2Messenger = new Contract(\n      predeploys.L2CrossDomainMessenger,\n      getContractInterface(\"L2CrossDomainMessenger\"),\n      l2RpcProvider\n    );\n    const l1Messenger = new Contract(\n      await l2Messenger.l1CrossDomainMessenger(),\n      getContractInterface(\"L1CrossDomainMessenger\"),\n      l1RpcProvider\n    );\n    // Watch for messages to be relayed between L1 and L2.\n    const watcher = new Watcher({\n      l1: {\n        provider: l1RpcProvider,\n        messengerAddress: l1Messenger.address,\n      },\n      l2: {\n        provider: l2RpcProvider,\n        messengerAddress: l2Messenger.address,\n      },\n    });\n    // Wait for the message to be relayed to L2\n    const [msgHash1] = await watcher.getMessageHashesFromL1Tx(tx.hash);\n    return watcher.getL2TransactionReceipt(msgHash1, true);\n  }\n\n  public async checkAllowance(l1Signer: Signer, l1Erc20Address: string) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1_ERC20.allowance(await l1Signer.getAddress(), l1StandardBridgeAddress);\n  }\n\n  public async approve(l1Signer: Signer, l1Erc20Address: string, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = this.getL1BridgeAddress(chainId);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1_ERC20.approve(l1StandardBridgeAddress, amount);\n  }\n}\n","import assert from \"assert\";\nimport { ethers } from \"ethers\";\nimport { Provider } from \"@ethersproject/providers\";\nimport { Signer, BigNumber, ContractTransaction } from \"ethers\";\nimport {\n  ERC20Ethers__factory,\n  OptimismL1StandardBridgeEthers__factory,\n  BobaAddressManagerEthers__factory,\n} from \"@uma/contracts-node\";\nimport { Watcher } from \"@eth-optimism/core-utils\";\nimport { SignerOrProvider } from \"../..\";\n\nexport const l1Contracts: { ADDRESS_MANAGER_ADDRESS: { [chainId: number]: string } } = {\n  ADDRESS_MANAGER_ADDRESS: {\n    // mainnet\n    1: \"0x8376ac6C3f73a25Dd994E0b0669ca7ee0C02F089\",\n    // rinkeby\n    4: \"0x93A96D6A5beb1F661cf052722A1424CDDA3e9418\",\n  },\n};\n\nexport class BobaBridgeClient {\n  // Gas limit for the L2 transaction initiated by the Sequencer\n  public readonly L2_DEPOSIT_GAS_LIMIT = 1300000;\n\n  public async getL1BridgeAddress(chainId: number, l1Provider: SignerOrProvider): Promise<string> {\n    const addressManagerAddress = l1Contracts.ADDRESS_MANAGER_ADDRESS[chainId];\n    assert(typeof addressManagerAddress === \"string\", \"Chain not supported\");\n    const addressManager = BobaAddressManagerEthers__factory.connect(addressManagerAddress, l1Provider);\n    const l1StandardBridgeAddress = await addressManager.getAddress(\"Proxy__OVM_L1StandardBridge\");\n\n    return l1StandardBridgeAddress;\n  }\n\n  /**\n   * Create a transaction to deposit ERC20 tokens to Boba. Mainnet and Rinkeby are currently supported\n   * @param l1Signer The L1 wallet provider (signer)\n   * @param l1Erc20Address The L1 token address\n   * @param l2Erc20Address The L2 token address\n   * @param amount The amount to be deposited in wei\n   * @returns The submitted transaction\n   */\n  async depositERC20(l1Signer: Signer, l1Erc20Address: string, l2Erc20Address: string, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);\n    const l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1StandardBridge.depositERC20(\n      l1_ERC20.address,\n      l2Erc20Address,\n      amount,\n      this.L2_DEPOSIT_GAS_LIMIT,\n      ethers.utils.formatBytes32String(new Date().getTime().toString())\n    );\n  }\n\n  /**\n   * Create transaction to deposit ETH to Boba\n   * @param l1Signer The L1 wallet provider (signer)\n   * @param amount The amount to be deposited in wei\n   * @returns The submitted transaction\n   */\n  async depositEth(l1Signer: Signer, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);\n    const l1StandardBridge = OptimismL1StandardBridgeEthers__factory.connect(l1StandardBridgeAddress, l1Signer);\n    return l1StandardBridge.depositETH(\n      this.L2_DEPOSIT_GAS_LIMIT,\n      ethers.utils.formatBytes32String(new Date().getTime().toString()),\n      { value: amount }\n    );\n  }\n\n  /**\n   * Wait a L1 transaction to be relayed by the L1 Cross Domain Messenger\n   * @param tx The L1 -> L2 transaction\n   * @param l1RpcProvider Layer 1 RPC provider\n   * @param l2RpcProvider Layer 2 RPC provider\n   * @returns The transaction receipt\n   */\n  async waitRelayToL2(tx: ContractTransaction, l1RpcProvider: Provider, l2RpcProvider: Provider) {\n    const chainId = (await l1RpcProvider.getNetwork()).chainId;\n    const addressManagerAddress = l1Contracts.ADDRESS_MANAGER_ADDRESS[chainId];\n    assert(typeof addressManagerAddress === \"string\", \"Chain not supported\");\n    const addressManager = BobaAddressManagerEthers__factory.connect(addressManagerAddress, l1RpcProvider);\n    const proxyL1CrossDomainMessengerAddress = await addressManager.getAddress(\"Proxy__L1CrossDomainMessenger\");\n    const l2CrossDomainMessenger = await addressManager.getAddress(\"L2CrossDomainMessenger\");\n    // Watch for messages to be relayed between L1 and L2.\n    const watcher = new Watcher({\n      l1: {\n        provider: l1RpcProvider,\n        messengerAddress: proxyL1CrossDomainMessengerAddress,\n      },\n      l2: {\n        provider: l2RpcProvider,\n        messengerAddress: l2CrossDomainMessenger,\n      },\n    });\n    // Wait for the message to be relayed to L2\n    const [msgHash] = await watcher.getMessageHashesFromL1Tx(tx.hash);\n    return watcher.getL2TransactionReceipt(msgHash, true);\n  }\n\n  public async checkAllowance(l1Signer: Signer, l1Erc20Address: string) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1_ERC20.allowance(await l1Signer.getAddress(), l1StandardBridgeAddress);\n  }\n\n  public async approve(l1Signer: Signer, l1Erc20Address: string, amount: BigNumber) {\n    const chainId = await l1Signer.getChainId();\n    const l1StandardBridgeAddress = await this.getL1BridgeAddress(chainId, l1Signer);\n    const l1_ERC20 = ERC20Ethers__factory.connect(l1Erc20Address, l1Signer);\n    return l1_ERC20.approve(l1StandardBridgeAddress, amount);\n  }\n}\n","import { exists } from \"../utils\";\n\n// This error should be thrown if an expected value does not exist\nexport class ExistenceError extends Error {\n  constructor(message = \"\") {\n    super(message);\n    this.name = \"ExistenceError\";\n    // if this isnt included, we cannot use instanceof to check the type\n    Object.setPrototypeOf(this, ExistenceError.prototype);\n  }\n}\n\n// Special assert which checks for existence and throw existence error\nexport function assertExists<T>(condition: T, message = \"\"): asserts condition is NonNullable<T> {\n  if (!exists(condition)) throw new ExistenceError(message);\n}\n\n// Ignore only existence errors. If thrown properly this can be used to convert a non existent value to undefined.\nexport function ignoreExistenceError<X>(call: () => X): X | undefined {\n  try {\n    return call();\n  } catch (err) {\n    if (err instanceof ExistenceError) return undefined;\n    throw err;\n  }\n}\n\n// same function but for async calls\nexport async function ignoreExistenceErrorAsync<X>(call: () => X): Promise<X | undefined> {\n  try {\n    return await call();\n  } catch (err) {\n    if (err instanceof ExistenceError) return undefined;\n    throw err;\n  }\n}\n","import { JsonRpcSigner, BigNumber, Web3Provider, FallbackProvider } from \"./ethers\";\nimport type { erc20, sortedRequests } from \"../services\";\nimport { Request, OracleInterface } from \"./interfaces\";\nimport type Multicall2 from \"../../multicall2\";\nimport { Context, Memory } from \"./statemachine\";\nimport { RequestState, RequestKey } from \"../../clients/optimisticOracle\";\n\n// create partial picker: https://stackoverflow.com/questions/43159887/make-a-single-property-optional-in-typescript\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport { Context, Memory };\n\nexport type ChainServices = {\n  multicall2: Multicall2;\n  provider: FallbackProvider;\n  erc20s: Record<string, erc20.Erc20>;\n  optimisticOracle: OracleInterface;\n};\n\nexport type Services = {\n  sortedRequests?: sortedRequests.SortedRequests;\n  chains?: Record<number, Partial<ChainServices>>;\n};\n\n// this is required data in order to add a new chain to users wallet\nexport type ChainMetadata = {\n  chainId: number;\n  chainName: string;\n  // require at least 1 url\n  rpcUrls: [string, ...string[]];\n  blockExplorerUrls: [string, ...string[]];\n  nativeCurrency: {\n    name: string;\n    symbol: string;\n    decimals: number;\n  };\n};\n\nexport type ChainConfig = ChainMetadata & {\n  checkTxIntervalSec: number;\n  multicall2Address?: string;\n  optimisticOracleAddress: string;\n  // specify a block number which we do not care about blocks before this. This effectively prevents listing\n  // requests older than this. If not specified, we will lookback to block 0 when considering request history.\n  earliestBlockNumber?: number;\n  maxEventRangeQuery?: number;\n  disableFetchEventBased?: boolean;\n};\n\nexport type InputRequestWithOracleType = InputRequest & { oracleType: OracleType };\nexport type RequestWithOracleType = Request & { oracleType: OracleType };\nexport type RequestsWithOracleType = RequestWithOracleType[];\n// partial config lets user omit some fields which we can infer internally using contracts-frontend\nexport type PartialChainConfig = PartialBy<ChainConfig, \"chainId\" | \"checkTxIntervalSec\" | \"earliestBlockNumber\">;\n\nexport enum OracleType {\n  Optimistic = \"Optimistic\",\n  Skinny = \"Skinny\",\n  OptimisticV2 = \"OptimisticV2\",\n}\n// config definition\nexport type Config = {\n  chains: Record<number, ChainConfig>;\n  oracleType: OracleType;\n};\n\nexport type PartialConfig = {\n  chains: Record<number, PartialChainConfig>;\n};\n\nexport type PartialConfigTable = {\n  [key in OracleType]?: PartialConfig;\n};\nexport type Balances = Record<string, BigNumber>;\n\nexport type User = {\n  address: string;\n  chainId: number;\n  signer: JsonRpcSigner;\n  provider: Web3Provider;\n};\n\nexport enum Flag {\n  MissingRequest = \"MissingRequest\", // the client does not know the request, use client.setActiveRequest\n  MissingUser = \"MissingUser\", // client does not have user data, use client.setUser\n  WrongChain = \"WrongChain\", // user and request chain ids do not match, switch chains with client.switchOrAddChain\n  CanPropose = \"CanPropose\", // The on chain request is in a state where someone could propose, use client.proposePrice\n  CanDispute = \"CanDispute\", // The on chain request is in a state where someone could dispute, use client.disputePrice\n  CanSettle = \"CanSettle\", // The on chain request is in a stae where someone could settle the request.\n  InDvmVote = \"InDvmVote\", // Proposed answer has been disputed and passed to dvm for full vote.\n  RequestSettled = \"RequestSettled\", // Request is finalized, no more changes.\n  InsufficientBalance = \"InsufficientBalance\", // The user does not have enough balance to cover bond collateral for dispute/propose\n  InsufficientApproval = \"InsufficientApproval\", // The oracle contract does not have enough approval to cover bond for dispute/propose, use client.approve\n  ChainChangeInProgress = \"ChainChangeInProgress\", // The user is changing his chain\n  ProposalTxInProgress = \"ProposalTxInProgress\", // The user is sending a proposal tx\n  ApprovalTxInProgress = \"ApprovalTxInProgress\", // The user is sending an approval tx\n  DisputeTxInProgress = \"DisputeTxInProgress\", // The user is sending a dispute tx\n}\nexport type Flags = Record<Flag, boolean>;\n\nexport type InputRequest = RequestKey & { chainId: number };\n\nexport type Inputs = {\n  request: InputRequest;\n  user: Partial<User>;\n};\n\nexport type Erc20Props = {\n  address: string;\n  symbol: string;\n  name: string;\n  decimals: number;\n  totalSupply: BigNumber;\n};\n\nexport type Erc20 = {\n  props: Partial<Erc20Props>;\n  allowances: Record<string, Balances>;\n  balances: Balances;\n};\n\nexport { RequestState };\n\nexport type OptimisticOracle = {\n  address: string;\n  defaultLiveness: BigNumber;\n  requests: Record<string, Request>;\n};\n\nexport type Chain = {\n  erc20s: Record<string, Partial<Erc20>>;\n  optimisticOracle: Partial<OptimisticOracle>;\n  currentTime: BigNumber;\n};\n\nexport type State = Partial<{\n  error: Error;\n  inputs: Partial<Inputs>;\n  chains: Record<number, Partial<Chain>>;\n  config: Config;\n  services: Services;\n  commands: Record<string, Context<unknown, unknown & Memory>>;\n  descendingRequests: Request[];\n}>;\n","import type { ContextClient } from \"../services/statemachines/utils\";\n\n// memory can be any non primitive type or undefined\n// eslint-disable-next-line\nexport type Memory = object | undefined;\n\nexport enum ContextType {\n  setUser = \"setUser\",\n  setActiveRequest = \"setActiveRequest\",\n  approve = \"approve\",\n  clearUser = \"clearUser\",\n  disputePrice = \"disputePrice\",\n  proposePrice = \"proposePrice\",\n  switchOrAddChain = \"switchOrAddChain\",\n  pollActiveRequest = \"pollActiveRequest\",\n  pollActiveUser = \"pollActiveUser\",\n  fetchPastEvents = \"fetchPastEvents\",\n  pollNewEvents = \"pollNewEvents\",\n  setActiveRequestByTransaction = \"setActiveRequestByTransaction\",\n  settle = \"settle\",\n  updateActiveRequest = \"updateActiveRequest\",\n  fetchEventBased = \"fetchEventBased\",\n}\n\nexport type ContextProps = {\n  id: string;\n  user?: string;\n  type: ContextType;\n  state: \"done\" | \"error\" | string;\n  done: boolean;\n  created: number;\n  updated?: number;\n  error?: Error;\n  sleep?: number;\n};\n\nexport type Context<P = undefined, M extends Memory = undefined> = ContextProps & {\n  memory: M;\n  params: P;\n};\n\nexport type Handler<P = undefined, M extends Memory = undefined> = (\n  params: P,\n  memory: M,\n  client: ContextClient\n) => string | undefined | void | Promise<string | undefined | void>;\n\nexport type Handlers<P = undefined, M extends Memory = undefined> = Record<string, Handler<P, M>> & {\n  start: Handler<P, M>;\n};\n\nexport type Step<P = undefined, M extends Memory = undefined> = (\n  context: Context<P, M>,\n  now: number\n) => Promise<Context<P, M>>;\n\nexport type Emit<P = undefined, M extends Memory = undefined> = (context: Context<P, M>) => void;\n","import assert from \"assert\";\nimport { ethers } from \"ethers\";\nimport sortedLastIndexBy from \"lodash/sortedLastIndexBy\";\nimport { ignoreExistenceError } from \"./errors\";\n// this request id does not include chain id\nexport { requestId } from \"../clients/optimisticOracle\";\n\nimport {\n  State,\n  RequestState,\n  Flag,\n  Flags,\n  PartialChainConfig,\n  ChainConfig,\n  PartialConfig,\n  ChainMetadata,\n  Config,\n  OracleType,\n} from \"./types/state\";\nimport type { Provider, TransactionReceipt, BigNumberish } from \"./types/ethers\";\nimport { ContextType } from \"./types/statemachine\";\nimport { Read } from \"./store\";\n\nexport const getAddress = ethers.utils.getAddress;\nexport const hexValue = ethers.utils.hexValue;\n\nexport function initFlags(): Flags {\n  return {\n    [Flag.MissingRequest]: false,\n    [Flag.MissingUser]: false,\n    [Flag.WrongChain]: false,\n    [Flag.CanPropose]: false,\n    [Flag.CanDispute]: false,\n    [Flag.CanSettle]: false,\n    [Flag.InDvmVote]: false,\n    [Flag.RequestSettled]: false,\n    [Flag.InsufficientBalance]: false,\n    [Flag.InsufficientApproval]: false,\n    [Flag.ProposalTxInProgress]: false,\n    [Flag.ApprovalTxInProgress]: false,\n    [Flag.DisputeTxInProgress]: false,\n    [Flag.ChainChangeInProgress]: false,\n  };\n}\n\nexport const nowS = (now = Date.now()): number => Math.floor(now / 1000);\n\n// reduce global state into important UI boolean states. this should never throw errors.\nexport function getFlags(state: State): Record<Flag, boolean> {\n  const read = new Read(state);\n  const flags = initFlags();\n\n  const signer = ignoreExistenceError(read.signer);\n  flags[Flag.MissingUser] = signer ? false : true;\n\n  const inputRequest = ignoreExistenceError(read.inputRequest);\n  flags[Flag.MissingRequest] = inputRequest ? false : true;\n\n  const userChainId = ignoreExistenceError(read.userChainId);\n  const requestChainId = ignoreExistenceError(read.requestChainId);\n  flags[Flag.WrongChain] = userChainId && requestChainId ? userChainId !== requestChainId : false;\n\n  const request = ignoreExistenceError(read.request);\n\n  // these are a bit redundant with request state, but just an alternate way to see current request state\n  flags[Flag.CanPropose] = request?.state === RequestState.Requested;\n  flags[Flag.CanDispute] = request?.state === RequestState.Proposed;\n  flags[Flag.CanSettle] = request?.state === RequestState.Resolved || request?.state === RequestState.Expired;\n  flags[Flag.InDvmVote] = request?.state === RequestState.Disputed;\n  flags[Flag.RequestSettled] = request?.state === RequestState.Settled;\n\n  if (request && request.bond && request.finalFee) {\n    const totalBond = request.bond.add(request.finalFee);\n    const userCollateralBalance = ignoreExistenceError(read.userCollateralBalance);\n    const userCollateralAllowance = ignoreExistenceError(read.userCollateralAllowance);\n    flags[Flag.InsufficientBalance] = userCollateralBalance ? userCollateralBalance.lt(totalBond) : false;\n    flags[Flag.InsufficientApproval] = userCollateralAllowance ? userCollateralAllowance.lt(totalBond) : false;\n  }\n\n  const userAddress = ignoreExistenceError(read.userAddress);\n  const commands = ignoreExistenceError(() => read.filterCommands({ done: false, user: userAddress }));\n  if (userAddress && commands) {\n    commands.forEach((command) => {\n      if (!flags[Flag.ProposalTxInProgress] && command.type === ContextType.proposePrice) {\n        flags[Flag.ProposalTxInProgress] = true;\n      }\n      if (!flags[Flag.DisputeTxInProgress] && command.type === ContextType.disputePrice) {\n        flags[Flag.DisputeTxInProgress] = true;\n      }\n      if (!flags[Flag.ApprovalTxInProgress] && command.type === ContextType.approve) {\n        flags[Flag.ApprovalTxInProgress] = true;\n      }\n      if (!flags[Flag.ChainChangeInProgress] && command.type === ContextType.switchOrAddChain) {\n        flags[Flag.ChainChangeInProgress] = true;\n      }\n    });\n  }\n\n  return flags;\n}\n\nexport function getMulticall2Address(chainId: number): string {\n  switch (chainId.toString()) {\n    case \"1\":\n      return getAddress(\"0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696\");\n    case \"4\":\n      return getAddress(\"0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696\");\n    case \"5\":\n      return getAddress(\"0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696\");\n    case \"42\":\n      return getAddress(\"0x5BA1e12693Dc8F9c48aAD8770482f4739bEeD696\");\n    default:\n      throw new Error(`No address found for deployment Multicall2 on chainId ${chainId}`);\n  }\n}\ntype AddressGetter = (chainId: number) => string;\ninterface AddressGetters {\n  getMulticall2Address: AddressGetter;\n}\n\nexport const DefaultChainConfig = ({ getMulticall2Address }: AddressGetters) => (\n  chainId: number,\n  chainConfig: PartialChainConfig\n): ChainConfig => {\n  let multicall2Address = chainConfig.multicall2Address;\n  try {\n    multicall2Address = multicall2Address || getMulticall2Address(chainId);\n  } catch (err) {\n    // ignore, multicall optional\n  }\n\n  const checkTxIntervalSec = chainConfig.checkTxIntervalSec || 5;\n\n  return {\n    ...chainConfig,\n    chainId,\n    multicall2Address,\n    checkTxIntervalSec,\n  };\n};\n\nexport const DefaultConfig = (getters: AddressGetters) => (config: PartialConfig, oracleType: OracleType): Config => {\n  return Object.entries(config.chains).reduce(\n    (config: Config, [chainId, chainConfig]) => {\n      config.chains[Number(chainId)] = DefaultChainConfig(getters)(Number(chainId), chainConfig);\n      return config;\n    },\n    { ...config, chains: {}, oracleType }\n  );\n};\n\nexport class TransactionConfirmer {\n  constructor(private provider: Provider) {}\n  async getReceipt(hash: string): Promise<TransactionReceipt> {\n    return this.provider.getTransactionReceipt(hash);\n  }\n  async isConfirmed(hash: string, confirmations = 1): Promise<false | TransactionReceipt> {\n    try {\n      const receipt = await this.getReceipt(hash);\n      if (receipt.confirmations >= confirmations) return receipt;\n    } catch (err) {\n      // do nothing\n    }\n    return false;\n  }\n}\n\nexport function chainConfigToChainMetadata(config: ChainConfig): ChainMetadata {\n  const {\n    // remove extra fields\n    checkTxIntervalSec,\n    multicall2Address,\n    optimisticOracleAddress,\n    earliestBlockNumber,\n    maxEventRangeQuery,\n    ...chainMetadata\n  } = config;\n  return chainMetadata;\n}\n\n// This state is meant for adjusting a start/end block when querying events. Some apis will fail if the range\n// is too big, so the following functions will adjust range dynamically.\nexport type RangeState = {\n  startBlock: number;\n  endBlock: number;\n  maxRange: number;\n  currentRange: number;\n  currentStart: number; // This is the start value you want for your query.\n  currentEnd: number; // this is the end value you want for your query.\n  done: boolean; // Signals we successfully queried the entire range.\n  multiplier?: number; // Multiplier increases or decreases range by this value, depending on success or failure\n};\n\n/**\n * rangeStart. This starts a new range query and sets defaults for state.  Use this as the first call before starting your queries\n *\n * @param {Pick} state\n * @returns {RangeState}\n */\nexport function rangeStart(\n  state: Pick<RangeState, \"startBlock\" | \"endBlock\" | \"multiplier\"> & { maxRange?: number }\n): RangeState {\n  const { startBlock, endBlock, multiplier = 2 } = state;\n  if (state.maxRange && state.maxRange > 0) {\n    const range = endBlock - startBlock;\n    assert(range > 0, \"End block must be higher than start block\");\n    const currentRange = Math.min(state.maxRange, range);\n    const currentStart = endBlock - currentRange;\n    const currentEnd = endBlock;\n    return {\n      done: false,\n      startBlock,\n      endBlock,\n      maxRange: state.maxRange,\n      currentRange,\n      currentStart,\n      currentEnd,\n      multiplier,\n    };\n  } else {\n    // the largest range we can have, since this is the users query for start and end\n    const maxRange = endBlock - startBlock;\n    assert(maxRange > 0, \"End block must be higher than start block\");\n    const currentStart = startBlock;\n    const currentEnd = endBlock;\n    const currentRange = maxRange;\n\n    return {\n      done: false,\n      startBlock,\n      endBlock,\n      maxRange,\n      currentRange,\n      currentStart,\n      currentEnd,\n      multiplier,\n    };\n  }\n}\n/**\n * rangeSuccessDescending. We have 2 ways of querying events, from oldest to newest, or newest to oldest. Typically we want them in order, from\n * oldest to newest, but for this particular case we want them newest to oldest, ie descending ( larger timestamp to smaller timestamp).\n * This function will increase the range between start/end block and return a new start/end to use since by calling this you are signalling\n * that the last range ended in a successful query.\n *\n * @param {RangeState} state\n * @returns {RangeState}\n */\nexport function rangeSuccessDescending(state: RangeState): RangeState {\n  const { startBlock, currentStart, maxRange, currentRange, multiplier = 2 } = state;\n  // we are done if we succeeded querying where the currentStart matches are initial start block\n  const done = currentStart <= startBlock;\n  // increase range up to max range for every successful query\n  const nextRange = Math.min(Math.ceil(currentRange * multiplier), maxRange);\n  // move our end point to the previously successful start, ie moving from newest to oldest\n  const nextEnd = currentStart;\n  // move our start block to the next range down\n  const nextStart = Math.max(nextEnd - nextRange, startBlock);\n  return {\n    ...state,\n    currentStart: nextStart,\n    currentEnd: nextEnd,\n    currentRange: nextRange,\n    done,\n  };\n}\n/**\n * rangeFailureDescending. Like the previous function, this will decrease the range between start/end for your query, because you are signalling\n * that the last query failed. It will also keep the end of your range the same, while moving the start range up. This is why\n * its considered descending, it will attempt to move from end to start, rather than start to end.\n *\n * @param {RangeState} state\n * @returns {RangeState}\n */\nexport function rangeFailureDescending(state: RangeState): RangeState {\n  const { startBlock, currentEnd, currentRange, multiplier = 2 } = state;\n  const nextRange = Math.floor(currentRange / multiplier);\n  // this will eventually throw an error if you keep calling this function, which protects us against re-querying a broken api in a loop\n  assert(nextRange > 0, \"Range must be above 0\");\n  // we stay at the same end block\n  const nextEnd = currentEnd;\n  // move our start block closer to the end block, shrinking the range\n  const nextStart = Math.max(nextEnd - nextRange, startBlock);\n  return {\n    ...state,\n    currentStart: nextStart,\n    currentEnd: nextEnd,\n    currentRange: nextRange,\n  };\n}\n\n/**\n * eventKey. Make a unique and sortable identifier string for an event\n *\n * @param {Event} event\n * @returns {string} - the unique id\n */\nexport function eventKey(event: {\n  blockNumber: BigNumberish;\n  transactionIndex: BigNumberish;\n  logIndex: BigNumberish;\n}): string {\n  return [\n    // we pad these because numbers of varying lengths will not sort correctly, ie \"10\" will incorrectly sort before \"9\", but \"09\" will be correct.\n    event.blockNumber.toString().padStart(16, \"0\"),\n    event.transactionIndex.toString().padStart(16, \"0\"),\n    event.logIndex?.toString().padStart(16, \"0\"),\n    // ~ is the last printable ascii char, so it does not interfere with sorting\n  ].join(\"~\");\n}\n/**\n * insertOrdered. Inserts items in an array maintaining sorted order, in this case lowest to highest. Does not check duplicates.\n * Mainly used for caching all known events, in order of oldest to newest.\n *\n * @param {T[]} array\n * @param {T} element\n * @param {Function} orderBy\n */\nexport function insertOrderedAscending<T>(array: T[], element: T, orderBy: (element: T) => string | number): T[] {\n  const index = sortedLastIndexBy(array, element, orderBy);\n  array.splice(index, 0, element);\n  return array;\n}\nexport function isUnique<T>(array: T[], element: T, id: (element: T) => string | number): boolean {\n  const elementId = id(element);\n  const found = array.find((next: T) => {\n    return id(next) === elementId;\n  });\n  return found === undefined;\n}\n\nexport function isSupportedOracleType(oracleType: string): oracleType is OracleType {\n  return oracleType in OracleType;\n}\n","import { erc20 } from \"../../clients\";\nimport Multicall2 from \"../../multicall2\";\nimport { BatchReadWithErrors, BatchReadWithErrorsType, Calls } from \"../../utils\";\nimport { Provider, Signer, BigNumberish, TransactionResponse } from \"../types/ethers\";\nimport { Erc20Props } from \"../types/state\";\n\nconst batchProps: Calls = [[\"symbol\"], [\"name\"], [\"decimals\"], [\"totalSupply\"]];\nexport class Erc20 {\n  public contract: erc20.Instance;\n  constructor(protected provider: Provider, public readonly address: string) {\n    this.contract = erc20.connect(address, provider);\n  }\n  async approve(signer: Signer, spender: string, amount: BigNumberish): Promise<TransactionResponse> {\n    const contract = erc20.connect(this.address, signer);\n    return contract.approve(spender, amount);\n  }\n  async getProps(): Promise<Erc20Props> {\n    const { contract } = this;\n    return {\n      address: this.address,\n      symbol: await contract.callStatic.symbol(),\n      name: await contract.callStatic.name(),\n      decimals: await contract.callStatic.decimals(),\n      totalSupply: await contract.callStatic.totalSupply(),\n    };\n  }\n}\nexport class Erc20Multicall extends Erc20 {\n  private batchRead: BatchReadWithErrorsType;\n  constructor(provider: Provider, address: string, private multicall2: Multicall2) {\n    super(provider, address);\n    this.batchRead = BatchReadWithErrors(multicall2)(this.contract);\n  }\n  async getProps(): Promise<Erc20Props> {\n    return {\n      ...(await this.batchRead<Erc20Props>(batchProps)),\n      address: this.address,\n    };\n  }\n}\nexport function factory(provider: Provider, address: string, multicall2?: Multicall2): Erc20 {\n  if (!multicall2) return new Erc20(provider, address);\n  return new Erc20Multicall(provider, address, multicall2);\n}\n","import type * as ethersTypes from \"../types/ethers\";\nimport * as state from \"../types/state\";\nimport * as statemachine from \"../types/statemachine\";\n\nimport { requestId } from \"../utils\";\nimport { factory as Erc20Factory } from \"../services/erc20\";\nimport Multicall2 from \"../../multicall2\";\nimport { SortedRequests } from \"../services/sortedRequests\";\nimport type { OracleInterface, Request, Requests } from \"../types/interfaces\";\n\n// This file contains composable and type safe state writers which mirror the state in types/state.\n// Each component takes in 1 parameters, state and you can include any number of functions to operate on the state.\n// Some things to consider:\n// 1. State can be nested, but it should strictly one direction, each class should ideally only operate on its direct state object.\n// 2. The parent can return new components, but its responsible for initializing the state for the child.\n// 3. You can modify this.state in the component thanks to immer, but you cannot set this.state to a new object, only its properties.\n\nexport class User {\n  constructor(private state: Partial<state.User>) {}\n  set(data: Partial<state.User>): void {\n    // note that this is done because we cannot replace this.state = data or immer loses visibility to the change.\n    if (data.chainId) this.chainId(data.chainId);\n    if (data.address) this.address(data.address);\n    if (data.signer) this.signer(data.signer);\n    if (data.provider) this.provider(data.provider);\n  }\n  clear(): void {\n    delete this.state.chainId;\n    delete this.state.address;\n    delete this.state.signer;\n    delete this.state.provider;\n  }\n  chainId(chainId: number): void {\n    this.state.chainId = chainId;\n  }\n  address(address: string): void {\n    this.state.address = address;\n  }\n  signer(signer: ethersTypes.JsonRpcSigner): void {\n    this.state.signer = signer;\n  }\n  provider(provider: ethersTypes.Web3Provider): void {\n    this.state.provider = provider;\n  }\n}\nexport class Balances {\n  constructor(private state: Partial<state.Balances>) {}\n  set(address: string, amount: ethersTypes.BigNumber): void {\n    this.state[address] = amount;\n  }\n}\nexport class Erc20 {\n  constructor(private state: Partial<state.Erc20>) {}\n  props(data: state.Erc20[\"props\"]): void {\n    this.state.props = data;\n  }\n  balance(account: string, amount: ethersTypes.BigNumber): void {\n    if (!this.state.balances) this.state.balances = {};\n    new Balances(this.state.balances).set(account, amount);\n  }\n  allowance(account: string, spender: string, amount: ethersTypes.BigNumber): void {\n    if (!this.state.allowances) this.state.allowances = {};\n    if (!this.state.allowances[spender]) this.state.allowances[spender] = {};\n    new Balances(this.state.allowances[spender]).set(account, amount);\n  }\n}\nexport class OptimisticOracle {\n  constructor(private state: Partial<state.OptimisticOracle>) {}\n  address(address: string): void {\n    this.state.address = address;\n  }\n  request(request: Request): void {\n    const id = requestId(request);\n    if (!this.state.requests) this.state.requests = {};\n    // merge data in rather than replace\n    this.state.requests[id] = { ...this.state.requests[id], ...request };\n  }\n  defaultLiveness(defaultLiveness: ethersTypes.BigNumber): void {\n    this.state.defaultLiveness = defaultLiveness;\n  }\n}\nexport class Chain {\n  constructor(private state: Partial<state.Chain>) {}\n  erc20s(address: string): Erc20 {\n    if (!this.state?.erc20s) this.state.erc20s = {};\n    if (!this.state.erc20s?.[address]) this.state.erc20s[address] = {};\n    return new Erc20(this.state.erc20s[address]);\n  }\n  optimisticOracle(): OptimisticOracle {\n    if (!this.state?.optimisticOracle) this.state.optimisticOracle = {};\n    return new OptimisticOracle(this.state.optimisticOracle);\n  }\n  currentTime(currentTime: ethersTypes.BigNumber): void {\n    this.state.currentTime = currentTime;\n  }\n}\nexport class Inputs {\n  constructor(private state: Partial<state.Inputs>) {}\n  request(params: state.Inputs[\"request\"]): void {\n    this.state.request = params;\n  }\n  user(): User {\n    if (!this.state.user) this.state.user = {};\n    return new User(this.state.user);\n  }\n}\n\nexport class Services {\n  constructor(private state: Partial<state.ChainServices>) {}\n  provider(provider: ethersTypes.FallbackProvider): void {\n    this.state.provider = provider;\n  }\n  erc20s(address: string): void {\n    if (!this.state?.provider) return;\n    if (!this.state?.erc20s) this.state.erc20s = {};\n    // only add this once\n    if (this.state?.erc20s[address]) return;\n    this.state.erc20s[address] = Erc20Factory(this.state.provider, address, this.state.multicall2);\n  }\n  optimisticOracle(optimisticOracle: OracleInterface): void {\n    if (this.state.optimisticOracle) return;\n    this.state.optimisticOracle = optimisticOracle;\n  }\n  multicall2(multicall2Address?: string): void {\n    if (!multicall2Address) return;\n    if (this.state.multicall2) return;\n    if (!this.state.provider) return;\n    this.state.multicall2 = new Multicall2(multicall2Address, this.state.provider);\n  }\n}\n\n/**\n * Write. The main writer class for this applications global state object. Composes classes that initialize, validate\n * and simplify changes to the global state. This class modifies state directly, and really is only useful in combination with immer.\n */\nexport default class Write {\n  constructor(private state: state.State) {}\n  chains(chainId: number): Chain {\n    if (!this.state?.chains) this.state.chains = {};\n    if (!this.state?.chains?.[chainId]) this.state.chains[chainId] = {};\n    return new Chain(this.state.chains[chainId]);\n  }\n  inputs(): Inputs {\n    if (!this.state.inputs) this.state.inputs = {};\n    return new Inputs(this.state.inputs);\n  }\n  config(config: state.Config): void {\n    this.state.config = config;\n  }\n  services(chainId: number): Services {\n    if (!this.state.services) this.state.services = {};\n    if (!this.state.services.chains) this.state.services.chains = {};\n    if (!this.state.services.chains[chainId]) this.state.services.chains[chainId] = {};\n    return new Services(this.state.services.chains[chainId]);\n  }\n  error(error?: Error): void {\n    this.state.error = error;\n  }\n  command(context: statemachine.Context<unknown, unknown & statemachine.Memory>): void {\n    if (!this.state.commands) this.state.commands = {};\n    this.state.commands[context.id] = context;\n  }\n  sortedRequestsService(sortedRequests: SortedRequests): void {\n    if (this.state?.services?.sortedRequests) return;\n    // only want to add this once\n    this.state.services = { sortedRequests };\n  }\n  descendingRequests(sortedRequests: Requests): void {\n    this.state.descendingRequests = sortedRequests;\n  }\n}\n","import filter from \"lodash/filter\";\n\nimport type {\n  State,\n  Chain,\n  InputRequest,\n  Erc20Props,\n  ChainConfig,\n  Context,\n  Memory,\n  User,\n  OracleType,\n} from \"../types/state\";\nimport type { JsonRpcSigner, BigNumber, Provider } from \"../types/ethers\";\nimport { TransactionConfirmer, requestId } from \"../utils\";\nimport { OracleInterface, Request, Requests } from \"../types/interfaces\";\nimport { Erc20 } from \"../services/erc20\";\nimport { SortedRequests } from \"../services/sortedRequests\";\nimport { assertExists } from \"../errors\";\n\n// This is a typescript compatible way of pulling out values from the global state object, essentially\n// forming a basic API. Most calls are parameterless, requiring first setting state which determines, the\n// user/chain, etc of the query.\n\nexport default class Read {\n  constructor(private state: State) {}\n  chainConfig = (optionalChainId?: number): ChainConfig => {\n    const chainId = optionalChainId || this.requestChainId();\n    const config = this.state?.config?.chains?.[chainId];\n    assertExists(config, \"No config set for chain: \" + chainId);\n    return config;\n  };\n  oracleType = (): OracleType => {\n    const source = this.state?.config?.oracleType;\n    assertExists(source, \"No oracle name set on config\");\n    return source;\n  };\n  requestChainId = (): number => {\n    const chainId = this.state?.inputs?.request?.chainId;\n    assertExists(chainId, \"ChainId is not set on request\");\n    return chainId;\n  };\n  user = (): Partial<User> => {\n    const result = this.state?.inputs?.user;\n    assertExists(result, \"user not set\");\n    return result;\n  };\n  userChainId = (): number => {\n    const chainId = this.state?.inputs?.user?.chainId;\n    assertExists(chainId, \"ChainId is not set\");\n    return chainId;\n  };\n  requestChain = (optionalChainId?: number): Partial<Chain> => {\n    const chainId = optionalChainId || this.requestChainId();\n    const chain = this.state?.chains?.[chainId];\n    assertExists(chain, \"Chain not set\");\n    return chain;\n  };\n  userAddress = (): string => {\n    const address = this.state?.inputs?.user?.address;\n    assertExists(address, \"User address is not set\");\n    return address;\n  };\n  oracleAddress = (optionalChainId?: number): string => {\n    const chain = this.requestChain(optionalChainId);\n    const address = chain?.optimisticOracle?.address;\n    assertExists(address, \"Optimistic oracle address not set\");\n    return address;\n  };\n  signer = (): JsonRpcSigner => {\n    const signer = this.state?.inputs?.user?.signer;\n    assertExists(signer, \"Signer is not set\");\n    return signer;\n  };\n  inputRequest = (): InputRequest => {\n    const input = this.state?.inputs?.request;\n    assertExists(input, \"Input request is not set\");\n    return input;\n  };\n  defaultLiveness = (): BigNumber => {\n    const chain = this.requestChain();\n    const liveness = chain?.optimisticOracle?.defaultLiveness;\n    assertExists(liveness, \"Optimistic oracle defaultLiveness set\");\n    return liveness;\n  };\n  request = (): Request => {\n    const chain = this.requestChain();\n    const input = this.inputRequest();\n    const id = requestId(input);\n    const request = chain?.optimisticOracle?.requests?.[id];\n    assertExists(request, \"Request has not been fetched\");\n    return request;\n  };\n  collateralProps = (): Partial<Erc20Props> => {\n    const request = this.request();\n    assertExists(request.currency, \"Request currency not set\");\n    const chain = this.requestChain();\n    const props = chain.erc20s?.[request.currency]?.props;\n    assertExists(props, \"Props not set on collateral token\");\n    return props;\n  };\n  userCollateralBalance = (): BigNumber => {\n    const request = this.request();\n    assertExists(request.currency, \"Request currency not set\");\n    const chain = this.requestChain();\n    const user = this.userAddress();\n    const balance = chain?.erc20s?.[request.currency]?.balances?.[user];\n    assertExists(balance, \"Balance not set on collateral token for user\");\n    return balance;\n  };\n  userCollateralAllowance = (): BigNumber => {\n    const request = this.request();\n    assertExists(request.currency, \"Request currency not set\");\n    const chain = this.requestChain();\n    const user = this.userAddress();\n    const oracle = this.oracleAddress();\n    const allowance = chain?.erc20s?.[request.currency]?.allowances?.[oracle]?.[user];\n    assertExists(allowance, \"Allowance not set on user on collateral token for oracle\");\n    return allowance;\n  };\n  oracleService = (optionalChainId?: number): OracleInterface => {\n    const chainId = optionalChainId || this.requestChainId();\n    const result = this.state?.services?.chains?.[chainId]?.optimisticOracle;\n    assertExists(result, \"Optimistic Oracle Not found on chain \" + chainId);\n    return result;\n  };\n  collateralService = (): Erc20 => {\n    const chainId = this.requestChainId();\n    const request = this.request();\n    assertExists(request.currency, \"Request currency not set\");\n    const result = this.state?.services?.chains?.[chainId]?.erc20s?.[request.currency];\n    assertExists(result, \"Token not supported on chain \" + chainId);\n    return result;\n  };\n  command = (id: string): Context<unknown, unknown & Memory> => {\n    const result = this.state?.commands?.[id];\n    assertExists(result, \"Unable to find command \" + id);\n    return result;\n  };\n  tokenService = (chainId: number, address: string): Erc20 => {\n    const result = this.state?.services?.chains?.[chainId]?.erc20s?.[address];\n    assertExists(result, \"Token service not found: \" + [chainId, address].join(\".\"));\n    return result;\n  };\n  provider = (chainId: number): Provider => {\n    const result = this.state?.services?.chains?.[chainId]?.provider;\n    assertExists(result, \"Provider not found on chainid: \" + chainId);\n    return result;\n  };\n  transactionService = (chainId: number): TransactionConfirmer => {\n    const provider = this.provider(chainId);\n    return new TransactionConfirmer(provider);\n  };\n  listCommands = (): Context<unknown, unknown & Memory>[] => {\n    return Object.values(this.state?.commands || []);\n  };\n  filterCommands = (search: { user?: string; done?: boolean }): Context<unknown, unknown & Memory>[] => {\n    return filter(this.listCommands(), search) as Context<unknown, unknown & Memory>[];\n  };\n  chain = (optionalChainId?: number): Partial<Chain> => {\n    const chainId = optionalChainId || this.requestChainId();\n    const chain = this.state?.chains?.[chainId];\n    assertExists(chain, \"No chain for chainId: \" + chainId);\n    return chain;\n  };\n  currentTime = (optionalChainId?: number): BigNumber => {\n    const chainId = optionalChainId || this.requestChainId();\n    const chain = this.chain(chainId);\n    const time = chain?.currentTime;\n    assertExists(time, \"Current time not available on chain: \" + chainId);\n    return time;\n  };\n  sortedRequestsService = (): SortedRequests => {\n    const result = this.state?.services?.sortedRequests;\n    assertExists(result, \"Sorted request service not set\");\n    return result;\n  };\n  listChains = (): number[] => {\n    return Object.keys(this.state?.chains || {}).map(Number);\n  };\n  descendingRequests = (): Requests => {\n    return this.state.descendingRequests || [];\n  };\n  filterRequests = (query: Partial<Request>): Requests => {\n    return filter(this.descendingRequests(), query);\n  };\n}\n","// return true only if value is not null or undefined\nimport { exists } from \"../../utils\";\n\n// we only ignore this specific error type explicitly emitted from reader class, meaning value is undefined\nimport { ignoreExistenceError } from \"../errors\";\nimport type { State } from \"../types/state\";\n\nimport Read from \"./read\";\n\n// This class checks for existence for values you could potentially read. It mirrors the read interface but returns bools from functions.\nexport default class Has {\n  private read: Read;\n  constructor(private state: State) {\n    // by design, reads do not mutate or cause side effects\n    this.read = new Read(state);\n  }\n  inputRequest = (): boolean => {\n    // the rule about reads is they will only throw errors if it cant return the value you request.\n    // If no errors are thrown the read was successful.\n    // Reads will never not return a value without throwing an error, enforced by TS.\n    return exists(ignoreExistenceError(this.read.inputRequest));\n  };\n  sortedRequestsService = (): boolean => {\n    return exists(ignoreExistenceError(this.read.sortedRequestsService));\n  };\n  requestChainId = (): boolean => {\n    return exists(ignoreExistenceError(this.read.requestChainId));\n  };\n  userAddress = (): boolean => {\n    return exists(ignoreExistenceError(this.read.userAddress));\n  };\n  request = (): boolean => {\n    return exists(ignoreExistenceError(this.read.request));\n  };\n  collateralProps = (): boolean => {\n    return exists(ignoreExistenceError(this.read.collateralProps));\n  };\n  defaultLiveness = (): boolean => {\n    return exists(ignoreExistenceError(this.read.defaultLiveness));\n  };\n  currentTime = (): boolean => {\n    return exists(ignoreExistenceError(this.read.currentTime));\n  };\n}\n","import produce from \"immer\";\n\nexport type WriteCallback<S> = (state: S) => void;\nexport type Emit<S> = (state: S, prev: S) => void;\n/**\n * Store. The store is meant to provide a global state that conforms to the type in types/state and\n * allow you to read/write and watch for change events. This uses immer, which manages how the nested\n * object gets updated to allow shallow change detection through nested paths.\n */\nexport default class Store<S> {\n  /**\n   * constructor.\n   *\n   * @param {Emit} emit - Change callback, passes you the current and previous state any time theres a state change.\n   * @param {State} state - The full state type which conforms to the state object.\n   */\n  constructor(private emit: Emit<S>, private state: S) {}\n  /**\n   * write. Allows caller to write to state. This wraps the state in \"immer\" which manages nested updates to state\n   * through a proxy interface. When write is complete, an event is emitted with the current and previous state.\n   *\n   * @param {WriteCallback} cb\n   */\n  write(cb: WriteCallback<S>): void {\n    const prevState = this.state;\n\n    // immer's produce method, takes an object, and passes a draft of that object to the callback. Any changes to the draft\n    // will be returned as the new state at the end of the callback. Changes to this object are optimized to be used in state\n    // for React or other front-end state managers.\n    this.state = produce(this.state, cb);\n\n    // Once state is changed, an event is emitted, this is how we get changes out of the client and also allow for change detection.\n    this.emit(this.state, prevState);\n  }\n  // same as write\n  async writeAsync(cb: WriteCallback<S>): Promise<void> {\n    const prevState = this.state;\n    this.state = await produce(this.state, cb);\n    this.emit(this.state, prevState);\n  }\n  read(): S {\n    return this.state;\n  }\n}\n","import Write from \"./write\";\nimport Read from \"./read\";\nimport Has from \"./has\";\n\nimport Store, { Emit as GenericEmit } from \"./store\";\nimport { State } from \"../types/state\";\n\ntype WriteCallback = (write: Write, state: State) => void;\ntype Emit = GenericEmit<State>;\n\nexport { Write, Store, Read, Emit, WriteCallback, Has };\n\n/**\n * OracleStore. Wraps the store with a specific state shape and passes the Write client through to end user.\n */\nexport default class OracleStore {\n  private store: Store<State>;\n  constructor(private emit: Emit = () => undefined, private state: State = {}) {\n    this.store = new Store<State>(emit, state);\n  }\n  /**\n   * write - Function for updating state.\n   *\n   * @param {WriteCallback} cb - Sends a write client to the caller for safer and easier state mutations rather than the raw object.\n   */\n  write = (cb: WriteCallback): void => {\n    this.store.write((state) => cb(new Write(state), state));\n  };\n  /**\n   * read - Function for reading from state. Returns a read client to the user.\n   *\n   * @returns {Read}\n   */\n  read = (): Read => {\n    return new Read(this.store.read());\n  };\n  /**\n   * get - Function for getting access to the raw state object, not wrapped by the reader class.\n   * State should not be modified directly and treated as read only.\n   *\n   * @returns {State}\n   */\n  get = (): State => {\n    return this.store.read();\n  };\n  /**\n   * has. Checks for existence. Mirrors the read interface, but instead of reading values returns true or false.\n   *\n   * @returns {Has}\n   */\n  has = (): Has => {\n    return new Has(this.store.read());\n  };\n}\n","import Store from \"../store\";\nimport { InputRequest } from \"../types/state\";\nimport { TransactionReceipt } from \"../types/ethers\";\n\nexport class Update {\n  private read: Store[\"read\"];\n  private write: Store[\"write\"];\n  constructor(private store: Store) {\n    this.read = store.read;\n    this.write = store.write;\n  }\n  all = async (): Promise<void> => {\n    await this.oracle();\n    await this.request();\n    await this.collateralProps();\n    await this.userCollateralBalance();\n    await this.oracleAllowance();\n  };\n  request = async (params?: InputRequest): Promise<void> => {\n    const request = params || this.read().inputRequest();\n    const chainId = request.chainId;\n    const oo = this.read().oracleService(chainId);\n    // // pull in data from contract on chain\n    const contractRequest = await oo.fetchRequest(request);\n    this.write((write) => {\n      // create the erc20 service to handle currency\n      if (contractRequest.currency) {\n        write.services(chainId).erc20s(contractRequest.currency);\n      }\n      write\n        .chains(chainId)\n        .optimisticOracle()\n        // update request object with all the data we have about it. order is important,\n        // we want to prioritize latest state pulled from contract.\n        .request({ ...contractRequest });\n    });\n    this.sortedRequests(chainId);\n  };\n  oracle = async (): Promise<void> => {\n    const chainId = this.read().requestChainId();\n    const oo = this.read().oracleService();\n    const { defaultLiveness } = await oo.getProps();\n    this.write((write) => write.chains(chainId).optimisticOracle().defaultLiveness(defaultLiveness));\n  };\n  userCollateralBalance = async (): Promise<void> => {\n    const chainId = this.read().requestChainId();\n    const account = this.read().userAddress();\n    const token = this.read().collateralService();\n    const result = await token.contract.balanceOf(account);\n    this.write((write) => write.chains(chainId).erc20s(token.address).balance(account, result));\n  };\n  collateralProps = async (): Promise<void> => {\n    const chainId = this.read().requestChainId();\n    const token = this.read().collateralService();\n    const props = await token.getProps();\n    this.write((write) => write.chains(chainId).erc20s(token.address).props(props));\n  };\n  oracleAllowance = async (): Promise<void> => {\n    const chainId = this.read().requestChainId();\n    const account = this.read().userAddress();\n    const oracleAddress = this.read().oracleAddress();\n    const token = this.read().collateralService();\n    const result = await token.contract.allowance(account, oracleAddress);\n    this.write((write) => write.chains(chainId).erc20s(token.address).allowance(account, oracleAddress, result));\n  };\n  balance = async (chainId: number, token: string, account: string): Promise<void> => {\n    const tokenService = this.read().tokenService(chainId, token);\n    const result = await tokenService.contract.balanceOf(account);\n    this.write((write) => write.chains(chainId).erc20s(token).balance(account, result));\n  };\n  allowance = async (chainId: number, token: string, account: string, spender: string): Promise<void> => {\n    const tokenService = this.read().tokenService(chainId, token);\n    const result = await tokenService.contract.allowance(account, spender);\n    this.write((write) => write.chains(chainId).erc20s(token).allowance(account, spender, result));\n  };\n  isConfirmed = async (chainId: number, hash: string, confirmations: number): Promise<boolean | TransactionReceipt> => {\n    const txService = this.read().transactionService(chainId);\n    return txService.isConfirmed(hash, confirmations);\n  };\n  // update new events from this range query, will accumulate new events\n  oracleEvents = async (chainId: number, startBlock = 0, endBlock?: number): Promise<void> => {\n    const provider = this.read().provider(chainId);\n    const oracle = this.read().oracleService(chainId);\n    endBlock = endBlock || (await provider.getBlockNumber());\n    await oracle.update(startBlock, endBlock);\n  };\n  // takes all known events, decodes them into requests and puts them into a sorted table. then updates the sorted list.\n  sortedRequests = (chainId: number): void => {\n    const sortedRequestsService = this.read().sortedRequestsService();\n    const oracle = this.read().oracleService(chainId);\n    const requests = oracle.listRequests();\n    const oracleType = this.read().oracleType();\n    Object.values(requests).forEach((value) => {\n      // chains can have colliding keys ( mainly testnet forks), so we always need to append chain to to keep key unique across chains otherwise\n      // collisions will cause overwrites, removing ability to list identical requests across chains.\n      sortedRequestsService.setByRequest({ ...value, oracleType });\n    });\n    // query all known requests and update our state with the entire list.\n    // this is expensive, consider optimizing after proven detrimental.\n    const descendingRequests = sortedRequestsService.descending();\n    this.write((w) => {\n      w.descendingRequests(descendingRequests);\n    });\n  };\n  // this updates the current active request object used in the details page, as new properties might come in from events\n  // current request needs access to things like transation hash, only available through events.\n  activeRequestFromEvents = (params?: InputRequest): void => {\n    const request = params || this.read().inputRequest();\n    const chainId = request.chainId;\n    // pull in request data generated from events\n    const requestIndexData = this.read().oracleService().getRequest(request);\n    // we really only care about a handful of props from event based requests. We also dont want to override\n    // any properties that might overlap with the data queried from the contract.\n    const {\n      requestTx,\n      proposeTx,\n      disputeTx,\n      settleTx,\n      requestBlockNumber,\n      proposeBlockNumber,\n      disputeBlockNumber,\n      settleBlockNumber,\n    } = requestIndexData;\n\n    const update = {\n      ...request,\n      requestTx,\n      proposeTx,\n      disputeTx,\n      settleTx,\n      requestBlockNumber,\n      proposeBlockNumber,\n      disputeBlockNumber,\n      settleBlockNumber,\n    };\n\n    this.write((write) => {\n      write.chains(chainId).optimisticOracle().request(update);\n    });\n  };\n}\n","import { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { User } from \"../../types/state\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\n// require exports for a new context handler\nexport type Params = Partial<User>;\nexport type Memory = undefined;\n\nexport function initMemory(): Memory {\n  return undefined;\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params) {\n      store.write((write) => write.inputs().user().set(params));\n\n      // ignore erorrs caused by data not existing on reads, pass through other errors\n      await ignoreExistenceErrorAsync(update.userCollateralBalance);\n      await ignoreExistenceErrorAsync(update.oracleAllowance);\n\n      return \"done\";\n    },\n  };\n}\n","import Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\n\n// require exports for a new context handler\nexport type Params = undefined;\nexport type Memory = undefined;\n\nexport function initMemory(): Memory {\n  return undefined;\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  return {\n    async start() {\n      store.write((write) => {\n        write.inputs().user().clear();\n      });\n      return \"done\";\n    },\n  };\n}\n","import Store from \"../../store\";\nimport { Inputs } from \"../../types/state\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\n\n// required exports for state machine\nexport type Params = Inputs[\"request\"];\nexport type Memory = undefined;\nexport function initMemory(): Memory {\n  return undefined;\n}\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  return {\n    async start(params: Params) {\n      store.write((write) => write.inputs().request(params));\n      return \"done\";\n    },\n  };\n}\n","import assert from \"assert\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Signer } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\n\nexport type Params = {\n  currency: string;\n  chainId: number;\n  signer: Signer;\n  account: string;\n  spender: string;\n  amount: string;\n  confirmations: number;\n  checkTxIntervalSec: number;\n};\n\nexport type Memory = { hash?: string };\n\nexport function initMemory(): Memory {\n  return {};\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory) {\n      const { chainId, currency, spender, amount, account, signer } = params;\n      assert(chainId === (await signer.getChainId()), \"Signer on wrong chainid\");\n      assert(account === (await signer.getAddress()), \"Signer on wrong account\");\n\n      // create service if it does not exist\n      store.write((w) => w.services(chainId).erc20s(currency));\n      const erc20 = store.read().tokenService(chainId, currency);\n      const tx = await erc20.approve(signer, spender, amount);\n      memory.hash = tx.hash;\n      return \"confirm\";\n    },\n    async confirm(params: Params, memory: Memory, context: ContextClient) {\n      const { chainId, confirmations, checkTxIntervalSec } = params;\n      const { hash } = memory;\n      assert(hash, \"requires hash\");\n      if (await update.isConfirmed(chainId, hash, confirmations)) {\n        return \"update\";\n      }\n      // wait x seconds before running this state again\n      return context.sleep(checkTxIntervalSec * 1000);\n    },\n    async update(params: Params) {\n      const { chainId, currency, spender, account } = params;\n      await update.balance(chainId, currency, account);\n      await update.allowance(chainId, currency, account, spender);\n      return \"done\";\n    },\n  };\n}\n","import assert from \"assert\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Signer, TransactionReceipt } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { InputRequest } from \"../../types/state\";\nimport { ContextClient } from \"./utils\";\n\nexport type Params = InputRequest & {\n  signer: Signer;\n  confirmations: number;\n  currency: string;\n  account: string;\n  checkTxIntervalSec: number;\n};\n\nexport type Memory = { hash?: string; receipt?: TransactionReceipt };\n\nexport function initMemory(): Memory {\n  return {};\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory) {\n      const { requester, identifier, timestamp, ancillaryData, chainId, signer } = params;\n      assert(chainId === (await signer.getChainId()), \"Signer on wrong chainid\");\n\n      const oracle = store.read().oracleService(chainId);\n      const tx = await oracle.disputePrice(signer, { requester, identifier, timestamp, ancillaryData });\n      memory.hash = tx.hash;\n      return \"confirm\";\n    },\n    async confirm(params: Params, memory: Memory, context: ContextClient) {\n      const { chainId, confirmations, checkTxIntervalSec } = params;\n      const { hash } = memory;\n      assert(hash, \"requires hash\");\n      const receipt = await update.isConfirmed(chainId, hash, confirmations);\n      if (receipt) {\n        memory.receipt = receipt as TransactionReceipt;\n        return \"update\";\n      }\n      // wait x seconds before running this state again\n      return context.sleep(checkTxIntervalSec * 1000);\n    },\n    async update(params: Params, memory: Memory) {\n      const { chainId, currency, account } = params;\n      const { receipt } = memory;\n      const oracle = store.read().oracleService(chainId);\n      await update.balance(chainId, currency, account);\n      if (receipt) {\n        oracle.updateFromTransactionReceipt(receipt);\n      }\n      store.write((w) => {\n        w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));\n      });\n      update.sortedRequests(chainId);\n      return \"done\";\n    },\n  };\n}\n","import assert from \"assert\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Signer, TransactionReceipt } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { InputRequest } from \"../../types/state\";\nimport { ContextClient } from \"./utils\";\n\nexport type Params = InputRequest & {\n  signer: Signer;\n  confirmations: number;\n  currency: string;\n  account: string;\n  proposedPrice: string;\n  checkTxIntervalSec: number;\n};\n\nexport type Memory = { hash?: string; receipt?: TransactionReceipt };\n\nexport function initMemory(): Memory {\n  return {};\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory) {\n      const { requester, identifier, timestamp, ancillaryData, chainId, signer, proposedPrice } = params;\n      assert(chainId === (await signer.getChainId()), \"Signer on wrong chainid\");\n      const oracle = store.read().oracleService(chainId);\n      const tx = await oracle.proposePrice(signer, { requester, identifier, timestamp, ancillaryData }, proposedPrice);\n      memory.hash = tx.hash;\n      return \"confirm\";\n    },\n    async confirm(params: Params, memory: Memory, context: ContextClient) {\n      const { chainId, confirmations, checkTxIntervalSec } = params;\n      const { hash } = memory;\n      assert(hash, \"requires hash\");\n      const receipt = await update.isConfirmed(chainId, hash, confirmations);\n      if (receipt) {\n        memory.receipt = receipt as TransactionReceipt;\n        return \"update\";\n      }\n      // wait x seconds before running this state again\n      return context.sleep(checkTxIntervalSec * 1000);\n    },\n    async update(params: Params, memory: Memory) {\n      const { chainId, currency, account } = params;\n      const { receipt } = memory;\n      const oracle = store.read().oracleService(chainId);\n      await update.balance(chainId, currency, account);\n      if (receipt) {\n        oracle.updateFromTransactionReceipt(receipt);\n      }\n      store.write((w) => {\n        w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));\n      });\n      await update.sortedRequests(chainId);\n      return \"done\";\n    },\n  };\n}\n","import Store from \"../../store\";\nimport { Web3Provider } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { chainConfigToChainMetadata, hexValue } from \"../../utils\";\n\nexport type Params = {\n  chainId: number;\n  provider: Web3Provider;\n};\n\nexport type Memory = undefined;\n\nexport function initMemory(): Memory {\n  return undefined;\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  return {\n    async start(params: Params) {\n      const { provider, chainId } = params;\n      try {\n        await provider.send(\"wallet_switchEthereumChain\", [\n          {\n            chainId: hexValue(chainId),\n          },\n        ]);\n        return \"done\";\n      } catch (err) {\n        const error = (err as unknown) as Error & { code: number };\n        if (error.code === -32603 || error.code === 4902) {\n          return \"addAndSwitch\";\n        }\n        throw error;\n      }\n    },\n    async addAndSwitch(params: Params) {\n      const { chainId, provider } = params;\n      const config = store.read().chainConfig(chainId);\n      const chainMetadata = chainConfigToChainMetadata(config);\n      await provider.send(\"wallet_addEthereumChain\", [\n        {\n          ...chainMetadata,\n          chainId: hexValue(chainId),\n        },\n      ]);\n      await provider.send(\"wallet_switchEthereumChain\", [\n        {\n          chainId: hexValue(chainId),\n        },\n      ]);\n      return \"done\";\n    },\n  };\n}\n","// this should only run as a single instance, will continue updating the active request as needed.\n// this is a single poller for requests on all chains\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { RequestState } from \"../../types/state\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\n// required exports for state machine\nexport type Params = undefined;\nexport type Memory = { iterations: number };\nexport function initMemory(): Memory {\n  return { iterations: 0 };\n}\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient): Promise<void | undefined> {\n      const request = await ignoreExistenceErrorAsync(store.read().request);\n      // requests can change externally if not already in one of these states\n      const shouldUpdate = request && request.state !== RequestState.Invalid && request.state !== RequestState.Settled;\n\n      if (shouldUpdate) {\n        await update.request();\n        // count how many times we have updated this request as a sanity check\n        memory.iterations++;\n      }\n\n      const { checkTxIntervalSec = 30 } = (await ignoreExistenceErrorAsync(store.read().chainConfig)) || {};\n      return ctx.sleep(checkTxIntervalSec * 1000);\n    },\n  };\n}\n","// this will attempt to fetch all events down to startBlock in descending order. It will try to reduce the\n// range of blocks queried to prevent errors with the provider. This can sometimes lead to really long query times\n// for providers on chains which are very restrictive about block range.\n// Normally you want to query events in order, ie oldest to newest, but in this case we want to prioritize the\n// newest requests first in the case we cant fetch the whole range. Also we will store all events in order and\n// process them on each iteration, so we should always have a consistent view of request with our currently known events.\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\nimport { Update } from \"../update\";\nimport { rangeStart, rangeSuccessDescending, rangeFailureDescending, RangeState } from \"../../utils\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\nexport type Params = {\n  chainId: number;\n  startBlock?: number;\n  endBlock?: number;\n  maxRange?: number;\n};\n\nexport type Memory = { error?: Error; state?: RangeState; iterations: number };\n\nexport function initMemory(): Memory {\n  return { iterations: 0 };\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient) {\n      const provider = store.read().provider(params.chainId);\n      const { chainId, startBlock = 0, endBlock = await provider.getBlockNumber(), maxRange } = params;\n\n      memory.error = undefined;\n      // we use this wierd range thing because in the case we cant query the entire block range due to provider error\n      // we want to move start block closer to endblock to reduce the range until it stops erroring. These range functions\n      // will do that for us.\n      const rangeState = memory.state || rangeStart({ startBlock, endBlock, maxRange });\n      const { currentStart, currentEnd } = rangeState;\n\n      try {\n        // this just queries events between start and end\n        await update.oracleEvents(chainId, currentStart, currentEnd);\n        // reprocess all known events and create a table of requests from it\n        await update.sortedRequests(chainId);\n\n        // try to update the active request by event data\n        await ignoreExistenceErrorAsync(update.activeRequestFromEvents);\n\n        // we signal that the current range was a success, now move currentStart, currentEnd accordingly\n        // we set multiplier to 1 so we dont grow the range on success, this tends to create more errors and slow down querying\n        memory.state = rangeSuccessDescending({ ...rangeState, multiplier: 1 });\n      } catch (err) {\n        memory.error = (err as unknown) as Error;\n        // the provider threw an error so we will reduce our range by moving startblock closer to endblock next iteration\n        memory.state = rangeFailureDescending(rangeState);\n      }\n      memory.iterations++;\n      // the range functions will tell us when we have successfully queried the entire range of blocks.\n      if (memory?.state?.done) return \"done\";\n      // sleep to let other contexts run, but just resume right after.\n      return ctx.sleep(100);\n    },\n  };\n}\n","// this statemachine will continue to poll for new events from startBlock ( or latest block if not defined).\n// It will maintain memory of the last block it polled for events up to, and use that as the start block for next\n// iteration, while always querying up to the latest block.\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\nimport { Update } from \"../update\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\nexport type Params = {\n  chainId: number;\n  startBlock?: number;\n  pollRateSec?: number;\n};\n\nexport type Memory = { error?: Error; lastBlock?: number; iterations: number };\n\nexport function initMemory(): Memory {\n  return { iterations: 0 };\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient) {\n      // start at the latest block, we have other command to get historical events\n      const { chainId, startBlock, pollRateSec = 50 } = params;\n      const provider = store.read().provider(chainId);\n      const latestBlock = await provider.getBlockNumber();\n      // our current block is the start block, or last known block we have queried up to\n      const currentBlock = memory.lastBlock || startBlock || latestBlock;\n      memory.error = undefined;\n      try {\n        // dont worry about querying if latest and current are the same. This optimization causes wierd effects\n        // during testing, as block number rarely changes unless user moves it manually, giving the impression that events are missed.\n        if (latestBlock !== currentBlock) {\n          // this pulls all events from current to latest block\n          await update.oracleEvents(chainId, currentBlock, latestBlock);\n\n          // we can just try to update the current active request, we dont care if it fails, active request might not be set\n          await ignoreExistenceErrorAsync(update.activeRequestFromEvents);\n\n          // reset our last block seen to the latest (end) block\n          memory.lastBlock = latestBlock;\n          // just count how many successful iterations we do as a kind of sanity check\n          memory.iterations++;\n        } else {\n          // if we dont have a lastblock set, set it to our current block\n          memory.lastBlock = memory.lastBlock || currentBlock;\n        }\n      } catch (err) {\n        // store an error for an iteration if we need to debug. we want to keep polling though.\n        memory.error = (err as unknown) as Error;\n      }\n\n      // update our request table list with all known events\n      // this needs to be done outside the block sorted requests holds requests across different clients\n      await update.sortedRequests(chainId);\n\n      // we dont need to poll these events very fast, so just set to once a min\n      return ctx.sleep(pollRateSec * 1000);\n    },\n  };\n}\n","import assert from \"assert\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\n\n// required exports for state machine\nexport type Params = { chainId: number; transactionHash: string; eventIndex?: number };\nexport type Memory = undefined;\nexport function initMemory(): Memory {\n  return undefined;\n}\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  return {\n    async start(params: Params) {\n      const { chainId, transactionHash, eventIndex = 0 } = params;\n\n      // search all known requests first\n      const filteredRequests = store\n        .read()\n        .descendingRequests()\n        .filter((request) => {\n          if (request.chainId.toString() !== chainId.toString()) return false;\n          if (\n            ![\n              request?.requestTx?.toLowerCase(),\n              request?.proposeTx?.toLowerCase(),\n              request?.disputeTx?.toLowerCase(),\n              request?.settleTx?.toLowerCase(),\n            ].includes(transactionHash.toLowerCase())\n          )\n            return false;\n          return [\n            request?.requestLogIndex?.toString(),\n            request?.proposeLogIndex?.toString(),\n            request?.disputeLogIndex?.toString(),\n            request?.settleLogIndex?.toString(),\n          ].includes(eventIndex.toString());\n        });\n\n      // if we found a request from known requests, then set it as our selected request\n      if (filteredRequests.length === 1) {\n        const [found] = filteredRequests;\n        // we can parse out the necessary params to kick off fetching the state of the request\n        const requestInput = {\n          timestamp: found.timestamp,\n          requester: found.requester,\n          ancillaryData: found.ancillaryData,\n          identifier: found.identifier,\n          chainId,\n        };\n        store.write((write) => write.inputs().request(requestInput));\n        return \"done\";\n      }\n\n      // have to do all of this to fetch the identifier, ancData, requester and timestamp from the request\n      const provider = store.read().provider(chainId);\n      const receipt = await provider.getTransactionReceipt(transactionHash);\n      assert(receipt, \"Unable to find transaction receipt from hash: \" + transactionHash);\n      const oracle = store.read().oracleService(chainId);\n      const oracleAddress = store.read().oracleAddress(chainId);\n      // filter out logs that originate from oracle contract\n      const oracleLogs = receipt.logs.filter((log) => log.address.toLowerCase() === oracleAddress.toLowerCase());\n      // decode logs using abi\n      const decodedLogs = oracleLogs.map((log) => oracle.parseLog(log));\n\n      // this is the event we care about, we index into the appropriate oracle event generated from this tx\n      // we want to keep backwards compatibility with previous links which were indexed by an array index and not logIndex\n      const log =\n        decodedLogs.find((log) => log?.logIndex?.toString() === eventIndex.toString()) ||\n        decodedLogs[eventIndex] ||\n        decodedLogs[0];\n      // we dont actually know the type of the log, so we need to do some validation before continuing\n      assert(log, `Unable to find optimistic oracle event at ${transactionHash} eventIndex ${eventIndex}`);\n      assert(log.args, `Unable to find optimistic oracle event args at ${transactionHash} eventIndex ${eventIndex}`);\n      assert(\n        log.args.timestamp,\n        `Unable to find optimistic oracle event.timestamp at ${transactionHash} eventIndex ${eventIndex}`\n      );\n      assert(\n        log.args.requester,\n        `Unable to find optimistic oracle event.requester at ${transactionHash} eventIndex ${eventIndex}`\n      );\n      assert(\n        log.args.ancillaryData,\n        `Unable to find optimistic oracle event.ancillaryData at ${transactionHash} eventIndex ${eventIndex}`\n      );\n      assert(\n        log.args.identifier,\n        `Unable to find optimistic oracle event.identifier at ${transactionHash} eventIndex ${eventIndex}`\n      );\n\n      // we can parse out the necessary params to kick off fetching the state of the request\n      const requestInput = {\n        timestamp: log.args.timestamp,\n        requester: log.args.requester,\n        ancillaryData: log.args.ancillaryData,\n        identifier: log.args.identifier,\n        chainId,\n      };\n\n      store.write((write) => write.inputs().request(requestInput));\n      return \"done\";\n    },\n  };\n}\n","import assert from \"assert\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Signer } from \"../../types/ethers\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { InputRequest } from \"../../types/state\";\nimport { ContextClient } from \"./utils\";\n\nexport type Params = InputRequest & {\n  signer: Signer;\n  confirmations: number;\n  currency: string;\n  account: string;\n  checkTxIntervalSec: number;\n};\n\nexport type Memory = { hash?: string };\n\nexport function initMemory(): Memory {\n  return {};\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory) {\n      const { requester, identifier, timestamp, ancillaryData, chainId, signer } = params;\n      assert(chainId === (await signer.getChainId()), \"Signer on wrong chainid\");\n\n      const oracle = store.read().oracleService(chainId);\n      const tx = await oracle.settle(signer, { requester, identifier, timestamp, ancillaryData });\n      memory.hash = tx.hash;\n      return \"confirm\";\n    },\n    async confirm(params: Params, memory: Memory, context: ContextClient) {\n      const { chainId, confirmations, checkTxIntervalSec } = params;\n      const { hash } = memory;\n      assert(hash, \"requires hash\");\n      if (await update.isConfirmed(chainId, hash, confirmations)) {\n        return \"update\";\n      }\n      // wait x seconds before running this state again\n      return context.sleep(checkTxIntervalSec * 1000);\n    },\n    async update(params: Params) {\n      const { chainId, currency, account } = params;\n      const oracle = store.read().oracleService(chainId);\n      await update.balance(chainId, currency, account);\n      store.write((w) => {\n        w.chains(chainId).optimisticOracle().request(oracle.getRequest(params));\n      });\n      update.sortedRequests(chainId);\n      return \"done\";\n    },\n  };\n}\n","import bluebird from \"bluebird\";\nimport { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\n\n// required exports for state machine\nexport type Params = {\n  chainId: number;\n  concurrency?: number;\n  pollRateSec?: number;\n};\n\nexport type Memory = undefined;\n\nexport function initMemory(): Memory {\n  return undefined;\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient): Promise<void | undefined> {\n      const { chainId, pollRateSec = 15, concurrency = 5 } = params;\n      const oracle = store.read().oracleService(chainId);\n      const requests = oracle.listRequests();\n      const requestsToFetch = requests.filter((request) => request.eventBased === undefined);\n      await bluebird.map(requestsToFetch, (request) => update.request(request), { concurrency });\n      return ctx.sleep(pollRateSec * 1000);\n    },\n  };\n}\n","import assert from \"assert\";\nimport uid from \"lodash/uniqueId\";\n\nimport { Handlers, Memory, Context, Step as StepType, ContextProps, ContextType } from \"../../types/statemachine\";\n\n// client to pass into handlers to allow them to modify context\nexport class ContextClient {\n  constructor(private context: ContextProps) {}\n  sleep(ms?: number): void {\n    this.context.sleep = ms;\n  }\n}\n\nexport const Step = <P = undefined, M extends Memory = undefined>(handlers: Handlers<P, M>): StepType<P, M> => async (\n  context: Context<P, M>,\n  now: number\n): Promise<Context<P, M>> => {\n  assert(!context.done, \"Context has ended\");\n  assert(handlers[context.state], \"No handler for state: \" + context.state);\n  // conext is read only for some reason, have to copy it\n  const copy = Object.assign({}, context);\n\n  try {\n    // remove sleep, assume it should be reset if needed\n    if (copy.sleep) copy.sleep = undefined;\n    const handler = handlers[copy.state];\n    // have to copy this out because memory becomes read only for some reason?\n    const memory = Object.assign({}, copy.memory);\n    // handlers take in params and return a new state or nothin\n    const state = await handler(copy.params, memory, new ContextClient(copy));\n    copy.memory = memory;\n    // update context state\n    if (state) copy.state = state;\n    // check for done\n    if (state === \"done\") copy.done = true;\n  } catch (err) {\n    return {\n      ...copy,\n      error: err as Error,\n      state: \"error\",\n      done: true,\n      updated: now,\n    };\n  }\n  copy.updated = now;\n  return copy;\n};\n\nexport function shouldStep(context: Context<unknown, unknown & Memory> | undefined, now: number): context is Context {\n  if (!context) return false;\n  if (context.done) return false;\n  if (context.updated === undefined) return true;\n  if (!context?.sleep) return true;\n  return now - context.updated >= context.sleep;\n}\n\nexport function create<P, M extends Memory>(\n  type: ContextType,\n  params: P,\n  memory: M,\n  override: Partial<ContextProps> = {},\n  now = Date.now()\n): Context<P, M> {\n  const context: Context<P, M> = {\n    id: uid(type + \"_\"),\n    state: \"start\",\n    done: false,\n    updated: undefined,\n    created: now,\n    type,\n    // override any part of the context, not recommended for most cases\n    ...override,\n    params,\n    memory,\n  };\n  return context;\n}\n\nexport class ContextManager<P, M extends Memory> {\n  constructor(\n    private type: ContextType,\n    private handlers: Handlers<P, M>,\n    private initMemory: (params: P) => M,\n    private emit: (ctx: Context<P, M>) => void\n  ) {}\n  create = (params: P, user?: string): string => {\n    const context = create<P, M>(this.type, params, this.initMemory(params), { user });\n    this.emit(context);\n    return context.id;\n  };\n  // this step function will keep looping until either the state machine is done transitioning, or sleep has been specified\n  async step(context: Context<P, M>, now: number = Date.now(), iterations = 10): Promise<Context<P, M>> {\n    const step = Step<P, M>(this.handlers);\n    let next = context;\n    while (shouldStep(next, now)) {\n      assert(\n        iterations >= 0,\n        \"Infinite loop detected in state machine, make sure it each state transitions to done: \" + context.type\n      );\n      next = await step(next, now);\n      iterations--;\n    }\n    return next;\n  }\n}\n","import { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ContextClient } from \"./utils\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\nexport type Params = undefined;\nexport type Memory = { iterations: number };\n\nexport function initMemory(): Memory {\n  return { iterations: 0 };\n}\n\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start(params: Params, memory: Memory, ctx: ContextClient) {\n      await ignoreExistenceErrorAsync(update.userCollateralBalance);\n      await ignoreExistenceErrorAsync(update.oracleAllowance);\n      memory.iterations++;\n      // this is set differently for every chain\n      const { checkTxIntervalSec = 30 } = (await ignoreExistenceErrorAsync(store.read().chainConfig)) || {};\n      return ctx.sleep(checkTxIntervalSec * 1000);\n    },\n  };\n}\n","import { Update } from \"../update\";\nimport Store from \"../../store\";\nimport { Handlers as GenericHandlers } from \"../../types/statemachine\";\nimport { ignoreExistenceErrorAsync } from \"../../errors\";\n\n// required exports for state machine\nexport type Params = undefined;\nexport type Memory = undefined;\nexport function initMemory(): Memory {\n  return undefined;\n}\nexport function Handlers(store: Store): GenericHandlers<Params, Memory> {\n  const update = new Update(store);\n  return {\n    async start() {\n      const has = store.has();\n      // we can ignore errors where reads fail, but all other errors will propogate\n      // this will rerun when user is set.\n      if (!has.defaultLiveness()) {\n        await ignoreExistenceErrorAsync(update.oracle);\n      }\n\n      await ignoreExistenceErrorAsync(update.request);\n\n      if (!has.collateralProps()) {\n        await ignoreExistenceErrorAsync(update.collateralProps);\n      }\n\n      return \"done\";\n    },\n  };\n}\n","import { Context, Memory, ContextType } from \"../../types/statemachine\";\nimport type Store from \"../../store\";\nimport { ContextManager, shouldStep } from \"./utils\";\n\n// context types, import new ones here\nimport * as setUser from \"./setUser\";\nimport * as clearUser from \"./clearUser\";\nimport * as setActiveRequest from \"./setActiveRequest\";\nimport * as approve from \"./approve\";\nimport * as disputePrice from \"./disputePrice\";\nimport * as proposePrice from \"./proposePrice\";\nimport * as switchOrAddChain from \"./switchOrAddChain\";\nimport * as pollActiveRequest from \"./pollActiveRequest\";\nimport * as pollActiveUser from \"./pollActiveUser\";\nimport * as fetchPastEvents from \"./fetchPastEvents\";\nimport * as pollNewEvents from \"./pollNewEvents\";\nimport * as updateActiveRequest from \"./updateActiveRequest\";\nimport * as settle from \"./settle\";\nimport * as setActiveRequestByTransaction from \"./setActiveRequestByTransaction\";\nimport * as fetchEventBased from \"./fetchEventBased\";\n\n/**\n * StateMachine. This class will be used to handle all change requests by the user, including setting state which\n * may require triggering fetching data from chain, or initiating transactions that require tracking.\n *\n * This class is meant to step through states of a Context object. This object can have variable\n * parameters and memory. There are several concepts to understand before using this class:\n *\n * 1. Handlers - This is the state machine state handlers, it is an objected keyed by each state, with a function handler.\n * 2. Params - These are common parameters set by the caller, passed into each handler function.\n * 3. Memory - This is a writing space within the state machine handlers that accumulates through states.\n * 4. Context - This is the sum of all data needed to transition through the state machine states. It includes params, memory and metadata about the runtime.\n * 5. Context.done - This is a special property on context.done which represents that the state machine is done transitioning this context.\n * 6. Context.state = \"done\" - This is a reserved state on context.state, if set to \"done\" its the same thing as done = true.\n * 7. Context.state = \"error\" - This is a reserved state on context.state, if set to \"error\" it means the context is done, but also there is an context.error object.\n * 8. Interval - This is a property on the context which specifies the maximum rate in MS this context will transition, based on the current timestamp.\n */\nexport class StateMachine {\n  private pending: Context<unknown, unknown & Memory>[] = [];\n  // this needs to be updated when adding new context type\n  public types: {\n    [ContextType.setUser]: ContextManager<setUser.Params, setUser.Memory>;\n    [ContextType.clearUser]: ContextManager<clearUser.Params, clearUser.Memory>;\n    [ContextType.setActiveRequest]: ContextManager<setActiveRequest.Params, setActiveRequest.Memory>;\n    [ContextType.approve]: ContextManager<approve.Params, approve.Memory>;\n    [ContextType.disputePrice]: ContextManager<disputePrice.Params, disputePrice.Memory>;\n    [ContextType.proposePrice]: ContextManager<proposePrice.Params, proposePrice.Memory>;\n    [ContextType.switchOrAddChain]: ContextManager<switchOrAddChain.Params, switchOrAddChain.Memory>;\n    [ContextType.pollActiveRequest]: ContextManager<pollActiveRequest.Params, pollActiveRequest.Memory>;\n    [ContextType.pollActiveUser]: ContextManager<pollActiveUser.Params, pollActiveUser.Memory>;\n    [ContextType.fetchPastEvents]: ContextManager<fetchPastEvents.Params, fetchPastEvents.Memory>;\n    [ContextType.pollNewEvents]: ContextManager<pollNewEvents.Params, pollNewEvents.Memory>;\n    [ContextType.setActiveRequestByTransaction]: ContextManager<\n      setActiveRequestByTransaction.Params,\n      setActiveRequestByTransaction.Memory\n    >;\n    [ContextType.settle]: ContextManager<settle.Params, settle.Memory>;\n    [ContextType.updateActiveRequest]: ContextManager<updateActiveRequest.Params, updateActiveRequest.Memory>;\n    [ContextType.fetchEventBased]: ContextManager<fetchEventBased.Params, fetchEventBased.Memory>;\n  };\n  constructor(private store: Store) {\n    // need to initizlie state types here manually for each new context type\n    this.types = {\n      [ContextType.setUser]: new ContextManager<setUser.Params, setUser.Memory>(\n        ContextType.setUser,\n        setUser.Handlers(store),\n        setUser.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.clearUser]: new ContextManager<clearUser.Params, clearUser.Memory>(\n        ContextType.clearUser,\n        clearUser.Handlers(store),\n        clearUser.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.setActiveRequest]: new ContextManager<setActiveRequest.Params, setActiveRequest.Memory>(\n        ContextType.setActiveRequest,\n        setActiveRequest.Handlers(store),\n        setActiveRequest.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.approve]: new ContextManager<approve.Params, approve.Memory>(\n        ContextType.approve,\n        approve.Handlers(store),\n        approve.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.disputePrice]: new ContextManager<disputePrice.Params, disputePrice.Memory>(\n        ContextType.disputePrice,\n        disputePrice.Handlers(store),\n        disputePrice.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.proposePrice]: new ContextManager<proposePrice.Params, proposePrice.Memory>(\n        ContextType.proposePrice,\n        proposePrice.Handlers(store),\n        proposePrice.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.switchOrAddChain]: new ContextManager<switchOrAddChain.Params, switchOrAddChain.Memory>(\n        ContextType.switchOrAddChain,\n        switchOrAddChain.Handlers(store),\n        switchOrAddChain.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.pollActiveRequest]: new ContextManager<pollActiveRequest.Params, pollActiveRequest.Memory>(\n        ContextType.pollActiveRequest,\n        pollActiveRequest.Handlers(store),\n        pollActiveRequest.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.pollActiveUser]: new ContextManager<pollActiveUser.Params, pollActiveUser.Memory>(\n        ContextType.pollActiveUser,\n        pollActiveUser.Handlers(store),\n        pollActiveUser.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.fetchPastEvents]: new ContextManager<fetchPastEvents.Params, fetchPastEvents.Memory>(\n        ContextType.fetchPastEvents,\n        fetchPastEvents.Handlers(store),\n        fetchPastEvents.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.pollNewEvents]: new ContextManager<pollNewEvents.Params, pollNewEvents.Memory>(\n        ContextType.pollNewEvents,\n        pollNewEvents.Handlers(store),\n        pollNewEvents.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.setActiveRequestByTransaction]: new ContextManager<\n        setActiveRequestByTransaction.Params,\n        setActiveRequestByTransaction.Memory\n      >(\n        ContextType.setActiveRequestByTransaction,\n        setActiveRequestByTransaction.Handlers(store),\n        setActiveRequestByTransaction.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.settle]: new ContextManager<settle.Params, settle.Memory>(\n        ContextType.settle,\n        settle.Handlers(store),\n        settle.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.updateActiveRequest]: new ContextManager<updateActiveRequest.Params, updateActiveRequest.Memory>(\n        ContextType.updateActiveRequest,\n        updateActiveRequest.Handlers(store),\n        updateActiveRequest.initMemory,\n        this.handleCreate\n      ),\n      [ContextType.fetchEventBased]: new ContextManager<fetchEventBased.Params, fetchEventBased.Memory>(\n        ContextType.fetchEventBased,\n        fetchEventBased.Handlers(store),\n        fetchEventBased.initMemory,\n        this.handleCreate\n      ),\n    };\n  }\n  private saveContext(context: Context<unknown, unknown & Memory>) {\n    this.store.write((w) => w.command(context));\n  }\n  private handleCreate = (context: Context<unknown, unknown & Memory>) => {\n    this.push(context);\n    this.saveContext(context);\n  };\n\n  // remove element from front of queue\n  private shift(): Context<unknown, unknown & Memory> | undefined {\n    return this.pending.shift();\n  }\n  // remove element from back of queue\n  private pop(): Context<unknown, unknown & Memory> | undefined {\n    return this.pending.pop();\n  }\n  private size(): number {\n    return this.pending.length;\n  }\n  private push(context: Context<unknown, unknown & Memory>): void {\n    this.pending.push(context);\n  }\n  /**\n   * tick. Process all pending contexts, move them to done if needed\n   *\n   * @param {} now - Specify the timestamp this tick is running on.\n   * @returns {Promise<boolean>} - Returns if there are still any pending contexts to run.\n   */\n  tick = async (now = Date.now()): Promise<boolean> => {\n    const context = this.shift();\n    // if this cant step, then push it to back of queue\n    if (!shouldStep(context, now)) {\n      context && !context.done && this.push(context);\n      // if we can step, then step it and push result into queue\n    } else {\n      let next;\n      switch (context.type) {\n        // need to update this function with the new context processor\n        case ContextType.setUser: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<setUser.Params, setUser.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.clearUser: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<clearUser.Params, clearUser.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.setActiveRequest: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<setActiveRequest.Params, setActiveRequest.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.approve: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<approve.Params, approve.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.disputePrice: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<disputePrice.Params, disputePrice.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.proposePrice: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<proposePrice.Params, proposePrice.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.switchOrAddChain: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<switchOrAddChain.Params, switchOrAddChain.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.pollActiveRequest: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<pollActiveRequest.Params, pollActiveRequest.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.pollActiveUser: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<pollActiveUser.Params, pollActiveUser.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.fetchPastEvents: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<fetchPastEvents.Params, fetchPastEvents.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.pollNewEvents: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<pollNewEvents.Params, pollNewEvents.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.setActiveRequestByTransaction: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<setActiveRequestByTransaction.Params, setActiveRequestByTransaction.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.settle: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<settle.Params, settle.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.updateActiveRequest: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<updateActiveRequest.Params, updateActiveRequest.Memory>,\n            now\n          );\n          break;\n        }\n        case ContextType.fetchEventBased: {\n          next = await this.types[context.type].step(\n            (context as unknown) as Context<fetchEventBased.Params, fetchEventBased.Memory>,\n            now\n          );\n          break;\n        }\n        default: {\n          throw new Error(\"Unable to handle type: \" + context.type);\n        }\n      }\n      if (!next.done) {\n        this.push(next);\n      }\n      this.saveContext(next);\n    }\n\n    return this.size() > 0;\n  };\n}\n","import assert from \"assert\";\nimport { ethers } from \"ethers\";\nimport Store, { Emit } from \"./store\";\nimport type { state } from \"./types\";\nimport type { FallbackProvider } from \"./types/ethers\";\nimport { InputRequest, User } from \"./types/state\";\nimport { Update } from \"./services/update\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { StateMachine, setActiveRequestByTransaction } from \"./services/statemachines\";\nimport { loop } from \"../utils\";\nimport { toWei } from \"../across/utils\";\nimport { NewOracle } from \"./types/interfaces\";\n\nexport class Client {\n  private intervalStarted = false;\n  constructor(\n    public readonly store: Store,\n    public readonly update: Update,\n    public readonly sm: StateMachine,\n    public readonly poller: StateMachine\n  ) {}\n  setUser(params: Partial<User>): string {\n    const address = params.address && ethers.utils.getAddress(params.address);\n    return this.sm.types.setUser.create({ ...params, address });\n  }\n  clearUser(): string {\n    return this.sm.types.clearUser.create(undefined);\n  }\n  setActiveRequest(params: InputRequest): string {\n    const requester = ethers.utils.getAddress(params.requester);\n    // these are case and number senstive\n    const ancillaryData = params.ancillaryData.toLowerCase();\n    const identifier = params.identifier.toLowerCase();\n    const chainId = Number(params.chainId);\n    const timestamp = Number(params.timestamp);\n    const result = this.sm.types.setActiveRequest.create({ requester, ancillaryData, identifier, chainId, timestamp });\n    this.sm.types.updateActiveRequest.create(undefined);\n    return result;\n  }\n  setActiveRequestByTransaction(params: setActiveRequestByTransaction.Params): string {\n    const result = this.sm.types.setActiveRequestByTransaction.create(params);\n    this.sm.types.updateActiveRequest.create(undefined);\n    return result;\n  }\n  approveCollateral(): string {\n    const { checkTxIntervalSec } = this.store.read().chainConfig();\n    const request = this.store.read().request();\n    const inputRequest = this.store.read().inputRequest();\n    const user = this.store.read().user();\n    const oracleAddress = this.store.read().oracleAddress();\n    assert(user.address, \"requires a user account address\");\n    assert(user.signer, \"requires a user signer\");\n    assert(user.chainId === inputRequest.chainId, \"On wrong chain\");\n    assert(request.currency, \"Request currency is unknown\");\n    return this.sm.types.approve.create(\n      {\n        currency: request.currency,\n        account: user.address,\n        chainId: inputRequest.chainId,\n        signer: user.signer,\n        spender: oracleAddress,\n        amount: ethers.constants.MaxUint256.toString(),\n        confirmations: 1,\n        checkTxIntervalSec,\n      },\n      user.address\n    );\n  }\n  proposePrice(proposedPriceDecimals: string | number): string {\n    const { checkTxIntervalSec } = this.store.read().chainConfig();\n    const proposedPrice = toWei(proposedPriceDecimals);\n    const inputRequest = this.store.read().inputRequest();\n    const request = this.store.read().request();\n    const user = this.store.read().user();\n    assert(user.address, \"requires a user account address\");\n    assert(user.signer, \"requires a user signer\");\n    assert(user.chainId === inputRequest.chainId, \"On wrong chain\");\n    assert(request.currency, \"Request currency is unknown\");\n    return this.sm.types.proposePrice.create(\n      {\n        ...inputRequest,\n        proposedPrice,\n        signer: user.signer,\n        account: user.address,\n        currency: request.currency,\n        confirmations: 1,\n        checkTxIntervalSec,\n      },\n      user.address\n    );\n  }\n  disputePrice(): string {\n    const { checkTxIntervalSec } = this.store.read().chainConfig();\n    const inputRequest = this.store.read().inputRequest();\n    const user = this.store.read().user();\n    const request = this.store.read().request();\n    assert(user.address, \"requires a user account address\");\n    assert(user.signer, \"requires a user signer\");\n    assert(user.chainId === inputRequest.chainId, \"On wrong chain\");\n    assert(request.currency, \"Request currency is unknown\");\n    return this.sm.types.disputePrice.create(\n      {\n        ...inputRequest,\n        confirmations: 1,\n        signer: user.signer,\n        account: user.address,\n        currency: request.currency,\n        checkTxIntervalSec,\n      },\n      user.address\n    );\n  }\n  settle(): string {\n    const { checkTxIntervalSec } = this.store.read().chainConfig();\n    const inputRequest = this.store.read().inputRequest();\n    const user = this.store.read().user();\n    const request = this.store.read().request();\n    assert(user.address, \"requires a user account address\");\n    assert(user.signer, \"requires a user signer\");\n    assert(user.chainId === inputRequest.chainId, \"On wrong chain\");\n    assert(request.currency, \"Request currency is unknown\");\n    return this.sm.types.settle.create(\n      {\n        ...inputRequest,\n        confirmations: 1,\n        signer: user.signer,\n        account: user.address,\n        currency: request.currency,\n        checkTxIntervalSec,\n      },\n      user.address\n    );\n  }\n  switchOrAddChain(): string {\n    const inputRequest = this.store.read().inputRequest();\n    const user = this.store.read().user();\n    assert(user.provider, \"requires user provider\");\n    assert(user.address, \"requires user address\");\n    assert(inputRequest.chainId, \"requires active request chainId\");\n    return this.sm.types.switchOrAddChain.create(\n      { chainId: inputRequest.chainId, provider: user.provider },\n      user.address\n    );\n  }\n  // runs statemachine step loop pretty fast by default.\n  startInterval(delayMs = 1): void {\n    assert(!this.intervalStarted, \"Interval already started, try stopping first\");\n    this.intervalStarted = true;\n    loop(async () => {\n      assert(this.intervalStarted, \"Interval Stopped\");\n      // it turns out since these 2 state machines share the same immer state, they need to be run serially and\n      // cant be run concurrently or you get wierd state oscillations. For now keep them in the same timing loop.\n      await this.sm.tick();\n      await this.poller.tick();\n    }, delayMs).catch((err) => {\n      console.error(err);\n      this.intervalStarted = false;\n      this.store.write((w) => w.error(err));\n    });\n  }\n  stopInterval(): void {\n    assert(!this.intervalStarted, \"Interval already stopped\");\n    this.intervalStarted = false;\n  }\n}\n\nfunction makeProvider(rpcUrls: string[]): FallbackProvider {\n  const providers = rpcUrls.map((url) => {\n    const provider = ethers.getDefaultProvider(url);\n    // turn off all polling, we will poll manually\n    provider.polling = false;\n    return provider;\n  });\n  const provider = new ethers.providers.FallbackProvider(providers, 1);\n  // turn off all polling, we will poll manually\n  provider.polling = false;\n  return provider;\n}\nexport function factory(\n  config: state.Config,\n  emit: Emit,\n  OptimisticOracle: NewOracle,\n  sortedRequests: SortedRequests\n): Client {\n  const store = new Store(emit);\n  store.write((write) => {\n    write.config(config);\n    // maintains queryable ordered list of requests across all chains\n    write.sortedRequestsService(sortedRequests);\n    for (const chain of Object.values(config.chains)) {\n      const provider = makeProvider(chain.rpcUrls);\n      write.chains(chain.chainId).optimisticOracle().address(chain.optimisticOracleAddress);\n      write.services(chain.chainId).provider(provider);\n      write.services(chain.chainId).multicall2(chain.multicall2Address);\n      write\n        .services(chain.chainId)\n        .optimisticOracle(new OptimisticOracle(provider, chain.optimisticOracleAddress, chain.chainId));\n    }\n  });\n  const update = new Update(store);\n\n  // this first state machine is for user actions\n  const sm = new StateMachine(store);\n  // this one is system actions used for long running commands independent of the user\n  const poller = new StateMachine(store);\n\n  // start the request list checkers\n  for (const [chainId, chainConfig] of Object.entries(config.chains)) {\n    poller.types.fetchPastEvents.create(\n      {\n        chainId: Number(chainId),\n        startBlock: chainConfig.earliestBlockNumber,\n        maxRange: chainConfig.maxEventRangeQuery,\n      },\n      \"poller\"\n    );\n    // long running poller which only looks for new events\n    poller.types.pollNewEvents.create(\n      { chainId: Number(chainId), pollRateSec: chainConfig.checkTxIntervalSec },\n      \"poller\"\n    );\n    // updates event based data on all requests\n    if (!chainConfig.disableFetchEventBased)\n      poller.types.fetchEventBased.create({ chainId: Number(chainId) }, \"poller\");\n  }\n  // create active request poller for all chains. Should only have one of these\n  poller.types.pollActiveRequest.create(undefined, \"poller\");\n  // polls user for balances/approvals on the current chain, in case it changes external to app\n  poller.types.pollActiveUser.create(undefined, \"poller\");\n\n  return new Client(store, update, sm, poller);\n}\n","import { optimisticOracle } from \"../../clients\";\nimport { BigNumberish, Provider, Signer, TransactionResponse, Log, TransactionReceipt } from \"../types/ethers\";\nimport type { OracleInterface, RequestKey, OracleProps, Request } from \"../types/interfaces\";\nimport { requestId, insertOrderedAscending, eventKey, isUnique } from \"../utils\";\n\nimport {\n  RequestPrice,\n  ProposePrice,\n  DisputePrice,\n  Settle,\n  Request as RawRequest,\n} from \"../../clients/optimisticOracle\";\n\nexport type OptimisticOracleEvent = RequestPrice | ProposePrice | DisputePrice | Settle;\n\nexport type { RequestPrice, ProposePrice, DisputePrice, Settle };\n\nexport class OptimisticOracle implements OracleInterface {\n  private readonly contract: optimisticOracle.Instance;\n  private readonly events: OptimisticOracleEvent[] = [];\n  private requests: Record<string, Request> = {};\n  constructor(protected provider: Provider, protected address: string, public readonly chainId: number) {\n    this.contract = optimisticOracle.connect(address, provider);\n  }\n  private upsertRequest = (request: RawRequest): Request => {\n    const id = requestId(request);\n    const cachedRequest = this.requests[id] || {};\n    const update = { ...cachedRequest, ...request, chainId: this.chainId, eventBased: false };\n    this.requests[id] = update;\n    return update;\n  };\n  parseLog = (log: Log) => {\n    const description = this.contract.interface.parseLog(log);\n    return {\n      ...log,\n      ...description,\n      event: description.name,\n      eventSignature: description.signature,\n    };\n  };\n  private setDisputeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, disputeTx: hash });\n  }\n  private setProposeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, proposeTx: hash });\n  }\n  private setSettleHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, settleTx: hash });\n  }\n  private updateFromEvents = (events: OptimisticOracleEvent[]) => {\n    events.forEach((event) => {\n      if (isUnique(this.events, event, eventKey)) {\n        insertOrderedAscending(this.events, event, eventKey);\n      }\n    });\n    const { requests = {} } = optimisticOracle.getEventState(this.events);\n    Object.values(requests).map((request) => this.upsertRequest(request));\n  };\n  async fetchRequest({ requester, identifier, timestamp, ancillaryData }: RequestKey): Promise<Request> {\n    const request = await this.contract.callStatic.getRequest(requester, identifier, timestamp, ancillaryData);\n    const state = await this.contract.callStatic.getState(requester, identifier, timestamp, ancillaryData);\n    return this.upsertRequest({ ...request, state, requester, identifier, timestamp, ancillaryData });\n  }\n\n  getRequest(key: RequestKey): Request {\n    const id = requestId(key);\n    const request = this.requests[id] || key;\n    return { ...request };\n  }\n  async disputePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.disputePrice(requester, identifier, timestamp, ancillaryData);\n    this.setDisputeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async proposePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey,\n    price: BigNumberish\n  ): Promise<TransactionResponse> {\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.proposePrice(requester, identifier, timestamp, ancillaryData, price);\n    this.setProposeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async settle(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.settle(requester, identifier, timestamp, ancillaryData);\n    this.setSettleHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async update(startBlock = 0, endBlock: number | \"latest\" = \"latest\"): Promise<void> {\n    const events = await this.contract.queryFilter({}, startBlock, endBlock);\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  async getProps(): Promise<OracleProps> {\n    return {\n      defaultLiveness: await this.contract.defaultLiveness(),\n    };\n  }\n  updateFromTransactionReceipt(receipt: TransactionReceipt): void {\n    const events = receipt.logs.map((log) => this.parseLog(log));\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  listRequests(): Request[] {\n    return Object.values(this.requests);\n  }\n}\n","// this is a special service that works across all oracles type, chains, etc, to give a combined\n// view of all requests across running instances.\nimport sortedIndex from \"lodash/sortedIndex\";\nimport sortedLastIndex from \"lodash/sortedLastIndex\";\n\nimport { exists } from \"../../utils\";\nimport { requestId } from \"../utils\";\n\nimport { InputRequestWithOracleType, RequestWithOracleType, RequestsWithOracleType } from \"../types/state\";\n\n// this was copied out of store and made to be 1. a class, and 2. sync.  Could not modify old implementation since\n// other services rely on this currently and it causes cascading refactors. This has been copied without modification to logic.\nexport class SortedStore<Id, Data> {\n  private ids: Id[] = [];\n  private map = new Map<Id, Data>();\n  private getStart = (id: Id, inclusive = true): number => {\n    if (inclusive) {\n      return sortedIndex(this.ids, id);\n    } else {\n      return sortedLastIndex(this.ids, id);\n    }\n  };\n  private getEnd = (id: Id, inclusive = false): number => {\n    return this.getStart(id, !inclusive);\n  };\n  private del = (id: Id): Data | undefined => {\n    const index = sortedIndex(this.ids, id);\n    this.ids.splice(index, 1);\n    const result = this.map.get(id);\n    this.map.delete(id);\n    return result;\n  };\n  // keeps typescript from complaining that return values may be undefined\n  private getSafe = (id: Id): Data => {\n    const result = this.map.get(id);\n    if (exists(result)) return result;\n    throw new Error(\"Missing data for index: \" + id);\n  };\n  has = (id: Id): boolean => {\n    return this.map.has(id);\n  };\n  set = (id: Id, data: Data): void => {\n    if (this.map.has(id)) {\n      this.map.set(id, data);\n    } else {\n      const index = sortedIndex(this.ids, id);\n      this.ids.splice(index, 0, id);\n      this.map.set(id, data);\n    }\n  };\n  get = (id: Id): Data | undefined => {\n    return this.map.get(id);\n  };\n  values = (): Data[] => {\n    return this.ids.map(this.getSafe);\n  };\n  entries = (): [Id, Data][] => {\n    return this.ids.map((id) => [id, this.getSafe(id)]);\n  };\n  keys = (): Id[] => {\n    return [...this.ids];\n  };\n  clear = (): void => {\n    this.map.clear();\n    this.ids.length = 0;\n  };\n  size = (): number => {\n    return this.ids.length;\n  };\n  delete = (id: Id): void => {\n    if (!this.map.has(id)) return;\n    this.del(id);\n  };\n  // assume [a,b)\n  between = (a: Id, b: Id): Data[] => {\n    const start = this.getStart(a);\n    const end = this.getEnd(b);\n    return this.ids.slice(start, end).map(this.getSafe);\n  };\n  slice = (id: Id, length: number): Data[] => {\n    const start = this.getStart(id);\n    return this.ids.slice(start, start + length).map(this.getSafe);\n  };\n}\n\n// this sorts requests across all chains and oracles\nexport class SortedRequests extends SortedStore<string, RequestWithOracleType> {\n  setByRequest(value: InputRequestWithOracleType): void {\n    return this.set(this.id(value), value);\n  }\n  descending(): RequestsWithOracleType {\n    // sadly you cannot control lodash sorting descending, so reverse is necessary\n    return this.values().reverse();\n  }\n  ascending(): RequestsWithOracleType {\n    return this.values();\n  }\n  getByRequest(request: InputRequestWithOracleType): RequestWithOracleType {\n    // always return at least the original query data\n    return this.get(this.id(request)) || request;\n  }\n  id(request: InputRequestWithOracleType): string {\n    return requestId(request) + \"!\" + request.chainId + \"!\" + request.oracleType;\n  }\n}\n","import assert from \"assert\";\nimport { skinnyOptimisticOracle as optimisticOracle } from \"../../clients\";\nimport { BigNumberish, Provider, Signer, TransactionResponse, Log, TransactionReceipt } from \"../types/ethers\";\nimport type { OracleInterface, RequestKey, OracleProps, Request } from \"../types/interfaces\";\nimport { requestId, insertOrderedAscending, eventKey, isUnique } from \"../utils\";\n\nimport {\n  RequestPrice,\n  ProposePrice,\n  DisputePrice,\n  Settle,\n  SolidityRequest,\n} from \"../../clients/skinnyOptimisticOracle\";\n\nexport type OptimisticOracleEvent = RequestPrice | ProposePrice | DisputePrice | Settle;\n\nexport type { RequestPrice, ProposePrice, DisputePrice, Settle };\n\nfunction validateSolidityRequest(request: Request): SolidityRequest {\n  assert(request.proposer, \"Missing proposer\");\n  assert(request.disputer, \"Missing disputer\");\n  assert(request.currency, \"Missing currency\");\n  assert(request.settled, \"Missing settled\");\n  assert(request.proposedPrice, \"Missing proposedPrice\");\n  assert(request.resolvedPrice, \"Missing resolvedPrice\");\n  assert(request.expirationTime, \"Missing expirationTime\");\n  assert(request.reward, \"Missing reward\");\n  assert(request.finalFee, \"Missing finalFee\");\n  assert(request.bond, \"Missing bond\");\n  assert(request.customLiveness, \"Missing customLiveness\");\n  return {\n    proposer: request.proposer,\n    disputer: request.disputer,\n    currency: request.currency,\n    settled: request.settled,\n    proposedPrice: request.proposedPrice,\n    resolvedPrice: request.resolvedPrice,\n    expirationTime: request.expirationTime,\n    reward: request.reward,\n    finalFee: request.finalFee,\n    bond: request.bond,\n    customLiveness: request.customLiveness,\n  };\n}\n\nexport class SkinnyOptimisticOracle implements OracleInterface {\n  private readonly contract: optimisticOracle.Instance;\n  private readonly events: OptimisticOracleEvent[] = [];\n  private requests: Record<string, Request> = {};\n  constructor(protected provider: Provider, protected address: string, public readonly chainId: number) {\n    this.contract = optimisticOracle.connect(address, provider);\n  }\n  private upsertRequest = (request: Omit<Request, \"chainId\">): Request => {\n    const id = requestId(request);\n    const cachedRequest = this.requests[id] || {};\n    const update = { ...cachedRequest, ...request, chainId: this.chainId, eventBased: false };\n    this.requests[id] = update;\n    return update;\n  };\n  private setDisputeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, disputeTx: hash });\n  }\n  private setProposeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, proposeTx: hash });\n  }\n  private setSettleHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, settleTx: hash });\n  }\n  private updateFromEvents = (events: OptimisticOracleEvent[]) => {\n    events.forEach((event) => {\n      if (isUnique(this.events, event, eventKey)) {\n        insertOrderedAscending(this.events, event, eventKey);\n      }\n    });\n    const { requests = {} } = optimisticOracle.getEventState(this.events);\n    Object.values(requests).map((request) => this.upsertRequest(request));\n  };\n  async fetchRequest(key: RequestKey): Promise<Request> {\n    // skinny oo does not have a way to query request data from contract, can only find this though events.\n    return this.getRequest(key);\n  }\n\n  parseLog = (log: Log) => {\n    const description = this.contract.interface.parseLog(log);\n    return {\n      ...log,\n      ...description,\n      event: description.name,\n      eventSignature: description.signature,\n    };\n  };\n  getRequest(key: RequestKey): Request {\n    const id = requestId(key);\n    const request = this.requests[id] || key;\n    return { ...request };\n  }\n  async disputePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const request = validateSolidityRequest(this.getRequest({ requester, identifier, timestamp, ancillaryData }));\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.disputePrice(requester, identifier, timestamp, ancillaryData, request);\n    this.setDisputeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async proposePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey,\n    price: BigNumberish\n  ): Promise<TransactionResponse> {\n    const request = validateSolidityRequest(this.getRequest({ requester, identifier, timestamp, ancillaryData }));\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.proposePrice(requester, identifier, timestamp, ancillaryData, request, price);\n    this.setProposeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async settle(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const request = validateSolidityRequest(this.getRequest({ requester, identifier, timestamp, ancillaryData }));\n    const contract = optimisticOracle.connect(this.address, signer);\n    const tx = await contract.settle(requester, identifier, timestamp, ancillaryData, request);\n    this.setSettleHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async update(startBlock = 0, endBlock: number | \"latest\" = \"latest\"): Promise<void> {\n    const events = await this.contract.queryFilter({}, startBlock, endBlock);\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  async getProps(): Promise<OracleProps> {\n    return {\n      defaultLiveness: await this.contract.defaultLiveness(),\n    };\n  }\n  updateFromTransactionReceipt(receipt: TransactionReceipt): void {\n    const events = receipt.logs.map((log) => this.parseLog(log));\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  listRequests(): Request[] {\n    return Object.values(this.requests);\n  }\n}\n","// This is almost a direct copy of the OO v1 service, just with updated abis and different contract addresses\nimport { BigNumberish, Provider, Signer, TransactionResponse, Log, TransactionReceipt } from \"../types/ethers\";\nimport type { OracleInterface, RequestKey, OracleProps, Request } from \"../types/interfaces\";\nimport { requestId, insertOrderedAscending, eventKey, isUnique } from \"../utils\";\n\nimport {\n  RequestPrice,\n  ProposePrice,\n  DisputePrice,\n  Settle,\n  connect,\n  Instance,\n  getEventState,\n  Request as RawRequest,\n} from \"../../clients/optimisticOracleV2\";\n\nexport type OptimisticOracleEvent = RequestPrice | ProposePrice | DisputePrice | Settle;\n\nexport type { RequestPrice, ProposePrice, DisputePrice, Settle };\n\nexport class OptimisticOracleV2 implements OracleInterface {\n  private readonly contract: Instance;\n  private readonly events: OptimisticOracleEvent[] = [];\n  private requests: Record<string, Request> = {};\n  constructor(protected provider: Provider, protected address: string, public readonly chainId: number) {\n    this.contract = connect(address, provider);\n  }\n  private upsertRequest = (request: RawRequest): Request => {\n    const id = requestId(request);\n    const cachedRequest = this.requests[id] || {};\n    const update = { ...cachedRequest, ...request, ...(request.requestSettings || {}), chainId: this.chainId };\n    this.requests[id] = update;\n    return update;\n  };\n  private setDisputeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, disputeTx: hash });\n  }\n  private setProposeHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, proposeTx: hash });\n  }\n  private setSettleHash({ requester, identifier, timestamp, ancillaryData }: RequestKey, hash: string): Request {\n    return this.upsertRequest({ requester, identifier, timestamp, ancillaryData, settleTx: hash });\n  }\n  private updateFromEvents = (events: OptimisticOracleEvent[]) => {\n    events.forEach((event) => {\n      if (isUnique(this.events, event, eventKey)) {\n        insertOrderedAscending(this.events, event, eventKey);\n      }\n    });\n    const { requests = {} } = getEventState(this.events);\n    Object.values(requests).map((request) => this.upsertRequest(request));\n  };\n  async fetchRequest({ requester, identifier, timestamp, ancillaryData }: RequestKey): Promise<Request> {\n    const request = await this.contract.callStatic.getRequest(requester, identifier, timestamp, ancillaryData);\n    const state = await this.contract.callStatic.getState(requester, identifier, timestamp, ancillaryData);\n    return this.upsertRequest({ ...request, state, requester, identifier, timestamp, ancillaryData });\n  }\n\n  parseLog = (log: Log) => {\n    const description = this.contract.interface.parseLog(log);\n    return {\n      ...log,\n      ...description,\n      event: description.name,\n      eventSignature: description.signature,\n    };\n  };\n  getRequest(key: RequestKey): Request {\n    const id = requestId(key);\n    const request = this.requests[id] || key;\n    return { ...request };\n  }\n  async disputePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const contract = connect(this.address, signer);\n    const tx = await contract.disputePrice(requester, identifier, timestamp, ancillaryData);\n    this.setDisputeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async proposePrice(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey,\n    price: BigNumberish\n  ): Promise<TransactionResponse> {\n    const contract = connect(this.address, signer);\n    const tx = await contract.proposePrice(requester, identifier, timestamp, ancillaryData, price);\n    this.setProposeHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async settle(\n    signer: Signer,\n    { requester, identifier, timestamp, ancillaryData }: RequestKey\n  ): Promise<TransactionResponse> {\n    const contract = connect(this.address, signer);\n    const tx = await contract.settle(requester, identifier, timestamp, ancillaryData);\n    this.setSettleHash({ requester, identifier, timestamp, ancillaryData }, tx.hash);\n    return tx;\n  }\n  async update(startBlock = 0, endBlock: number | \"latest\" = \"latest\"): Promise<void> {\n    const events = await this.contract.queryFilter({}, startBlock, endBlock);\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  async getProps(): Promise<OracleProps> {\n    return {\n      defaultLiveness: await this.contract.defaultLiveness(),\n    };\n  }\n  updateFromTransactionReceipt(receipt: TransactionReceipt): void {\n    const events = receipt.logs.map((log) => this.parseLog(log));\n    this.updateFromEvents((events as unknown[]) as OptimisticOracleEvent[]);\n  }\n  listRequests(): Request[] {\n    return Object.values(this.requests);\n  }\n}\n","import { Client, factory } from \"./client\";\nimport { SkinnyOptimisticOracle } from \"./services/skinnyOptimisticOracle\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { DefaultConfig, getMulticall2Address } from \"./utils\";\nimport { state } from \"./types\";\nimport { Emit } from \"./store\";\n\nexport default (\n  config: state.PartialConfig,\n  emit: Emit,\n  sortedRequests: SortedRequests = new SortedRequests()\n): Client => {\n  const fullConfig = DefaultConfig({\n    getMulticall2Address,\n  })({ ...config }, state.OracleType.Skinny);\n  return factory(fullConfig, emit, SkinnyOptimisticOracle, sortedRequests);\n};\n","import { Client, factory } from \"./client\";\nimport { OptimisticOracle } from \"./services/optimisticOracle\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { DefaultConfig, getMulticall2Address } from \"./utils\";\nimport { state } from \"./types\";\nimport { Emit } from \"./store\";\n\nexport default (\n  config: state.PartialConfig,\n  emit: Emit,\n  sortedRequests: SortedRequests = new SortedRequests()\n): Client => {\n  const fullConfig = DefaultConfig({\n    getMulticall2Address,\n  })({ ...config }, state.OracleType.Optimistic);\n  return factory(fullConfig, emit, OptimisticOracle, sortedRequests);\n};\n","import { Client, factory } from \"./client\";\nimport { OptimisticOracleV2 } from \"./services/optimisticOracleV2\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { DefaultConfig, getMulticall2Address } from \"./utils\";\nimport { state } from \"./types\";\nimport { Emit } from \"./store\";\n\nexport default (\n  config: state.PartialConfig,\n  emit: Emit,\n  sortedRequests: SortedRequests = new SortedRequests()\n): Client => {\n  const fullConfig = DefaultConfig({\n    getMulticall2Address,\n  })({ ...config }, state.OracleType.OptimisticV2);\n  return factory(fullConfig, emit, OptimisticOracleV2, sortedRequests);\n};\n","import assert from \"assert\";\nimport { SortedRequests } from \"./services/sortedRequests\";\nimport { ClientTable } from \"./types/interfaces\";\nimport { State, OracleType, PartialConfigTable } from \"./types/state\";\nimport { Emit } from \"./store\";\nimport SkinnyFactory from \"./skinnyFactory\";\nimport OptimisticFactory from \"./optimisticFactory\";\nimport OptimisticV2Factory from \"./optimisticV2Factory\";\n\nexport type PublicEmit = (oracleType: OracleType, state: State, prev: State) => void;\nconst EventHandler = (oracleType: OracleType, publicEmit: PublicEmit): Emit => (state: State, prev: State) =>\n  publicEmit(oracleType, state, prev);\n\nexport default (configTable: PartialConfigTable, emit: PublicEmit): ClientTable => {\n  const sortedRequests = new SortedRequests();\n  return Object.fromEntries(\n    Object.entries(configTable).map(([oracleType, config]) => {\n      assert(config, \"requires config for type: \" + oracleType);\n      switch (oracleType) {\n        case OracleType.Optimistic:\n          return [oracleType, OptimisticFactory(config, EventHandler(oracleType, emit), sortedRequests)];\n        case OracleType.Skinny:\n          return [oracleType, SkinnyFactory(config, EventHandler(oracleType, emit), sortedRequests)];\n        case OracleType.OptimisticV2:\n          return [oracleType, OptimisticV2Factory(config, EventHandler(oracleType, emit), sortedRequests)];\n        default:\n          throw new Error(\"Unknown oracle type: \" + oracleType);\n      }\n    })\n  );\n};\n"],"names":["Factory","RegistryEthers__factory","connect","address","provider","reduceEvents","state","event","typedEvent","contractAddress","args","contracts","getEventState","events","reduce","exists","value","undefined","Balances","balances","create","id","amount","assert","has","set","add","BigNumber","from","getOrCreate","toString","sub","get","ConvertDecimals","fromDecimals","toDecimals","isZero","diff","div","pow","mul","sleep","delay","Promise","res","setTimeout","loop","fn","BatchReadWithErrors","multicall2","contract","calls","results","batch","map","method","readWithErrors","Object","fromEntries","zip","call","result","averageBlockTimeSeconds","chainId","defaultBlockTimeSeconds","estimateBlocksElapsed","seconds","cushionPercentage","cushionMultiplier","averageBlockTime","Math","floor","ExpiringMultiPartyEthers__factory","oldSponsor","newSponsor","tokens","collateral","collateralBalance","tokenBalance","sponsor","collateralAmount","tokenAmount","sponsors","Set","Array","values","caller","collateralReturned","tokensBurned","expired","tokensOutstanding","liquidatedCollateral","initialState","ERC20Ethers__factory","to","owner","spender","MulticallEthers__factory","Multicall2Ethers__factory","LongShortPairCreatorEthers__factory","longShortPair","eventState","LongShortPairEthers__factory","collateralUsed","tokensMinted","longs","shorts","tokensRedeemed","expiredBy","longTokens","shortTokens","BridgeDepositBoxEthers__factory","newMinimumBridgingDelay","minimumBridgingDelay","l1Token","l2Token","lastBridgeTime","bridgePool","whitelistedTokens","depositsEnabled","depositId","l1Recipient","l2Sender","slowRelayFeePct","instantRelayFeePct","quoteTimestamp","deposits","BridgePoolEthers__factory","attach","eventStateDefaults","lpTokens","relays","instantRelays","lpTokensMinted","liquidityProvider","lpTokensBurnt","depositHash","depositData","relay","relayAncillaryDataHash","instantRelayer","oldAdmin","newAdmin","Etherchain","constructor","url","getGasPrice","endpoint","axios","data","err","msg","Error","RateModelStoreEthers__factory","OptimisticOracleInterfaceEthers__factory","contractInterface","utils","Interface","getOptimisticOracleInterfaceAbi","RequestState","requestId","request","timestamp","identifier","requester","ancillaryData","join","currency","reward","finalFee","requests","Requested","requestTx","transactionHash","requestBlockNumber","blockNumber","requestLogIndex","logIndex","proposer","proposedPrice","expirationTimestamp","expirationTime","Proposed","proposeTx","proposeBlockNumber","proposeLogIndex","disputer","Disputed","disputeTx","disputeBlockNumber","disputeLogIndex","price","payout","Settled","settleTx","settleBlockNumber","settleLogIndex","SkinnyOptimisticOracleEthers__factory","getSkinnyOptimisticOracleAbi","OptimisticOracleV2InterfaceEthers__factory","getOptimisticOracleV2InterfaceAbi","Map","del","delete","entries","keys","size","clear","ids","getStart","inclusive","sortedIndex","sortedLastIndex","getEnd","index","splice","getSafe","length","between","a","b","start","end","slice","kind","store","excludeFromIndexes","makeKey","key","save","createQuery","run","KEY","name","select","highland","runStream","val","flatMap","collect","toPromise","filter","limit","Table","config","makeId","type","update","got","number","JsMap","table","BaseTable","prune","blocks","deleted","block","_block$id","push","addSponsors","setCreatedTimestamp","createdTimestamp","padStart","SortedJsMap","betweenByTimestamp","sliceByTimestamp","hasByTimestamp","getByTimestamp","upsert","toBN","num","toBNWei","decimals","ethers","parseUnits","toWei","fromWei","formatUnits","min","bna","bnb","lte","max","gte","fixedPointAdjustment","ethToToken","fromAmount","priceWei","toAmount","gasToEth","gas","gasPrice","calculateGasFees","amountEth","percent","numerator","denominator","calcContinuousCompoundInterest","startAmount","endAmount","periodsElapsed","periodsPerYear","years","Decimal","ln","calcPeriodicCompoundInterest","n","A","P","t","one","calcApr","calculateInstantaneousRate","rateModel","utilization","beforeKink","UBar","R1","afterKink","R2","R0","calculateAreaUnderRateCurve","utilizationBeforeKink","rectangle1Area","triangle1Area","utilizationAfter","rectangle2Area","triangle2Area","convertApyToWeeklyFee","apy","weeklyFeePct","plus","dividedBy","minus","times","calculateApyFromUtilization","utilizationBeforeDeposit","utilizationAfterDeposit","eq","areaBeforeDeposit","areaAfterDeposit","calculateRealizedLpFeePct","SLOW_ETH_GAS","SLOW_ERC_GAS","SLOW_UMA_GAS","FAST_ETH_GAS","FAST_ERC_GAS","FAST_UMA_GAS","SPEED_UP_ETH_GAS","SPEED_UP_ERC_GAS","SPEED_UP_UMA_GAS","DEFAULT_GAS_DISCOUNT","expectedRateModelKeys","L2_STATE_COMMITMENT_DELAY_BLOCKS","AddressZero","constants","ADDRESSES","ETH","UMA","WETH","USDC","RateModel","SECONDS_PER_YEAR","DEFAULT_BLOCK_DELTA","RateModelDictionary","_throwIfNotInitialized","rateModelDictionary","updateWithEvents","rateModelEvents","createRateModelEventDictionary","getRateModelForBlockNumber","l1TokenNormalized","getAddress","parseAndReturnRateModelFromString","firstEventBlockNumber","reverse","find","getL1TokensFromRateModel","rateModelString","rateModelFromEvent","JSON","parse","includes","updatedRateModelEventsForToken","sort","transactionIndex","updatedRateModelEvent","BlockFinder","requestBlock","getBlockForTimestamp","Number","getLatestBlock","initialBlock","cushion","incrementDistance","multiplier","distance","getBlock","sortedIndexBy","findBlock","_this$blocks$index","_this$blocks$index2","_this$blocks$index3","_startBlock","_endBlock","startBlock","endBlock","totalTimeDifference","totalBlockDistance","blockPercentile","estimatedBlock","round","newBlock","clamp","LpFeeCalculator","blockFinder","bind","getLpFeePct","tokenAddress","bridgePoolAddress","gt","bridgePoolInstance","rateModelStoreAddress","rateModelStore","getNetwork","rateModelStoreInstance","targetBlock","blockTag","currentUt","nextUt","rateModelForBlockHeight","all","callStatic","liquidityUtilizationCurrent","liquidityUtilizationPostRelay","l1TokenRateModels","Coingecko","host","getHistoricContractPrices","toLowerCase","prices","getContractDetails","contract_address","platform_id","getCurrentPriceByContract","last_updated","getContractPrices","addresses","contract_addresses","lookup","last_updated_at","getPlatforms","path","getGasFee","ethersProvider","baseFeePerGas","priorityFeePerGas","fastest","priorityFeePerGasWei","coingecko","tokenPrice","erc20Client","erc20Connect","makeSlowGasTable","DEFAULT","makeInstantGasTable","GetGasByAddress","gasTable","getInstantGasByAddress","getSlowGasByAddress","getDepositFees","amountToRelay","discountPercent","slowGas","slowGasDiscounted","slowGasFee","instantGas","instantGasDiscounted","instantGasFee","slowPct","instantPct","getDepositFeesDetails","feeLimitPercent","slowTotal","instantTotal","isAmountTooLow","instant","pct","total","slow","Multicall","multicallClient","contractInstance","encodeRequest","target","callData","interface","encodeFunctionData","decodeResponse","response","decodeFunctionResult","child","forEach","read","_requests","encodedRequests","returnData","aggregate","zipped","multicall","Multicall2","tryBlockAndAggregate","success","Multicall2Factory","tx","stringify","signer","emit","confirmations","submissions","mined","unsignedTx","populated","processRequest","sent","sendTransaction","hash","processSubmission","receipt","getTransactionReceipt","catch","isMined","PoolState","batchRead","latestBlock","previousBlock","exchangeRatePrevious","exchangeRateCurrent","PoolEventState","params","seen","hasEvent","addEvent","iface","abi","userAddress","queryFilter","filters","LiquidityAdded","LiquidityRemoved","filterSeen","makeEventFromLog","log","description","parseLog","eventSignature","signature","readTxReceipt","logs","UserState","user","balanceOf","calculateRemoval","amountWei","percentWei","receive","remain","recieve","previewRemoval","percentFloat","position","totalDeposited","fees","feesEarned","positionValue","joinUserState","poolState","userState","poolAddress","joinPoolState","totalPoolSize","liquidReserves","utilizedReserves","secondsElapsed","blocksElapsed","estimatedApy","estimatedApr","projectedApr","pendingReserves","ReadPoolClient","multicallAddress","validateWithdraw","pool","lpTokenAmount","l1TokensToReturn","Client","deps","pools","users","transactions","multicall2Address","rateModelInstance","getOrCreatePoolContract","poolContracts","getOrCreatePoolEvents","poolEvents","getOrCreateTransactionManager","transactionManagers","txman","TransactionManager","txReceipt","updatePool","toAddress","then","updateUserWithTransaction","fromAddress","error","addEthLiquidity","l1TokenAmount","overrides","populateTransaction","addLiquidity","addTokenLiquidity","lpAmount","hasPool","getPool","hasUser","updateUser","getUser","removeTokenLiquidity","removeLiquidity","removeEthliquidity","Boolean","hasTx","getTx","getUserState","getPoolEventState","blockDelta","rateModelRaw","updateTransactions","txMan","startInterval","delayMs","intervalStarted","stopInterval","l1Contracts","Proxy__OVM_L1StandardBridge","OptimismBridgeClient","getL1BridgeAddress","l1StandardBridgeAddress","depositERC20","l1Signer","l1Erc20Address","l2Erc20Address","getChainId","l1StandardBridge","OptimismL1StandardBridgeEthers__factory","l1_ERC20","L2_DEPOSIT_GAS_LIMIT","depositEth","depositETH","waitRelayToL2","l1RpcProvider","l2RpcProvider","l2Messenger","Contract","predeploys","L2CrossDomainMessenger","getContractInterface","l1Messenger","l1CrossDomainMessenger","watcher","Watcher","l1","messengerAddress","l2","msgHash1","getMessageHashesFromL1Tx","getL2TransactionReceipt","checkAllowance","allowance","approve","ADDRESS_MANAGER_ADDRESS","BobaBridgeClient","l1Provider","addressManagerAddress","addressManager","BobaAddressManagerEthers__factory","formatBytes32String","Date","getTime","proxyL1CrossDomainMessengerAddress","l2CrossDomainMessenger","msgHash","ExistenceError","message","setPrototypeOf","prototype","assertExists","condition","ignoreExistenceError","ignoreExistenceErrorAsync","OracleType","Flag","ContextType","hexValue","initFlags","MissingRequest","MissingUser","WrongChain","CanPropose","CanDispute","CanSettle","InDvmVote","RequestSettled","InsufficientBalance","InsufficientApproval","ProposalTxInProgress","ApprovalTxInProgress","DisputeTxInProgress","ChainChangeInProgress","nowS","now","getFlags","Read","flags","inputRequest","userChainId","requestChainId","Resolved","Expired","bond","totalBond","userCollateralBalance","userCollateralAllowance","lt","commands","filterCommands","done","command","proposePrice","disputePrice","switchOrAddChain","getMulticall2Address","DefaultChainConfig","chainConfig","checkTxIntervalSec","DefaultConfig","getters","oracleType","chains","TransactionConfirmer","getReceipt","isConfirmed","chainConfigToChainMetadata","optimisticOracleAddress","earliestBlockNumber","maxEventRangeQuery","chainMetadata","rangeStart","maxRange","range","currentRange","currentStart","currentEnd","rangeSuccessDescending","nextRange","ceil","nextEnd","nextStart","rangeFailureDescending","eventKey","_event$logIndex","insertOrderedAscending","array","element","orderBy","sortedLastIndexBy","isUnique","elementId","found","next","isSupportedOracleType","batchProps","Erc20","erc20","getProps","symbol","totalSupply","Erc20Multicall","factory","User","props","balance","account","allowances","OptimisticOracle","defaultLiveness","Chain","erc20s","_this$state","_this$state$erc20s","optimisticOracle","_this$state2","currentTime","Inputs","Services","_this$state3","_this$state4","_this$state5","Erc20Factory","Write","_this$state6","_this$state7","_this$state7$chains","inputs","services","context","sortedRequestsService","sortedRequests","_this$state8","_this$state8$services","descendingRequests","optionalChainId","_this$state$config","_this$state$config$ch","source","_this$state2$config","_this$state3$inputs","_this$state3$inputs$r","_this$state4$inputs","_this$state5$inputs","_this$state5$inputs$u","chain","_this$state6$chains","_this$state7$inputs","_this$state7$inputs$u","requestChain","_chain$optimisticOrac","_this$state8$inputs","_this$state8$inputs$u","input","_this$state9","_this$state9$inputs","liveness","_chain$optimisticOrac2","_chain$optimisticOrac3","_chain$optimisticOrac4","_chain$erc20s","_chain$erc20s$request","_chain$erc20s2","_chain$erc20s2$reques","_chain$erc20s2$reques2","oracle","oracleAddress","_chain$erc20s3","_chain$erc20s3$reques","_chain$erc20s3$reques2","_chain$erc20s3$reques3","_this$state10","_this$state10$service","_this$state10$service2","_this$state10$service3","_this$state11","_this$state11$service","_this$state11$service2","_this$state11$service3","_this$state11$service4","_this$state12","_this$state12$command","_this$state13","_this$state13$service","_this$state13$service2","_this$state13$service3","_this$state13$service4","_this$state14","_this$state14$service","_this$state14$service2","_this$state14$service3","_this$state15","search","listCommands","_this$state16","_this$state16$chains","time","_this$state17","_this$state17$service","_this$state18","query","Has","collateralProps","Store","write","cb","prevState","produce","writeAsync","OracleStore","Update","oracleAllowance","oo","oracleService","contractRequest","fetchRequest","token","collateralService","tokenService","txService","transactionService","getBlockNumber","listRequests","setByRequest","descending","w","requestIndexData","getRequest","initMemory","Handlers","memory","confirm","updateFromTransactionReceipt","send","code","addAndSwitch","iterations","ctx","shouldUpdate","Invalid","rangeState","oracleEvents","activeRequestFromEvents","_memory$state","pollRateSec","currentBlock","lastBlock","eventIndex","filteredRequests","_request$requestTx","_request$proposeTx","_request$disputeTx","_request$settleTx","_request$requestLogIn","_request$proposeLogIn","_request$disputeLogIn","_request$settleLogInd","requestInput","oracleLogs","decodedLogs","_log$logIndex","settle","concurrency","requestsToFetch","eventBased","bluebird","ContextClient","ms","Step","handlers","copy","assign","handler","updated","shouldStep","override","uid","created","ContextManager","step","StateMachine","saveContext","shift","setUser","types","clearUser","setActiveRequest","pollActiveRequest","pollActiveUser","fetchPastEvents","pollNewEvents","setActiveRequestByTransaction","updateActiveRequest","fetchEventBased","handleCreate","pending","pop","sm","poller","approveCollateral","MaxUint256","proposedPriceDecimals","tick","console","makeProvider","rpcUrls","providers","getDefaultProvider","polling","FallbackProvider","disableFetchEventBased","cachedRequest","upsertRequest","setDisputeHash","setProposeHash","setSettleHash","getState","updateFromEvents","SortedStore","SortedRequests","ascending","getByRequest","validateSolidityRequest","settled","resolvedPrice","customLiveness","SkinnyOptimisticOracle","OptimisticOracleV2","requestSettings","fullConfig","Skinny","Optimistic","OptimisticV2","EventHandler","publicEmit","prev","configTable","OptimisticFactory","SkinnyFactory","OptimisticV2Factory"],"mappings":"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"}