export * as clients from "./clients";
export * as stores from "./stores";
export * as tables from "./tables";
export * as utils from "./utils";
export * as across from "./across";
export * as oracle from "./oracle";
export { default as Coingecko } from "./coingecko";
export { default as Multicall } from "./multicall";
export { default as Multicall2 } from "./multicall2";
export { default as BlockFinder } from "./blockFinder";
import type { TypedEventFilterEthers as TypedEventFilter, TypedEventEthers as TypedEvent } from "@uma/contracts-frontend";
import { Contract, ethers, providers, Event } from "ethers";
import { Provider } from "@ethersproject/providers";
import { Signer } from "@ethersproject/abstract-signer";
declare type Result = ethers.utils.Result;
export declare type SignerOrProvider = providers.Provider | providers.BaseProvider | Signer | Provider | providers.JsonRpcProvider | ethers.Signer;
export interface MakeId<I, D> {
    (d: D): I;
}
export interface MaybeId<I> {
    id?: I;
}
export interface HasId<I> {
    id: I;
}
export interface Callable {
    (...args: any[]): any;
}
export declare type SerializableEvent = Omit<Event, "decode" | "removeListener" | "getBlock" | "getTransaction" | "getTransactionReceipt">;
export declare type GetEventType<ContractType extends Contract, EventName extends string> = ReturnType<ContractType["filters"][EventName] extends Callable ? ContractType["filters"][EventName] : never> extends TypedEventFilter<infer T, infer S> ? TypedEvent<T & S extends Result ? T & S : any> : never;
