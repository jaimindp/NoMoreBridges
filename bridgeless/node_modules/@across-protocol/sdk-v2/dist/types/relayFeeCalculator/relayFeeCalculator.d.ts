import { BigNumber } from "ethers";
import { BigNumberish, TransactionCostEstimate } from "../utils";
import { Deposit } from "../interfaces";
export interface QueryInterface {
    getGasCosts: (deposit: Deposit, fillAmount: BigNumberish, relayer: string) => Promise<TransactionCostEstimate>;
    getTokenPrice: (tokenSymbol: string) => Promise<number>;
    getTokenDecimals: (tokenSymbol: string) => number;
}
export declare const expectedCapitalCostsKeys: string[];
export interface CapitalCostConfig {
    lowerBound: string;
    upperBound: string;
    cutoff: string;
    decimals: number;
}
type ChainIdAsString = string;
export interface CapitalCostConfigOverride {
    default: CapitalCostConfig;
    routeOverrides?: Record<ChainIdAsString, Record<ChainIdAsString, CapitalCostConfig>>;
}
export type RelayCapitalCostConfig = CapitalCostConfigOverride | CapitalCostConfig;
export interface BaseRelayFeeCalculatorConfig {
    nativeTokenDecimals?: number;
    gasDiscountPercent?: number;
    capitalDiscountPercent?: number;
    feeLimitPercent?: number;
    capitalCostsConfig: {
        [token: string]: CapitalCostConfig | CapitalCostConfigOverride;
    };
}
export interface RelayFeeCalculatorConfigWithQueries extends BaseRelayFeeCalculatorConfig {
    queries: QueryInterface;
}
export interface RelayFeeCalculatorConfigWithMap extends BaseRelayFeeCalculatorConfig {
    queriesMap: Record<number, QueryInterface>;
}
export type RelayFeeCalculatorConfig = RelayFeeCalculatorConfigWithQueries | RelayFeeCalculatorConfigWithMap;
export interface RelayerFeeDetails {
    amountToRelay: string;
    tokenSymbol: string;
    gasFeePercent: string;
    gasFeeTotal: string;
    gasDiscountPercent: number;
    capitalFeePercent: string;
    capitalFeeTotal: string;
    capitalDiscountPercent: number;
    relayFeePercent: string;
    relayFeeTotal: string;
    feeLimitPercent: number;
    isAmountTooLow: boolean;
    maxGasFeePercent: string;
    minDeposit: string;
}
export interface LoggingFunction {
    (data: {
        at: string;
        message: string;
        [key: string]: unknown;
    }): void;
}
export interface Logger {
    debug: LoggingFunction;
    info: LoggingFunction;
    warn: LoggingFunction;
    error: LoggingFunction;
}
export declare const DEFAULT_LOGGER: Logger;
export declare class RelayFeeCalculator {
    private queries;
    private gasDiscountPercent;
    private capitalDiscountPercent;
    private feeLimitPercent;
    private nativeTokenDecimals;
    private capitalCostsConfig;
    private logger;
    constructor(config: RelayFeeCalculatorConfigWithQueries, logger?: Logger);
    constructor(config: RelayFeeCalculatorConfigWithMap, logger?: Logger, destinationChainId?: number);
    /**
     * Type guard to check if a config is a CapitalCostConfigOverride or a CapitalCostConfig.
     * @param config CapitalCostConfig or CapitalCostConfigOverride
     * @returns true if the config is a CapitalCostConfigOverride, false otherwise.
     * @private
     * @dev This is a type guard that is used to check if a config is a CapitalCostConfigOverride or a CapitalCostConfig.
     * This is needed because the config can be either a CapitalCostConfig or a CapitalCostConfigOverride. If it's a
     * CapitalCostConfig, then we need to convert it to a CapitalCostConfigOverride with the default config set with no route
     * overrides.
     */
    private static capitalCostConfigIsOverride;
    /**
     * Validates a CapitalCostConfigOverride or a CapitalCostConfig.
     * @param capitalCosts CapitalCostConfig or CapitalCostConfigOverride
     * @returns CapitalCostConfigOverride
     */
    static validateAndTransformCapitalCostsConfigOverride(capitalCosts: CapitalCostConfigOverride | CapitalCostConfig): CapitalCostConfigOverride;
    /**
     * Validates a CapitalCostConfig.
     * @param capitalCosts CapitalCostConfig
     */
    static validateCapitalCostsConfig(capitalCosts: CapitalCostConfig): void;
    getTokenPrice(tokenSymbol: string): Promise<number>;
    /**
     * Calculate the gas fee as a % of the amount to relay.
     * @param deposit A valid deposit object to reason about
     * @param amountToRelay The amount that we should fill the deposit for
     * @param simulateZeroFill Whether to simulate a zero fill for the gas cost simulation
     *        A fill of 1 wei which would result in a slow/partial fill.
     *        You should do this if you're not worried about simulating a proper fill of a deposit
     *        with a message or if you are worried a fill amount that could exceed the balance of
     *        the relayer.
     * @param relayerAddress The relayer that will be used for the gas cost simulation
     * @param _tokenPrice The token price for normalizing fees
     * @returns The fee as a % of the amount to relay.
     * @note Setting simulateZeroFill to true will result on the gas costs being estimated
     *       on a zero fill. However, the percentage will be returned as a percentage of the
     *       amount to relay. This is useful for determining the maximum gas fee % that a
     *       relayer may need to make on a regular fill. You will get differing results if
     *       a message & recipient contract is provided as this function may not simulate with
     *       the correct parameters to see a full fill.
     */
    gasFeePercent(deposit: Deposit, amountToRelay: BigNumberish, simulateZeroFill?: boolean, relayerAddress?: string, _tokenPrice?: number, tokenMapping?: {
        ACX: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        BAL: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        BADGER: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        BOBA: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        DAI: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        ETH: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        MATIC: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        POOL: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        SNX: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        UMA: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        USDC: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        USDT: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        WBTC: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        WETH: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        WMATIC: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
        OP: {
            name: string;
            symbol: string;
            decimals: number;
            addresses: {
                [x: number]: string;
            };
        };
    }): Promise<BigNumber>;
    capitalFeePercent(_amountToRelay: BigNumberish, _tokenSymbol: string, _originRoute?: ChainIdAsString, _destinationRoute?: ChainIdAsString): BigNumber;
    /**
     * Retrieves the relayer fee details for a deposit.
     * @param deposit A valid deposit object to reason about
     * @param amountToRelay The amount that the relayer would simulate a fill for
     * @param simulateZeroFill Whether to simulate a zero fill for the gas cost simulation
     *       For simulateZeroFill: A fill of 1 wei which would result in a slow/partial fill.
     *       You should do this if you're not worried about simulating a proper fill of a deposit
     *       with a message or if you are worried a fill amount that could exceed the balance of
     *       the relayer.
     * @param relayerAddress The relayer that will be used for the gas cost simulation
     * @param _tokenPrice The token price for normalizing fees
     * @returns A resulting `RelayerFeeDetails` object
     */
    relayerFeeDetails(deposit: Deposit, amountToRelay?: BigNumberish, simulateZeroFill?: boolean, relayerAddress?: string, _tokenPrice?: number): Promise<RelayerFeeDetails>;
}
export {};
//# sourceMappingURL=relayFeeCalculator.d.ts.map