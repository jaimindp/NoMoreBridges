import { Provider } from "@ethersproject/providers";
import { AcrossConfigStore } from "../typechain";
import { Infer } from "superstruct";
import type { CallOverrides } from "@ethersproject/contracts";
declare const RateModelSs: import("superstruct").Struct<{
    UBar: string;
    R0: string;
    R1: string;
    R2: string;
}, {
    UBar: import("superstruct").Struct<string, null>;
    R0: import("superstruct").Struct<string, null>;
    R1: import("superstruct").Struct<string, null>;
    R2: import("superstruct").Struct<string, null>;
}>;
declare const L1TokenConfigSs: import("superstruct").Struct<{
    rateModel: {
        UBar: string;
        R0: string;
        R1: string;
        R2: string;
    };
    routeRateModel?: Record<string, {
        UBar: string;
        R0: string;
        R1: string;
        R2: string;
    }> | undefined;
}, {
    rateModel: import("superstruct").Struct<{
        UBar: string;
        R0: string;
        R1: string;
        R2: string;
    }, {
        UBar: import("superstruct").Struct<string, null>;
        R0: import("superstruct").Struct<string, null>;
        R1: import("superstruct").Struct<string, null>;
        R2: import("superstruct").Struct<string, null>;
    }>;
    routeRateModel: import("superstruct").Struct<Record<string, {
        UBar: string;
        R0: string;
        R1: string;
        R2: string;
    }> | undefined, null>;
}>;
export type RateModel = Infer<typeof RateModelSs>;
export type L1TokenConfig = Infer<typeof L1TokenConfigSs>;
export declare class Client {
    readonly contract: AcrossConfigStore;
    constructor(address: string, provider: Provider);
    static parseL1TokenConfig(data: string): L1TokenConfig;
    getL1TokenConfig(l1TokenAddress: string, overrides?: CallOverrides): Promise<L1TokenConfig>;
    getRateModel(l1TokenAddress: string, overrides?: CallOverrides, originChainId?: number, destinationChainId?: number): Promise<RateModel>;
}
export {};
//# sourceMappingURL=acrossConfigStore.d.ts.map