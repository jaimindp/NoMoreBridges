import type { Block, Provider } from "@ethersproject/abstract-provider";
import { CachingMechanismInterface } from "../interfaces";
type Opts = {
    highBlock?: number;
    highBlockOffset?: number;
    blockRange?: number;
};
type BlockTimeAverage = {
    average: number;
    blockRange: number;
    timestamp: number;
};
/**
 * @description Compute the average block time over a block range.
 * @returns Average number of seconds per block.
 */
export declare function averageBlockTime(provider: Provider, { highBlock, highBlockOffset, blockRange }?: Opts): Promise<Pick<BlockTimeAverage, "average" | "blockRange">>;
export type BlockFinderHints = {
    lowBlock?: number;
    highBlock?: number;
};
export declare class BlockFinder {
    private readonly provider;
    private readonly blocks;
    constructor(provider: Provider, blocks?: Block[]);
    /**
     * @notice Gets the latest block whose timestamp is <= the provided timestamp.
     * @param number Timestamp timestamp to search.
     * @param hints Optional low and high block to bound the search space.
     */
    getBlockForTimestamp(timestamp: number | string, hints?: BlockFinderHints): Promise<Block>;
    private getLatestBlock;
    private getBlock;
    private findBlock;
}
/**
 * @notice Get the block number for a given timestamp fresh from on-chain data if not found in redis cache.
 * If redis cache is not available, then requests block from blockFinder.
 * @param chainId Chain to load block finder for.
 * @param timestamp Approximate timestamp of the to requested block number.
 * @param blockFinder Caller can optionally pass in a block finder object to use instead of creating a new one
 * or loading from cache. This is useful for testing primarily.
 * @returns Block number for the requested timestamp.
 */
export declare function getCachedBlockForTimestamp(chainId: number, timestamp: number, blockFinder: BlockFinder, cache?: CachingMechanismInterface, hints?: BlockFinderHints): Promise<number>;
export {};
//# sourceMappingURL=BlockUtils.d.ts.map