"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var typechain_1 = require("../../typechain");
var coingecko_1 = require("../../coingecko");
var constants_1 = require("../../constants");
var utils_1 = require("../../utils");
var QueryBase = (function () {
    function QueryBase(provider, symbolMapping, spokePoolAddress, simulatedRelayerAddress, gasMarkup, logger, coingeckoProApiKey, fixedGasPrice, coingeckoBaseCurrency) {
        if (coingeckoBaseCurrency === void 0) { coingeckoBaseCurrency = "eth"; }
        this.provider = provider;
        this.symbolMapping = symbolMapping;
        this.spokePoolAddress = spokePoolAddress;
        this.simulatedRelayerAddress = simulatedRelayerAddress;
        this.gasMarkup = gasMarkup;
        this.logger = logger;
        this.coingeckoProApiKey = coingeckoProApiKey;
        this.fixedGasPrice = fixedGasPrice;
        this.coingeckoBaseCurrency = coingeckoBaseCurrency;
        this.spokePool = typechain_1.SpokePool__factory.connect(spokePoolAddress, provider);
    }
    QueryBase.prototype.getGasCosts = function (deposit, fillAmount, relayer) {
        if (relayer === void 0) { relayer = constants_1.DEFAULT_SIMULATED_RELAYER_ADDRESS; }
        relayer !== null && relayer !== void 0 ? relayer : (relayer = this.simulatedRelayerAddress);
        return (0, utils_1.isV2Deposit)(deposit)
            ? this.getV2GasCosts(deposit, fillAmount, relayer)
            : this.getV3GasCosts(deposit, relayer);
    };
    QueryBase.prototype.getV2GasCosts = function (deposit, amountToRelay, relayer) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tx;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, (0, utils_1.createUnsignedFillRelayTransactionFromDeposit)(this.spokePool, deposit, (0, utils_1.toBN)(amountToRelay), relayer)];
                    case 1:
                        tx = _a.sent();
                        return [2, (0, utils_1.estimateTotalGasRequiredByUnsignedTransaction)(tx, relayer, this.provider, this.gasMarkup, this.fixedGasPrice)];
                }
            });
        });
    };
    QueryBase.prototype.getV3GasCosts = function (deposit, relayer) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tx;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, (0, utils_1.populateV3Relay)(this.spokePool, deposit, relayer)];
                    case 1:
                        tx = _a.sent();
                        return [2, (0, utils_1.estimateTotalGasRequiredByUnsignedTransaction)(tx, relayer, this.provider, this.gasMarkup, this.fixedGasPrice)];
                }
            });
        });
    };
    QueryBase.prototype.getTokenPrice = function (tokenSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var coingeckoInstance, _a, price;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.symbolMapping[tokenSymbol])
                            throw new Error("".concat(tokenSymbol, " does not exist in mapping"));
                        coingeckoInstance = coingecko_1.Coingecko.get(this.logger, this.coingeckoProApiKey);
                        return [4, coingeckoInstance.getCurrentPriceByContract(this.symbolMapping[tokenSymbol].addresses[constants_1.CHAIN_IDs.MAINNET], this.coingeckoBaseCurrency)];
                    case 1:
                        _a = _b.sent(), price = _a[1];
                        return [2, price];
                }
            });
        });
    };
    QueryBase.prototype.getTokenDecimals = function (tokenSymbol) {
        if (!this.symbolMapping[tokenSymbol])
            throw new Error("".concat(tokenSymbol, " does not exist in mapping"));
        return this.symbolMapping[tokenSymbol].decimals;
    };
    return QueryBase;
}());
exports.default = QueryBase;
//# sourceMappingURL=baseQuery.js.map