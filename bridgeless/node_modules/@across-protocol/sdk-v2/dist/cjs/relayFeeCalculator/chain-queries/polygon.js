"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolygonAmoyQueries = exports.PolygonMumbaiQueries = exports.PolygonQueries = void 0;
var tslib_1 = require("tslib");
var DeploymentUtils_1 = require("../../utils/DeploymentUtils");
var relayFeeCalculator_1 = require("../relayFeeCalculator");
var constants_1 = require("../../constants");
var Coingecko_1 = require("../../coingecko/Coingecko");
var baseQuery_1 = tslib_1.__importDefault(require("./baseQuery"));
var PolygonQueries = (function (_super) {
    tslib_1.__extends(PolygonQueries, _super);
    function PolygonQueries(provider, symbolMapping, spokePoolAddress, simulatedRelayerAddress, coingeckoProApiKey, logger, gasMarkup) {
        if (symbolMapping === void 0) { symbolMapping = constants_1.TOKEN_SYMBOLS_MAP; }
        if (spokePoolAddress === void 0) { spokePoolAddress = (0, DeploymentUtils_1.getDeployedAddress)("SpokePool", constants_1.CHAIN_IDs.POLYGON); }
        if (simulatedRelayerAddress === void 0) { simulatedRelayerAddress = constants_1.DEFAULT_SIMULATED_RELAYER_ADDRESS; }
        if (logger === void 0) { logger = relayFeeCalculator_1.DEFAULT_LOGGER; }
        if (gasMarkup === void 0) { gasMarkup = 0; }
        return _super.call(this, provider, symbolMapping, spokePoolAddress, simulatedRelayerAddress, gasMarkup, logger, coingeckoProApiKey, undefined, "usd") || this;
    }
    PolygonQueries.prototype.getTokenPrice = function (tokenSymbol) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var coingeckoInstance, _a, tokenPrice, _b, maticPrice;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!this.symbolMapping[tokenSymbol])
                            throw new Error("".concat(tokenSymbol, " does not exist in mapping"));
                        coingeckoInstance = Coingecko_1.Coingecko.get(this.logger, this.coingeckoProApiKey);
                        return [4, coingeckoInstance.getCurrentPriceByContract(this.symbolMapping[tokenSymbol].addresses[constants_1.CHAIN_IDs.MAINNET], "usd")];
                    case 1:
                        _a = _c.sent(), tokenPrice = _a[1];
                        return [4, coingeckoInstance.getCurrentPriceByContract(this.symbolMapping["MATIC"].addresses[constants_1.CHAIN_IDs.MAINNET], "usd")];
                    case 2:
                        _b = _c.sent(), maticPrice = _b[1];
                        return [2, Number((tokenPrice / maticPrice).toFixed(this.symbolMapping["MATIC"].decimals))];
                }
            });
        });
    };
    return PolygonQueries;
}(baseQuery_1.default));
exports.PolygonQueries = PolygonQueries;
var PolygonMumbaiQueries = (function (_super) {
    tslib_1.__extends(PolygonMumbaiQueries, _super);
    function PolygonMumbaiQueries(provider, symbolMapping, spokePoolAddress, simulatedRelayerAddress, coingeckoProApiKey, logger, gasMarkup) {
        if (symbolMapping === void 0) { symbolMapping = constants_1.TOKEN_SYMBOLS_MAP; }
        if (spokePoolAddress === void 0) { spokePoolAddress = (0, DeploymentUtils_1.getDeployedAddress)("SpokePool", constants_1.CHAIN_IDs.MUMBAI); }
        if (simulatedRelayerAddress === void 0) { simulatedRelayerAddress = constants_1.DEFAULT_SIMULATED_RELAYER_ADDRESS_TEST; }
        if (logger === void 0) { logger = relayFeeCalculator_1.DEFAULT_LOGGER; }
        if (gasMarkup === void 0) { gasMarkup = 0; }
        return _super.call(this, provider, symbolMapping, spokePoolAddress, simulatedRelayerAddress, coingeckoProApiKey, logger, gasMarkup) || this;
    }
    return PolygonMumbaiQueries;
}(PolygonQueries));
exports.PolygonMumbaiQueries = PolygonMumbaiQueries;
var PolygonAmoyQueries = (function (_super) {
    tslib_1.__extends(PolygonAmoyQueries, _super);
    function PolygonAmoyQueries(provider, symbolMapping, spokePoolAddress, simulatedRelayerAddress, coingeckoProApiKey, logger, gasMarkup) {
        if (symbolMapping === void 0) { symbolMapping = constants_1.TOKEN_SYMBOLS_MAP; }
        if (spokePoolAddress === void 0) { spokePoolAddress = (0, DeploymentUtils_1.getDeployedAddress)("SpokePool", constants_1.CHAIN_IDs.POLYGON_AMOY); }
        if (simulatedRelayerAddress === void 0) { simulatedRelayerAddress = constants_1.DEFAULT_SIMULATED_RELAYER_ADDRESS_TEST; }
        if (logger === void 0) { logger = relayFeeCalculator_1.DEFAULT_LOGGER; }
        if (gasMarkup === void 0) { gasMarkup = 0; }
        return _super.call(this, provider, symbolMapping, spokePoolAddress, simulatedRelayerAddress, coingeckoProApiKey, logger, gasMarkup) || this;
    }
    return PolygonAmoyQueries;
}(PolygonQueries));
exports.PolygonAmoyQueries = PolygonAmoyQueries;
//# sourceMappingURL=polygon.js.map