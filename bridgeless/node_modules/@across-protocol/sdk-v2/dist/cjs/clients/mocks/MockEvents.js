"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEventManager = exports.EventManager = void 0;
var tslib_1 = require("tslib");
var assert_1 = tslib_1.__importDefault(require("assert"));
var ethers_1 = require("ethers");
var lodash_1 = require("lodash");
var utils_1 = require("../../utils");
var id = ethers_1.utils.id, keccak256 = ethers_1.utils.keccak256, toUtf8Bytes = ethers_1.utils.toUtf8Bytes;
var eventManagers = {};
var getTransaction = function () {
    throw new Error("getTransaction() not supported");
};
var getTransactionReceipt = function () {
    throw new Error("getTransactionReceipt() not supported");
};
var removeListener = function () {
    throw new Error("removeListener not supported");
};
var EventManager = (function () {
    function EventManager(blockNumber) {
        if (blockNumber === void 0) { blockNumber = 0; }
        this.blockNumber = blockNumber;
        this.logIndexes = {};
        this.events = [];
        this.minBlockRange = 10;
        this.eventSignatures = {};
    }
    EventManager.prototype.addEventSignatures = function (eventSignatures) {
        var _this = this;
        Object.entries(eventSignatures).forEach(function (_a) {
            var event = _a[0], signature = _a[1];
            if ((0, utils_1.isDefined)(_this.eventSignatures[event])) {
                (0, assert_1.default)(signature === _this.eventSignatures[event], "Event ".concat(event, " conflict detected."));
            }
            _this.eventSignatures[event] = signature;
        });
    };
    EventManager.prototype.addEvent = function (event) {
        this.events.push(event);
    };
    EventManager.prototype.getEvents = function () {
        var events = this.events;
        this.events = [];
        return events;
    };
    EventManager.prototype.generateEvent = function (inputs) {
        var _a;
        var _b;
        var address = inputs.address, event = inputs.event, _topics = inputs.topics, data = inputs.data, args = inputs.args;
        var eventSignature = "".concat(event, "(").concat(this.eventSignatures[event], ")");
        var topics = [keccak256(toUtf8Bytes(eventSignature))].concat(_topics);
        var blockNumber = inputs.blockNumber, transactionIndex = inputs.transactionIndex;
        blockNumber !== null && blockNumber !== void 0 ? blockNumber : (blockNumber = (0, lodash_1.random)(this.blockNumber + 1, this.blockNumber + this.minBlockRange, false));
        (0, assert_1.default)(blockNumber >= this.blockNumber, "".concat(blockNumber, " < ").concat(this.blockNumber));
        this.blockNumber = blockNumber;
        transactionIndex !== null && transactionIndex !== void 0 ? transactionIndex : (transactionIndex = (0, lodash_1.random)(1, 32, false));
        var transactionHash = id("Across-v2-".concat(event, "-").concat(blockNumber, "-").concat(transactionIndex, "-").concat((0, lodash_1.random)(1, 100000)));
        var _logIndex = "".concat(blockNumber, "-").concat(transactionIndex);
        (_a = (_b = this.logIndexes)[_logIndex]) !== null && _a !== void 0 ? _a : (_b[_logIndex] = 0);
        var logIndex = this.logIndexes[_logIndex]++;
        var decodeError = new Error("".concat(event, " decoding error"));
        var parentHash = id("Across-v2-blockHash-".concat((0, lodash_1.random)(1, 100000)));
        var blockHash = id("Across-v2-blockHash-".concat(parentHash, "-").concat((0, lodash_1.random)(1, 100000)));
        var getBlock = function () {
            return Promise.resolve({
                hash: blockHash,
                parentHash: parentHash,
                number: blockNumber,
                timestamp: Math.floor(Date.now() / 1000),
                nonce: "",
                difficulty: (0, lodash_1.random)(1, 1000, false),
                _difficulty: (0, utils_1.toBN)((0, lodash_1.random)(1, 1000, false)),
                gasLimit: (0, utils_1.toBN)((0, lodash_1.random)(1000000, 10000000, false)),
                gasUsed: (0, utils_1.toBN)((0, lodash_1.random)(1, 1000, false)),
                miner: (0, utils_1.randomAddress)(),
                extraData: "Block containing test transaction ".concat(transactionHash, "."),
                transactions: [transactionHash],
            });
        };
        var generatedEvent = {
            blockNumber: blockNumber,
            transactionIndex: transactionIndex,
            logIndex: logIndex,
            transactionHash: transactionHash,
            removed: false,
            address: address,
            data: data !== null && data !== void 0 ? data : id("Across-v2-random-txndata-".concat((0, lodash_1.random)(1, 100000))),
            topics: topics,
            args: args,
            blockHash: blockHash,
            event: event,
            eventSignature: eventSignature,
            decodeError: decodeError,
            getBlock: getBlock,
            getTransaction: getTransaction,
            getTransactionReceipt: getTransactionReceipt,
            removeListener: removeListener,
        };
        this.addEvent(generatedEvent);
        return generatedEvent;
    };
    return EventManager;
}());
exports.EventManager = EventManager;
function getEventManager(chainId, eventSignatures, blockNumber) {
    if (!(0, utils_1.isDefined)(eventManagers[chainId])) {
        eventManagers[chainId] = new EventManager(blockNumber);
    }
    var eventManager = eventManagers[chainId];
    if ((0, utils_1.isDefined)(eventSignatures)) {
        eventManager.addEventSignatures(eventSignatures);
    }
    return eventManager;
}
exports.getEventManager = getEventManager;
//# sourceMappingURL=MockEvents.js.map