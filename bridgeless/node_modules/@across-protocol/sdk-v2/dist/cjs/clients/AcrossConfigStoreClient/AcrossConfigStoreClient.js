"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcrossConfigStoreClient = exports.GLOBAL_CONFIG_STORE_KEYS = exports.DEFAULT_CONFIG_STORE_VERSION = void 0;
var tslib_1 = require("tslib");
var sdk_1 = require("@uma/sdk");
var assert_1 = tslib_1.__importDefault(require("assert"));
var typeguards_1 = require("../../typeguards");
var utils_1 = require("../../utils");
var constants_1 = require("../../constants");
var JSONUtils_1 = require("../../utils/JSONUtils");
var BaseAbstractClient_1 = require("../BaseAbstractClient");
exports.DEFAULT_CONFIG_STORE_VERSION = 0;
var GLOBAL_CONFIG_STORE_KEYS;
(function (GLOBAL_CONFIG_STORE_KEYS) {
    GLOBAL_CONFIG_STORE_KEYS["MAX_RELAYER_REPAYMENT_LEAF_SIZE"] = "MAX_RELAYER_REPAYMENT_LEAF_SIZE";
    GLOBAL_CONFIG_STORE_KEYS["MAX_POOL_REBALANCE_LEAF_SIZE"] = "MAX_POOL_REBALANCE_LEAF_SIZE";
    GLOBAL_CONFIG_STORE_KEYS["VERSION"] = "VERSION";
    GLOBAL_CONFIG_STORE_KEYS["DISABLED_CHAINS"] = "DISABLED_CHAINS";
    GLOBAL_CONFIG_STORE_KEYS["CHAIN_ID_INDICES"] = "CHAIN_ID_INDICES";
})(GLOBAL_CONFIG_STORE_KEYS || (exports.GLOBAL_CONFIG_STORE_KEYS = GLOBAL_CONFIG_STORE_KEYS = {}));
var AcrossConfigStoreClient = (function (_super) {
    tslib_1.__extends(AcrossConfigStoreClient, _super);
    function AcrossConfigStoreClient(logger, configStore, eventSearchConfig, configStoreVersion) {
        if (eventSearchConfig === void 0) { eventSearchConfig = { fromBlock: 0, maxBlockLookBack: 0 }; }
        var _this = _super.call(this) || this;
        _this.logger = logger;
        _this.configStore = configStore;
        _this.eventSearchConfig = eventSearchConfig;
        _this.configStoreVersion = configStoreVersion;
        _this.cumulativeRateModelUpdates = [];
        _this.ubaConfigUpdates = [];
        _this.cumulativeRouteRateModelUpdates = [];
        _this.cumulativeMaxRefundCountUpdates = [];
        _this.cumulativeMaxL1TokenCountUpdates = [];
        _this.chainIdIndicesUpdates = [];
        _this.cumulativeSpokeTargetBalanceUpdates = [];
        _this.cumulativeConfigStoreVersionUpdates = [];
        _this.cumulativeDisabledChainUpdates = [];
        _this.hasLatestConfigStoreVersion = false;
        _this.firstBlockToSearch = eventSearchConfig.fromBlock;
        _this.latestBlockSearched = 0;
        _this.rateModelDictionary = new sdk_1.across.rateModel.RateModelDictionary();
        return _this;
    }
    AcrossConfigStoreClient.prototype.getRateModelForBlockNumber = function (l1Token, originChainId, destinationChainId, blockNumber) {
        if (blockNumber === void 0) { blockNumber = undefined; }
        var route = "".concat(originChainId, "-").concat(destinationChainId);
        var routeRateModel = this.getRouteRateModelForBlockNumber(l1Token, route, blockNumber);
        return routeRateModel !== null && routeRateModel !== void 0 ? routeRateModel : this.rateModelDictionary.getRateModelForBlockNumber(l1Token, blockNumber);
    };
    AcrossConfigStoreClient.prototype.getRouteRateModelForBlockNumber = function (l1Token, route, blockNumber) {
        if (blockNumber === void 0) { blockNumber = undefined; }
        var config = (0, utils_1.sortEventsDescending)(this.cumulativeRouteRateModelUpdates).find(function (config) { return config.blockNumber <= (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) && config.l1Token === l1Token; });
        if ((config === null || config === void 0 ? void 0 : config.routeRateModel[route]) === undefined) {
            return undefined;
        }
        return sdk_1.across.rateModel.parseAndReturnRateModelFromString(config.routeRateModel[route]);
    };
    AcrossConfigStoreClient.prototype.implicitChainIdIndices = function (chainId) {
        (0, assert_1.default)((0, utils_1.isDefined)(chainId), "ConfigStoreClient used before update");
        return constants_1.PROTOCOL_DEFAULT_CHAIN_ID_INDICES[0] === chainId ? constants_1.PROTOCOL_DEFAULT_CHAIN_ID_INDICES : [chainId];
    };
    AcrossConfigStoreClient.prototype.getChainIdIndicesForBlock = function (blockNumber) {
        var _a;
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var chainIdUpdates = (0, utils_1.sortEventsDescending)(this.chainIdIndicesUpdates);
        var chainIdIndices = (_a = chainIdUpdates.find(function (update) { return update.blockNumber <= blockNumber; })) === null || _a === void 0 ? void 0 : _a.value;
        return chainIdIndices !== null && chainIdIndices !== void 0 ? chainIdIndices : this.implicitChainIdIndices(this.chainId);
    };
    AcrossConfigStoreClient.prototype.getSpokeTargetBalancesForBlock = function (l1Token, chainId, blockNumber) {
        var _a;
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var config = (0, utils_1.sortEventsDescending)(this.cumulativeSpokeTargetBalanceUpdates).find(function (config) { return config.l1Token === l1Token && config.blockNumber <= blockNumber; });
        var targetBalance = (_a = config === null || config === void 0 ? void 0 : config.spokeTargetBalances) === null || _a === void 0 ? void 0 : _a[chainId];
        return targetBalance || { target: (0, utils_1.toBN)(0), threshold: (0, utils_1.toBN)(0) };
    };
    AcrossConfigStoreClient.prototype.getMaxRefundCountForRelayerRefundLeafForBlock = function (blockNumber) {
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var config = (0, utils_1.sortEventsDescending)(this.cumulativeMaxRefundCountUpdates).find(function (config) { return config.blockNumber <= blockNumber; });
        if (!config) {
            throw new Error("Could not find MaxRefundCount before block ".concat(blockNumber));
        }
        return Number(config.value);
    };
    AcrossConfigStoreClient.prototype.getMaxL1TokenCountForPoolRebalanceLeafForBlock = function (blockNumber) {
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var config = (0, utils_1.sortEventsDescending)(this.cumulativeMaxL1TokenCountUpdates).find(function (config) { return config.blockNumber <= blockNumber; });
        if (!config) {
            throw new Error("Could not find MaxL1TokenCount before block ".concat(blockNumber));
        }
        return Number(config.value);
    };
    AcrossConfigStoreClient.prototype.getEnabledChainsInBlockRange = function (fromBlock, toBlock) {
        if (toBlock === void 0) { toBlock = Number.MAX_SAFE_INTEGER; }
        if (fromBlock > toBlock) {
            throw new Error("Invalid block range: fromBlock ".concat(fromBlock, " > toBlock ").concat(toBlock));
        }
        var disabledChainsAtFromBlock = this.getDisabledChainsForBlock(fromBlock);
        var allPossibleChains = this.getChainIdIndicesForBlock(toBlock);
        var enabledChainsInBlockRange = allPossibleChains.filter(function (chainId) { return !disabledChainsAtFromBlock.includes(chainId); });
        this.cumulativeDisabledChainUpdates
            .filter(function (e) { return e.blockNumber <= toBlock && e.blockNumber >= fromBlock; })
            .forEach(function (e) {
            var newDisabledSet = e.chainIds;
            disabledChainsAtFromBlock.forEach(function (disabledChain) {
                if (!newDisabledSet.includes(disabledChain)) {
                    enabledChainsInBlockRange.push(disabledChain);
                }
            });
        });
        return allPossibleChains.filter(function (chainId) { return enabledChainsInBlockRange.includes(chainId); });
    };
    AcrossConfigStoreClient.prototype.getEnabledChains = function (block) {
        if (block === void 0) { block = Number.MAX_SAFE_INTEGER; }
        var currentlyDisabledChains = this.getDisabledChainsForBlock(block);
        return this.getChainIdIndicesForBlock(block).filter(function (chainId) { return !currentlyDisabledChains.includes(chainId); });
    };
    AcrossConfigStoreClient.prototype.getDisabledChainsForBlock = function (blockNumber) {
        var _a, _b;
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        return ((_b = (_a = (0, utils_1.sortEventsDescending)(this.cumulativeDisabledChainUpdates).find(function (config) { return config.blockNumber <= blockNumber; })) === null || _a === void 0 ? void 0 : _a.chainIds) !== null && _b !== void 0 ? _b : []);
    };
    AcrossConfigStoreClient.prototype.getConfigStoreVersionForTimestamp = function (timestamp) {
        if (timestamp === void 0) { timestamp = Number.MAX_SAFE_INTEGER; }
        var config = this.cumulativeConfigStoreVersionUpdates.find(function (config) { return config.timestamp <= timestamp; });
        return (0, utils_1.isDefined)(config) ? Number(config.value) : exports.DEFAULT_CONFIG_STORE_VERSION;
    };
    AcrossConfigStoreClient.prototype.getConfigStoreVersionForBlock = function (blockNumber) {
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var config = this.cumulativeConfigStoreVersionUpdates.find(function (config) { return config.blockNumber <= blockNumber; });
        return (0, utils_1.isDefined)(config) ? Number(config.value) : exports.DEFAULT_CONFIG_STORE_VERSION;
    };
    AcrossConfigStoreClient.prototype.hasValidConfigStoreVersionForTimestamp = function (timestamp) {
        if (timestamp === void 0) { timestamp = Number.MAX_SAFE_INTEGER; }
        var version = this.getConfigStoreVersionForTimestamp(timestamp);
        return this.configStoreVersion >= version;
    };
    AcrossConfigStoreClient.prototype.resolveChainId = function () {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!((_a = this.chainId) !== null && _a !== void 0)) return [3, 1];
                        _b = _a;
                        return [3, 3];
                    case 1: return [4, this.configStore.provider.getNetwork()];
                    case 2:
                        _b = (_c.sent()).chainId;
                        _c.label = 3;
                    case 3: return [2, _b];
                }
            });
        });
    };
    AcrossConfigStoreClient.prototype._update = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var chainId, searchConfig, _a, _b, updatedTokenConfigEvents, updatedGlobalConfigEvents, globalConfigUpdateTimes;
            var _c;
            var _this = this;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4, this.resolveChainId()];
                    case 1:
                        chainId = _d.sent();
                        _c = {
                            fromBlock: this.firstBlockToSearch
                        };
                        _a = this.eventSearchConfig.toBlock;
                        if (_a) return [3, 3];
                        return [4, this.configStore.provider.getBlockNumber()];
                    case 2:
                        _a = (_d.sent());
                        _d.label = 3;
                    case 3:
                        searchConfig = (_c.toBlock = _a,
                            _c.maxBlockLookBack = this.eventSearchConfig.maxBlockLookBack,
                            _c);
                        this.logger.debug({ at: "AcrossConfigStore", message: "Updating ConfigStore client", searchConfig: searchConfig });
                        if (searchConfig.fromBlock > searchConfig.toBlock) {
                            this.logger.warn({ at: "AcrossConfigStore", message: "Invalid search config.", searchConfig: searchConfig });
                            return [2, { success: false }];
                        }
                        return [4, Promise.all([
                                (0, utils_1.paginatedEventQuery)(this.configStore, this.configStore.filters.UpdatedTokenConfig(), searchConfig),
                                (0, utils_1.paginatedEventQuery)(this.configStore, this.configStore.filters.UpdatedGlobalConfig(), searchConfig),
                            ])];
                    case 4:
                        _b = _d.sent(), updatedTokenConfigEvents = _b[0], updatedGlobalConfigEvents = _b[1];
                        [updatedTokenConfigEvents, updatedGlobalConfigEvents].forEach(function (events) { return (0, utils_1.sortEventsAscendingInPlace)(events); });
                        return [4, Promise.all(updatedGlobalConfigEvents.map(function (event) { return _this.configStore.provider.getBlock(event.blockNumber); }))];
                    case 5:
                        globalConfigUpdateTimes = (_d.sent()).map(function (block) { return block.timestamp; });
                        return [2, {
                                success: true,
                                chainId: chainId,
                                searchEndBlock: searchConfig.toBlock,
                                events: {
                                    updatedTokenConfigEvents: updatedTokenConfigEvents,
                                    updatedGlobalConfigEvents: updatedGlobalConfigEvents,
                                    globalConfigUpdateTimes: globalConfigUpdateTimes,
                                },
                            }];
                }
            });
        });
    };
    AcrossConfigStoreClient.prototype.update = function () {
        var _a, _b, _c, _d, _e;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, chainId, _f, updatedTokenConfigEvents, updatedGlobalConfigEvents, globalConfigUpdateTimes, _i, updatedTokenConfigEvents_1, event_1, args, parsedValue, l1Token, value, key, passedArgs, rateModelForToken, targetBalances, routeRateModel, err_1, maxWarnAge, _g, errMsg, _loop_1, this_1, i;
            return tslib_1.__generator(this, function (_h) {
                switch (_h.label) {
                    case 0: return [4, this._update()];
                    case 1:
                        result = _h.sent();
                        if (!result.success) {
                            return [2];
                        }
                        chainId = result.chainId;
                        _f = result.events, updatedTokenConfigEvents = _f.updatedTokenConfigEvents, updatedGlobalConfigEvents = _f.updatedGlobalConfigEvents, globalConfigUpdateTimes = _f.globalConfigUpdateTimes;
                        (0, assert_1.default)(updatedGlobalConfigEvents.length === globalConfigUpdateTimes.length, "GlobalConfigUpdate events mismatch (".concat(updatedGlobalConfigEvents.length, " != ").concat(globalConfigUpdateTimes.length, ")"));
                        _i = 0, updatedTokenConfigEvents_1 = updatedTokenConfigEvents;
                        _h.label = 2;
                    case 2:
                        if (!(_i < updatedTokenConfigEvents_1.length)) return [3, 7];
                        event_1 = updatedTokenConfigEvents_1[_i];
                        args = tslib_1.__assign({}, (0, utils_1.spreadEventWithBlockNumber)(event_1));
                        _h.label = 3;
                    case 3:
                        _h.trys.push([3, 4, , 6]);
                        parsedValue = (0, JSONUtils_1.parseJSONWithNumericString)(args.value);
                        l1Token = args.key;
                        value = args.value, key = args.key, passedArgs = tslib_1.__rest(args, ["value", "key"]);
                        if ((parsedValue === null || parsedValue === void 0 ? void 0 : parsedValue.rateModel) !== undefined) {
                            rateModelForToken = JSON.stringify(parsedValue.rateModel);
                            this.cumulativeRateModelUpdates.push(tslib_1.__assign(tslib_1.__assign({}, passedArgs), { rateModel: rateModelForToken, l1Token: l1Token }));
                            if (parsedValue === null || parsedValue === void 0 ? void 0 : parsedValue.spokeTargetBalances) {
                                targetBalances = Object.fromEntries(Object.entries(parsedValue.spokeTargetBalances).map(function (_a) {
                                    var chainId = _a[0], targetBalance = _a[1];
                                    var target = (0, utils_1.max)((0, utils_1.toBN)(targetBalance.target), (0, utils_1.toBN)(0));
                                    var threshold = (0, utils_1.max)((0, utils_1.toBN)(targetBalance.threshold), (0, utils_1.toBN)(0));
                                    return [chainId, { target: target, threshold: threshold }];
                                }));
                                this.cumulativeSpokeTargetBalanceUpdates.push(tslib_1.__assign(tslib_1.__assign({}, passedArgs), { spokeTargetBalances: targetBalances, l1Token: l1Token }));
                            }
                            else {
                                this.cumulativeSpokeTargetBalanceUpdates.push(tslib_1.__assign(tslib_1.__assign({}, passedArgs), { spokeTargetBalances: {}, l1Token: l1Token }));
                            }
                            if (parsedValue === null || parsedValue === void 0 ? void 0 : parsedValue.routeRateModel) {
                                routeRateModel = Object.fromEntries(Object.entries(parsedValue.routeRateModel).map(function (_a) {
                                    var path = _a[0], routeRateModel = _a[1];
                                    return [path, JSON.stringify(routeRateModel)];
                                }));
                                this.cumulativeRouteRateModelUpdates.push(tslib_1.__assign(tslib_1.__assign({}, passedArgs), { routeRateModel: routeRateModel, l1Token: l1Token }));
                            }
                            else {
                                this.cumulativeRouteRateModelUpdates.push(tslib_1.__assign(tslib_1.__assign({}, passedArgs), { routeRateModel: {}, l1Token: l1Token }));
                            }
                        }
                        return [3, 6];
                    case 4:
                        err_1 = _h.sent();
                        _g = (24 * 60 * 60);
                        return [4, sdk_1.utils.averageBlockTimeSeconds()];
                    case 5:
                        maxWarnAge = _g / (_h.sent());
                        if (result.searchEndBlock - event_1.blockNumber < maxWarnAge) {
                            errMsg = (0, typeguards_1.isError)(err_1) ? err_1.message : "unknown error";
                            this.logger.warn({
                                at: "ConfigStore::update",
                                message: "Caught error during ConfigStore update: ".concat(errMsg),
                                update: args,
                            });
                        }
                        else {
                            this.logger.debug({
                                at: "ConfigStoreClient::update",
                                message: "Skipping invalid historical update at block ".concat(event_1.blockNumber),
                            });
                        }
                        return [3, 6];
                    case 6:
                        _i++;
                        return [3, 2];
                    case 7:
                        (0, utils_1.sortEventsAscendingInPlace)(this.ubaConfigUpdates);
                        _loop_1 = function (i) {
                            var event_2 = updatedGlobalConfigEvents[i];
                            var args = tslib_1.__assign({ blockNumber: event_2.blockNumber, transactionIndex: event_2.transactionIndex, logIndex: event_2.logIndex }, (0, utils_1.spreadEvent)(event_2.args));
                            if (args.key === (0, utils_1.utf8ToHex)(GLOBAL_CONFIG_STORE_KEYS.MAX_RELAYER_REPAYMENT_LEAF_SIZE)) {
                                if (!isNaN(args.value)) {
                                    this_1.cumulativeMaxRefundCountUpdates.push(args);
                                }
                            }
                            else if (args.key === (0, utils_1.utf8ToHex)(GLOBAL_CONFIG_STORE_KEYS.CHAIN_ID_INDICES)) {
                                try {
                                    var chainIndices_1 = JSON.parse(args.value.replace(/['"\s]/g, ""));
                                    if (!(0, utils_1.isArrayOf)(chainIndices_1, utils_1.isPositiveInteger)) {
                                        this_1.logger.warn({ at: "ConfigStore", message: "The array ".concat(chainIndices_1, " is invalid.") });
                                        return "continue";
                                    }
                                    if (new Set(chainIndices_1).size !== chainIndices_1.length) {
                                        this_1.logger.warn({
                                            at: "ConfigStore",
                                            message: "The array ".concat(chainIndices_1, " contains duplicates making it invalid."),
                                        });
                                        return "continue";
                                    }
                                    var previousUpdate = (_b = (_a = this_1.chainIdIndicesUpdates.at(-1)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this_1.implicitChainIdIndices(chainId);
                                    if (!previousUpdate.every(function (chainId, idx) { return chainIndices_1[idx] === chainId; })) {
                                        this_1.logger.warn({
                                            at: "ConfigStoreClient#update",
                                            message: "The array ".concat(chainIndices_1, " is invalid. It must be a superset of the previous array ").concat(previousUpdate),
                                        });
                                        return "continue";
                                    }
                                    this_1.chainIdIndicesUpdates.push(tslib_1.__assign(tslib_1.__assign({}, args), { value: chainIndices_1 }));
                                }
                                catch (e) {
                                    this_1.logger.warn({ at: "ConfigStore::update", message: "Failed to parse chain ID indices: ".concat(args.value) });
                                }
                            }
                            else if (args.key === (0, utils_1.utf8ToHex)(GLOBAL_CONFIG_STORE_KEYS.MAX_POOL_REBALANCE_LEAF_SIZE)) {
                                if (!isNaN(args.value)) {
                                    this_1.cumulativeMaxL1TokenCountUpdates.push(args);
                                }
                            }
                            else if (args.key === (0, utils_1.utf8ToHex)(GLOBAL_CONFIG_STORE_KEYS.VERSION)) {
                                if (isNaN(args.value)) {
                                    return "continue";
                                }
                                var value = Number(args.value);
                                if (!Number.isInteger(value)) {
                                    return "continue";
                                }
                                var lastValue = Number((_d = (_c = this_1.cumulativeConfigStoreVersionUpdates[0]) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : exports.DEFAULT_CONFIG_STORE_VERSION);
                                if (value <= lastValue) {
                                    return "continue";
                                }
                                this_1.cumulativeConfigStoreVersionUpdates = tslib_1.__spreadArray([
                                    tslib_1.__assign(tslib_1.__assign({}, args), { timestamp: globalConfigUpdateTimes[i] })
                                ], this_1.cumulativeConfigStoreVersionUpdates, true);
                            }
                            else if (args.key === (0, utils_1.utf8ToHex)(GLOBAL_CONFIG_STORE_KEYS.DISABLED_CHAINS)) {
                                try {
                                    var chainIds = this_1.filterDisabledChains(JSON.parse(args.value));
                                    this_1.cumulativeDisabledChainUpdates.push(tslib_1.__assign(tslib_1.__assign({}, args), { chainIds: chainIds }));
                                }
                                catch (err) {
                                }
                            }
                            else {
                                return "continue";
                            }
                        };
                        this_1 = this;
                        for (i = 0; i < updatedGlobalConfigEvents.length; i++) {
                            _loop_1(i);
                        }
                        this.rateModelDictionary.updateWithEvents(this.cumulativeRateModelUpdates);
                        this.hasLatestConfigStoreVersion = this.hasValidConfigStoreVersionForTimestamp();
                        this.latestBlockSearched = result.searchEndBlock;
                        this.firstBlockToSearch = result.searchEndBlock + 1;
                        this.chainId = (_e = this.chainId) !== null && _e !== void 0 ? _e : chainId;
                        this.isUpdated = true;
                        this.logger.debug({ at: "ConfigStore", message: "ConfigStore client updated!" });
                        return [2];
                }
            });
        });
    };
    AcrossConfigStoreClient.prototype.filterDisabledChains = function (disabledChains) {
        return disabledChains.filter(function (chainId) { return !isNaN(chainId) && Number.isInteger(chainId) && chainId !== 1; });
    };
    AcrossConfigStoreClient.prototype.getUBAConfig = function (l1TokenAddress, blockNumber) {
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var config = (0, utils_1.findLast)(this.ubaConfigUpdates, function (config) { return config.l1Token === l1TokenAddress && config.blockNumber <= blockNumber; });
        return config === null || config === void 0 ? void 0 : config.config;
    };
    return AcrossConfigStoreClient;
}(BaseAbstractClient_1.BaseAbstractClient));
exports.AcrossConfigStoreClient = AcrossConfigStoreClient;
//# sourceMappingURL=AcrossConfigStoreClient.js.map