"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HubPoolClient = void 0;
var tslib_1 = require("tslib");
var assert_1 = tslib_1.__importDefault(require("assert"));
var ethers_1 = require("ethers");
var lodash_1 = tslib_1.__importDefault(require("lodash"));
var constants_1 = require("../constants");
var lpFeeCalculator = tslib_1.__importStar(require("../lpFeeCalculator"));
var utils_1 = require("../utils");
var BaseAbstractClient_1 = require("./BaseAbstractClient");
var HubPoolClient = (function (_super) {
    tslib_1.__extends(HubPoolClient, _super);
    function HubPoolClient(logger, hubPool, configStoreClient, deploymentBlock, chainId, eventSearchConfig, configOverride, cachingMechanism) {
        if (deploymentBlock === void 0) { deploymentBlock = 0; }
        if (chainId === void 0) { chainId = 1; }
        if (eventSearchConfig === void 0) { eventSearchConfig = { fromBlock: 0, maxBlockLookBack: 0 }; }
        if (configOverride === void 0) { configOverride = {
            ignoredHubExecutedBundles: [],
            ignoredHubProposedBundles: [],
        }; }
        var _this = _super.call(this, cachingMechanism) || this;
        _this.logger = logger;
        _this.hubPool = hubPool;
        _this.configStoreClient = configStoreClient;
        _this.deploymentBlock = deploymentBlock;
        _this.chainId = chainId;
        _this.eventSearchConfig = eventSearchConfig;
        _this.configOverride = configOverride;
        _this.l1TokensToDestinationTokens = {};
        _this.l1Tokens = [];
        _this.lpTokens = {};
        _this.proposedRootBundles = [];
        _this.canceledRootBundles = [];
        _this.disputedRootBundles = [];
        _this.executedRootBundles = [];
        _this.crossChainContracts = {};
        _this.l1TokensToDestinationTokensWithBlock = {};
        _this.latestBlockSearched = Math.min(deploymentBlock - 1, 0);
        _this.firstBlockToSearch = eventSearchConfig.fromBlock;
        var provider = _this.hubPool.provider;
        _this.blockFinder = new utils_1.BlockFinder(provider);
        return _this;
    }
    HubPoolClient.prototype.hubPoolEventFilters = function () {
        return {
            SetPoolRebalanceRoute: this.hubPool.filters.SetPoolRebalanceRoute(),
            L1TokenEnabledForLiquidityProvision: this.hubPool.filters.L1TokenEnabledForLiquidityProvision(),
            ProposeRootBundle: this.hubPool.filters.ProposeRootBundle(),
            RootBundleCanceled: this.hubPool.filters.RootBundleCanceled(),
            RootBundleDisputed: this.hubPool.filters.RootBundleDisputed(),
            RootBundleExecuted: this.hubPool.filters.RootBundleExecuted(),
            CrossChainContractsSet: this.hubPool.filters.CrossChainContractsSet(),
        };
    };
    HubPoolClient.prototype.hasPendingProposal = function () {
        return this.pendingRootBundle !== undefined;
    };
    HubPoolClient.prototype.getPendingRootBundle = function () {
        return this.pendingRootBundle;
    };
    HubPoolClient.prototype.getProposedRootBundles = function () {
        return this.proposedRootBundles;
    };
    HubPoolClient.prototype.getCancelledRootBundles = function () {
        return this.canceledRootBundles;
    };
    HubPoolClient.prototype.getDisputedRootBundles = function () {
        return this.disputedRootBundles;
    };
    HubPoolClient.prototype.getExecutedRootBundles = function () {
        return this.executedRootBundles;
    };
    HubPoolClient.prototype.getSpokePoolForBlock = function (chain, block) {
        if (block === void 0) { block = Number.MAX_SAFE_INTEGER; }
        if (!this.crossChainContracts[chain]) {
            throw new Error("No cross chain contracts set for ".concat(chain));
        }
        var mostRecentSpokePoolUpdateBeforeBlock = (0, utils_1.sortEventsDescending)(this.crossChainContracts[chain]).find(function (crossChainContract) { return crossChainContract.blockNumber <= block; });
        if (!mostRecentSpokePoolUpdateBeforeBlock) {
            throw new Error("No cross chain contract found before block ".concat(block, " for chain ").concat(chain));
        }
        else {
            return mostRecentSpokePoolUpdateBeforeBlock.spokePool;
        }
    };
    HubPoolClient.prototype.getSpokePoolActivationBlock = function (chain, spokePool) {
        var mostRecentSpokePoolUpdateBeforeBlock = this.crossChainContracts[chain].find(function (crossChainContract) { return crossChainContract.spokePool === spokePool; });
        return mostRecentSpokePoolUpdateBeforeBlock === null || mostRecentSpokePoolUpdateBeforeBlock === void 0 ? void 0 : mostRecentSpokePoolUpdateBeforeBlock.blockNumber;
    };
    HubPoolClient.prototype.getL2TokenForL1TokenAtBlock = function (l1Token, destinationChainId, latestHubBlock) {
        var _a, _b, _c, _d;
        if (latestHubBlock === void 0) { latestHubBlock = Number.MAX_SAFE_INTEGER; }
        if (!((_b = (_a = this.l1TokensToDestinationTokensWithBlock) === null || _a === void 0 ? void 0 : _a[l1Token]) === null || _b === void 0 ? void 0 : _b[destinationChainId])) {
            var chain = (0, utils_1.getNetworkName)(destinationChainId);
            var symbol = ((_c = this.l1Tokens.find(function (_a) {
                var address = _a.address;
                return address === l1Token;
            })) !== null && _c !== void 0 ? _c : { symbol: l1Token }).symbol;
            throw new Error("Could not find SpokePool mapping for ".concat(symbol, " on ").concat(chain, " and L1 token ").concat(l1Token));
        }
        var l2Token = (0, utils_1.sortEventsDescending)(this.l1TokensToDestinationTokensWithBlock[l1Token][destinationChainId]).find(function (mapping) { return mapping.blockNumber <= latestHubBlock; });
        if (!l2Token) {
            var chain = (0, utils_1.getNetworkName)(destinationChainId);
            var symbol = ((_d = this.l1Tokens.find(function (_a) {
                var address = _a.address;
                return address === l1Token;
            })) !== null && _d !== void 0 ? _d : { symbol: l1Token }).symbol;
            throw new Error("Could not find SpokePool mapping for ".concat(symbol, " on ").concat(chain, " at or before HubPool block ").concat(latestHubBlock, "!"));
        }
        return l2Token.l2Token;
    };
    HubPoolClient.prototype.getL1TokenForL2TokenAtBlock = function (l2Token, destinationChainId, latestHubBlock) {
        var _this = this;
        if (latestHubBlock === void 0) { latestHubBlock = Number.MAX_SAFE_INTEGER; }
        var l2Tokens = Object.keys(this.l1TokensToDestinationTokensWithBlock)
            .filter(function (l1Token) { return _this.l2TokenEnabledForL1Token(l1Token, destinationChainId); })
            .map(function (l1Token) {
            return _this.l1TokensToDestinationTokensWithBlock[l1Token][destinationChainId].filter(function (mapping) { return mapping.l2Token === l2Token && mapping.blockNumber <= latestHubBlock; });
        })
            .flat();
        if (l2Tokens.length === 0) {
            var chain = (0, utils_1.getNetworkName)(destinationChainId);
            throw new Error("Could not find HubPool mapping for ".concat(l2Token, " on ").concat(chain, " at or before HubPool block ").concat(latestHubBlock, "!"));
        }
        return (0, utils_1.sortEventsDescending)(l2Tokens)[0].l1Token;
    };
    HubPoolClient.prototype.getL1TokenForDeposit = function (deposit) {
        var inputToken = (0, utils_1.getDepositInputToken)(deposit);
        return this.getL1TokenForL2TokenAtBlock(inputToken, deposit.originChainId, deposit.quoteBlockNumber);
    };
    HubPoolClient.prototype.getL2TokenForDeposit = function (deposit, l2ChainId) {
        if (l2ChainId === void 0) { l2ChainId = deposit.destinationChainId; }
        var l1Token = this.getL1TokenForDeposit(deposit);
        return this.getL2TokenForL1TokenAtBlock(l1Token, l2ChainId, deposit.quoteBlockNumber);
    };
    HubPoolClient.prototype.l2TokenEnabledForL1Token = function (l1Token, destinationChainId) {
        return this.l1TokensToDestinationTokens[l1Token][destinationChainId] != undefined;
    };
    HubPoolClient.prototype.getBlockNumber = function (timestamp) {
        var hints = { lowBlock: this.deploymentBlock };
        return (0, utils_1.getCachedBlockForTimestamp)(this.chainId, timestamp, this.blockFinder, this.cachingMechanism, hints);
    };
    HubPoolClient.prototype.getCurrentPoolUtilization = function (l1Token) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var blockNumber, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!((_a = this.latestBlockSearched) !== null && _a !== void 0)) return [3, 1];
                        _b = _a;
                        return [3, 3];
                    case 1: return [4, this.hubPool.provider.getBlockNumber()];
                    case 2:
                        _b = (_c.sent());
                        _c.label = 3;
                    case 3:
                        blockNumber = _b;
                        return [4, this.getUtilization(l1Token, blockNumber, utils_1.bnZero, (0, utils_1.getCurrentTime)(), 0)];
                    case 4: return [2, _c.sent()];
                }
            });
        });
    };
    HubPoolClient.prototype.getUtilization = function (hubPoolToken, blockNumber, depositAmount, timestamp, timeToCache) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var resolver, cache, key, result, utilization;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        resolver = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var overrides;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        overrides = { blockTag: blockNumber };
                                        if (!depositAmount.eq(0)) return [3, 2];
                                        return [4, this.hubPool.callStatic.liquidityUtilizationCurrent(hubPoolToken, overrides)];
                                    case 1: return [2, _a.sent()];
                                    case 2: return [4, this.hubPool.callStatic.liquidityUtilizationPostRelay(hubPoolToken, depositAmount, overrides)];
                                    case 3: return [2, _a.sent()];
                                }
                            });
                        }); };
                        cache = this.cachingMechanism;
                        if (!cache || !(0, utils_1.shouldCache)((0, utils_1.getCurrentTime)(), timestamp, timeToCache)) {
                            return [2, resolver()];
                        }
                        key = depositAmount.eq(0)
                            ? "utilization_".concat(hubPoolToken, "_").concat(blockNumber)
                            : "utilization_".concat(hubPoolToken, "_").concat(blockNumber, "_").concat(depositAmount.toString(), "_");
                        return [4, cache.get(key)];
                    case 1:
                        result = _a.sent();
                        if ((0, utils_1.isDefined)(result)) {
                            return [2, ethers_1.BigNumber.from(result)];
                        }
                        return [4, resolver()];
                    case 2:
                        utilization = _a.sent();
                        if (!(cache && (0, utils_1.shouldCache)((0, utils_1.getCurrentTime)(), timestamp, timeToCache))) return [3, 4];
                        return [4, cache.set(key, "".concat(utilization.toString()), constants_1.DEFAULT_CACHING_TTL)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2, utilization];
                }
            });
        });
    };
    HubPoolClient.prototype.computeRealizedLpFeePct = function (deposit) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var lpFee;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.batchComputeRealizedLpFeePct([deposit])];
                    case 1:
                        lpFee = (_a.sent())[0];
                        return [2, lpFee];
                }
            });
        });
    };
    HubPoolClient.prototype.batchComputeRealizedLpFeePct = function (_deposits) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var deposits, utilizationTimestamps, utilization, quoteBlocks, hubPoolTokens, getHubPoolToken, getHubPoolTokens, resolveUniqueQuoteTimestamps, resolveTimestampsToBlocks, resolveUtilization, computeRealizedLpFeePct, timeToCache, quoteTimestamps, _b, _c, _d, _e;
            var _this = this;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        (0, assert_1.default)(_deposits.length > 0, "No deposits supplied to batchComputeRealizedLpFeePct");
                        if (!(0, utils_1.isDefined)(this.currentTime)) {
                            throw new Error("HubPoolClient has not set a currentTime");
                        }
                        deposits = _deposits.map(function (deposit) {
                            if ((0, utils_1.isV3Deposit)(deposit)) {
                                return deposit;
                            }
                            var inputToken = deposit.originToken, inputAmount = deposit.amount, partialDeposit = tslib_1.__rest(deposit, ["originToken", "amount"]);
                            return tslib_1.__assign(tslib_1.__assign({}, partialDeposit), { inputToken: inputToken, inputAmount: inputAmount });
                        });
                        utilizationTimestamps = {};
                        utilization = {};
                        quoteBlocks = {};
                        hubPoolTokens = {};
                        getHubPoolToken = function (deposit, quoteBlockNumber) {
                            var _a;
                            var tokenKey = "".concat(deposit.originChainId, "-").concat(deposit.inputToken);
                            return ((_a = hubPoolTokens[tokenKey]) !== null && _a !== void 0 ? _a : (hubPoolTokens[tokenKey] = _this.getL1TokenForDeposit(tslib_1.__assign(tslib_1.__assign({}, deposit), { quoteBlockNumber: quoteBlockNumber }))));
                        };
                        getHubPoolTokens = function () { return (0, utils_1.dedupArray)(Object.values(hubPoolTokens)); };
                        resolveUniqueQuoteTimestamps = function (deposit) {
                            var _a;
                            var quoteTimestamp = deposit.quoteTimestamp;
                            var quoteBlockNumber = quoteBlocks[quoteTimestamp];
                            var hubPoolToken = getHubPoolToken(deposit, quoteBlockNumber);
                            (_a = utilizationTimestamps[hubPoolToken]) !== null && _a !== void 0 ? _a : (utilizationTimestamps[hubPoolToken] = []);
                            if (!utilizationTimestamps[hubPoolToken].includes(quoteTimestamp)) {
                                utilizationTimestamps[hubPoolToken].push(quoteTimestamp);
                            }
                        };
                        resolveTimestampsToBlocks = function (quoteTimestamp) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var quoteBlock;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4, this.getBlockNumber(quoteTimestamp)];
                                    case 1:
                                        quoteBlock = _a.sent();
                                        if (!(0, utils_1.isDefined)(quoteBlock)) {
                                            throw new Error("Could not find block for timestamp ".concat(quoteTimestamp));
                                        }
                                        return [2, [quoteTimestamp, quoteBlock]];
                                }
                            });
                        }); };
                        resolveUtilization = function (hubPoolToken) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var _a, _b;
                            var _this = this;
                            return tslib_1.__generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        _b = (_a = Object).fromEntries;
                                        return [4, (0, utils_1.mapAsync)(utilizationTimestamps[hubPoolToken], function (quoteTimestamp) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                                var blockNumber, utilization;
                                                return tslib_1.__generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0:
                                                            blockNumber = quoteBlocks[quoteTimestamp];
                                                            return [4, this.getUtilization(hubPoolToken, blockNumber, utils_1.bnZero, quoteTimestamp, timeToCache)];
                                                        case 1:
                                                            utilization = _a.sent();
                                                            return [2, [blockNumber, utilization]];
                                                    }
                                                });
                                            }); })];
                                    case 1: return [2, _b.apply(_a, [_c.sent()])];
                                }
                            });
                        }); };
                        computeRealizedLpFeePct = function (deposit) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var originChainId, paymentChainId, inputAmount, quoteTimestamp, quoteBlock, hubPoolToken, rateModel, preUtilization, postUtilization, realizedLpFeePct;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        originChainId = deposit.originChainId, paymentChainId = deposit.paymentChainId, inputAmount = deposit.inputAmount, quoteTimestamp = deposit.quoteTimestamp;
                                        quoteBlock = quoteBlocks[quoteTimestamp];
                                        if (paymentChainId === undefined) {
                                            return [2, { quoteBlock: quoteBlock, realizedLpFeePct: utils_1.bnZero }];
                                        }
                                        hubPoolToken = getHubPoolToken(deposit, quoteBlock);
                                        rateModel = this.configStoreClient.getRateModelForBlockNumber(hubPoolToken, originChainId, paymentChainId, quoteBlock);
                                        preUtilization = utilization[hubPoolToken][quoteBlock];
                                        return [4, this.getUtilization(hubPoolToken, quoteBlock, inputAmount, quoteTimestamp, timeToCache)];
                                    case 1:
                                        postUtilization = _a.sent();
                                        realizedLpFeePct = lpFeeCalculator.calculateRealizedLpFeePct(rateModel, preUtilization, postUtilization);
                                        return [2, { quoteBlock: quoteBlock, realizedLpFeePct: realizedLpFeePct }];
                                }
                            });
                        }); };
                        timeToCache = (_a = this.configOverride.timeToCache) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_CACHING_SAFE_LAG;
                        deposits.forEach(function (deposit) { return resolveUniqueQuoteTimestamps(deposit); });
                        quoteTimestamps = (0, utils_1.dedupArray)(deposits.map(function (_a) {
                            var quoteTimestamp = _a.quoteTimestamp;
                            return quoteTimestamp;
                        }));
                        _c = (_b = Object).fromEntries;
                        return [4, (0, utils_1.mapAsync)(quoteTimestamps, function (quoteTimestamp) { return resolveTimestampsToBlocks(quoteTimestamp); })];
                    case 1:
                        quoteBlocks = _c.apply(_b, [_f.sent()]);
                        _e = (_d = Object).fromEntries;
                        return [4, (0, utils_1.mapAsync)(getHubPoolTokens(), function (hubPoolToken) { return tslib_1.__awaiter(_this, void 0, void 0, function () { var _a; return tslib_1.__generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _a = [hubPoolToken];
                                        return [4, resolveUtilization(hubPoolToken)];
                                    case 1: return [2, _a.concat([_b.sent()])];
                                }
                            }); }); })];
                    case 2:
                        utilization = _e.apply(_d, [_f.sent()]);
                        return [4, (0, utils_1.mapAsync)(deposits, function (deposit) { return computeRealizedLpFeePct(deposit); })];
                    case 3: return [2, _f.sent()];
                }
            });
        });
    };
    HubPoolClient.prototype.getL1Tokens = function () {
        return this.l1Tokens;
    };
    HubPoolClient.prototype.getTokenInfoForL1Token = function (l1Token) {
        return this.l1Tokens.find(function (token) { return token.address === l1Token; });
    };
    HubPoolClient.prototype.getLpTokenInfoForL1Token = function (l1Token) {
        return this.lpTokens[l1Token];
    };
    HubPoolClient.prototype.getL1TokenInfoForL2Token = function (l2Token, chainId) {
        var l1TokenCounterpart = this.getL1TokenForL2TokenAtBlock(l2Token, chainId, this.latestBlockSearched);
        return this.getTokenInfoForL1Token(l1TokenCounterpart);
    };
    HubPoolClient.prototype.getTokenInfoForDeposit = function (deposit) {
        var inputToken = (0, utils_1.getDepositInputToken)(deposit);
        return this.getTokenInfoForL1Token(this.getL1TokenForL2TokenAtBlock(inputToken, deposit.originChainId, this.latestBlockSearched));
    };
    HubPoolClient.prototype.getTokenInfo = function (chainId, tokenAddress) {
        var deposit = { originChainId: parseInt(chainId.toString()), originToken: tokenAddress };
        return this.getTokenInfoForDeposit(deposit);
    };
    HubPoolClient.prototype.areTokensEquivalent = function (tokenA, chainIdA, tokenB, chainIdB, hubPoolBlock) {
        if (hubPoolBlock === void 0) { hubPoolBlock = this.latestBlockSearched; }
        try {
            var l1TokenA = this.getL1TokenForL2TokenAtBlock(tokenA, chainIdA, hubPoolBlock);
            var l1TokenB = this.getL1TokenForL2TokenAtBlock(tokenB, chainIdB, hubPoolBlock);
            if (l1TokenA !== l1TokenB) {
                return false;
            }
            var _tokenA = this.getL2TokenForL1TokenAtBlock(l1TokenA, chainIdA, hubPoolBlock);
            var _tokenB = this.getL2TokenForL1TokenAtBlock(l1TokenB, chainIdB, hubPoolBlock);
            return tokenA === _tokenA && tokenB === _tokenB;
        }
        catch (_a) {
            return false;
        }
    };
    HubPoolClient.prototype.getSpokeActivationBlockForChain = function (chainId) {
        var _a;
        return (_a = this.getSpokePoolActivationBlock(chainId, this.getSpokePoolForBlock(chainId))) !== null && _a !== void 0 ? _a : 0;
    };
    HubPoolClient.prototype.isRootBundleValid = function (rootBundle, latestMainnetBlock) {
        var nextRootBundle = this.getFollowingRootBundle(rootBundle);
        var executedLeafCount = this.getExecutedLeavesForRootBundle(rootBundle, nextRootBundle ? Math.min(nextRootBundle.blockNumber, latestMainnetBlock) : latestMainnetBlock);
        return executedLeafCount.length === rootBundle.poolRebalanceLeafCount;
    };
    HubPoolClient.prototype.getRootBundleEvalBlockNumberContainingBlock = function (latestMainnetBlock, block, chain, chainIdListOverride) {
        var chainIdList = chainIdListOverride !== null && chainIdListOverride !== void 0 ? chainIdListOverride : this.configStoreClient.getChainIdIndicesForBlock(latestMainnetBlock);
        var endingBlockNumber;
        for (var i = this.proposedRootBundles.length - 1; i >= 0; i--) {
            var rootBundle = this.proposedRootBundles[i];
            var nextRootBundle = this.getFollowingRootBundle(rootBundle);
            if (!this.isRootBundleValid(rootBundle, nextRootBundle ? nextRootBundle.blockNumber : latestMainnetBlock)) {
                continue;
            }
            var bundleEvalBlockNumber = this.getBundleEndBlockForChain(rootBundle, chain, chainIdList);
            if (bundleEvalBlockNumber <= block) {
                if (bundleEvalBlockNumber === block) {
                    endingBlockNumber = bundleEvalBlockNumber;
                }
                break;
            }
            endingBlockNumber = bundleEvalBlockNumber;
        }
        return endingBlockNumber;
    };
    HubPoolClient.prototype.getProposedRootBundlesInBlockRange = function (startingBlock, endingBlock) {
        return this.proposedRootBundles.filter(function (bundle) { return bundle.blockNumber >= startingBlock && bundle.blockNumber <= endingBlock; });
    };
    HubPoolClient.prototype.getCancelledRootBundlesInBlockRange = function (startingBlock, endingBlock) {
        return (0, utils_1.sortEventsDescending)(this.canceledRootBundles).filter(function (bundle) { return bundle.blockNumber >= startingBlock && bundle.blockNumber <= endingBlock; });
    };
    HubPoolClient.prototype.getDisputedRootBundlesInBlockRange = function (startingBlock, endingBlock) {
        return (0, utils_1.sortEventsDescending)(this.disputedRootBundles).filter(function (bundle) { return bundle.blockNumber >= startingBlock && bundle.blockNumber <= endingBlock; });
    };
    HubPoolClient.prototype.getLatestProposedRootBundle = function () {
        return this.proposedRootBundles[this.proposedRootBundles.length - 1];
    };
    HubPoolClient.prototype.getFollowingRootBundle = function (currentRootBundle) {
        var index = lodash_1.default.findLastIndex(this.proposedRootBundles, function (bundle) { return bundle.blockNumber === currentRootBundle.blockNumber; });
        if (index === -1 || index === this.proposedRootBundles.length - 1) {
            return undefined;
        }
        return this.proposedRootBundles[index + 1];
    };
    HubPoolClient.prototype.getExecutedLeavesForRootBundle = function (rootBundle, latestMainnetBlockToSearch) {
        return this.executedRootBundles.filter(function (executedLeaf) {
            return executedLeaf.blockNumber <= latestMainnetBlockToSearch &&
                executedLeaf.blockNumber > rootBundle.blockNumber;
        });
    };
    HubPoolClient.prototype.getValidatedRootBundles = function (latestMainnetBlock) {
        var _this = this;
        if (latestMainnetBlock === void 0) { latestMainnetBlock = Number.MAX_SAFE_INTEGER; }
        return this.proposedRootBundles.filter(function (rootBundle) {
            if (rootBundle.blockNumber > latestMainnetBlock) {
                return false;
            }
            return _this.isRootBundleValid(rootBundle, latestMainnetBlock);
        });
    };
    HubPoolClient.prototype.getLatestFullyExecutedRootBundle = function (latestMainnetBlock) {
        var _this = this;
        return lodash_1.default.findLast(this.proposedRootBundles, function (rootBundle) {
            if (rootBundle.blockNumber > latestMainnetBlock) {
                return false;
            }
            return _this.isRootBundleValid(rootBundle, latestMainnetBlock);
        });
    };
    HubPoolClient.prototype.getEarliestFullyExecutedRootBundle = function (latestMainnetBlock, startBlock) {
        var _this = this;
        if (startBlock === void 0) { startBlock = 0; }
        return this.proposedRootBundles.find(function (rootBundle) {
            if (rootBundle.blockNumber > latestMainnetBlock) {
                return false;
            }
            if (rootBundle.blockNumber < startBlock) {
                return false;
            }
            return _this.isRootBundleValid(rootBundle, latestMainnetBlock);
        });
    };
    HubPoolClient.prototype.getNthFullyExecutedRootBundle = function (n, startBlock) {
        if (n === 0) {
            throw new Error("n cannot be 0");
        }
        if (!this.latestBlockSearched) {
            throw new Error("HubPoolClient::getNthFullyExecutedRootBundle client not updated");
        }
        var bundleToReturn;
        if (n < 0) {
            var nextLatestMainnetBlock = startBlock !== null && startBlock !== void 0 ? startBlock : this.latestBlockSearched;
            for (var i = 0; i < Math.abs(n); i++) {
                bundleToReturn = this.getLatestFullyExecutedRootBundle(nextLatestMainnetBlock);
                var bundleBlockNumber = bundleToReturn ? bundleToReturn.blockNumber : 0;
                nextLatestMainnetBlock = Math.max(0, bundleBlockNumber - 1);
            }
        }
        else {
            var nextStartBlock = startBlock !== null && startBlock !== void 0 ? startBlock : 0;
            for (var i = 0; i < n; i++) {
                bundleToReturn = this.getEarliestFullyExecutedRootBundle(this.latestBlockSearched, nextStartBlock);
                var bundleBlockNumber = bundleToReturn ? bundleToReturn.blockNumber : 0;
                nextStartBlock = Math.min(bundleBlockNumber + 1, this.latestBlockSearched);
            }
        }
        return bundleToReturn;
    };
    HubPoolClient.prototype.getLatestBundleEndBlockForChain = function (chainIdList, latestMainnetBlock, chainId) {
        var latestFullyExecutedPoolRebalanceRoot = this.getLatestFullyExecutedRootBundle(latestMainnetBlock);
        if (!latestFullyExecutedPoolRebalanceRoot) {
            return 0;
        }
        return this.getBundleEndBlockForChain(latestFullyExecutedPoolRebalanceRoot, chainId, chainIdList);
    };
    HubPoolClient.prototype.getNextBundleStartBlockNumber = function (chainIdList, latestMainnetBlock, chainId) {
        var endBlock = this.getLatestBundleEndBlockForChain(chainIdList, latestMainnetBlock, chainId);
        return endBlock > 0 ? endBlock + 1 : 0;
    };
    HubPoolClient.prototype.getRunningBalanceBeforeBlockForChain = function (block, chain, l1Token) {
        var executedRootBundle = (0, utils_1.sortEventsDescending)(this.executedRootBundles).find(function (executedLeaf) {
            return (executedLeaf.blockNumber <= block &&
                executedLeaf.chainId === chain &&
                executedLeaf.l1Tokens.map(function (l1Token) { return l1Token.toLowerCase(); }).includes(l1Token.toLowerCase()));
        });
        return this.getRunningBalanceForToken(l1Token, executedRootBundle);
    };
    HubPoolClient.prototype.getRunningBalanceForToken = function (l1Token, executedRootBundle) {
        var runningBalance = (0, utils_1.toBN)(0);
        var incentiveBalance = (0, utils_1.toBN)(0);
        if (executedRootBundle) {
            var indexOfL1Token = executedRootBundle.l1Tokens
                .map(function (l1Token) { return l1Token.toLowerCase(); })
                .indexOf(l1Token.toLowerCase());
            runningBalance = executedRootBundle.runningBalances[indexOfL1Token];
            incentiveBalance = executedRootBundle.incentiveBalances[indexOfL1Token];
        }
        return { runningBalance: runningBalance, incentiveBalance: incentiveBalance };
    };
    HubPoolClient.prototype._update = function (eventNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var hubPoolEvents, searchConfig, _a, timerStart, _b, currentTime, pendingRootBundleProposal, events, _events;
            var _c;
            var _this = this;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        hubPoolEvents = this.hubPoolEventFilters();
                        _c = {
                            fromBlock: this.firstBlockToSearch
                        };
                        _a = this.eventSearchConfig.toBlock;
                        if (_a) return [3, 2];
                        return [4, this.hubPool.provider.getBlockNumber()];
                    case 1:
                        _a = (_d.sent());
                        _d.label = 2;
                    case 2:
                        searchConfig = (_c.toBlock = _a,
                            _c.maxBlockLookBack = this.eventSearchConfig.maxBlockLookBack,
                            _c);
                        if (searchConfig.fromBlock > searchConfig.toBlock) {
                            this.logger.warn({ at: "HubPoolClient#_update", message: "Invalid update() searchConfig.", searchConfig: searchConfig });
                            return [2, { success: false }];
                        }
                        this.logger.debug({
                            at: "HubPoolClient",
                            message: "Updating HubPool client",
                            searchConfig: searchConfig,
                            eventNames: eventNames,
                        });
                        timerStart = Date.now();
                        return [4, Promise.all(tslib_1.__spreadArray([
                                this.hubPool.getCurrentTime({ blockTag: searchConfig.toBlock }),
                                this.hubPool.rootBundleProposal({ blockTag: searchConfig.toBlock })
                            ], eventNames.map(function (eventName) { return (0, utils_1.paginatedEventQuery)(_this.hubPool, hubPoolEvents[eventName], searchConfig); }), true))];
                    case 3:
                        _b = _d.sent(), currentTime = _b[0], pendingRootBundleProposal = _b[1], events = _b.slice(2);
                        this.logger.debug({
                            at: "HubPoolClient#_update",
                            message: "Time to query new events from RPC for ".concat(this.chainId, ": ").concat(Date.now() - timerStart, " ms"),
                        });
                        _events = Object.fromEntries(eventNames.map(function (eventName, idx) { return [eventName, events[idx]]; }));
                        return [2, {
                                success: true,
                                currentTime: currentTime,
                                pendingRootBundleProposal: pendingRootBundleProposal,
                                searchEndBlock: searchConfig.toBlock,
                                events: _events,
                            }];
                }
            });
        });
    };
    HubPoolClient.prototype.update = function (eventsToQuery) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var update, events, currentTime, pendingRootBundleProposal, searchEndBlock, _i, _a, event_1, args, _b, _c, event_2, args, uniqueL1Tokens, _d, tokenInfo, lpTokenInfo, _loop_1, this_1, _e, tokenInfo_1, info, _f, _g, event_3, executedRootBundle, l1Tokens, runningBalances, nTokens, mostRecentProposedRootBundle;
            var _h, _j, _k;
            var _this = this;
            return tslib_1.__generator(this, function (_l) {
                switch (_l.label) {
                    case 0:
                        if (!this.configStoreClient.isUpdated) {
                            throw new Error("ConfigStoreClient not updated");
                        }
                        eventsToQuery = eventsToQuery !== null && eventsToQuery !== void 0 ? eventsToQuery : Object.keys(this.hubPoolEventFilters());
                        return [4, this._update(eventsToQuery)];
                    case 1:
                        update = _l.sent();
                        if (!update.success) {
                            return [2];
                        }
                        events = update.events, currentTime = update.currentTime, pendingRootBundleProposal = update.pendingRootBundleProposal, searchEndBlock = update.searchEndBlock;
                        for (_i = 0, _a = events["CrossChainContractsSet"]; _i < _a.length; _i++) {
                            event_1 = _a[_i];
                            args = (0, utils_1.spreadEventWithBlockNumber)(event_1);
                            (0, utils_1.assign)(this.crossChainContracts, [args.l2ChainId], [
                                {
                                    spokePool: args.spokePool,
                                    blockNumber: args.blockNumber,
                                    transactionIndex: args.transactionIndex,
                                    logIndex: args.logIndex,
                                },
                            ]);
                        }
                        for (_b = 0, _c = events["SetPoolRebalanceRoute"]; _b < _c.length; _b++) {
                            event_2 = _c[_b];
                            args = (0, utils_1.spreadEventWithBlockNumber)(event_2);
                            (0, utils_1.assign)(this.l1TokensToDestinationTokens, [args.l1Token, args.destinationChainId], args.destinationToken);
                            (0, utils_1.assign)(this.l1TokensToDestinationTokensWithBlock, [args.l1Token, args.destinationChainId], [
                                {
                                    l1Token: args.l1Token,
                                    l2Token: args.destinationToken,
                                    blockNumber: args.blockNumber,
                                    transactionIndex: args.transactionIndex,
                                    logIndex: args.logIndex,
                                },
                            ]);
                        }
                        uniqueL1Tokens = tslib_1.__spreadArray([], Array.from(new Set(events["L1TokenEnabledForLiquidityProvision"].map(function (event) { return (0, utils_1.spreadEvent)(event.args).l1Token; }))), true);
                        return [4, Promise.all([
                                Promise.all(uniqueL1Tokens.map(function (l1Token) { return (0, utils_1.fetchTokenInfo)(l1Token, _this.hubPool.provider); })),
                                Promise.all(uniqueL1Tokens.map(function (l1Token) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4, this.hubPool.pooledTokens(l1Token, { blockTag: update.searchEndBlock })];
                                        case 1: return [2, _a.sent()];
                                    }
                                }); }); })),
                            ])];
                    case 2:
                        _d = _l.sent(), tokenInfo = _d[0], lpTokenInfo = _d[1];
                        _loop_1 = function (info) {
                            if (!this_1.l1Tokens.find(function (token) { return token.symbol === info.symbol; })) {
                                if (info.decimals > 0 && info.decimals <= 18) {
                                    this_1.l1Tokens.push(info);
                                }
                                else {
                                    throw new Error("Unsupported HubPool token: ".concat(JSON.stringify(info)));
                                }
                            }
                        };
                        this_1 = this;
                        for (_e = 0, tokenInfo_1 = tokenInfo; _e < tokenInfo_1.length; _e++) {
                            info = tokenInfo_1[_e];
                            _loop_1(info);
                        }
                        uniqueL1Tokens.forEach(function (token, i) {
                            _this.lpTokens[token] = { lastLpFeeUpdate: lpTokenInfo[i].lastLpFeeUpdate };
                        });
                        (_h = this.proposedRootBundles).push.apply(_h, events["ProposeRootBundle"]
                            .filter(function (event) { return !_this.configOverride.ignoredHubProposedBundles.includes(event.blockNumber); })
                            .map(function (event) {
                            return tslib_1.__assign(tslib_1.__assign({}, (0, utils_1.spreadEventWithBlockNumber)(event)), { transactionHash: event.transactionHash });
                        }));
                        (_j = this.canceledRootBundles).push.apply(_j, events["RootBundleCanceled"].map(function (event) { return (0, utils_1.spreadEventWithBlockNumber)(event); }));
                        (_k = this.disputedRootBundles).push.apply(_k, events["RootBundleDisputed"].map(function (event) { return (0, utils_1.spreadEventWithBlockNumber)(event); }));
                        for (_f = 0, _g = events["RootBundleExecuted"]; _f < _g.length; _f++) {
                            event_3 = _g[_f];
                            if (this.configOverride.ignoredHubExecutedBundles.includes(event_3.blockNumber)) {
                                continue;
                            }
                            executedRootBundle = (0, utils_1.spreadEventWithBlockNumber)(event_3);
                            l1Tokens = executedRootBundle.l1Tokens, runningBalances = executedRootBundle.runningBalances;
                            nTokens = l1Tokens.length;
                            if (![nTokens, nTokens * 2].includes(runningBalances.length)) {
                                throw new Error("Invalid runningBalances length: ".concat(runningBalances.length, ". Expected ").concat(nTokens, " or ").concat(nTokens * 2, " for chain ").concat(this.chainId, " transaction ").concat(event_3.transactionHash));
                            }
                            executedRootBundle.runningBalances = runningBalances.slice(0, nTokens);
                            executedRootBundle.incentiveBalances =
                                runningBalances.length > nTokens ? runningBalances.slice(nTokens) : runningBalances.map(function () { return (0, utils_1.toBN)(0); });
                            this.executedRootBundles.push(executedRootBundle);
                        }
                        if (pendingRootBundleProposal.unclaimedPoolRebalanceLeafCount > 0) {
                            mostRecentProposedRootBundle = this.proposedRootBundles[this.proposedRootBundles.length - 1];
                            this.pendingRootBundle = {
                                poolRebalanceRoot: pendingRootBundleProposal.poolRebalanceRoot,
                                relayerRefundRoot: pendingRootBundleProposal.relayerRefundRoot,
                                slowRelayRoot: pendingRootBundleProposal.slowRelayRoot,
                                proposer: pendingRootBundleProposal.proposer,
                                unclaimedPoolRebalanceLeafCount: pendingRootBundleProposal.unclaimedPoolRebalanceLeafCount,
                                challengePeriodEndTimestamp: pendingRootBundleProposal.challengePeriodEndTimestamp,
                                bundleEvaluationBlockNumbers: mostRecentProposedRootBundle.bundleEvaluationBlockNumbers.map(function (block) {
                                    try {
                                        return block.toNumber();
                                    }
                                    catch (_a) {
                                        return 0;
                                    }
                                }),
                                proposalBlockNumber: mostRecentProposedRootBundle.blockNumber,
                            };
                        }
                        else {
                            this.pendingRootBundle = undefined;
                        }
                        this.currentTime = currentTime;
                        this.latestBlockSearched = searchEndBlock;
                        this.firstBlockToSearch = update.searchEndBlock + 1;
                        this.eventSearchConfig.toBlock = undefined;
                        this.isUpdated = true;
                        this.logger.debug({ at: "HubPoolClient::update", message: "HubPool client updated!", searchEndBlock: searchEndBlock });
                        return [2];
                }
            });
        });
    };
    HubPoolClient.prototype.getBundleEndBlockForChain = function (proposeRootBundleEvent, chainId, chainIdList) {
        var bundleEvaluationBlockNumbers = proposeRootBundleEvent.bundleEvaluationBlockNumbers;
        var chainIdIndex = chainIdList.indexOf(chainId);
        if (chainIdIndex === -1) {
            return 0;
        }
        if (chainIdIndex >= bundleEvaluationBlockNumbers.length) {
            return 0;
        }
        return bundleEvaluationBlockNumbers[chainIdIndex].toNumber();
    };
    return HubPoolClient;
}(BaseAbstractClient_1.BaseAbstractClient));
exports.HubPoolClient = HubPoolClient;
//# sourceMappingURL=HubPoolClient.js.map