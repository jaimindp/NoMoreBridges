"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpokePoolClient = void 0;
var tslib_1 = require("tslib");
var ethers_1 = require("ethers");
var lodash_1 = require("lodash");
var utils_1 = require("../utils");
var EventUtils_1 = require("../utils/EventUtils");
var FlowUtils_1 = require("../utils/FlowUtils");
var constants_1 = require("../constants");
var NetworkUtils_1 = require("../utils/NetworkUtils");
var SpokeUtils_1 = require("../utils/SpokeUtils");
var BaseAbstractClient_1 = require("./BaseAbstractClient");
var SpokePoolClient = (function (_super) {
    tslib_1.__extends(SpokePoolClient, _super);
    function SpokePoolClient(logger, spokePool, hubPoolClient, chainId, deploymentBlock, eventSearchConfig) {
        if (eventSearchConfig === void 0) { eventSearchConfig = { fromBlock: 0, maxBlockLookBack: 0 }; }
        var _this = _super.call(this) || this;
        _this.logger = logger;
        _this.spokePool = spokePool;
        _this.hubPoolClient = hubPoolClient;
        _this.chainId = chainId;
        _this.deploymentBlock = deploymentBlock;
        _this.eventSearchConfig = eventSearchConfig;
        _this.currentTime = 0;
        _this.oldestTime = 0;
        _this.depositHashes = {};
        _this.depositHashesToFills = {};
        _this.speedUps = {};
        _this.slowFillRequests = {};
        _this.depositRoutes = {};
        _this.tokensBridged = [];
        _this.rootBundleRelays = [];
        _this.relayerRefundExecutions = [];
        _this.earlyDeposits = [];
        _this.queryableEventNames = [];
        _this.earliestDepositIdQueried = Number.MAX_SAFE_INTEGER;
        _this.latestDepositIdQueried = 0;
        _this.firstDepositIdForSpokePool = Number.MAX_SAFE_INTEGER;
        _this.lastDepositIdForSpokePool = Number.MAX_SAFE_INTEGER;
        _this.fills = {};
        _this.firstBlockToSearch = eventSearchConfig.fromBlock;
        _this.latestBlockSearched = 0;
        _this.queryableEventNames = Object.keys(_this._queryableEventNames());
        return _this;
    }
    SpokePoolClient.prototype._queryableEventNames = function () {
        var _this = this;
        var knownEventNames = [
            "FundsDeposited",
            "RequestedSpeedUpDeposit",
            "FilledRelay",
            "EnabledDepositRoute",
            "TokensBridged",
            "RelayedRootBundle",
            "ExecutedRelayerRefundRoot",
            "V3FundsDeposited",
            "RequestedSpeedUpV3Deposit",
            "RequestedV3SlowFill",
            "FilledV3Relay",
        ];
        return Object.fromEntries(this.spokePool.interface.fragments
            .filter(function (_a) {
            var name = _a.name, type = _a.type;
            return type === "event" && knownEventNames.includes(name);
        })
            .map(function (_a) {
            var name = _a.name;
            return [name, _this.spokePool.filters[name]()];
        }));
    };
    SpokePoolClient.prototype.getDepositsForDestinationChain = function (destinationChainId) {
        return Object.values(this.depositHashes).filter(function (deposit) { return deposit.destinationChainId === destinationChainId; });
    };
    SpokePoolClient.prototype.getDeposits = function (filter) {
        var deposits = Object.values(this.depositHashes);
        if ((0, utils_1.isDefined)(filter)) {
            var fromBlock_1 = filter.fromBlock, toBlock_1 = filter.toBlock;
            deposits = deposits.filter(function (_a) {
                var blockNumber = _a.blockNumber;
                return blockNumber >= fromBlock_1 && toBlock_1 >= blockNumber;
            });
        }
        return (0, EventUtils_1.sortEventsAscendingInPlace)(deposits);
    };
    SpokePoolClient.prototype.getTokensBridged = function () {
        return this.tokensBridged;
    };
    SpokePoolClient.prototype.getDepositRoutes = function () {
        return this.depositRoutes;
    };
    SpokePoolClient.prototype.isDepositRouteEnabled = function (originToken, destinationChainId) {
        var _a, _b;
        return (_b = (_a = this.depositRoutes[originToken]) === null || _a === void 0 ? void 0 : _a[destinationChainId]) !== null && _b !== void 0 ? _b : false;
    };
    SpokePoolClient.prototype.getAllOriginTokens = function () {
        return Object.keys(this.depositRoutes);
    };
    SpokePoolClient.prototype.getFills = function () {
        return (0, EventUtils_1.sortEventsAscendingInPlace)(Object.values(this.fills).flat());
    };
    SpokePoolClient.prototype.getFillsForOriginChain = function (originChainId) {
        return this.fills[originChainId] || [];
    };
    SpokePoolClient.prototype.getFillsForRelayer = function (relayer) {
        return this.getFills().filter(function (fill) { return fill.relayer === relayer; });
    };
    SpokePoolClient.prototype.getFillsWithBlockInRange = function (startingBlock, endingBlock) {
        return this.getFills().filter(function (fill) { return fill.blockNumber >= startingBlock && fill.blockNumber <= endingBlock; });
    };
    SpokePoolClient.prototype.getRootBundleRelays = function () {
        return this.rootBundleRelays;
    };
    SpokePoolClient.prototype.getLatestRootBundleId = function () {
        var _a;
        return this.rootBundleRelays.length > 0
            ? ((_a = this.rootBundleRelays[this.rootBundleRelays.length - 1]) === null || _a === void 0 ? void 0 : _a.rootBundleId) + 1
            : 0;
    };
    SpokePoolClient.prototype.getRelayerRefundExecutions = function () {
        return this.relayerRefundExecutions;
    };
    SpokePoolClient.prototype.getExecutedRefunds = function (relayerRefundRoot) {
        var bundle = this.getRootBundleRelays().find(function (bundle) { return bundle.relayerRefundRoot === relayerRefundRoot; });
        if (bundle === undefined) {
            return {};
        }
        var executedRefundLeaves = this.getRelayerRefundExecutions().filter(function (leaf) { return leaf.rootBundleId === bundle.rootBundleId; });
        var executedRefunds = {};
        for (var _i = 0, executedRefundLeaves_1 = executedRefundLeaves; _i < executedRefundLeaves_1.length; _i++) {
            var refundLeaf = executedRefundLeaves_1[_i];
            var tokenAddress = refundLeaf.l2TokenAddress;
            if (executedRefunds[tokenAddress] === undefined) {
                executedRefunds[tokenAddress] = {};
            }
            var executedTokenRefunds = executedRefunds[tokenAddress];
            for (var i = 0; i < refundLeaf.refundAddresses.length; i++) {
                var relayer = refundLeaf.refundAddresses[i];
                var refundAmount = refundLeaf.refundAmounts[i];
                if (executedTokenRefunds[relayer] === undefined) {
                    executedTokenRefunds[relayer] = ethers_1.ethers.constants.Zero;
                }
                executedTokenRefunds[relayer] = executedTokenRefunds[relayer].add(refundAmount);
            }
        }
        return executedRefunds;
    };
    SpokePoolClient.prototype.appendMaxSpeedUpSignatureToDeposit = function (deposit) {
        var _a;
        var depositId = deposit.depositId, depositor = deposit.depositor;
        var depositorSpeedUps = (_a = this.speedUps[depositor]) === null || _a === void 0 ? void 0 : _a[depositId];
        if (!(0, utils_1.isDefined)(depositorSpeedUps)) {
            return deposit;
        }
        if ((0, utils_1.isV2Deposit)(deposit)) {
            var v2SpeedUps = depositorSpeedUps.filter((utils_1.isV2SpeedUp));
            if (v2SpeedUps.length === 0) {
                return deposit;
            }
            var maxSpeedUp_1 = v2SpeedUps.reduce(function (prev, current) {
                return prev.newRelayerFeePct.gt(current.newRelayerFeePct) ? prev : current;
            });
            if (!maxSpeedUp_1 || maxSpeedUp_1.newRelayerFeePct.lte(deposit.relayerFeePct)) {
                return deposit;
            }
            var updatedDeposit_1 = tslib_1.__assign(tslib_1.__assign({}, deposit), { speedUpSignature: maxSpeedUp_1.depositorSignature, newRelayerFeePct: maxSpeedUp_1.newRelayerFeePct, updatedRecipient: maxSpeedUp_1.updatedRecipient, updatedMessage: maxSpeedUp_1.updatedMessage });
            return updatedDeposit_1;
        }
        var v3SpeedUps = depositorSpeedUps.filter((utils_1.isV3SpeedUp));
        if (v3SpeedUps.length === 0) {
            return deposit;
        }
        var maxSpeedUp = v3SpeedUps.reduce(function (prev, current) {
            return prev.updatedOutputAmount.lt(current.updatedOutputAmount) ? prev : current;
        });
        if (maxSpeedUp.updatedOutputAmount.gte(deposit.outputAmount)) {
            return deposit;
        }
        var updatedDeposit = tslib_1.__assign(tslib_1.__assign({}, deposit), { speedUpSignature: maxSpeedUp.depositorSignature, updatedOutputAmount: maxSpeedUp.updatedOutputAmount, updatedRecipient: maxSpeedUp.updatedRecipient, updatedMessage: maxSpeedUp.updatedMessage });
        return updatedDeposit;
    };
    SpokePoolClient.prototype.getDeposit = function (depositId) {
        var depositHash = this.getDepositHash({ depositId: depositId, originChainId: this.chainId });
        return this.depositHashes[depositHash];
    };
    SpokePoolClient.prototype.getSlowFillRequest = function (relayData) {
        var hash = (0, utils_1.getRelayDataHash)(relayData, this.chainId);
        return this.slowFillRequests[hash];
    };
    SpokePoolClient.prototype.getSlowFillRequestsForOriginChain = function (originChainId) {
        return Object.values(this.slowFillRequests).filter(function (e) { return e.originChainId === originChainId; });
    };
    SpokePoolClient.prototype.getDepositForFill = function (fill, fillFieldsToIgnore) {
        if (fillFieldsToIgnore === void 0) { fillFieldsToIgnore = []; }
        var depositWithMatchingDepositId = this.depositHashes[this.getDepositHash(fill)];
        return (0, FlowUtils_1.validateFillForDeposit)(fill, depositWithMatchingDepositId, fillFieldsToIgnore)
            ? depositWithMatchingDepositId
            : undefined;
    };
    SpokePoolClient.prototype.updateDepositRealizedLpFeePct = function (event, realizedLpFeePct) {
        this.depositHashes[this.getDepositHash(event)] = tslib_1.__assign(tslib_1.__assign({}, this.depositHashes[this.getDepositHash(event)]), { realizedLpFeePct: realizedLpFeePct });
    };
    SpokePoolClient.prototype.getValidUnfilledAmountForDeposit = function (deposit) {
        var outputAmount = (0, utils_1.getDepositOutputAmount)(deposit);
        var fillsForDeposit = this.depositHashesToFills[this.getDepositHash(deposit)];
        if (fillsForDeposit === undefined || fillsForDeposit.length === 0) {
            return { unfilledAmount: (0, utils_1.toBN)(outputAmount), fillCount: 0, invalidFills: [] };
        }
        var _a = fillsForDeposit.reduce(function (groupedFills, fill) {
            if ((0, FlowUtils_1.validateFillForDeposit)(fill, deposit)) {
                groupedFills.validFills.push(fill);
            }
            else {
                groupedFills.invalidFills.push(fill);
            }
            return groupedFills;
        }, { validFills: [], invalidFills: [] }), validFills = _a.validFills, invalidFills = _a.invalidFills;
        var invalidFillsForDeposit = invalidFills.filter(function (x) { return x.depositId === deposit.depositId; });
        if (invalidFillsForDeposit.length > 0) {
            this.logger.warn({
                at: "SpokePoolClient",
                chainId: this.chainId,
                message: "Invalid fills found matching deposit ID",
                deposit: deposit,
                invalidFills: Object.fromEntries(invalidFillsForDeposit.map(function (x) { return [x.relayer, x]; })),
                notificationPath: "across-invalid-fills",
            });
        }
        if (validFills.length === 0) {
            return { unfilledAmount: (0, utils_1.toBN)(outputAmount), fillCount: 0, invalidFills: invalidFills };
        }
        var fillsOrderedByTotalFilledAmount = validFills.sort(function (fillA, fillB) {
            var totalFilledA = (0, utils_1.getTotalFilledAmount)(fillA);
            var totalFilledB = (0, utils_1.getTotalFilledAmount)(fillB);
            return totalFilledB.gt(totalFilledA) ? 1 : totalFilledB.lt(totalFilledA) ? -1 : 0;
        });
        var lastFill = fillsOrderedByTotalFilledAmount[0];
        return {
            unfilledAmount: (0, utils_1.getFillOutputAmount)(lastFill).sub((0, utils_1.getTotalFilledAmount)(lastFill)),
            fillCount: validFills.length,
            invalidFills: invalidFills,
        };
    };
    SpokePoolClient.prototype.getDepositHash = function (event) {
        return "".concat(event.depositId, "-").concat(event.originChainId);
    };
    SpokePoolClient.prototype._getBlockRangeForDepositId = function (targetDepositId, initLow, initHigh, maxSearches) {
        return (0, SpokeUtils_1.getBlockRangeForDepositId)(targetDepositId, initLow, initHigh, maxSearches, this);
    };
    SpokePoolClient.prototype._getDepositIdAtBlock = function (blockTag) {
        return (0, SpokeUtils_1.getDepositIdAtBlock)(this.spokePool, blockTag);
    };
    SpokePoolClient.prototype.queryHistoricalMatchingFills = function (fill, deposit, toBlock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var searchConfig;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        searchConfig = {
                            fromBlock: this.deploymentBlock,
                            toBlock: toBlock,
                            maxBlockLookBack: this.eventSearchConfig.maxBlockLookBack,
                        };
                        return [4, this.queryFillsInBlockRange(fill, searchConfig)];
                    case 1: return [2, (_a.sent()).filter(function (_fill) {
                            return (0, FlowUtils_1.validateFillForDeposit)(_fill, deposit);
                        })];
                }
            });
        });
    };
    SpokePoolClient.prototype.queryFillsInBlockRange = function (matchingFill, searchConfig) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, fills;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, (0, EventUtils_1.paginatedEventQuery)(this.spokePool, this.spokePool.filters.FilledRelay(undefined, undefined, undefined, undefined, matchingFill.originChainId, undefined, undefined, undefined, matchingFill.depositId, undefined, undefined, matchingFill.depositor, undefined, undefined, undefined), searchConfig)];
                    case 1:
                        query = _a.sent();
                        fills = query.map(function (event) { return (0, EventUtils_1.spreadEventWithBlockNumber)(event); });
                        return [2, (0, EventUtils_1.sortEventsAscending)(fills.filter(function (_fill) { return (0, FlowUtils_1.filledSameDeposit)(_fill, matchingFill); }))];
                }
            });
        });
    };
    SpokePoolClient.prototype.getMaxFillDeadlineInRange = function (startBlock, endBlock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var fillDeadlineBuffers;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, Promise.all([
                            this.spokePool.fillDeadlineBuffer({ blockTag: startBlock }),
                            this.spokePool.fillDeadlineBuffer({ blockTag: endBlock }),
                        ])];
                    case 1:
                        fillDeadlineBuffers = _a.sent();
                        return [2, Math.max(fillDeadlineBuffers[0], fillDeadlineBuffers[1])];
                }
            });
        });
    };
    SpokePoolClient.prototype._update = function (eventsToQuery) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var firstDepositId, searchConfig, _a, eventSearchConfigs, timerStart, _b, numberOfDeposits, currentTime, oldestTime, events, errMsg;
            var _c;
            var _this = this;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        firstDepositId = this.firstDepositIdForSpokePool;
                        if (!(firstDepositId === Number.MAX_SAFE_INTEGER)) return [3, 2];
                        return [4, this.spokePool.numberOfDeposits({ blockTag: this.deploymentBlock })];
                    case 1:
                        firstDepositId = _d.sent();
                        if (isNaN(firstDepositId) || firstDepositId < 0) {
                            throw new Error("SpokePoolClient::update: Invalid first deposit id (".concat(firstDepositId, ")"));
                        }
                        _d.label = 2;
                    case 2:
                        _c = {
                            fromBlock: this.firstBlockToSearch
                        };
                        _a = this.eventSearchConfig.toBlock;
                        if (_a) return [3, 4];
                        return [4, this.spokePool.provider.getBlockNumber()];
                    case 3:
                        _a = (_d.sent());
                        _d.label = 4;
                    case 4:
                        searchConfig = (_c.toBlock = _a,
                            _c.maxBlockLookBack = this.eventSearchConfig.maxBlockLookBack,
                            _c);
                        if (searchConfig.fromBlock > searchConfig.toBlock) {
                            this.log("warn", "Invalid update() searchConfig.", { searchConfig: searchConfig });
                            return [2, { success: false }];
                        }
                        eventSearchConfigs = eventsToQuery.map(function (eventName) {
                            if (!_this.queryableEventNames.includes(eventName)) {
                                throw new Error("SpokePoolClient: Cannot query unrecognised SpokePool event name: ".concat(eventName));
                            }
                            var _searchConfig = tslib_1.__assign({}, searchConfig);
                            if (eventName === "EnabledDepositRoute" && !_this.isUpdated) {
                                _searchConfig.fromBlock = _this.deploymentBlock;
                            }
                            return {
                                filter: _this._queryableEventNames()[eventName],
                                searchConfig: _searchConfig,
                            };
                        });
                        this.log("debug", "Updating SpokePool client for chain ".concat(this.chainId), {
                            eventsToQuery: eventsToQuery,
                            searchConfig: searchConfig,
                            spokePool: this.spokePool.address,
                        });
                        timerStart = Date.now();
                        return [4, Promise.all(tslib_1.__spreadArray([
                                this.spokePool.numberOfDeposits({ blockTag: searchConfig.toBlock }),
                                this.spokePool.getCurrentTime({ blockTag: searchConfig.toBlock }),
                                this.spokePool.getCurrentTime({ blockTag: Math.max(searchConfig.fromBlock, this.deploymentBlock) })
                            ], eventSearchConfigs.map(function (config) { return (0, EventUtils_1.paginatedEventQuery)(_this.spokePool, config.filter, config.searchConfig); }), true))];
                    case 5:
                        _b = _d.sent(), numberOfDeposits = _b[0], currentTime = _b[1], oldestTime = _b[2], events = _b.slice(3);
                        this.log("debug", "Time to query new events from RPC for ".concat(this.chainId, ": ").concat(Date.now() - timerStart, " ms"));
                        if (!ethers_1.BigNumber.isBigNumber(currentTime) || currentTime.lt(this.currentTime)) {
                            errMsg = ethers_1.BigNumber.isBigNumber(currentTime)
                                ? "currentTime: ".concat(currentTime, " < ").concat((0, utils_1.toBN)(this.currentTime))
                                : "currentTime is not a BigNumber: ".concat(JSON.stringify(currentTime));
                            throw new Error("SpokePoolClient::update: ".concat(errMsg));
                        }
                        events.forEach(function (events) { return (0, EventUtils_1.sortEventsAscendingInPlace)(events); });
                        return [2, {
                                success: true,
                                currentTime: currentTime.toNumber(),
                                oldestTime: oldestTime.toNumber(),
                                firstDepositId: firstDepositId,
                                latestDepositId: Math.max(numberOfDeposits - 1, 0),
                                searchEndBlock: searchConfig.toBlock,
                                events: events,
                            }];
                }
            });
        });
    };
    SpokePoolClient.prototype._isEarlyDeposit = function (depositEvent, currentTime) {
        return depositEvent.args.quoteTimestamp > currentTime;
    };
    SpokePoolClient.prototype.isV3DepositEvent = function (event) {
        return (0, utils_1.isDefined)(event.args.inputToken);
    };
    SpokePoolClient.prototype.isV3FillEvent = function (event) {
        return (0, utils_1.isDefined)(event.args.inputToken);
    };
    SpokePoolClient.prototype.update = function (eventsToQuery) {
        var _a, _b, _c, _d, _e, _f;
        if (eventsToQuery === void 0) { eventsToQuery = this.queryableEventNames; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var update, queryResults, currentTime, oldestTime, searchEndBlock, _i, _g, event_1, _h, _j, earlyDeposits, _k, v2DepositEvents, depositEvents, dataForQuoteTime, _l, _m, _o, index, event_2, rawDeposit, deposit, _p, quoteBlockNumber, realizedLpFeePct, speedUpEvents, _q, speedUpEvents_1, event_3, speedUp, depositHash, depositDataAssociatedWithSpeedUp, slowFillRequests, _r, slowFillRequests_1, event_4, slowFillRequest, relayDataHash, fillEvents, _s, fillEvents_1, event_5, fill, enableDepositsEvents, _t, enableDepositsEvents_1, event_6, enableDeposit, relayedRootBundleEvents, _u, relayedRootBundleEvents_1, event_7, refundEvents, _v, refundEvents_1, event_8, executedRefund;
            var _this = this;
            return tslib_1.__generator(this, function (_w) {
                switch (_w.label) {
                    case 0:
                        if (this.hubPoolClient !== null && !this.hubPoolClient.isUpdated) {
                            throw new Error("HubPoolClient not updated");
                        }
                        return [4, this._update(eventsToQuery)];
                    case 1:
                        update = _w.sent();
                        if (!update.success) {
                            return [2];
                        }
                        queryResults = update.events, currentTime = update.currentTime, oldestTime = update.oldestTime, searchEndBlock = update.searchEndBlock;
                        if (eventsToQuery.includes("TokensBridged")) {
                            for (_i = 0, _g = queryResults[eventsToQuery.indexOf("TokensBridged")]; _i < _g.length; _i++) {
                                event_1 = _g[_i];
                                this.tokensBridged.push((0, EventUtils_1.spreadEventWithBlockNumber)(event_1));
                            }
                        }
                        if (!(eventsToQuery.includes("FundsDeposited") || eventsToQuery.includes("V3FundsDeposited"))) return [3, 3];
                        _h = (0, lodash_1.groupBy)(tslib_1.__spreadArray(tslib_1.__spreadArray([], this.earlyDeposits, true), ((_a = queryResults[eventsToQuery.indexOf("FundsDeposited")]) !== null && _a !== void 0 ? _a : []), true), function (depositEvent) { return (_this._isEarlyDeposit(depositEvent, currentTime) ? "earlyDeposits" : "v2DepositEvents"); }), _j = _h.earlyDeposits, earlyDeposits = _j === void 0 ? [] : _j, _k = _h.v2DepositEvents, v2DepositEvents = _k === void 0 ? [] : _k;
                        if (earlyDeposits.length > 0) {
                            this.logger.debug({
                                at: "SpokePoolClient#update",
                                message: "Deferring ".concat(earlyDeposits.length, " early v2 deposit events."),
                                currentTime: currentTime,
                                deposits: earlyDeposits.map(function (_a) {
                                    var args = _a.args, transactionHash = _a.transactionHash;
                                    return ({ depositId: args.depositId, transactionHash: transactionHash });
                                }),
                            });
                        }
                        this.earlyDeposits = earlyDeposits;
                        depositEvents = tslib_1.__spreadArray(tslib_1.__spreadArray([], v2DepositEvents, true), ((_b = queryResults[eventsToQuery.indexOf("V3FundsDeposited")]) !== null && _b !== void 0 ? _b : []), true);
                        if (depositEvents.length > 0) {
                            this.log("debug", "Using ".concat(depositEvents.length, " newly queried deposit events for chain ").concat(this.chainId), {
                                earliestEvent: depositEvents[0].blockNumber,
                            });
                        }
                        return [4, this.batchComputeRealizedLpFeePct(depositEvents)];
                    case 2:
                        dataForQuoteTime = _w.sent();
                        for (_l = 0, _m = Array.from(depositEvents.entries()); _l < _m.length; _l++) {
                            _o = _m[_l], index = _o[0], event_2 = _o[1];
                            rawDeposit = (0, EventUtils_1.spreadEventWithBlockNumber)(event_2);
                            deposit = void 0;
                            _p = dataForQuoteTime[index], quoteBlockNumber = _p.quoteBlock, realizedLpFeePct = _p.realizedLpFeePct;
                            if (this.isV3DepositEvent(event_2)) {
                                deposit = tslib_1.__assign(tslib_1.__assign({}, rawDeposit), { originChainId: this.chainId });
                                deposit.realizedLpFeePct = undefined;
                                deposit.quoteBlockNumber = quoteBlockNumber;
                                if (deposit.outputToken === constants_1.ZERO_ADDRESS) {
                                    deposit.outputToken = this.getDestinationTokenForDeposit(deposit);
                                }
                            }
                            else {
                                deposit = tslib_1.__assign({}, rawDeposit);
                                deposit.realizedLpFeePct = realizedLpFeePct;
                                deposit.quoteBlockNumber = quoteBlockNumber;
                                deposit.destinationToken = this.getDestinationTokenForDeposit(deposit);
                            }
                            if (this.depositHashes[this.getDepositHash(deposit)] !== undefined) {
                                continue;
                            }
                            (0, utils_1.assign)(this.depositHashes, [this.getDepositHash(deposit)], deposit);
                            if (deposit.depositId < this.earliestDepositIdQueried) {
                                this.earliestDepositIdQueried = deposit.depositId;
                            }
                            if (deposit.depositId > this.latestDepositIdQueried) {
                                this.latestDepositIdQueried = deposit.depositId;
                            }
                        }
                        _w.label = 3;
                    case 3:
                        if (eventsToQuery.includes("RequestedSpeedUpDeposit") || eventsToQuery.includes("RequestedSpeedUpV3Deposit")) {
                            speedUpEvents = tslib_1.__spreadArray(tslib_1.__spreadArray([], ((_c = queryResults[eventsToQuery.indexOf("RequestedSpeedUpDeposit")]) !== null && _c !== void 0 ? _c : []), true), ((_d = queryResults[eventsToQuery.indexOf("RequestedSpeedUpV3Deposit")]) !== null && _d !== void 0 ? _d : []), true);
                            for (_q = 0, speedUpEvents_1 = speedUpEvents; _q < speedUpEvents_1.length; _q++) {
                                event_3 = speedUpEvents_1[_q];
                                speedUp = tslib_1.__assign(tslib_1.__assign({}, (0, EventUtils_1.spreadEvent)(event_3.args)), { originChainId: this.chainId });
                                (0, utils_1.assign)(this.speedUps, [speedUp.depositor, speedUp.depositId], [speedUp]);
                                depositHash = this.getDepositHash(speedUp);
                                depositDataAssociatedWithSpeedUp = this.depositHashes[depositHash];
                                if ((0, utils_1.isDefined)(depositDataAssociatedWithSpeedUp)) {
                                    this.depositHashes[depositHash] = this.appendMaxSpeedUpSignatureToDeposit(depositDataAssociatedWithSpeedUp);
                                }
                            }
                        }
                        if (eventsToQuery.includes("RequestedV3SlowFill")) {
                            slowFillRequests = queryResults[eventsToQuery.indexOf("RequestedV3SlowFill")];
                            for (_r = 0, slowFillRequests_1 = slowFillRequests; _r < slowFillRequests_1.length; _r++) {
                                event_4 = slowFillRequests_1[_r];
                                slowFillRequest = tslib_1.__assign(tslib_1.__assign({}, (0, EventUtils_1.spreadEventWithBlockNumber)(event_4)), { destinationChainId: this.chainId });
                                relayDataHash = (0, utils_1.getRelayDataHash)(slowFillRequest, this.chainId);
                                if (this.slowFillRequests[relayDataHash] !== undefined) {
                                    continue;
                                }
                                this.slowFillRequests[relayDataHash] = slowFillRequest;
                            }
                        }
                        if (eventsToQuery.includes("FilledRelay") || eventsToQuery.includes("FilledV3Relay")) {
                            fillEvents = tslib_1.__spreadArray(tslib_1.__spreadArray([], ((_e = queryResults[eventsToQuery.indexOf("FilledRelay")]) !== null && _e !== void 0 ? _e : []), true), ((_f = queryResults[eventsToQuery.indexOf("FilledV3Relay")]) !== null && _f !== void 0 ? _f : []), true);
                            if (fillEvents.length > 0) {
                                this.log("debug", "Using ".concat(fillEvents.length, " newly queried fill events for chain ").concat(this.chainId), {
                                    earliestEvent: fillEvents[0].blockNumber,
                                });
                            }
                            for (_s = 0, fillEvents_1 = fillEvents; _s < fillEvents_1.length; _s++) {
                                event_5 = fillEvents_1[_s];
                                fill = this.isV3FillEvent(event_5)
                                    ? tslib_1.__assign(tslib_1.__assign({}, (0, EventUtils_1.spreadEventWithBlockNumber)(event_5)), { destinationChainId: this.chainId }) : tslib_1.__assign({}, (0, EventUtils_1.spreadEventWithBlockNumber)(event_5));
                                (0, utils_1.assign)(this.fills, [fill.originChainId], [fill]);
                                (0, utils_1.assign)(this.depositHashesToFills, [this.getDepositHash(fill)], [fill]);
                            }
                        }
                        if (eventsToQuery.includes("EnabledDepositRoute")) {
                            enableDepositsEvents = queryResults[eventsToQuery.indexOf("EnabledDepositRoute")];
                            for (_t = 0, enableDepositsEvents_1 = enableDepositsEvents; _t < enableDepositsEvents_1.length; _t++) {
                                event_6 = enableDepositsEvents_1[_t];
                                enableDeposit = (0, EventUtils_1.spreadEvent)(event_6.args);
                                (0, utils_1.assign)(this.depositRoutes, [enableDeposit.originToken, enableDeposit.destinationChainId], enableDeposit.enabled);
                            }
                        }
                        if (eventsToQuery.includes("RelayedRootBundle")) {
                            relayedRootBundleEvents = queryResults[eventsToQuery.indexOf("RelayedRootBundle")];
                            for (_u = 0, relayedRootBundleEvents_1 = relayedRootBundleEvents; _u < relayedRootBundleEvents_1.length; _u++) {
                                event_7 = relayedRootBundleEvents_1[_u];
                                this.rootBundleRelays.push((0, EventUtils_1.spreadEventWithBlockNumber)(event_7));
                            }
                        }
                        if (eventsToQuery.includes("ExecutedRelayerRefundRoot")) {
                            refundEvents = queryResults[eventsToQuery.indexOf("ExecutedRelayerRefundRoot")];
                            for (_v = 0, refundEvents_1 = refundEvents; _v < refundEvents_1.length; _v++) {
                                event_8 = refundEvents_1[_v];
                                executedRefund = (0, EventUtils_1.spreadEventWithBlockNumber)(event_8);
                                executedRefund.l2TokenAddress = SpokePoolClient.getExecutedRefundLeafL2Token(executedRefund.chainId, executedRefund.l2TokenAddress);
                                this.relayerRefundExecutions.push(executedRefund);
                            }
                        }
                        this.currentTime = currentTime;
                        if (this.oldestTime === 0)
                            this.oldestTime = oldestTime;
                        this.firstDepositIdForSpokePool = update.firstDepositId;
                        this.latestBlockSearched = searchEndBlock;
                        this.lastDepositIdForSpokePool = update.latestDepositId;
                        this.firstBlockToSearch = searchEndBlock + 1;
                        this.eventSearchConfig.toBlock = undefined;
                        this.isUpdated = true;
                        this.log("debug", "SpokePool client for chain ".concat(this.chainId, " updated!"), {
                            nextFirstBlockToSearch: this.firstBlockToSearch,
                        });
                        return [2];
                }
            });
        });
    };
    SpokePoolClient.getExecutedRefundLeafL2Token = function (chainId, eventL2Token) {
        if ((chainId === 10 || chainId === 8453) &&
            eventL2Token.toLowerCase() === "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000") {
            return "0x4200000000000000000000000000000000000006";
        }
        else if (chainId === 288 && eventL2Token.toLowerCase() === "0x4200000000000000000000000000000000000006") {
            return "0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000";
        }
        else {
            return eventL2Token;
        }
    };
    SpokePoolClient.prototype.computeRealizedLpFeePct = function (depositEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var lpFee;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.batchComputeRealizedLpFeePct([depositEvent])];
                    case 1:
                        lpFee = (_a.sent())[0];
                        return [2, lpFee];
                }
            });
        });
    };
    SpokePoolClient.prototype.batchComputeRealizedLpFeePct = function (depositEvents) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var realizedLpFeePct_1, quoteBlock_1, deposits, _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.hubPoolClient === null) {
                            realizedLpFeePct_1 = utils_1.bnZero;
                            quoteBlock_1 = utils_1.MAX_BIG_INT.toNumber();
                            return [2, depositEvents.map(function () {
                                    return { realizedLpFeePct: realizedLpFeePct_1, quoteBlock: quoteBlock_1 };
                                })];
                        }
                        deposits = depositEvents.map(function (event) {
                            var _a, _b;
                            var inputToken, inputAmount;
                            var _paymentChainId;
                            if (_this.isV3DepositEvent(event)) {
                                (_a = event.args, inputToken = _a.inputToken, inputAmount = _a.inputAmount);
                            }
                            else {
                                (_b = event.args, inputToken = _b.originToken, inputAmount = _b.amount);
                                _paymentChainId = Number(event.args.destinationChainId);
                            }
                            return {
                                inputToken: inputToken,
                                inputAmount: inputAmount,
                                originChainId: _this.chainId,
                                paymentChainId: _paymentChainId,
                                quoteTimestamp: event.args.quoteTimestamp,
                            };
                        });
                        if (!(deposits.length > 0)) return [3, 2];
                        return [4, this.hubPoolClient.batchComputeRealizedLpFeePct(deposits)];
                    case 1:
                        _a = _b.sent();
                        return [3, 3];
                    case 2:
                        _a = [];
                        _b.label = 3;
                    case 3: return [2, _a];
                }
            });
        });
    };
    SpokePoolClient.prototype.getDestinationTokenForDeposit = function (deposit) {
        if (!this.hubPoolClient) {
            return constants_1.ZERO_ADDRESS;
        }
        return this.hubPoolClient.getL2TokenForDeposit(deposit);
    };
    SpokePoolClient.prototype.log = function (level, message, data) {
        this.logger[level](tslib_1.__assign({ at: "SpokePoolClient", chainId: this.chainId, message: message }, data));
    };
    SpokePoolClient.prototype.getCurrentTime = function () {
        return this.currentTime;
    };
    SpokePoolClient.prototype.getOldestTime = function () {
        return this.oldestTime;
    };
    SpokePoolClient.prototype.findDeposit = function (depositId, destinationChainId, depositor) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var searchBounds, tStart, query, tStop, event, srcChain, dstChain, partialDeposit, _a, realizedLpFeePct, quoteBlockNumber, deposit;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4, this._getBlockRangeForDepositId(depositId, this.deploymentBlock, this.latestBlockSearched, 7)];
                    case 1:
                        searchBounds = _b.sent();
                        tStart = Date.now();
                        return [4, (0, EventUtils_1.paginatedEventQuery)(this.spokePool, this.spokePool.filters.FundsDeposited(null, null, destinationChainId, null, depositId, null, null, null, depositor, null), {
                                fromBlock: searchBounds.low,
                                toBlock: searchBounds.high,
                                maxBlockLookBack: this.eventSearchConfig.maxBlockLookBack,
                            })];
                    case 2:
                        query = _b.sent();
                        tStop = Date.now();
                        event = query.find(function (deposit) { return deposit.args.depositId === depositId; });
                        if (event === undefined) {
                            srcChain = (0, NetworkUtils_1.getNetworkName)(this.chainId);
                            dstChain = (0, NetworkUtils_1.getNetworkName)(destinationChainId);
                            throw new Error("Could not find deposit ".concat(depositId, " for ").concat(dstChain, " fill") +
                                " between ".concat(srcChain, " blocks [").concat(searchBounds.low, ", ").concat(searchBounds.high, "]"));
                        }
                        partialDeposit = (0, EventUtils_1.spreadEventWithBlockNumber)(event);
                        return [4, this.batchComputeRealizedLpFeePct([event])];
                    case 3:
                        _a = (_b.sent())[0], realizedLpFeePct = _a.realizedLpFeePct, quoteBlockNumber = _a.quoteBlock;
                        deposit = tslib_1.__assign(tslib_1.__assign({}, partialDeposit), { realizedLpFeePct: realizedLpFeePct, destinationToken: this.getDestinationTokenForDeposit(partialDeposit), quoteBlockNumber: quoteBlockNumber });
                        this.logger.debug({
                            at: "SpokePoolClient#findDeposit",
                            message: "Located deposit outside of SpokePoolClient's search range",
                            deposit: deposit,
                            elapsedMs: tStop - tStart,
                        });
                        return [2, deposit];
                }
            });
        });
    };
    SpokePoolClient.prototype.findDepositV3 = function (depositId, destinationChainId, depositor) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var searchBounds, tStart, query, tStop, event, srcChain, dstChain, partialDeposit, quoteBlockNumber, deposit;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this._getBlockRangeForDepositId(depositId, this.deploymentBlock, this.latestBlockSearched, 7)];
                    case 1:
                        searchBounds = _a.sent();
                        tStart = Date.now();
                        return [4, (0, EventUtils_1.paginatedEventQuery)(this.spokePool, this.spokePool.filters.V3FundsDeposited(null, null, null, null, destinationChainId, depositId, null, null, null, depositor, null, null, null), {
                                fromBlock: searchBounds.low,
                                toBlock: searchBounds.high,
                                maxBlockLookBack: this.eventSearchConfig.maxBlockLookBack,
                            })];
                    case 2:
                        query = _a.sent();
                        tStop = Date.now();
                        event = query.find(function (deposit) { return deposit.args.depositId === depositId; });
                        if (event === undefined) {
                            srcChain = (0, NetworkUtils_1.getNetworkName)(this.chainId);
                            dstChain = (0, NetworkUtils_1.getNetworkName)(destinationChainId);
                            throw new Error("Could not find deposit ".concat(depositId, " for ").concat(dstChain, " fill") +
                                " between ".concat(srcChain, " blocks [").concat(searchBounds.low, ", ").concat(searchBounds.high, "]"));
                        }
                        partialDeposit = (0, EventUtils_1.spreadEventWithBlockNumber)(event);
                        return [4, this.batchComputeRealizedLpFeePct([event])];
                    case 3:
                        quoteBlockNumber = (_a.sent())[0].quoteBlock;
                        deposit = tslib_1.__assign(tslib_1.__assign({}, partialDeposit), { originChainId: this.chainId, quoteBlockNumber: quoteBlockNumber, outputToken: partialDeposit.outputToken === constants_1.ZERO_ADDRESS
                                ? this.getDestinationTokenForDeposit(tslib_1.__assign(tslib_1.__assign({}, partialDeposit), { originChainId: this.chainId }))
                                : partialDeposit.outputToken });
                        this.logger.debug({
                            at: "SpokePoolClient#findDepositV3",
                            message: "Located V3 deposit outside of SpokePoolClient's search range",
                            deposit: deposit,
                            elapsedMs: tStop - tStart,
                        });
                        return [2, deposit];
                }
            });
        });
    };
    return SpokePoolClient;
}(BaseAbstractClient_1.BaseAbstractClient));
exports.SpokePoolClient = SpokePoolClient;
//# sourceMappingURL=SpokePoolClient.js.map