"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTokenBalance = exports.getTokenInformationFromAddress = exports.resolveContractFromSymbol = exports.resolveSymbolOnChain = exports.getL2TokenAddresses = exports.fetchTokenInfo = void 0;
var tslib_1 = require("tslib");
var ethers_1 = require("ethers");
var constants = tslib_1.__importStar(require("../constants"));
var typechain_1 = require("../typechain");
var NetworkUtils_1 = require("./NetworkUtils");
var TypeGuards_1 = require("./TypeGuards");
var TOKEN_SYMBOLS_MAP = constants.TOKEN_SYMBOLS_MAP, CHAIN_IDs = constants.CHAIN_IDs;
function fetchTokenInfo(address, signerOrProvider) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var token, _a, symbol, decimals;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    token = new ethers_1.Contract(address, typechain_1.ERC20__factory.abi, signerOrProvider);
                    return [4, Promise.all([token.symbol(), token.decimals()])];
                case 1:
                    _a = _b.sent(), symbol = _a[0], decimals = _a[1];
                    return [2, { address: address, symbol: symbol, decimals: decimals }];
            }
        });
    });
}
exports.fetchTokenInfo = fetchTokenInfo;
var getL2TokenAddresses = function (l1TokenAddress, l1ChainId) {
    var _a;
    if (l1ChainId === void 0) { l1ChainId = CHAIN_IDs.MAINNET; }
    return (_a = Object.values(TOKEN_SYMBOLS_MAP).find(function (details) {
        return details.addresses[l1ChainId] === l1TokenAddress;
    })) === null || _a === void 0 ? void 0 : _a.addresses;
};
exports.getL2TokenAddresses = getL2TokenAddresses;
function resolveSymbolOnChain(chainId, symbol) {
    var token = TOKEN_SYMBOLS_MAP[symbol];
    if (!(0, TypeGuards_1.isDefined)(token) || !(0, TypeGuards_1.isDefined)(token.addresses[chainId])) {
        var network = (0, NetworkUtils_1.getNetworkName)(chainId);
        throw new Error("Unable to find token ".concat(symbol, " on ").concat(network, " (chain ID ").concat(chainId));
    }
    var decimals = token.decimals, addresses = token.addresses;
    var address = addresses[chainId];
    return { symbol: symbol, decimals: decimals, address: address };
}
exports.resolveSymbolOnChain = resolveSymbolOnChain;
var resolveContractFromSymbol = function (symbol, chainId, tokenMapping) {
    var _a;
    if (tokenMapping === void 0) { tokenMapping = TOKEN_SYMBOLS_MAP; }
    return (_a = Object.values(tokenMapping).find(function (details) {
        return details.symbol.toLowerCase() === symbol.toLowerCase();
    })) === null || _a === void 0 ? void 0 : _a.addresses[Number(chainId)];
};
exports.resolveContractFromSymbol = resolveContractFromSymbol;
function getTokenInformationFromAddress(address, tokenMapping) {
    if (tokenMapping === void 0) { tokenMapping = TOKEN_SYMBOLS_MAP; }
    var details = Object.values(tokenMapping).find(function (details) {
        return Object.values(details.addresses).some(function (t) { return t.toLowerCase() === address.toLowerCase(); });
    });
    return (0, TypeGuards_1.isDefined)(details)
        ? {
            decimals: details.decimals,
            symbol: details.symbol,
            address: address,
        }
        : undefined;
}
exports.getTokenInformationFromAddress = getTokenInformationFromAddress;
function getTokenBalance(address, tokenAddress, signerOrProvider, blockTag) {
    if (blockTag === void 0) { blockTag = "latest"; }
    var token = typechain_1.ERC20__factory.connect(tokenAddress, signerOrProvider);
    return token.balanceOf(address, { blockTag: blockTag });
}
exports.getTokenBalance = getTokenBalance;
//# sourceMappingURL=TokenUtils.js.map