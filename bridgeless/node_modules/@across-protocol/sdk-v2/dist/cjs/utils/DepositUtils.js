"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDepositMessage = exports.isDepositSpedUp = exports.isMessageEmpty = exports.queryHistoricalDepositForFill = exports.InvalidFill = void 0;
var tslib_1 = require("tslib");
var assert_1 = tslib_1.__importDefault(require("assert"));
var constants_1 = require("../constants");
var NetworkUtils_1 = require("./NetworkUtils");
var CachingUtils_1 = require("./CachingUtils");
var FlowUtils_1 = require("./FlowUtils");
var TimeUtils_1 = require("./TimeUtils");
var TypeGuards_1 = require("./TypeGuards");
var ValidatorUtils_1 = require("./ValidatorUtils");
var V3Utils_1 = require("./V3Utils");
var InvalidFill;
(function (InvalidFill) {
    InvalidFill[InvalidFill["DepositIdInvalid"] = 0] = "DepositIdInvalid";
    InvalidFill[InvalidFill["DepositIdNotFound"] = 1] = "DepositIdNotFound";
    InvalidFill[InvalidFill["FillMismatch"] = 2] = "FillMismatch";
})(InvalidFill || (exports.InvalidFill = InvalidFill = {}));
function queryHistoricalDepositForFill(spokePoolClient, fill, cache) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var depositId, lowId, highId, deposit_1, deposit, cachedDeposit;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (fill.originChainId !== spokePoolClient.chainId) {
                        throw new Error("OriginChainId mismatch (".concat(fill.originChainId, " != ").concat(spokePoolClient.chainId, ")"));
                    }
                    if (!spokePoolClient.isUpdated) {
                        throw new Error("SpokePoolClient must be updated before querying historical deposits");
                    }
                    depositId = fill.depositId;
                    lowId = spokePoolClient.firstDepositIdForSpokePool, highId = spokePoolClient.lastDepositIdForSpokePool;
                    if (depositId < lowId || depositId > highId) {
                        return [2, {
                                found: false,
                                code: InvalidFill.DepositIdInvalid,
                                reason: "Deposit ID ".concat(depositId, " is outside of SpokePool bounds [").concat(lowId, ",").concat(highId, "]."),
                            }];
                    }
                    (lowId = spokePoolClient.earliestDepositIdQueried, highId = spokePoolClient.latestDepositIdQueried);
                    if (depositId >= lowId && depositId <= highId) {
                        deposit_1 = spokePoolClient.getDeposit(depositId);
                        if ((0, TypeGuards_1.isDefined)(deposit_1) && (0, FlowUtils_1.validateFillForDeposit)(fill, deposit_1)) {
                            return [2, { found: true, deposit: deposit_1 }];
                        }
                        return [2, {
                                found: false,
                                code: (0, TypeGuards_1.isDefined)(deposit_1) ? InvalidFill.FillMismatch : InvalidFill.DepositIdNotFound,
                                reason: "Deposit ID ".concat(depositId, " not found in SpokePoolClient event buffer."),
                            }];
                    }
                    if (!cache) return [3, 2];
                    return [4, (0, CachingUtils_1.getDepositInCache)((0, CachingUtils_1.getDepositKey)(fill), cache)];
                case 1:
                    cachedDeposit = _a.sent();
                    if ((0, TypeGuards_1.isDefined)(cachedDeposit) && !(0, ValidatorUtils_1.isDepositFormedCorrectly)(cachedDeposit)) {
                        spokePoolClient.logger.warn({
                            at: "[SDK]:DepositUtils#queryHistoricalDepositForFill",
                            message: "Cached deposit was not formed correctly, removing from cache",
                            fill: fill,
                            cachedDeposit: cachedDeposit,
                        });
                        cachedDeposit = undefined;
                    }
                    _a.label = 2;
                case 2:
                    if (!(0, TypeGuards_1.isDefined)(cachedDeposit)) return [3, 3];
                    deposit = cachedDeposit;
                    return [3, 9];
                case 3:
                    if (!(0, V3Utils_1.isV2Fill)(fill)) return [3, 5];
                    return [4, spokePoolClient.findDeposit(fill.depositId, fill.destinationChainId, fill.depositor)];
                case 4:
                    deposit = _a.sent();
                    return [3, 7];
                case 5: return [4, spokePoolClient.findDepositV3(fill.depositId, fill.destinationChainId, fill.depositor)];
                case 6:
                    deposit = _a.sent();
                    _a.label = 7;
                case 7:
                    if (!cache) return [3, 9];
                    return [4, (0, CachingUtils_1.setDepositInCache)(deposit, (0, TimeUtils_1.getCurrentTime)(), cache, constants_1.DEFAULT_CACHING_TTL)];
                case 8:
                    _a.sent();
                    _a.label = 9;
                case 9:
                    if ((0, FlowUtils_1.validateFillForDeposit)(fill, deposit)) {
                        return [2, { found: true, deposit: deposit }];
                    }
                    return [2, {
                            found: false,
                            code: InvalidFill.FillMismatch,
                            reason: "Fill is not valid for ".concat((0, NetworkUtils_1.getNetworkName)(deposit.originChainId), " deposit ").concat(depositId),
                        }];
            }
        });
    });
}
exports.queryHistoricalDepositForFill = queryHistoricalDepositForFill;
function isMessageEmpty(message) {
    if (message === void 0) { message = constants_1.EMPTY_MESSAGE; }
    return message === "" || message === "0x";
}
exports.isMessageEmpty = isMessageEmpty;
function isDepositSpedUp(deposit) {
    return ((0, TypeGuards_1.isDefined)(deposit.speedUpSignature) &&
        (((0, V3Utils_1.isV2Deposit)(deposit) && (0, TypeGuards_1.isDefined)(deposit.newRelayerFeePct)) ||
            ((0, V3Utils_1.isV3Deposit)(deposit) && (0, TypeGuards_1.isDefined)(deposit.updatedOutputAmount))));
}
exports.isDepositSpedUp = isDepositSpedUp;
function resolveDepositMessage(deposit) {
    var message = isDepositSpedUp(deposit) ? deposit.updatedMessage : deposit.message;
    (0, assert_1.default)((0, TypeGuards_1.isDefined)(message));
    return message;
}
exports.resolveDepositMessage = resolveDepositMessage;
//# sourceMappingURL=DepositUtils.js.map