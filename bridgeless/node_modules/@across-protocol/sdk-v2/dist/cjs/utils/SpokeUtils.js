"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findFillBlock = exports.relayFillStatus = exports.getV3RelayHashFromEvent = exports.getV3RelayHash = exports.getV2RelayHash = exports.getRelayDataHash = exports.getDepositIdAtBlock = exports.getBlockRangeForDepositId = exports.populateV3Relay = void 0;
var tslib_1 = require("tslib");
var assert_1 = tslib_1.__importDefault(require("assert"));
var ethers_1 = require("ethers");
var constants_1 = require("../constants");
var interfaces_1 = require("../interfaces");
var TypeGuards_1 = require("./TypeGuards");
var V3Utils_1 = require("./V3Utils");
var NetworkUtils_1 = require("./NetworkUtils");
function populateV3Relay(spokePool, deposit, relayer, repaymentChainId) {
    if (repaymentChainId === void 0) { repaymentChainId = deposit.destinationChainId; }
    var v3RelayData = {
        depositor: deposit.depositor,
        recipient: deposit.recipient,
        exclusiveRelayer: deposit.exclusiveRelayer,
        inputToken: deposit.inputToken,
        outputToken: deposit.outputToken,
        inputAmount: deposit.inputAmount,
        outputAmount: deposit.outputAmount,
        originChainId: deposit.originChainId,
        depositId: deposit.depositId,
        fillDeadline: deposit.fillDeadline,
        exclusivityDeadline: deposit.exclusivityDeadline,
        message: deposit.message,
    };
    if ((0, TypeGuards_1.isDefined)(deposit.speedUpSignature)) {
        (0, assert_1.default)((0, TypeGuards_1.isDefined)(deposit.updatedRecipient) && deposit.updatedRecipient !== constants_1.ZERO_ADDRESS);
        (0, assert_1.default)((0, TypeGuards_1.isDefined)(deposit.updatedOutputAmount));
        (0, assert_1.default)((0, TypeGuards_1.isDefined)(deposit.updatedMessage));
        return spokePool.populateTransaction.fillV3RelayWithUpdatedDeposit(v3RelayData, repaymentChainId, deposit.updatedOutputAmount, deposit.updatedRecipient, deposit.updatedMessage, deposit.speedUpSignature, { from: relayer });
    }
    return spokePool.populateTransaction.fillV3Relay(v3RelayData, repaymentChainId, { from: relayer });
}
exports.populateV3Relay = populateV3Relay;
function getBlockRangeForDepositId(targetDepositId, initLow, initHigh, maxSearches, spokePool) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var deploymentBlock, queriedIds, _getDepositIdAtBlock, _a, highestDepositIdInRange, lowestDepositIdInRange, low, high, searches, mid, midDepositId, accountedIdByMidBlock;
        var _this = this;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    deploymentBlock = spokePool.deploymentBlock;
                    initHigh = Math.min(initHigh, spokePool.latestBlockSearched);
                    [
                        [spokePool.isUpdated, "Spoke pool client is not updated"],
                        [initLow <= initHigh, "Binary search failed because low > high"],
                        [initLow >= deploymentBlock, "Binary search failed because low must be >= deploymentBlock"],
                        [maxSearches > 0, "maxSearches must be > 0"],
                        [deploymentBlock >= 0, "deploymentBlock must be >= 0"],
                    ].forEach(function (_a) {
                        var condition = _a[0], errorMessage = _a[1];
                        if (!condition) {
                            throw new Error(errorMessage);
                        }
                    });
                    queriedIds = {};
                    _getDepositIdAtBlock = function (blockNumber) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var _a, _b, _c;
                        var _d;
                        return tslib_1.__generator(this, function (_e) {
                            switch (_e.label) {
                                case 0:
                                    if (!((_d = queriedIds[blockNumber]) !== null && _d !== void 0)) return [3, 1];
                                    _a = _d;
                                    return [3, 3];
                                case 1:
                                    _b = queriedIds;
                                    _c = blockNumber;
                                    return [4, spokePool._getDepositIdAtBlock(blockNumber)];
                                case 2:
                                    _a = (_b[_c] = _e.sent());
                                    _e.label = 3;
                                case 3:
                                    _a;
                                    return [2, queriedIds[blockNumber]];
                            }
                        });
                    }); };
                    return [4, Promise.all([
                            _getDepositIdAtBlock(initHigh),
                            _getDepositIdAtBlock(Math.max(deploymentBlock, initLow - 1)),
                        ])];
                case 1:
                    _a = _b.sent(), highestDepositIdInRange = _a[0], lowestDepositIdInRange = _a[1];
                    if (highestDepositIdInRange <= targetDepositId) {
                        throw new Error("Target depositId is greater than the initial high block (".concat(targetDepositId, " > ").concat(highestDepositIdInRange, ")"));
                    }
                    if (lowestDepositIdInRange > targetDepositId) {
                        throw new Error("Target depositId is less than the initial low block (".concat(targetDepositId, " > ").concat(lowestDepositIdInRange, ")"));
                    }
                    low = initLow;
                    high = initHigh;
                    searches = 0;
                    _b.label = 2;
                case 2:
                    mid = Math.floor((low + high) / 2);
                    return [4, _getDepositIdAtBlock(mid)];
                case 3:
                    midDepositId = _b.sent();
                    accountedIdByMidBlock = midDepositId - 1;
                    if (targetDepositId <= accountedIdByMidBlock) {
                        high = mid;
                    }
                    else {
                        low = mid + 1;
                    }
                    _b.label = 4;
                case 4:
                    if (++searches <= maxSearches && low < high) return [3, 2];
                    _b.label = 5;
                case 5:
                    if (low > high) {
                        throw new Error("Binary search failed (".concat(low, " > ").concat(high, "). SHOULD NEVER HAPPEN (but here we are)"));
                    }
                    return [2, { low: low, high: high }];
            }
        });
    });
}
exports.getBlockRangeForDepositId = getBlockRangeForDepositId;
function getDepositIdAtBlock(contract, blockTag) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var depositIdAtBlock;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, contract.numberOfDeposits({ blockTag: blockTag })];
                case 1:
                    depositIdAtBlock = _a.sent();
                    if (!Number.isInteger(depositIdAtBlock) || depositIdAtBlock < 0) {
                        throw new Error("Invalid deposit count");
                    }
                    return [2, depositIdAtBlock];
            }
        });
    });
}
exports.getDepositIdAtBlock = getDepositIdAtBlock;
function getRelayDataHash(relayData, destinationChainId) {
    if ((0, V3Utils_1.isV2RelayData)(relayData)) {
        (0, assert_1.default)(!(0, TypeGuards_1.isDefined)(destinationChainId) || destinationChainId === relayData.destinationChainId);
        return getV2RelayHash(relayData);
    }
    (0, assert_1.default)((0, TypeGuards_1.isDefined)(destinationChainId));
    return getV3RelayHash(relayData, destinationChainId);
}
exports.getRelayDataHash = getRelayDataHash;
function getV2RelayHash(relayData) {
    return ethers_1.utils.keccak256(ethers_1.utils.defaultAbiCoder.encode([
        "tuple(" +
            "address depositor," +
            "address recipient," +
            "address destinationToken," +
            "uint256 amount," +
            "uint256 originChainId," +
            "uint256 destinationChainId," +
            "int64 realizedLpFeePct," +
            "int64 relayerFeePct," +
            "uint32 depositId," +
            "bytes message" +
            ")",
    ], [relayData]));
}
exports.getV2RelayHash = getV2RelayHash;
function getV3RelayHash(relayData, destinationChainId) {
    return ethers_1.utils.keccak256(ethers_1.utils.defaultAbiCoder.encode([
        "tuple(" +
            "address depositor," +
            "address recipient," +
            "address exclusiveRelayer," +
            "address inputToken," +
            "address outputToken," +
            "uint256 inputAmount," +
            "uint256 outputAmount," +
            "uint256 originChainId," +
            "uint32 depositId," +
            "uint32 fillDeadline," +
            "uint32 exclusivityDeadline," +
            "bytes message" +
            ")",
        "uint256 destinationChainId",
    ], [relayData, destinationChainId]));
}
exports.getV3RelayHash = getV3RelayHash;
function getV3RelayHashFromEvent(e) {
    return getV3RelayHash(e, e.destinationChainId);
}
exports.getV3RelayHashFromEvent = getV3RelayHashFromEvent;
function relayFillStatus(spokePool, relayData, blockTag, destinationChainId) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _a, hash, _fillStatus, fillStatus, originChainId, depositId;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!(destinationChainId !== null && destinationChainId !== void 0)) return [3, 1];
                    _a = destinationChainId;
                    return [3, 3];
                case 1: return [4, spokePool.chainId()];
                case 2:
                    _a = (destinationChainId = _b.sent());
                    _b.label = 3;
                case 3:
                    _a;
                    hash = getRelayDataHash(relayData, destinationChainId);
                    return [4, spokePool.fillStatuses(hash, { blockTag: blockTag })];
                case 4:
                    _fillStatus = _b.sent();
                    fillStatus = Number(_fillStatus);
                    if (![interfaces_1.FillStatus.Unfilled, interfaces_1.FillStatus.RequestedSlowFill, interfaces_1.FillStatus.Filled].includes(fillStatus)) {
                        originChainId = relayData.originChainId, depositId = relayData.depositId;
                        throw new Error("relayFillStatus: Unexpected fillStatus for ".concat(originChainId, " deposit ").concat(depositId));
                    }
                    return [2, fillStatus];
            }
        });
    });
}
exports.relayFillStatus = relayFillStatus;
function findFillBlock(spokePool, relayData, lowBlockNumber, highBlockNumber) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var provider, _a, destinationChainId, _b, _c, _d, initialFillStatus, finalFillStatus, depositId, originChainId, _e, srcChain, dstChain, midBlockNumber, fillStatus;
        return tslib_1.__generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    provider = spokePool.provider;
                    if (!(highBlockNumber !== null && highBlockNumber !== void 0)) return [3, 1];
                    _a = highBlockNumber;
                    return [3, 3];
                case 1: return [4, provider.getBlockNumber()];
                case 2:
                    _a = (highBlockNumber = _f.sent());
                    _f.label = 3;
                case 3:
                    _a;
                    (0, assert_1.default)(highBlockNumber > lowBlockNumber, "Block numbers out of range (".concat(lowBlockNumber, " > ").concat(highBlockNumber, ")"));
                    if (!Object.values(constants_1.CHAIN_IDs).includes(relayData.originChainId)) return [3, 5];
                    return [4, provider.getNetwork()];
                case 4:
                    _b = (_f.sent()).chainId;
                    return [3, 7];
                case 5:
                    _c = Number;
                    return [4, spokePool.chainId()];
                case 6:
                    _b = _c.apply(void 0, [_f.sent()]);
                    _f.label = 7;
                case 7:
                    destinationChainId = _b;
                    (0, assert_1.default)(relayData.originChainId !== destinationChainId, "Origin & destination chain IDs must not be equal (".concat(destinationChainId, ")"));
                    return [4, Promise.all([
                            relayFillStatus(spokePool, relayData, lowBlockNumber, destinationChainId),
                            relayFillStatus(spokePool, relayData, highBlockNumber, destinationChainId),
                        ])];
                case 8:
                    _d = (_f.sent()).map(Number), initialFillStatus = _d[0], finalFillStatus = _d[1];
                    if (finalFillStatus !== interfaces_1.FillStatus.Filled) {
                        return [2, undefined];
                    }
                    if (initialFillStatus === interfaces_1.FillStatus.Filled) {
                        depositId = relayData.depositId, originChainId = relayData.originChainId;
                        _e = [(0, NetworkUtils_1.getNetworkName)(originChainId), (0, NetworkUtils_1.getNetworkName)(destinationChainId)], srcChain = _e[0], dstChain = _e[1];
                        throw new Error("".concat(srcChain, " deposit ").concat(depositId, " filled on ").concat(dstChain, " before block ").concat(lowBlockNumber));
                    }
                    _f.label = 9;
                case 9:
                    midBlockNumber = Math.floor((highBlockNumber + lowBlockNumber) / 2);
                    return [4, relayFillStatus(spokePool, relayData, midBlockNumber, destinationChainId)];
                case 10:
                    fillStatus = _f.sent();
                    if (fillStatus === interfaces_1.FillStatus.Filled) {
                        highBlockNumber = midBlockNumber;
                    }
                    else {
                        lowBlockNumber = midBlockNumber + 1;
                    }
                    _f.label = 11;
                case 11:
                    if (lowBlockNumber < highBlockNumber) return [3, 9];
                    _f.label = 12;
                case 12: return [2, lowBlockNumber];
            }
        });
    });
}
exports.findFillBlock = findFillBlock;
//# sourceMappingURL=SpokeUtils.js.map