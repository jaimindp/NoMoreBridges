"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatWinston = exports.parseWinston = exports.ConvertDecimals = exports.formatWei = exports.shortenHexStrings = exports.convertFromWei = exports.bnToHex = exports.hexToUtf8 = exports.utf8ToHex = exports.createShortHexString = exports.formatFeePct = exports.createFormatFunction = exports.formatWithMaxDecimals = void 0;
var tslib_1 = require("tslib");
var ethers_1 = require("ethers");
var BigNumberUtils_1 = require("./BigNumberUtils");
var common_1 = require("./common");
var assert_1 = tslib_1.__importDefault(require("assert"));
var bignumber_js_1 = require("bignumber.js");
var formatWithMaxDecimals = function (num, decimalPlaces, minPrecision, roundUp, showSign) {
    if (roundUp) {
        bignumber_js_1.BigNumber.set({ ROUNDING_MODE: bignumber_js_1.BigNumber.ROUND_UP });
    }
    else {
        bignumber_js_1.BigNumber.set({ ROUNDING_MODE: bignumber_js_1.BigNumber.ROUND_DOWN });
    }
    var fullPrecisionFloat = new bignumber_js_1.BigNumber(num);
    var positiveSign = showSign && fullPrecisionFloat.gt(0) ? "+" : "";
    var fixedPrecisionFloat;
    if (fullPrecisionFloat.abs().gte(new bignumber_js_1.BigNumber(1))) {
        fixedPrecisionFloat = new bignumber_js_1.BigNumber(fullPrecisionFloat).toFixed(decimalPlaces).toString();
    }
    else {
        fixedPrecisionFloat = new bignumber_js_1.BigNumber(fullPrecisionFloat).toPrecision(minPrecision).toString();
    }
    var fixedPrecisionFloatParts = fixedPrecisionFloat.split(".");
    fixedPrecisionFloatParts[0] = fixedPrecisionFloatParts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    return positiveSign + fixedPrecisionFloatParts.join(".");
};
exports.formatWithMaxDecimals = formatWithMaxDecimals;
var createFormatFunction = function (numDisplayedDecimals, minDisplayedPrecision, showSign, decimals) {
    if (showSign === void 0) { showSign = false; }
    if (decimals === void 0) { decimals = 18; }
    return function (valInWei) {
        return (0, exports.formatWithMaxDecimals)((0, exports.formatWei)((0, exports.ConvertDecimals)(decimals, 18)(valInWei)), numDisplayedDecimals, minDisplayedPrecision, false, showSign);
    };
};
exports.createFormatFunction = createFormatFunction;
var formatFeePct = function (relayerFeePct) {
    return (0, exports.createFormatFunction)(2, 4, false, 16)((0, BigNumberUtils_1.toBN)(relayerFeePct).toString());
};
exports.formatFeePct = formatFeePct;
function createShortHexString(hex, maxLength, delimiter) {
    if (maxLength === void 0) { maxLength = 8; }
    if (delimiter === void 0) { delimiter = ".."; }
    if (hex.length <= maxLength) {
        return hex;
    }
    var maxAvailable = maxLength - delimiter.length;
    if (maxAvailable <= 0) {
        throw new Error("Invalid max length");
    }
    var leftCharacters = Math.floor(maxAvailable / 2 + 0.5);
    var rightCharacters = Math.floor(maxAvailable / 2);
    return "".concat(hex.substring(0, leftCharacters)).concat(delimiter).concat(hex.substring(hex.length - rightCharacters));
}
exports.createShortHexString = createShortHexString;
function utf8ToHex(input) {
    return ethers_1.ethers.utils.formatBytes32String(input);
}
exports.utf8ToHex = utf8ToHex;
function hexToUtf8(input) {
    return ethers_1.ethers.utils.toUtf8String(input);
}
exports.hexToUtf8 = hexToUtf8;
function bnToHex(input) {
    return ethers_1.ethers.utils.hexZeroPad(ethers_1.ethers.utils.hexlify((0, BigNumberUtils_1.toBN)(input)), 32);
}
exports.bnToHex = bnToHex;
function convertFromWei(weiVal, decimals) {
    var formatFunction = (0, exports.createFormatFunction)(2, 4, false, decimals);
    return formatFunction(weiVal);
}
exports.convertFromWei = convertFromWei;
function shortenHexStrings(addresses) {
    return addresses.map(function (h) { return createShortHexString(h); });
}
exports.shortenHexStrings = shortenHexStrings;
var formatWei = function (num) {
    return (0, common_1.fromWei)(num.toString());
};
exports.formatWei = formatWei;
var ConvertDecimals = function (fromDecimals, toDecimals) {
    (0, assert_1.default)(fromDecimals >= 0, "requires fromDecimals as an integer >= 0");
    (0, assert_1.default)(toDecimals >= 0, "requires toDecimals as an integer >= 0");
    return function (amountIn) {
        var amount = (0, BigNumberUtils_1.toBN)(amountIn.toString());
        if (amount.isZero())
            return amount;
        var diff = fromDecimals - toDecimals;
        if (diff == 0)
            return amount;
        if (diff > 0)
            return amount.div((0, BigNumberUtils_1.toBN)("10").pow((0, BigNumberUtils_1.toBN)(diff.toString())));
        return amount.mul((0, BigNumberUtils_1.toBN)("10").pow((0, BigNumberUtils_1.toBN)((-1 * diff).toString())));
    };
};
exports.ConvertDecimals = ConvertDecimals;
function parseWinston(numericString) {
    return ethers_1.ethers.utils.parseUnits(numericString, 12);
}
exports.parseWinston = parseWinston;
function formatWinston(winstonValue) {
    return ethers_1.ethers.utils.formatUnits(winstonValue, 12);
}
exports.formatWinston = formatWinston;
//# sourceMappingURL=FormattingUtils.js.map