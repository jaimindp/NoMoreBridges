"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomAddress = exports.getUpdateV3DepositTypedData = exports.getUpdateDepositTypedData = exports.createUnsignedFillRelayTransactionFromDeposit = exports.estimateTotalGasRequiredByUnsignedTransaction = exports.retry = exports.delay = exports.getSamplesBetween = exports.calcApr = exports.calcPeriodicCompoundInterest = exports.calcContinuousCompoundInterest = exports.percent = exports.calculateGasFees = exports.gasCost = exports.nativeToToken = exports.fixedPointAdjustment = exports.max = exports.min = exports.fromWei = exports.toBNWei = exports.MAX_BIG_INT = exports.AddressZero = void 0;
var tslib_1 = require("tslib");
var l2_provider_1 = require("@eth-optimism/sdk/dist/l2-provider");
var assert_1 = tslib_1.__importDefault(require("assert"));
var decimal_js_1 = tslib_1.__importDefault(require("decimal.js"));
var ethers_1 = require("ethers");
var gasPriceOracle_1 = require("../gasPriceOracle");
var BigNumberUtils_1 = require("./BigNumberUtils");
var V3Utils_1 = require("./V3Utils");
var FormattingUtils_1 = require("./FormattingUtils");
var TypeGuards_1 = require("./TypeGuards");
var NetworkUtils_1 = require("./NetworkUtils");
exports.AddressZero = ethers_1.ethers.constants.AddressZero;
exports.MAX_BIG_INT = ethers_1.BigNumber.from(Number.MAX_SAFE_INTEGER.toString());
var toBNWei = function (num, decimals) { return ethers_1.ethers.utils.parseUnits(num.toString(), decimals); };
exports.toBNWei = toBNWei;
var fromWei = function (num, decimals) {
    return ethers_1.ethers.utils.formatUnits(num.toString(), decimals);
};
exports.fromWei = fromWei;
function min(a, b) {
    var bna = (0, BigNumberUtils_1.toBN)(a);
    var bnb = (0, BigNumberUtils_1.toBN)(b);
    return bna.lte(bnb) ? bna : bnb;
}
exports.min = min;
function max(a, b) {
    var bna = (0, BigNumberUtils_1.toBN)(a);
    var bnb = (0, BigNumberUtils_1.toBN)(b);
    return bna.gte(bnb) ? bna : bnb;
}
exports.max = max;
exports.fixedPointAdjustment = (0, exports.toBNWei)("1");
function nativeToToken(fromAmount, price, toDecimals, nativeDecimals) {
    if (price === void 0) { price = 1; }
    if (toDecimals === void 0) { toDecimals = 18; }
    if (nativeDecimals === void 0) { nativeDecimals = 18; }
    var priceWei = (0, exports.toBNWei)(price);
    var toAmount = (0, exports.toBNWei)(fromAmount).div(priceWei);
    return (0, FormattingUtils_1.ConvertDecimals)(nativeDecimals, toDecimals)(toAmount).toString();
}
exports.nativeToToken = nativeToToken;
var gasCost = function (gas, gasPrice) {
    return ethers_1.BigNumber.from(gas).mul(gasPrice);
};
exports.gasCost = gasCost;
function calculateGasFees(gas, gasPrice, price, decimals) {
    if (price === void 0) { price = 1; }
    if (decimals === void 0) { decimals = 18; }
    var amountNative = (0, exports.gasCost)(gas, gasPrice);
    return nativeToToken(amountNative, price, decimals);
}
exports.calculateGasFees = calculateGasFees;
function percent(numerator, denominator) {
    return exports.fixedPointAdjustment.mul(numerator).div(denominator);
}
exports.percent = percent;
var calcContinuousCompoundInterest = function (startAmount, endAmount, periodsElapsed, periodsPerYear) {
    var years = new decimal_js_1.default(periodsPerYear).div(periodsElapsed);
    return new decimal_js_1.default(endAmount).div(startAmount).ln().div(years).toString();
};
exports.calcContinuousCompoundInterest = calcContinuousCompoundInterest;
var calcPeriodicCompoundInterest = function (startAmount, endAmount, periodsElapsed, periodsPerYear) {
    var n = new decimal_js_1.default(periodsPerYear);
    var A = new decimal_js_1.default(endAmount);
    var P = new decimal_js_1.default(startAmount);
    var t = new decimal_js_1.default(periodsPerYear).div(periodsElapsed);
    var one = new decimal_js_1.default(1);
    return n
        .mul(A.div(P)
        .pow(one.div(n.div(t)))
        .sub(one))
        .toFixed(18);
};
exports.calcPeriodicCompoundInterest = calcPeriodicCompoundInterest;
var calcApr = function (startAmount, endAmount, periodsElapsed, periodsPerYear) {
    return new decimal_js_1.default(endAmount).sub(startAmount).div(startAmount).mul(periodsPerYear).div(periodsElapsed).toFixed(18);
};
exports.calcApr = calcApr;
var getSamplesBetween = function (min, max, size) {
    var keepIterate = true;
    var intervals = [];
    while (keepIterate) {
        var to = Math.min(min + size - 1, max);
        intervals.push([min, to]);
        min = to + 1;
        if (min >= max)
            keepIterate = false;
    }
    return intervals;
};
exports.getSamplesBetween = getSamplesBetween;
function delay(seconds) {
    return new Promise(function (resolve) { return setTimeout(resolve, seconds * 1000); });
}
exports.delay = delay;
function retry(call, times, delayS) {
    var _this = this;
    var promiseChain = call();
    for (var i = 0; i < times; i++)
        promiseChain = promiseChain.catch(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, delay(delayS)];
                    case 1:
                        _a.sent();
                        return [4, call()];
                    case 2: return [2, _a.sent()];
                }
            });
        }); });
    return promiseChain;
}
exports.retry = retry;
function estimateTotalGasRequiredByUnsignedTransaction(unsignedTx, senderAddress, provider, gasMarkup, gasPrice) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var gasTotalMultiplier, chainId, voidSigner, nativeGasCost, tokenGasCost, populatedTransaction, gasPriceEstimate;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    (0, assert_1.default)(gasMarkup > -1 && gasMarkup <= 4, "Require -1.0 < Gas Markup (".concat(gasMarkup, ") <= 4.0 for a total gas multiplier within (0, +5.0]"));
                    gasTotalMultiplier = (0, exports.toBNWei)(1.0 + gasMarkup);
                    return [4, provider.getNetwork()];
                case 1:
                    chainId = (_a.sent()).chainId;
                    voidSigner = new ethers_1.VoidSigner(senderAddress, provider);
                    return [4, voidSigner.estimateGas(unsignedTx)];
                case 2:
                    nativeGasCost = _a.sent();
                    if (!(0, NetworkUtils_1.chainIsOPStack)(chainId)) return [3, 5];
                    (0, assert_1.default)((0, l2_provider_1.isL2Provider)(provider), "Unexpected provider for chain ID ".concat(chainId, "."));
                    (0, assert_1.default)(gasPrice === undefined, "Gas price (".concat(gasPrice, ") supplied for Optimism gas estimation (unused)."));
                    return [4, voidSigner.populateTransaction(unsignedTx)];
                case 3:
                    populatedTransaction = _a.sent();
                    return [4, provider.estimateTotalGasCost(populatedTransaction)];
                case 4:
                    tokenGasCost = _a.sent();
                    return [3, 8];
                case 5:
                    if (!!gasPrice) return [3, 7];
                    return [4, (0, gasPriceOracle_1.getGasPriceEstimate)(provider)];
                case 6:
                    gasPriceEstimate = _a.sent();
                    gasPrice = gasPriceEstimate.maxFeePerGas;
                    _a.label = 7;
                case 7:
                    tokenGasCost = nativeGasCost.mul(gasPrice);
                    _a.label = 8;
                case 8:
                    nativeGasCost = nativeGasCost.mul(gasTotalMultiplier).div(exports.fixedPointAdjustment);
                    tokenGasCost = tokenGasCost.mul(gasTotalMultiplier).div(exports.fixedPointAdjustment);
                    return [2, {
                            nativeGasCost: nativeGasCost,
                            tokenGasCost: tokenGasCost,
                        }];
            }
        });
    });
}
exports.estimateTotalGasRequiredByUnsignedTransaction = estimateTotalGasRequiredByUnsignedTransaction;
function createUnsignedFillRelayTransactionFromDeposit(spokePool, deposit, amountToFill, relayerAddress) {
    (0, assert_1.default)((0, V3Utils_1.isV2Deposit)(deposit));
    var realizedLpFeePct = deposit.realizedLpFeePct;
    (0, assert_1.default)((0, TypeGuards_1.isDefined)(realizedLpFeePct));
    if ((0, TypeGuards_1.isDefined)(deposit.speedUpSignature)) {
        var updatedRecipient = deposit.updatedRecipient;
        var updatedMessage = deposit.updatedMessage;
        var updatedRelayerFeePct = deposit.newRelayerFeePct;
        (0, assert_1.default)((0, TypeGuards_1.isDefined)(updatedRecipient) && (0, TypeGuards_1.isDefined)(updatedMessage) && (0, TypeGuards_1.isDefined)(updatedRelayerFeePct));
        return spokePool.populateTransaction.fillRelayWithUpdatedDeposit(deposit.depositor, deposit.recipient, updatedRecipient, deposit.destinationToken, deposit.amount, amountToFill, deposit.destinationChainId, deposit.originChainId, realizedLpFeePct, deposit.relayerFeePct, updatedRelayerFeePct, deposit.depositId, deposit.message, updatedMessage, deposit.speedUpSignature, BigNumberUtils_1.bnUint256Max, {
            from: relayerAddress,
        });
    }
    else {
        return spokePool.populateTransaction.fillRelay(deposit.depositor, deposit.recipient, deposit.destinationToken, deposit.amount, amountToFill, deposit.destinationChainId, deposit.originChainId, realizedLpFeePct, deposit.relayerFeePct, deposit.depositId, deposit.message, BigNumberUtils_1.bnUint256Max, {
            from: relayerAddress,
        });
    }
}
exports.createUnsignedFillRelayTransactionFromDeposit = createUnsignedFillRelayTransactionFromDeposit;
function getUpdateDepositTypedData(depositId, originChainId, updatedRelayerFeePct, updatedRecipient, updatedMessage) {
    return {
        types: {
            UpdateDepositDetails: [
                { name: "depositId", type: "uint32" },
                { name: "originChainId", type: "uint256" },
                { name: "updatedRelayerFeePct", type: "int64" },
                { name: "updatedRecipient", type: "address" },
                { name: "updatedMessage", type: "bytes" },
            ],
        },
        primaryType: "UpdateDepositDetails",
        domain: {
            name: "ACROSS-V2",
            version: "1.0.0",
            chainId: originChainId,
        },
        message: {
            depositId: depositId,
            originChainId: originChainId,
            updatedRelayerFeePct: updatedRelayerFeePct,
            updatedRecipient: updatedRecipient,
            updatedMessage: updatedMessage,
        },
    };
}
exports.getUpdateDepositTypedData = getUpdateDepositTypedData;
function getUpdateV3DepositTypedData(depositId, originChainId, updatedOutputAmount, updatedRecipient, updatedMessage) {
    return {
        types: {
            UpdateDepositDetails: [
                { name: "depositId", type: "uint32" },
                { name: "originChainId", type: "uint256" },
                { name: "updatedOutputAmount", type: "uint256" },
                { name: "updatedRecipient", type: "address" },
                { name: "updatedMessage", type: "bytes" },
            ],
        },
        primaryType: "UpdateDepositDetails",
        domain: {
            name: "ACROSS-V2",
            version: "1.0.0",
            chainId: originChainId,
        },
        message: {
            depositId: depositId,
            originChainId: originChainId,
            updatedOutputAmount: updatedOutputAmount,
            updatedRecipient: updatedRecipient,
            updatedMessage: updatedMessage,
        },
    };
}
exports.getUpdateV3DepositTypedData = getUpdateV3DepositTypedData;
function randomAddress() {
    return ethers_1.ethers.utils.getAddress(ethers_1.ethers.utils.hexlify(ethers_1.ethers.utils.randomBytes(20)));
}
exports.randomAddress = randomAddress;
//# sourceMappingURL=common.js.map