"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateFillForDeposit = exports.filledSameDeposit = exports.V3_DEPOSIT_COMPARISON_KEYS = exports.V2_DEPOSIT_COMPARISON_KEYS = exports.FILL_DEPOSIT_COMPARISON_KEYS = void 0;
var tslib_1 = require("tslib");
var SpokeUtils_1 = require("./SpokeUtils");
var V3Utils_1 = require("./V3Utils");
exports.FILL_DEPOSIT_COMPARISON_KEYS = [
    "depositId",
    "originChainId",
    "destinationChainId",
    "depositor",
    "recipient",
    "message",
];
exports.V2_DEPOSIT_COMPARISON_KEYS = tslib_1.__spreadArray(tslib_1.__spreadArray([], exports.FILL_DEPOSIT_COMPARISON_KEYS, true), [
    "amount",
    "destinationToken",
    "relayerFeePct",
    "realizedLpFeePct",
], false);
exports.V3_DEPOSIT_COMPARISON_KEYS = tslib_1.__spreadArray(tslib_1.__spreadArray([], exports.FILL_DEPOSIT_COMPARISON_KEYS, true), [
    "inputToken",
    "inputAmount",
    "outputToken",
    "outputAmount",
    "fillDeadline",
    "exclusivityDeadline",
    "exclusiveRelayer",
], false);
function filledSameDeposit(fillA, fillB) {
    if (fillA.depositId !== fillB.depositId) {
        return false;
    }
    if ((0, V3Utils_1.isV2Fill)(fillA) && (0, V3Utils_1.isV2Fill)(fillB)) {
        return (0, SpokeUtils_1.getV2RelayHash)(fillA) === (0, SpokeUtils_1.getV2RelayHash)(fillB);
    }
    else if ((0, V3Utils_1.isV3Fill)(fillA) && (0, V3Utils_1.isV3Fill)(fillB)) {
        var chainA = fillA.destinationChainId;
        var chainB = fillB.destinationChainId;
        return (0, SpokeUtils_1.getV3RelayHash)(fillA, chainA) === (0, SpokeUtils_1.getV3RelayHash)(fillB, chainB);
    }
    return false;
}
exports.filledSameDeposit = filledSameDeposit;
function validateFillForDeposit(relayData, deposit, fillFieldsToIgnore) {
    if (fillFieldsToIgnore === void 0) { fillFieldsToIgnore = []; }
    if (deposit === undefined) {
        return false;
    }
    return (0, V3Utils_1.isV2RelayData)(relayData)
        ? validateV2FillForDeposit(relayData, deposit, fillFieldsToIgnore)
        : validateV3FillForDeposit(relayData, deposit);
}
exports.validateFillForDeposit = validateFillForDeposit;
function validateV2FillForDeposit(fill, deposit, fillFieldsToIgnore) {
    if (fillFieldsToIgnore === void 0) { fillFieldsToIgnore = []; }
    if (!(0, V3Utils_1.isV2Deposit)(deposit)) {
        return false;
    }
    return exports.V2_DEPOSIT_COMPARISON_KEYS.every(function (key) {
        var _a;
        if (fillFieldsToIgnore.includes(key)) {
            return true;
        }
        return fill[key] !== undefined && fill[key].toString() === ((_a = deposit[key]) === null || _a === void 0 ? void 0 : _a.toString());
    });
}
function validateV3FillForDeposit(fill, deposit) {
    if (!(0, V3Utils_1.isV3Deposit)(deposit)) {
        return false;
    }
    return (0, SpokeUtils_1.getV3RelayHash)(fill, fill.destinationChainId) === (0, SpokeUtils_1.getV3RelayHash)(deposit, deposit.destinationChainId);
}
//# sourceMappingURL=FlowUtils.js.map