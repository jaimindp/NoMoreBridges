import { across } from "@uma/sdk";
import { Contract, Event } from "ethers";
import winston from "winston";
import { EventSearchConfig, MakeOptional } from "../../utils";
import { ConfigStoreVersionUpdate, DisabledChainsUpdate, GlobalConfigUpdate, RouteRateModelUpdate, SpokePoolTargetBalance, SpokeTargetBalanceUpdate, UBAConfigUpdates, UBAParsedConfigType } from "../../interfaces";
import { BaseAbstractClient } from "../BaseAbstractClient";
type _ConfigStoreUpdate = {
    success: true;
    chainId: number;
    searchEndBlock: number;
    events: {
        updatedTokenConfigEvents: Event[];
        updatedGlobalConfigEvents: Event[];
        globalConfigUpdateTimes: number[];
    };
};
export type ConfigStoreUpdate = {
    success: false;
} | _ConfigStoreUpdate;
export declare const DEFAULT_CONFIG_STORE_VERSION = 0;
export declare enum GLOBAL_CONFIG_STORE_KEYS {
    MAX_RELAYER_REPAYMENT_LEAF_SIZE = "MAX_RELAYER_REPAYMENT_LEAF_SIZE",
    MAX_POOL_REBALANCE_LEAF_SIZE = "MAX_POOL_REBALANCE_LEAF_SIZE",
    VERSION = "VERSION",
    DISABLED_CHAINS = "DISABLED_CHAINS",
    CHAIN_ID_INDICES = "CHAIN_ID_INDICES"
}
export declare class AcrossConfigStoreClient extends BaseAbstractClient {
    readonly logger: winston.Logger;
    readonly configStore: Contract;
    readonly eventSearchConfig: MakeOptional<EventSearchConfig, "toBlock">;
    readonly configStoreVersion: number;
    cumulativeRateModelUpdates: across.rateModel.RateModelEvent[];
    ubaConfigUpdates: UBAConfigUpdates[];
    cumulativeRouteRateModelUpdates: RouteRateModelUpdate[];
    cumulativeMaxRefundCountUpdates: GlobalConfigUpdate[];
    cumulativeMaxL1TokenCountUpdates: GlobalConfigUpdate[];
    chainIdIndicesUpdates: GlobalConfigUpdate<number[]>[];
    cumulativeSpokeTargetBalanceUpdates: SpokeTargetBalanceUpdate[];
    cumulativeConfigStoreVersionUpdates: ConfigStoreVersionUpdate[];
    cumulativeDisabledChainUpdates: DisabledChainsUpdate[];
    protected rateModelDictionary: across.rateModel.RateModelDictionary;
    hasLatestConfigStoreVersion: boolean;
    chainId: number | undefined;
    constructor(logger: winston.Logger, configStore: Contract, eventSearchConfig: MakeOptional<EventSearchConfig, "toBlock">, configStoreVersion: number);
    getRateModelForBlockNumber(l1Token: string, originChainId: number | string, destinationChainId: number | string, blockNumber?: number | undefined): across.constants.RateModel;
    getRouteRateModelForBlockNumber(l1Token: string, route: string, blockNumber?: number | undefined): across.constants.RateModel | undefined;
    /**
     * Resolve the implied set of chain ID indices based on the chain ID of the ConfigStore.
     * @param chainId Chain ID of the ConfigStore.
     * @dev If the resolved chain ID is part of the default set, assume the protocol defaults.
     *      Otherwise, assume this is a test deployment with a lone chain ID.
     * @dev The protocol defaults are [1, 10, 137, 288, 42161] (outlined in UMIP-157).
     * @dev chainId is marked optional to appease tsc. It must always be passed in.
     */
    protected implicitChainIdIndices(chainId?: number): number[];
    /**
     * Resolves the chain ids that were available to the protocol at a given block range.
     * @param blockNumber Block number to search for. Defaults to latest block.
     * @returns List of chain IDs that were available to the protocol at the given block number.
     * @note This dynamic functionality has been added after the launch of Across.
     * @note This function will return a default list of chain IDs if the block requested
     *       existed before the initial inclusion of this dynamic key/value entry. In the
     *       case that a block number is requested that is before the initial inclusion of
     *       this key/value entry, the function will return the default list of chain IDs as
     *       outlined per the UMIP (https://github.com/UMAprotocol/UMIPs/pull/590).
     */
    getChainIdIndicesForBlock(blockNumber?: number): number[];
    getSpokeTargetBalancesForBlock(l1Token: string, chainId: number, blockNumber?: number): SpokePoolTargetBalance;
    getMaxRefundCountForRelayerRefundLeafForBlock(blockNumber?: number): number;
    getMaxL1TokenCountForPoolRebalanceLeafForBlock(blockNumber?: number): number;
    /**
     * Returns list of chains that have been enabled at least once in the block range.
     * If a chain was disabled in the block range, it will be included in the list provided it was enabled
     * at some point in the block range.
     * @dev If fromBlock == toBlock then defaults to returning enabled chains at fromBlock
     * @param fromBlock Start block to search inclusive
     * @param toBlock End block to search inclusive. Defaults to MAX_SAFE_INTEGER, so grabs all disabled chain events
     * up until `latest`.
     * @returns List of chain IDs that have been enabled at least once in the block range. Sorted from lowest to highest.
     */
    getEnabledChainsInBlockRange(fromBlock: number, toBlock?: number): number[];
    getEnabledChains(block?: number): number[];
    getDisabledChainsForBlock(blockNumber?: number): number[];
    getConfigStoreVersionForTimestamp(timestamp?: number): number;
    getConfigStoreVersionForBlock(blockNumber?: number): number;
    hasValidConfigStoreVersionForTimestamp(timestamp?: number): boolean;
    /**
     * Resolve the chain ID for the ConfigStore Provider instance.
     * @dev When the provider is a StatisJsonRpcProvider instance, the getNetwork() is non-blocking.
     * @returns Chain ID for the ConfigStore deployment.
     */
    protected resolveChainId(): Promise<number>;
    protected _update(): Promise<ConfigStoreUpdate>;
    update(): Promise<void>;
    filterDisabledChains(disabledChains: number[]): number[];
    /**
     * Retrieves the most recently set UBA config for a given L1 token address before a block number.
     * @param l1TokenAddress The L1 token address to retrieve the config for
     * @param blockNumber The block number to retrieve the config for. If not specified, sets block to max integer
     * meaning that this function will return the latest config.
     * @returns The UBA config for the given L1 token address and block number, or undefined if no config exists
     * before blockNumber.
     */
    getUBAConfig(l1TokenAddress: string, blockNumber?: number): UBAParsedConfigType | undefined;
}
export {};
