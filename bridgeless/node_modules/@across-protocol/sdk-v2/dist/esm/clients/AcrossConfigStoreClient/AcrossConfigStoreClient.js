import { __assign, __awaiter, __extends, __generator, __rest, __spreadArray } from "tslib";
import { utils, across } from "@uma/sdk";
import assert from "assert";
import { isError } from "../../typeguards";
import { findLast, isArrayOf, isDefined, isPositiveInteger, max, paginatedEventQuery, sortEventsAscendingInPlace, sortEventsDescending, spreadEvent, spreadEventWithBlockNumber, toBN, utf8ToHex, } from "../../utils";
import { PROTOCOL_DEFAULT_CHAIN_ID_INDICES } from "../../constants";
import { parseJSONWithNumericString } from "../../utils/JSONUtils";
import { BaseAbstractClient } from "../BaseAbstractClient";
// Version 0 is the implicit ConfigStore version from before the version attribute was introduced.
// @dev Do not change this value.
export var DEFAULT_CONFIG_STORE_VERSION = 0;
export var GLOBAL_CONFIG_STORE_KEYS;
(function (GLOBAL_CONFIG_STORE_KEYS) {
    GLOBAL_CONFIG_STORE_KEYS["MAX_RELAYER_REPAYMENT_LEAF_SIZE"] = "MAX_RELAYER_REPAYMENT_LEAF_SIZE";
    GLOBAL_CONFIG_STORE_KEYS["MAX_POOL_REBALANCE_LEAF_SIZE"] = "MAX_POOL_REBALANCE_LEAF_SIZE";
    GLOBAL_CONFIG_STORE_KEYS["VERSION"] = "VERSION";
    GLOBAL_CONFIG_STORE_KEYS["DISABLED_CHAINS"] = "DISABLED_CHAINS";
    GLOBAL_CONFIG_STORE_KEYS["CHAIN_ID_INDICES"] = "CHAIN_ID_INDICES";
})(GLOBAL_CONFIG_STORE_KEYS || (GLOBAL_CONFIG_STORE_KEYS = {}));
var AcrossConfigStoreClient = /** @class */ (function (_super) {
    __extends(AcrossConfigStoreClient, _super);
    function AcrossConfigStoreClient(logger, configStore, eventSearchConfig, configStoreVersion) {
        if (eventSearchConfig === void 0) { eventSearchConfig = { fromBlock: 0, maxBlockLookBack: 0 }; }
        var _this = _super.call(this) || this;
        _this.logger = logger;
        _this.configStore = configStore;
        _this.eventSearchConfig = eventSearchConfig;
        _this.configStoreVersion = configStoreVersion;
        _this.cumulativeRateModelUpdates = [];
        _this.ubaConfigUpdates = [];
        _this.cumulativeRouteRateModelUpdates = [];
        _this.cumulativeMaxRefundCountUpdates = [];
        _this.cumulativeMaxL1TokenCountUpdates = [];
        _this.chainIdIndicesUpdates = [];
        _this.cumulativeSpokeTargetBalanceUpdates = [];
        _this.cumulativeConfigStoreVersionUpdates = [];
        _this.cumulativeDisabledChainUpdates = [];
        _this.hasLatestConfigStoreVersion = false;
        _this.firstBlockToSearch = eventSearchConfig.fromBlock;
        _this.latestBlockSearched = 0;
        _this.rateModelDictionary = new across.rateModel.RateModelDictionary();
        return _this;
    }
    // <-- START LEGACY CONFIGURATION OBJECTS -->
    // @dev The following configuration objects are pre-UBA fee model configurations and are deprecated as of version
    // 2 of the ConfigStore. They are kept here for backwards compatibility.
    AcrossConfigStoreClient.prototype.getRateModelForBlockNumber = function (l1Token, originChainId, destinationChainId, blockNumber) {
        if (blockNumber === void 0) { blockNumber = undefined; }
        // Use route-rate model if available, otherwise use default rate model for l1Token.
        var route = "".concat(originChainId, "-").concat(destinationChainId);
        var routeRateModel = this.getRouteRateModelForBlockNumber(l1Token, route, blockNumber);
        return routeRateModel !== null && routeRateModel !== void 0 ? routeRateModel : this.rateModelDictionary.getRateModelForBlockNumber(l1Token, blockNumber);
    };
    AcrossConfigStoreClient.prototype.getRouteRateModelForBlockNumber = function (l1Token, route, blockNumber) {
        if (blockNumber === void 0) { blockNumber = undefined; }
        var config = sortEventsDescending(this.cumulativeRouteRateModelUpdates).find(function (config) { return config.blockNumber <= (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) && config.l1Token === l1Token; });
        if ((config === null || config === void 0 ? void 0 : config.routeRateModel[route]) === undefined) {
            return undefined;
        }
        return across.rateModel.parseAndReturnRateModelFromString(config.routeRateModel[route]);
    };
    /**
     * Resolve the implied set of chain ID indices based on the chain ID of the ConfigStore.
     * @param chainId Chain ID of the ConfigStore.
     * @dev If the resolved chain ID is part of the default set, assume the protocol defaults.
     *      Otherwise, assume this is a test deployment with a lone chain ID.
     * @dev The protocol defaults are [1, 10, 137, 288, 42161] (outlined in UMIP-157).
     * @dev chainId is marked optional to appease tsc. It must always be passed in.
     */
    AcrossConfigStoreClient.prototype.implicitChainIdIndices = function (chainId) {
        assert(isDefined(chainId), "ConfigStoreClient used before update");
        return PROTOCOL_DEFAULT_CHAIN_ID_INDICES[0] === chainId ? PROTOCOL_DEFAULT_CHAIN_ID_INDICES : [chainId];
    };
    /**
     * Resolves the chain ids that were available to the protocol at a given block range.
     * @param blockNumber Block number to search for. Defaults to latest block.
     * @returns List of chain IDs that were available to the protocol at the given block number.
     * @note This dynamic functionality has been added after the launch of Across.
     * @note This function will return a default list of chain IDs if the block requested
     *       existed before the initial inclusion of this dynamic key/value entry. In the
     *       case that a block number is requested that is before the initial inclusion of
     *       this key/value entry, the function will return the default list of chain IDs as
     *       outlined per the UMIP (https://github.com/UMAprotocol/UMIPs/pull/590).
     */
    AcrossConfigStoreClient.prototype.getChainIdIndicesForBlock = function (blockNumber) {
        var _a;
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        // Resolve the chain ID indices for the block number requested.
        var chainIdUpdates = sortEventsDescending(this.chainIdIndicesUpdates);
        // Iterate through each of the chain ID updates and resolve the first update that is
        // less than or equal to the block number requested.
        var chainIdIndices = (_a = chainIdUpdates.find(function (update) { return update.blockNumber <= blockNumber; })) === null || _a === void 0 ? void 0 : _a.value;
        // Return either the found value or the protocol default.
        return chainIdIndices !== null && chainIdIndices !== void 0 ? chainIdIndices : this.implicitChainIdIndices(this.chainId);
    };
    AcrossConfigStoreClient.prototype.getSpokeTargetBalancesForBlock = function (l1Token, chainId, blockNumber) {
        var _a;
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var config = sortEventsDescending(this.cumulativeSpokeTargetBalanceUpdates).find(function (config) { return config.l1Token === l1Token && config.blockNumber <= blockNumber; });
        var targetBalance = (_a = config === null || config === void 0 ? void 0 : config.spokeTargetBalances) === null || _a === void 0 ? void 0 : _a[chainId];
        return targetBalance || { target: toBN(0), threshold: toBN(0) };
    };
    // <-- END LEGACY CONFIGURATION OBJECTS -->
    AcrossConfigStoreClient.prototype.getMaxRefundCountForRelayerRefundLeafForBlock = function (blockNumber) {
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var config = sortEventsDescending(this.cumulativeMaxRefundCountUpdates).find(function (config) { return config.blockNumber <= blockNumber; });
        if (!config) {
            throw new Error("Could not find MaxRefundCount before block ".concat(blockNumber));
        }
        return Number(config.value);
    };
    AcrossConfigStoreClient.prototype.getMaxL1TokenCountForPoolRebalanceLeafForBlock = function (blockNumber) {
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var config = sortEventsDescending(this.cumulativeMaxL1TokenCountUpdates).find(function (config) { return config.blockNumber <= blockNumber; });
        if (!config) {
            throw new Error("Could not find MaxL1TokenCount before block ".concat(blockNumber));
        }
        return Number(config.value);
    };
    /**
     * Returns list of chains that have been enabled at least once in the block range.
     * If a chain was disabled in the block range, it will be included in the list provided it was enabled
     * at some point in the block range.
     * @dev If fromBlock == toBlock then defaults to returning enabled chains at fromBlock
     * @param fromBlock Start block to search inclusive
     * @param toBlock End block to search inclusive. Defaults to MAX_SAFE_INTEGER, so grabs all disabled chain events
     * up until `latest`.
     * @returns List of chain IDs that have been enabled at least once in the block range. Sorted from lowest to highest.
     */
    AcrossConfigStoreClient.prototype.getEnabledChainsInBlockRange = function (fromBlock, toBlock) {
        if (toBlock === void 0) { toBlock = Number.MAX_SAFE_INTEGER; }
        // If our fromBlock is greater than our toBlock, then we have an invalid range.
        if (fromBlock > toBlock) {
            throw new Error("Invalid block range: fromBlock ".concat(fromBlock, " > toBlock ").concat(toBlock));
        }
        // Initiate list with all possible chains enabled at the toBlock while removing any chains
        // that were disabled at the from block.
        var disabledChainsAtFromBlock = this.getDisabledChainsForBlock(fromBlock);
        var allPossibleChains = this.getChainIdIndicesForBlock(toBlock);
        var enabledChainsInBlockRange = allPossibleChains.filter(function (chainId) { return !disabledChainsAtFromBlock.includes(chainId); });
        // If there are any disabled chain updates in the block range, then we might need to update the list of enabled
        // chains in the block range.
        this.cumulativeDisabledChainUpdates
            .filter(function (e) { return e.blockNumber <= toBlock && e.blockNumber >= fromBlock; })
            .forEach(function (e) {
            // If disabled chain update no longer includes a previously disabled chain, then add it back to the enabled chains
            // list.
            var newDisabledSet = e.chainIds;
            disabledChainsAtFromBlock.forEach(function (disabledChain) {
                // New disabled set doesn't include this chain that was previously disabled so it was re-enabled at this point
                // in the block range.
                if (!newDisabledSet.includes(disabledChain)) {
                    enabledChainsInBlockRange.push(disabledChain);
                }
            });
        });
        // Return the enabled chains in the block range sorted in the same order as the chain indices.
        return allPossibleChains.filter(function (chainId) { return enabledChainsInBlockRange.includes(chainId); });
    };
    AcrossConfigStoreClient.prototype.getEnabledChains = function (block) {
        if (block === void 0) { block = Number.MAX_SAFE_INTEGER; }
        // Get most recent disabled chain list before the block specified.
        var currentlyDisabledChains = this.getDisabledChainsForBlock(block);
        return this.getChainIdIndicesForBlock(block).filter(function (chainId) { return !currentlyDisabledChains.includes(chainId); });
    };
    AcrossConfigStoreClient.prototype.getDisabledChainsForBlock = function (blockNumber) {
        var _a, _b;
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        return ((_b = (_a = sortEventsDescending(this.cumulativeDisabledChainUpdates).find(function (config) { return config.blockNumber <= blockNumber; })) === null || _a === void 0 ? void 0 : _a.chainIds) !== null && _b !== void 0 ? _b : []);
    };
    AcrossConfigStoreClient.prototype.getConfigStoreVersionForTimestamp = function (timestamp) {
        if (timestamp === void 0) { timestamp = Number.MAX_SAFE_INTEGER; }
        var config = this.cumulativeConfigStoreVersionUpdates.find(function (config) { return config.timestamp <= timestamp; });
        return isDefined(config) ? Number(config.value) : DEFAULT_CONFIG_STORE_VERSION;
    };
    AcrossConfigStoreClient.prototype.getConfigStoreVersionForBlock = function (blockNumber) {
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        var config = this.cumulativeConfigStoreVersionUpdates.find(function (config) { return config.blockNumber <= blockNumber; });
        return isDefined(config) ? Number(config.value) : DEFAULT_CONFIG_STORE_VERSION;
    };
    AcrossConfigStoreClient.prototype.hasValidConfigStoreVersionForTimestamp = function (timestamp) {
        if (timestamp === void 0) { timestamp = Number.MAX_SAFE_INTEGER; }
        var version = this.getConfigStoreVersionForTimestamp(timestamp);
        return this.configStoreVersion >= version;
    };
    /**
     * Resolve the chain ID for the ConfigStore Provider instance.
     * @dev When the provider is a StatisJsonRpcProvider instance, the getNetwork() is non-blocking.
     * @returns Chain ID for the ConfigStore deployment.
     */
    AcrossConfigStoreClient.prototype.resolveChainId = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!((_a = this.chainId) !== null && _a !== void 0)) return [3 /*break*/, 1];
                        _b = _a;
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, this.configStore.provider.getNetwork()];
                    case 2:
                        _b = (_c.sent()).chainId;
                        _c.label = 3;
                    case 3: return [2 /*return*/, _b];
                }
            });
        });
    };
    AcrossConfigStoreClient.prototype._update = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chainId, searchConfig, _a, _b, updatedTokenConfigEvents, updatedGlobalConfigEvents, globalConfigUpdateTimes;
            var _c;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.resolveChainId()];
                    case 1:
                        chainId = _d.sent();
                        _c = {
                            fromBlock: this.firstBlockToSearch
                        };
                        _a = this.eventSearchConfig.toBlock;
                        if (_a) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.configStore.provider.getBlockNumber()];
                    case 2:
                        _a = (_d.sent());
                        _d.label = 3;
                    case 3:
                        searchConfig = (_c.toBlock = _a,
                            _c.maxBlockLookBack = this.eventSearchConfig.maxBlockLookBack,
                            _c);
                        this.logger.debug({ at: "AcrossConfigStore", message: "Updating ConfigStore client", searchConfig: searchConfig });
                        if (searchConfig.fromBlock > searchConfig.toBlock) {
                            this.logger.warn({ at: "AcrossConfigStore", message: "Invalid search config.", searchConfig: searchConfig });
                            return [2 /*return*/, { success: false }];
                        }
                        return [4 /*yield*/, Promise.all([
                                paginatedEventQuery(this.configStore, this.configStore.filters.UpdatedTokenConfig(), searchConfig),
                                paginatedEventQuery(this.configStore, this.configStore.filters.UpdatedGlobalConfig(), searchConfig),
                            ])];
                    case 4:
                        _b = _d.sent(), updatedTokenConfigEvents = _b[0], updatedGlobalConfigEvents = _b[1];
                        // Events *should* normally be received in ascending order, but explicitly enforce the ordering.
                        [updatedTokenConfigEvents, updatedGlobalConfigEvents].forEach(function (events) { return sortEventsAscendingInPlace(events); });
                        return [4 /*yield*/, Promise.all(updatedGlobalConfigEvents.map(function (event) { return _this.configStore.provider.getBlock(event.blockNumber); }))];
                    case 5:
                        globalConfigUpdateTimes = (_d.sent()).map(function (block) { return block.timestamp; });
                        return [2 /*return*/, {
                                success: true,
                                chainId: chainId,
                                searchEndBlock: searchConfig.toBlock,
                                events: {
                                    updatedTokenConfigEvents: updatedTokenConfigEvents,
                                    updatedGlobalConfigEvents: updatedGlobalConfigEvents,
                                    globalConfigUpdateTimes: globalConfigUpdateTimes,
                                },
                            }];
                }
            });
        });
    };
    AcrossConfigStoreClient.prototype.update = function () {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function () {
            var result, chainId, _f, updatedTokenConfigEvents, updatedGlobalConfigEvents, globalConfigUpdateTimes, _i, updatedTokenConfigEvents_1, event_1, args, parsedValue, l1Token, value, key, passedArgs, rateModelForToken, targetBalances, routeRateModel, err_1, maxWarnAge, _g, errMsg, _loop_1, this_1, i;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0: return [4 /*yield*/, this._update()];
                    case 1:
                        result = _h.sent();
                        if (!result.success) {
                            return [2 /*return*/];
                        }
                        chainId = result.chainId;
                        _f = result.events, updatedTokenConfigEvents = _f.updatedTokenConfigEvents, updatedGlobalConfigEvents = _f.updatedGlobalConfigEvents, globalConfigUpdateTimes = _f.globalConfigUpdateTimes;
                        assert(updatedGlobalConfigEvents.length === globalConfigUpdateTimes.length, "GlobalConfigUpdate events mismatch (".concat(updatedGlobalConfigEvents.length, " != ").concat(globalConfigUpdateTimes.length, ")"));
                        _i = 0, updatedTokenConfigEvents_1 = updatedTokenConfigEvents;
                        _h.label = 2;
                    case 2:
                        if (!(_i < updatedTokenConfigEvents_1.length)) return [3 /*break*/, 7];
                        event_1 = updatedTokenConfigEvents_1[_i];
                        args = __assign({}, spreadEventWithBlockNumber(event_1));
                        _h.label = 3;
                    case 3:
                        _h.trys.push([3, 4, , 6]);
                        parsedValue = parseJSONWithNumericString(args.value);
                        l1Token = args.key;
                        value = args.value, key = args.key, passedArgs = __rest(args, ["value", "key"]);
                        // Drop value and key before passing args.
                        if ((parsedValue === null || parsedValue === void 0 ? void 0 : parsedValue.rateModel) !== undefined) {
                            rateModelForToken = JSON.stringify(parsedValue.rateModel);
                            this.cumulativeRateModelUpdates.push(__assign(__assign({}, passedArgs), { rateModel: rateModelForToken, l1Token: l1Token }));
                            // Store spokeTargetBalances
                            if (parsedValue === null || parsedValue === void 0 ? void 0 : parsedValue.spokeTargetBalances) {
                                targetBalances = Object.fromEntries(Object.entries(parsedValue.spokeTargetBalances).map(function (_a) {
                                    var chainId = _a[0], targetBalance = _a[1];
                                    var target = max(toBN(targetBalance.target), toBN(0));
                                    var threshold = max(toBN(targetBalance.threshold), toBN(0));
                                    return [chainId, { target: target, threshold: threshold }];
                                }));
                                this.cumulativeSpokeTargetBalanceUpdates.push(__assign(__assign({}, passedArgs), { spokeTargetBalances: targetBalances, l1Token: l1Token }));
                            }
                            else {
                                this.cumulativeSpokeTargetBalanceUpdates.push(__assign(__assign({}, passedArgs), { spokeTargetBalances: {}, l1Token: l1Token }));
                            }
                            // Store route-specific rate models
                            if (parsedValue === null || parsedValue === void 0 ? void 0 : parsedValue.routeRateModel) {
                                routeRateModel = Object.fromEntries(Object.entries(parsedValue.routeRateModel).map(function (_a) {
                                    var path = _a[0], routeRateModel = _a[1];
                                    return [path, JSON.stringify(routeRateModel)];
                                }));
                                this.cumulativeRouteRateModelUpdates.push(__assign(__assign({}, passedArgs), { routeRateModel: routeRateModel, l1Token: l1Token }));
                            }
                            else {
                                this.cumulativeRouteRateModelUpdates.push(__assign(__assign({}, passedArgs), { routeRateModel: {}, l1Token: l1Token }));
                            }
                        }
                        return [3 /*break*/, 6];
                    case 4:
                        err_1 = _h.sent();
                        _g = (24 * 60 * 60);
                        return [4 /*yield*/, utils.averageBlockTimeSeconds()];
                    case 5:
                        maxWarnAge = _g / (_h.sent());
                        if (result.searchEndBlock - event_1.blockNumber < maxWarnAge) {
                            errMsg = isError(err_1) ? err_1.message : "unknown error";
                            this.logger.warn({
                                at: "ConfigStore::update",
                                message: "Caught error during ConfigStore update: ".concat(errMsg),
                                update: args,
                            });
                        }
                        else {
                            this.logger.debug({
                                at: "ConfigStoreClient::update",
                                message: "Skipping invalid historical update at block ".concat(event_1.blockNumber),
                            });
                        }
                        return [3 /*break*/, 6];
                    case 6:
                        _i++;
                        return [3 /*break*/, 2];
                    case 7:
                        sortEventsAscendingInPlace(this.ubaConfigUpdates);
                        _loop_1 = function (i) {
                            var event_2 = updatedGlobalConfigEvents[i];
                            var args = __assign({ blockNumber: event_2.blockNumber, transactionIndex: event_2.transactionIndex, logIndex: event_2.logIndex }, spreadEvent(event_2.args));
                            if (args.key === utf8ToHex(GLOBAL_CONFIG_STORE_KEYS.MAX_RELAYER_REPAYMENT_LEAF_SIZE)) {
                                if (!isNaN(args.value)) {
                                    this_1.cumulativeMaxRefundCountUpdates.push(args);
                                }
                            }
                            else if (args.key === utf8ToHex(GLOBAL_CONFIG_STORE_KEYS.CHAIN_ID_INDICES)) {
                                try {
                                    // We need to parse the chain ID indices array from the stringified JSON. However,
                                    // the on-chain string has quotes around the array, which will parse our JSON as a
                                    // string instead of an array. We need to remove these quotes before parsing.
                                    // To be sure, we can check for single quotes, double quotes, and spaces.
                                    var chainIndices_1 = JSON.parse(args.value.replace(/['"\s]/g, ""));
                                    // Check that the array is valid and that every element is a number.
                                    if (!isArrayOf(chainIndices_1, isPositiveInteger)) {
                                        this_1.logger.warn({ at: "ConfigStore", message: "The array ".concat(chainIndices_1, " is invalid.") });
                                        return "continue";
                                    }
                                    // Let's also check that the array doesn't contain any duplicates.
                                    if (new Set(chainIndices_1).size !== chainIndices_1.length) {
                                        this_1.logger.warn({
                                            at: "ConfigStore",
                                            message: "The array ".concat(chainIndices_1, " contains duplicates making it invalid."),
                                        });
                                        return "continue";
                                    }
                                    // Now check that we're only appending positive integers to the chainIndices array on each
                                    // update. If this isn't the case, skip the update & warn. If there is no previous update,
                                    // resolve an implcit chain ID list.
                                    var previousUpdate = (_b = (_a = this_1.chainIdIndicesUpdates.at(-1)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this_1.implicitChainIdIndices(chainId);
                                    // We should now check that previousUpdate is a subset of chainIndices.
                                    if (!previousUpdate.every(function (chainId, idx) { return chainIndices_1[idx] === chainId; })) {
                                        this_1.logger.warn({
                                            at: "ConfigStoreClient#update",
                                            message: "The array ".concat(chainIndices_1, " is invalid. It must be a superset of the previous array ").concat(previousUpdate),
                                        });
                                        return "continue";
                                    }
                                    // If all else passes, we can add this update.
                                    this_1.chainIdIndicesUpdates.push(__assign(__assign({}, args), { value: chainIndices_1 }));
                                }
                                catch (e) {
                                    this_1.logger.warn({ at: "ConfigStore::update", message: "Failed to parse chain ID indices: ".concat(args.value) });
                                }
                            }
                            else if (args.key === utf8ToHex(GLOBAL_CONFIG_STORE_KEYS.MAX_POOL_REBALANCE_LEAF_SIZE)) {
                                if (!isNaN(args.value)) {
                                    this_1.cumulativeMaxL1TokenCountUpdates.push(args);
                                }
                            }
                            else if (args.key === utf8ToHex(GLOBAL_CONFIG_STORE_KEYS.VERSION)) {
                                // If not a number, skip.
                                if (isNaN(args.value)) {
                                    return "continue";
                                }
                                var value = Number(args.value);
                                // If not an integer, skip.
                                if (!Number.isInteger(value)) {
                                    return "continue";
                                }
                                // Extract the current highest version. Require that the version always increments, otherwise skip the update.
                                var lastValue = Number((_d = (_c = this_1.cumulativeConfigStoreVersionUpdates[0]) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : DEFAULT_CONFIG_STORE_VERSION);
                                if (value <= lastValue) {
                                    return "continue";
                                }
                                // Prepend the update to impose descending ordering for version updates.
                                this_1.cumulativeConfigStoreVersionUpdates = __spreadArray([
                                    __assign(__assign({}, args), { timestamp: globalConfigUpdateTimes[i] })
                                ], this_1.cumulativeConfigStoreVersionUpdates, true);
                            }
                            else if (args.key === utf8ToHex(GLOBAL_CONFIG_STORE_KEYS.DISABLED_CHAINS)) {
                                try {
                                    var chainIds = this_1.filterDisabledChains(JSON.parse(args.value));
                                    this_1.cumulativeDisabledChainUpdates.push(__assign(__assign({}, args), { chainIds: chainIds }));
                                }
                                catch (err) {
                                    // Can't parse list, skip.
                                }
                            }
                            else {
                                return "continue";
                            }
                        };
                        this_1 = this;
                        // Save new Global config updates.
                        for (i = 0; i < updatedGlobalConfigEvents.length; i++) {
                            _loop_1(i);
                        }
                        this.rateModelDictionary.updateWithEvents(this.cumulativeRateModelUpdates);
                        this.hasLatestConfigStoreVersion = this.hasValidConfigStoreVersionForTimestamp();
                        this.latestBlockSearched = result.searchEndBlock;
                        this.firstBlockToSearch = result.searchEndBlock + 1; // Next iteration should start off from where this one ended.
                        this.chainId = (_e = this.chainId) !== null && _e !== void 0 ? _e : chainId; // Update on the first run only.
                        this.isUpdated = true;
                        this.logger.debug({ at: "ConfigStore", message: "ConfigStore client updated!" });
                        return [2 /*return*/];
                }
            });
        });
    };
    AcrossConfigStoreClient.prototype.filterDisabledChains = function (disabledChains) {
        // If any chain ID's are not integers then ignore. UMIP-157 requires that this key cannot include
        // the chain ID 1.
        return disabledChains.filter(function (chainId) { return !isNaN(chainId) && Number.isInteger(chainId) && chainId !== 1; });
    };
    /**
     * Retrieves the most recently set UBA config for a given L1 token address before a block number.
     * @param l1TokenAddress The L1 token address to retrieve the config for
     * @param blockNumber The block number to retrieve the config for. If not specified, sets block to max integer
     * meaning that this function will return the latest config.
     * @returns The UBA config for the given L1 token address and block number, or undefined if no config exists
     * before blockNumber.
     */
    AcrossConfigStoreClient.prototype.getUBAConfig = function (l1TokenAddress, blockNumber) {
        if (blockNumber === void 0) { blockNumber = Number.MAX_SAFE_INTEGER; }
        // We only care about searching on the block number and not any events that occurred in the same block
        // but with a lower transaction index. In other words, if the UBA config was updated as the absolute
        // last transaction in a block, the update still applies to all preceding UBA events in the same block.
        // This is a simplifying assumption that we can make because the ConfigStore admin role is whitelisted and assumed
        // to be acting in the best interest of the protocol.
        var config = findLast(this.ubaConfigUpdates, function (config) { return config.l1Token === l1TokenAddress && config.blockNumber <= blockNumber; });
        return config === null || config === void 0 ? void 0 : config.config;
    };
    return AcrossConfigStoreClient;
}(BaseAbstractClient));
export { AcrossConfigStoreClient };
//# sourceMappingURL=AcrossConfigStoreClient.js.map