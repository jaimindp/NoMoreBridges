import { __assign, __awaiter, __extends, __generator } from "tslib";
import assert from "assert";
import { random } from "lodash";
import { ZERO_ADDRESS } from "../../constants";
import { FillType, } from "../../interfaces";
import { bnZero, toBN, toBNWei, forEachAsync, getCurrentTime, isV2Deposit, isV2Fill, isV3Deposit, isV3Fill, randomAddress, } from "../../utils";
import { SpokePoolClient } from "../SpokePoolClient";
import { getEventManager } from "./MockEvents";
// This class replaces internal SpokePoolClient functionality, enabling the
// user to bypass on-chain queries and inject ethers Event objects directly.
var MockSpokePoolClient = /** @class */ (function (_super) {
    __extends(MockSpokePoolClient, _super);
    function MockSpokePoolClient(logger, spokePool, chainId, deploymentBlock) {
        var _this = _super.call(this, logger, spokePool, null, chainId, deploymentBlock) || this;
        _this.realizedLpFeePct = bnZero;
        _this.realizedLpFeePctOverride = false;
        _this.destinationTokenForChainOverride = {};
        // Allow tester to set the numberOfDeposits() returned by SpokePool at a block height.
        _this.depositIdAtBlock = [];
        _this.numberOfDeposits = 0;
        _this.blocks = {};
        // Event signatures. Not strictly required, but they make generated events more recognisable.
        _this.eventSignatures = {
            EnabledDepositRoute: "address,uint256,bool",
            FilledRelay: "uint256,uint256,uint256,int64,uint32,uint32,address,address,address,bytes",
            FundsDeposited: "uint256,uint256,uint256,int64,uint32,uint32,address,address,address,bytes",
        };
        _this.latestBlockSearched = deploymentBlock;
        _this.eventManager = getEventManager(chainId, _this.eventSignatures, deploymentBlock);
        return _this;
    }
    MockSpokePoolClient.prototype.setDefaultRealizedLpFeePct = function (fee) {
        this.realizedLpFeePct = fee;
        this.realizedLpFeePctOverride = true;
    };
    MockSpokePoolClient.prototype.clearDefaultRealizedLpFeePct = function () {
        this.realizedLpFeePctOverride = false;
    };
    MockSpokePoolClient.prototype.computeRealizedLpFeePct = function (depositEvent) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, realizedLpFeePct, realizedLpFeePctOverride, quoteBlock, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this, realizedLpFeePct = _a.realizedLpFeePct, realizedLpFeePctOverride = _a.realizedLpFeePctOverride;
                        quoteBlock = depositEvent.blockNumber;
                        if (!realizedLpFeePctOverride) return [3 /*break*/, 1];
                        _b = { realizedLpFeePct: realizedLpFeePct, quoteBlock: quoteBlock };
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, _super.prototype.computeRealizedLpFeePct.call(this, depositEvent)];
                    case 2:
                        _b = _c.sent();
                        _c.label = 3;
                    case 3: return [2 /*return*/, _b];
                }
            });
        });
    };
    MockSpokePoolClient.prototype.batchComputeRealizedLpFeePct = function (depositEvents) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, realizedLpFeePct, realizedLpFeePctOverride, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this, realizedLpFeePct = _a.realizedLpFeePct, realizedLpFeePctOverride = _a.realizedLpFeePctOverride;
                        if (!realizedLpFeePctOverride) return [3 /*break*/, 1];
                        _b = depositEvents.map(function (_a) {
                            var quoteBlock = _a.blockNumber;
                            return { realizedLpFeePct: realizedLpFeePct, quoteBlock: quoteBlock };
                        });
                        return [3 /*break*/, 3];
                    case 1: return [4 /*yield*/, _super.prototype.batchComputeRealizedLpFeePct.call(this, depositEvents)];
                    case 2:
                        _b = _c.sent();
                        _c.label = 3;
                    case 3: return [2 /*return*/, _b];
                }
            });
        });
    };
    MockSpokePoolClient.prototype.setDestinationTokenForChain = function (chainId, token) {
        this.destinationTokenForChainOverride[chainId] = token;
    };
    MockSpokePoolClient.prototype.getDestinationTokenForDeposit = function (deposit) {
        var _a;
        return (_a = this.destinationTokenForChainOverride[deposit.originChainId]) !== null && _a !== void 0 ? _a : _super.prototype.getDestinationTokenForDeposit.call(this, deposit);
    };
    MockSpokePoolClient.prototype.setLatestBlockNumber = function (blockNumber) {
        this.latestBlockSearched = blockNumber;
    };
    MockSpokePoolClient.prototype.setDepositIds = function (_depositIds) {
        this.depositIdAtBlock = [];
        if (_depositIds.length === 0) {
            return;
        }
        var lastDepositId = _depositIds[0];
        for (var i = 0; i < _depositIds.length; i++) {
            if (_depositIds[i] < lastDepositId) {
                throw new Error("deposit ID must be equal to or greater than previous");
            }
            this.depositIdAtBlock[i] = _depositIds[i];
            lastDepositId = _depositIds[i];
        }
    };
    MockSpokePoolClient.prototype._getDepositIdAtBlock = function (blockTag) {
        return Promise.resolve(this.depositIdAtBlock[blockTag]);
    };
    MockSpokePoolClient.prototype._update = function (eventsToQuery) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var latestBlockSearched, currentTime, blocks, events, idx, latestDepositId;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        latestBlockSearched = this.eventManager.blockNumber;
                        currentTime = getCurrentTime();
                        blocks = {};
                        events = eventsToQuery.map(function () { return []; });
                        return [4 /*yield*/, forEachAsync(this.eventManager.getEvents().flat(), function (event) { return __awaiter(_this, void 0, void 0, function () {
                                var idx, _a, _b;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            idx = eventsToQuery.indexOf(event.event);
                                            if (!(idx !== -1)) return [3 /*break*/, 2];
                                            events[idx].push(event);
                                            _a = blocks;
                                            _b = event.blockNumber;
                                            return [4 /*yield*/, event.getBlock()];
                                        case 1:
                                            _a[_b] = _c.sent();
                                            _c.label = 2;
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        _b.sent();
                        this.blocks = blocks;
                        idx = eventsToQuery.indexOf("FundsDeposited");
                        latestDepositId = ((_a = events[idx]) !== null && _a !== void 0 ? _a : []).reduce(function (depositId, event) { var _a, _b; return Math.max(depositId, (_b = (_a = event.args) === null || _a === void 0 ? void 0 : _a["depositId"]) !== null && _b !== void 0 ? _b : 0); }, this.latestDepositIdQueried);
                        return [2 /*return*/, {
                                success: true,
                                firstDepositId: 0,
                                latestDepositId: latestDepositId,
                                currentTime: currentTime,
                                oldestTime: 0,
                                events: events,
                                searchEndBlock: this.eventSearchConfig.toBlock || latestBlockSearched,
                            }];
                }
            });
        });
    };
    MockSpokePoolClient.prototype.deposit = function (deposit) {
        var _a, _b, _c, _d, _e, _f, _g;
        assert(isV2Deposit(deposit));
        var event = "FundsDeposited";
        var blockNumber = deposit.blockNumber, transactionIndex = deposit.transactionIndex;
        var depositId = deposit.depositId, depositor = deposit.depositor, destinationChainId = deposit.destinationChainId;
        depositId !== null && depositId !== void 0 ? depositId : (depositId = this.numberOfDeposits);
        assert(depositId >= this.numberOfDeposits, "".concat(depositId, " < ").concat(this.numberOfDeposits));
        this.numberOfDeposits = depositId + 1;
        destinationChainId !== null && destinationChainId !== void 0 ? destinationChainId : (destinationChainId = random(1, 42161, false));
        depositor !== null && depositor !== void 0 ? depositor : (depositor = randomAddress());
        var message = (_a = deposit["message"]) !== null && _a !== void 0 ? _a : "".concat(event, " event at block ").concat(blockNumber, ", index ").concat(transactionIndex, ".");
        var topics = [destinationChainId, depositId, depositor];
        var args = {
            amount: (_b = deposit.amount) !== null && _b !== void 0 ? _b : toBNWei(random(1, 1000, false)),
            originChainId: (_c = deposit.originChainId) !== null && _c !== void 0 ? _c : this.chainId,
            destinationChainId: destinationChainId,
            relayerFeePct: (_d = deposit.relayerFeePct) !== null && _d !== void 0 ? _d : toBNWei(0.0001),
            depositId: depositId,
            quoteTimestamp: (_e = deposit.quoteTimestamp) !== null && _e !== void 0 ? _e : getCurrentTime(),
            originToken: (_f = deposit.originToken) !== null && _f !== void 0 ? _f : randomAddress(),
            recipient: (_g = deposit.recipient) !== null && _g !== void 0 ? _g : depositor,
            depositor: depositor,
            message: message,
        };
        return this.eventManager.generateEvent({
            event: event,
            address: this.spokePool.address,
            topics: topics.map(function (topic) { return topic.toString(); }),
            args: args,
            blockNumber: blockNumber,
            transactionIndex: transactionIndex,
        });
    };
    MockSpokePoolClient.prototype.depositV3 = function (deposit) {
        var _a, _b, _c, _d, _e, _f, _g;
        assert(isV3Deposit(deposit));
        var event = "V3FundsDeposited";
        var blockNumber = deposit.blockNumber, transactionIndex = deposit.transactionIndex;
        var depositId = deposit.depositId, depositor = deposit.depositor, destinationChainId = deposit.destinationChainId, inputToken = deposit.inputToken, inputAmount = deposit.inputAmount, outputToken = deposit.outputToken, outputAmount = deposit.outputAmount;
        depositId !== null && depositId !== void 0 ? depositId : (depositId = this.numberOfDeposits);
        assert(depositId >= this.numberOfDeposits, "".concat(depositId, " < ").concat(this.numberOfDeposits));
        this.numberOfDeposits = depositId + 1;
        destinationChainId !== null && destinationChainId !== void 0 ? destinationChainId : (destinationChainId = random(1, 42161, false));
        depositor !== null && depositor !== void 0 ? depositor : (depositor = randomAddress());
        inputToken !== null && inputToken !== void 0 ? inputToken : (inputToken = randomAddress());
        outputToken !== null && outputToken !== void 0 ? outputToken : (outputToken = inputToken);
        inputAmount !== null && inputAmount !== void 0 ? inputAmount : (inputAmount = toBNWei(random(1, 1000, false)));
        outputAmount !== null && outputAmount !== void 0 ? outputAmount : (outputAmount = inputAmount.mul(toBN("0.95")));
        var message = (_a = deposit["message"]) !== null && _a !== void 0 ? _a : "".concat(event, " event at block ").concat(blockNumber, ", index ").concat(transactionIndex, ".");
        var topics = [destinationChainId, depositId, depositor];
        var quoteTimestamp = (_b = deposit.quoteTimestamp) !== null && _b !== void 0 ? _b : getCurrentTime();
        var args = {
            depositId: depositId,
            originChainId: (_c = deposit.originChainId) !== null && _c !== void 0 ? _c : this.chainId,
            destinationChainId: destinationChainId,
            depositor: depositor,
            recipient: (_d = deposit.recipient) !== null && _d !== void 0 ? _d : depositor,
            inputToken: inputToken,
            inputAmount: inputAmount,
            outputToken: outputToken,
            outputAmount: outputAmount,
            quoteTimestamp: quoteTimestamp,
            fillDeadline: (_e = deposit.fillDeadline) !== null && _e !== void 0 ? _e : quoteTimestamp + 3600,
            exclusiveRelayer: (_f = deposit.exclusiveRelayer) !== null && _f !== void 0 ? _f : ZERO_ADDRESS,
            exclusivityDeadline: (_g = deposit.exclusivityDeadline) !== null && _g !== void 0 ? _g : quoteTimestamp + 600,
            message: message,
        };
        return this.eventManager.generateEvent({
            event: event,
            address: this.spokePool.address,
            topics: topics.map(function (topic) { return topic.toString(); }),
            args: args,
            blockNumber: blockNumber,
            transactionIndex: transactionIndex,
        });
    };
    MockSpokePoolClient.prototype.fillRelay = function (fill) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        assert(isV2Fill(fill));
        var event = "FilledRelay";
        var blockNumber = fill.blockNumber, transactionIndex = fill.transactionIndex;
        var depositor = fill.depositor, originChainId = fill.originChainId, depositId = fill.depositId;
        originChainId !== null && originChainId !== void 0 ? originChainId : (originChainId = random(1, 42161, false));
        depositId !== null && depositId !== void 0 ? depositId : (depositId = random(1, 100000, false));
        depositor !== null && depositor !== void 0 ? depositor : (depositor = randomAddress());
        var topics = [originChainId, depositId, depositor];
        var recipient = (_a = fill.recipient) !== null && _a !== void 0 ? _a : randomAddress();
        var amount = (_b = fill.amount) !== null && _b !== void 0 ? _b : toBNWei(random(1, 1000, false));
        var relayerFeePct = (_c = fill.relayerFeePct) !== null && _c !== void 0 ? _c : toBNWei(0.0001);
        var message = (_d = fill["message"]) !== null && _d !== void 0 ? _d : "".concat(event, " event at block ").concat(blockNumber, ", index ").concat(transactionIndex, ".");
        var args = {
            amount: amount,
            totalFilledAmount: (_e = fill.totalFilledAmount) !== null && _e !== void 0 ? _e : amount,
            fillAmount: (_f = fill.fillAmount) !== null && _f !== void 0 ? _f : amount,
            repaymentChainId: (_g = fill.repaymentChainId) !== null && _g !== void 0 ? _g : this.chainId,
            originChainId: originChainId,
            destinationChainId: fill.destinationChainId,
            realizedLpFeePct: (_h = fill.realizedLpFeePct) !== null && _h !== void 0 ? _h : toBNWei(random(0.00001, 0.0001).toPrecision(6)),
            relayerFeePct: relayerFeePct,
            depositId: depositId,
            destinationToken: (_j = fill.destinationToken) !== null && _j !== void 0 ? _j : ZERO_ADDRESS,
            relayer: (_k = fill.relayer) !== null && _k !== void 0 ? _k : randomAddress(),
            depositor: depositor,
            recipient: recipient,
            message: message,
            updatableRelayData: {
                updatableRecipient: (_m = (_l = fill.updatableRelayData) === null || _l === void 0 ? void 0 : _l.updatedRecipient) !== null && _m !== void 0 ? _m : recipient,
                updatableMessage: (_p = (_o = fill.updatableRelayData) === null || _o === void 0 ? void 0 : _o.updatedMessage) !== null && _p !== void 0 ? _p : message,
                updatedRelayerFeePct: (_r = (_q = fill.updatableRelayData) === null || _q === void 0 ? void 0 : _q.relayerFeePct) !== null && _r !== void 0 ? _r : relayerFeePct,
                isSlowRelay: (_t = (_s = fill.updatableRelayData) === null || _s === void 0 ? void 0 : _s.isSlowRelay) !== null && _t !== void 0 ? _t : false,
                payoutAdjustmentPct: (_v = (_u = fill.updatableRelayData) === null || _u === void 0 ? void 0 : _u.payoutAdjustmentPct) !== null && _v !== void 0 ? _v : bnZero,
            },
        };
        return this.eventManager.generateEvent({
            event: event,
            address: this.spokePool.address,
            topics: topics.map(function (topic) { return topic.toString(); }),
            args: args,
            blockNumber: blockNumber,
            transactionIndex: transactionIndex,
        });
    };
    MockSpokePoolClient.prototype.fillV3Relay = function (fill) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        assert(isV3Fill(fill));
        var event = "FilledV3Relay";
        var blockNumber = fill.blockNumber, transactionIndex = fill.transactionIndex;
        var originChainId = fill.originChainId, depositId = fill.depositId, inputToken = fill.inputToken, inputAmount = fill.inputAmount, outputAmount = fill.outputAmount, fillDeadline = fill.fillDeadline, relayer = fill.relayer;
        originChainId !== null && originChainId !== void 0 ? originChainId : (originChainId = random(1, 42161, false));
        depositId !== null && depositId !== void 0 ? depositId : (depositId = random(1, 100000, false));
        inputToken !== null && inputToken !== void 0 ? inputToken : (inputToken = randomAddress());
        inputAmount !== null && inputAmount !== void 0 ? inputAmount : (inputAmount = toBNWei(random(1, 1000, false)));
        outputAmount !== null && outputAmount !== void 0 ? outputAmount : (outputAmount = inputAmount);
        fillDeadline !== null && fillDeadline !== void 0 ? fillDeadline : (fillDeadline = getCurrentTime() + 60);
        relayer !== null && relayer !== void 0 ? relayer : (relayer = randomAddress());
        var topics = [originChainId, depositId, relayer];
        var recipient = (_a = fill.recipient) !== null && _a !== void 0 ? _a : randomAddress();
        var message = (_b = fill["message"]) !== null && _b !== void 0 ? _b : "".concat(event, " event at block ").concat(blockNumber, ", index ").concat(transactionIndex, ".");
        var args = {
            inputToken: inputToken,
            outputToken: (_c = fill.outputToken) !== null && _c !== void 0 ? _c : ZERO_ADDRESS,
            inputAmount: fill.inputAmount,
            outputAmount: fill.outputAmount,
            repaymentChainId: (_d = fill.repaymentChainId) !== null && _d !== void 0 ? _d : this.chainId,
            originChainId: originChainId,
            depositId: depositId,
            fillDeadline: fillDeadline,
            exclusivityDeadline: (_e = fill.exclusivityDeadline) !== null && _e !== void 0 ? _e : fillDeadline,
            exclusiveRelayer: (_f = fill.exclusiveRelayer) !== null && _f !== void 0 ? _f : ZERO_ADDRESS,
            relayer: relayer,
            depositor: (_g = fill.depositor) !== null && _g !== void 0 ? _g : randomAddress(),
            recipient: recipient,
            message: message,
            relayExecutionInfo: {
                updatedRecipient: (_j = (_h = fill.relayExecutionInfo) === null || _h === void 0 ? void 0 : _h.updatedRecipient) !== null && _j !== void 0 ? _j : recipient,
                updatedMessage: (_l = (_k = fill.relayExecutionInfo) === null || _k === void 0 ? void 0 : _k.updatedMessage) !== null && _l !== void 0 ? _l : message,
                updatedOutputAmount: (_o = (_m = fill.relayExecutionInfo) === null || _m === void 0 ? void 0 : _m.updatedOutputAmount) !== null && _o !== void 0 ? _o : outputAmount,
                fillType: (_q = (_p = fill.relayExecutionInfo) === null || _p === void 0 ? void 0 : _p.fillType) !== null && _q !== void 0 ? _q : FillType.FastFill,
            },
        };
        return this.eventManager.generateEvent({
            event: event,
            address: this.spokePool.address,
            topics: topics.map(function (topic) { return topic.toString(); }),
            args: args,
            blockNumber: blockNumber,
            transactionIndex: transactionIndex,
        });
    };
    MockSpokePoolClient.prototype.speedUpDeposit = function (speedUp) {
        var event = "RequestedSpeedUpDeposit";
        var topics = [speedUp.depositId, speedUp.depositor];
        var args = __assign({}, speedUp);
        return this.eventManager.generateEvent({
            event: event,
            address: this.spokePool.address,
            topics: topics.map(function (topic) { return topic.toString(); }),
            args: args,
        });
    };
    MockSpokePoolClient.prototype.speedUpV3Deposit = function (speedUp) {
        var event = "RequestedSpeedUpV3Deposit";
        var topics = [speedUp.depositId, speedUp.depositor];
        var args = __assign({}, speedUp);
        return this.eventManager.generateEvent({
            event: event,
            address: this.spokePool.address,
            topics: topics.map(function (topic) { return topic.toString(); }),
            args: args,
        });
    };
    MockSpokePoolClient.prototype.requestV3SlowFill = function (request) {
        var event = "RequestedV3SlowFill";
        var originChainId = request.originChainId, depositId = request.depositId;
        var topics = [originChainId, depositId];
        var args = __assign({}, request);
        return this.eventManager.generateEvent({
            event: event,
            address: this.spokePool.address,
            topics: topics.map(function (topic) { return topic.toString(); }),
            args: args,
            blockNumber: request.blockNumber,
            transactionIndex: request.transactionIndex,
        });
    };
    // This is a simple wrapper around fillV3Relay().
    // rootBundleId and proof are discarded here - we have no interest in verifying that.
    MockSpokePoolClient.prototype.executeV3SlowRelayLeaf = function (leaf) {
        var fill = __assign(__assign({}, leaf.relayData), { destinationChainId: this.chainId, relayer: ZERO_ADDRESS, repaymentChainId: 0, relayExecutionInfo: {
                updatedRecipient: leaf.relayData.recipient,
                updatedOutputAmount: leaf.updatedOutputAmount,
                updatedMessage: leaf.relayData.message,
                fillType: FillType.SlowFill,
            } });
        return this.fillV3Relay(fill);
    };
    MockSpokePoolClient.prototype.executeRelayerRefundLeaf = function (refund) {
        var _a;
        var event = "ExecutedRelayerRefundRoot";
        var chainId = (_a = refund.chainId) !== null && _a !== void 0 ? _a : this.chainId;
        assert(chainId === this.chainId);
        var rootBundleId = refund.rootBundleId, leafId = refund.leafId;
        var topics = [chainId, rootBundleId, leafId];
        var args = {
            chainId: chainId,
            rootBundleId: rootBundleId,
            leafId: leafId,
            amountToReturn: refund.amountToReturn,
            l2TokenAddress: refund.l2TokenAddress,
            refundAddresses: refund.refundAddresses,
            refundAmounts: refund.refundAmounts,
        };
        return this.eventManager.generateEvent({
            event: event,
            address: this.spokePool.address,
            topics: topics.map(function (topic) { return topic.toString(); }),
            args: args,
            blockNumber: refund.blockNumber,
        });
    };
    MockSpokePoolClient.prototype.setEnableRoute = function (originToken, destinationChainId, enabled, overrides) {
        if (overrides === void 0) { overrides = {}; }
        var event = "EnabledDepositRoute";
        var topics = [originToken, destinationChainId];
        var args = { originToken: originToken, destinationChainId: destinationChainId, enabled: enabled };
        return this.eventManager.generateEvent({
            event: event,
            address: this.spokePool.address,
            topics: topics.map(function (topic) { return topic.toString(); }),
            args: args,
            blockNumber: overrides.blockNumber,
        });
    };
    return MockSpokePoolClient;
}(SpokePoolClient));
export { MockSpokePoolClient };
//# sourceMappingURL=MockSpokePoolClient.js.map