import assert from "assert";
import { utils as ethersUtils } from "ethers";
import { random } from "lodash";
import { isDefined, randomAddress, toBN } from "../../utils";
var id = ethersUtils.id, keccak256 = ethersUtils.keccak256, toUtf8Bytes = ethersUtils.toUtf8Bytes;
var eventManagers = {};
// May need to populate getTransaction and getTransactionReceipt if calling code starts using it.
// https://docs.ethers.org/v5/api/providers/provider/#Provider-getTransaction
var getTransaction = function () {
    throw new Error("getTransaction() not supported");
};
// https://docs.ethers.org/v5/api/providers/provider/#Provider-getTransactionReceipt
var getTransactionReceipt = function () {
    throw new Error("getTransactionReceipt() not supported");
};
var removeListener = function () {
    throw new Error("removeListener not supported");
};
var EventManager = /** @class */ (function () {
    function EventManager(blockNumber) {
        if (blockNumber === void 0) { blockNumber = 0; }
        this.blockNumber = blockNumber;
        this.logIndexes = {};
        this.events = [];
        this.minBlockRange = 10;
        this.eventSignatures = {};
    }
    EventManager.prototype.addEventSignatures = function (eventSignatures) {
        var _this = this;
        Object.entries(eventSignatures).forEach(function (_a) {
            var event = _a[0], signature = _a[1];
            if (isDefined(_this.eventSignatures[event])) {
                assert(signature === _this.eventSignatures[event], "Event ".concat(event, " conflict detected."));
            }
            _this.eventSignatures[event] = signature;
        });
    };
    EventManager.prototype.addEvent = function (event) {
        this.events.push(event);
    };
    EventManager.prototype.getEvents = function () {
        var events = this.events;
        this.events = [];
        return events;
    };
    EventManager.prototype.generateEvent = function (inputs) {
        var _a;
        var _b;
        var address = inputs.address, event = inputs.event, _topics = inputs.topics, data = inputs.data, args = inputs.args;
        var eventSignature = "".concat(event, "(").concat(this.eventSignatures[event], ")");
        var topics = [keccak256(toUtf8Bytes(eventSignature))].concat(_topics);
        var blockNumber = inputs.blockNumber, transactionIndex = inputs.transactionIndex;
        // Increment the block number by at least 1, by default. The caller may override
        // to force the same block number to be used, but never a previous block number.
        blockNumber !== null && blockNumber !== void 0 ? blockNumber : (blockNumber = random(this.blockNumber + 1, this.blockNumber + this.minBlockRange, false));
        assert(blockNumber >= this.blockNumber, "".concat(blockNumber, " < ").concat(this.blockNumber));
        this.blockNumber = blockNumber;
        transactionIndex !== null && transactionIndex !== void 0 ? transactionIndex : (transactionIndex = random(1, 32, false));
        var transactionHash = id("Across-v2-".concat(event, "-").concat(blockNumber, "-").concat(transactionIndex, "-").concat(random(1, 100000)));
        var _logIndex = "".concat(blockNumber, "-").concat(transactionIndex);
        (_a = (_b = this.logIndexes)[_logIndex]) !== null && _a !== void 0 ? _a : (_b[_logIndex] = 0);
        var logIndex = this.logIndexes[_logIndex]++;
        var decodeError = new Error("".concat(event, " decoding error"));
        var parentHash = id("Across-v2-blockHash-".concat(random(1, 100000)));
        var blockHash = id("Across-v2-blockHash-".concat(parentHash, "-").concat(random(1, 100000)));
        // getBlock() may later be used to retrieve (for example) the block timestamp.
        // @todo: If multiple events coincide on the same block number, this callback should return the same Block object.
        var getBlock = function () {
            return Promise.resolve({
                hash: blockHash,
                parentHash: parentHash,
                number: blockNumber,
                timestamp: Math.floor(Date.now() / 1000),
                nonce: "",
                difficulty: random(1, 1000, false),
                _difficulty: toBN(random(1, 1000, false)),
                gasLimit: toBN(random(1000000, 10000000, false)),
                gasUsed: toBN(random(1, 1000, false)),
                miner: randomAddress(),
                extraData: "Block containing test transaction ".concat(transactionHash, "."),
                transactions: [transactionHash],
            });
        };
        var generatedEvent = {
            blockNumber: blockNumber,
            transactionIndex: transactionIndex,
            logIndex: logIndex,
            transactionHash: transactionHash,
            removed: false,
            address: address,
            data: data !== null && data !== void 0 ? data : id("Across-v2-random-txndata-".concat(random(1, 100000))),
            topics: topics,
            args: args,
            blockHash: blockHash,
            event: event,
            eventSignature: eventSignature,
            decodeError: decodeError,
            getBlock: getBlock,
            getTransaction: getTransaction,
            getTransactionReceipt: getTransactionReceipt,
            removeListener: removeListener,
        };
        this.addEvent(generatedEvent);
        return generatedEvent;
    };
    return EventManager;
}());
export { EventManager };
/**
 * @description Retrieve an instance of the EventManager for a specific chain, or instantiate a new one.
 * @param chainId Chain ID to retrieve EventManager for.
 * @param eventSignatures Event Signatures to append to EventManager instance.
 * @param Initial blockNumber to use if a new EventManager is instantiated.
 * @returns EventManager instance for chain ID.
 */
export function getEventManager(chainId, eventSignatures, blockNumber) {
    if (!isDefined(eventManagers[chainId])) {
        eventManagers[chainId] = new EventManager(blockNumber);
    }
    var eventManager = eventManagers[chainId];
    if (isDefined(eventSignatures)) {
        eventManager.addEventSignatures(eventSignatures);
    }
    return eventManager;
}
//# sourceMappingURL=MockEvents.js.map