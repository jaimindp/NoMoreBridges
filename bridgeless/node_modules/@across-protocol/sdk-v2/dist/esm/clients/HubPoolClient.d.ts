import { BigNumber, Contract, Event, EventFilter } from "ethers";
import winston from "winston";
import { CachingMechanismInterface, CancelledRootBundle, CrossChainContractsSet, Deposit, DestinationTokenWithBlock, DisputedRootBundle, ExecutedRootBundle, L1Token, LpToken, PendingRootBundle, ProposedRootBundle, RealizedLpFee, TokenRunningBalance, V2DepositWithBlock, V3DepositWithBlock } from "../interfaces";
import { BlockFinder, EventSearchConfig, MakeOptional } from "../utils";
import { AcrossConfigStoreClient as ConfigStoreClient } from "./AcrossConfigStoreClient/AcrossConfigStoreClient";
import { BaseAbstractClient } from "./BaseAbstractClient";
type _HubPoolUpdate = {
    success: true;
    currentTime: number;
    pendingRootBundleProposal: PendingRootBundle;
    events: Record<string, Event[]>;
    searchEndBlock: number;
};
export type HubPoolUpdate = {
    success: false;
} | _HubPoolUpdate;
type HubPoolEvent = "SetPoolRebalanceRoute" | "L1TokenEnabledForLiquidityProvision" | "ProposeRootBundle" | "RootBundleCanceled" | "RootBundleDisputed" | "RootBundleExecuted" | "CrossChainContractsSet";
type L1TokensToDestinationTokens = {
    [l1Token: string]: {
        [destinationChainId: number]: string;
    };
};
type V2PartialDepositWithBlock = Pick<V2DepositWithBlock, "originChainId" | "originToken" | "amount" | "quoteTimestamp">;
type V3PartialDepositWithBlock = Pick<V3DepositWithBlock, "originChainId" | "inputToken" | "inputAmount" | "quoteTimestamp">;
export type LpFeeRequest = (V2PartialDepositWithBlock | V3PartialDepositWithBlock) & {
    paymentChainId?: number;
};
export declare class HubPoolClient extends BaseAbstractClient {
    readonly logger: winston.Logger;
    readonly hubPool: Contract;
    configStoreClient: ConfigStoreClient;
    deploymentBlock: number;
    readonly chainId: number;
    readonly eventSearchConfig: MakeOptional<EventSearchConfig, "toBlock">;
    protected readonly configOverride: {
        ignoredHubExecutedBundles: number[];
        ignoredHubProposedBundles: number[];
        timeToCache?: number;
    };
    protected l1TokensToDestinationTokens: L1TokensToDestinationTokens;
    protected l1Tokens: L1Token[];
    protected lpTokens: {
        [token: string]: LpToken;
    };
    protected proposedRootBundles: ProposedRootBundle[];
    protected canceledRootBundles: CancelledRootBundle[];
    protected disputedRootBundles: DisputedRootBundle[];
    protected executedRootBundles: ExecutedRootBundle[];
    protected crossChainContracts: {
        [l2ChainId: number]: CrossChainContractsSet[];
    };
    protected l1TokensToDestinationTokensWithBlock: {
        [l1Token: string]: {
            [destinationChainId: number]: DestinationTokenWithBlock[];
        };
    };
    protected pendingRootBundle: PendingRootBundle | undefined;
    currentTime: number | undefined;
    readonly blockFinder: BlockFinder;
    constructor(logger: winston.Logger, hubPool: Contract, configStoreClient: ConfigStoreClient, deploymentBlock?: number, chainId?: number, eventSearchConfig?: MakeOptional<EventSearchConfig, "toBlock">, configOverride?: {
        ignoredHubExecutedBundles: number[];
        ignoredHubProposedBundles: number[];
        timeToCache?: number;
    }, cachingMechanism?: CachingMechanismInterface);
    protected hubPoolEventFilters(): Record<HubPoolEvent, EventFilter>;
    hasPendingProposal(): boolean;
    getPendingRootBundle(): PendingRootBundle | undefined;
    getProposedRootBundles(): ProposedRootBundle[];
    getCancelledRootBundles(): CancelledRootBundle[];
    getDisputedRootBundles(): DisputedRootBundle[];
    getExecutedRootBundles(): ExecutedRootBundle[];
    getSpokePoolForBlock(chain: number, block?: number): string;
    getSpokePoolActivationBlock(chain: number, spokePool: string): number | undefined;
    getL2TokenForL1TokenAtBlock(l1Token: string, destinationChainId: number, latestHubBlock?: number): string;
    getL1TokenForL2TokenAtBlock(l2Token: string, destinationChainId: number, latestHubBlock?: number): string;
    /**
     * Returns the L1 token that should be used for an L2 Bridge event. This function is
     * designed to be used by the caller to associate the L2 token with its mapped L1 token
     * at the HubPool equivalent block number of the L2 event.
     * @param deposit Deposit event
     * @param returns string L1 token counterpart for Deposit
     */
    getL1TokenForDeposit(deposit: Pick<V2DepositWithBlock, "originChainId" | "originToken" | "quoteBlockNumber"> | Pick<V3DepositWithBlock, "originChainId" | "inputToken" | "quoteBlockNumber">): string;
    /**
     * Returns the L2 token that should be used as a counterpart to a deposit event. For example, the caller
     * might want to know what the refund token will be on l2ChainId for the deposit event.
     * @param l2ChainId Chain where caller wants to get L2 token counterpart for
     * @param event Deposit event
     * @returns string L2 token counterpart on l2ChainId
     */
    getL2TokenForDeposit(deposit: Pick<V2DepositWithBlock, "originChainId" | "destinationChainId" | "originToken" | "quoteBlockNumber"> | Pick<V3DepositWithBlock, "originChainId" | "destinationChainId" | "inputToken" | "quoteBlockNumber">, l2ChainId?: number): string;
    l2TokenEnabledForL1Token(l1Token: string, destinationChainId: number): boolean;
    getBlockNumber(timestamp: number): Promise<number | undefined>;
    getCurrentPoolUtilization(l1Token: string): Promise<BigNumber>;
    /**
     * For a HubPool token at a specific block number, compute the relevant utilization.
     * @param hubPoolToken HubPool token to query utilization for.
     * @param blocknumber Block number to query utilization at.
     * @param amount Amount to query. If set to 0, the closing utilization at blockNumber is returned.
     * @param amount timestamp Associated quoteTimestamp for query, used for caching evaluation.
     * @param timeToCache Age at which the response is able to be cached.
     * @returns HubPool utilization at `blockNumber` after optional `amount` increase in utilization.
     */
    protected getUtilization(hubPoolToken: string, blockNumber: number, depositAmount: BigNumber, timestamp: number, timeToCache: number): Promise<BigNumber>;
    computeRealizedLpFeePct(deposit: LpFeeRequest): Promise<RealizedLpFee>;
    batchComputeRealizedLpFeePct(_deposits: LpFeeRequest[]): Promise<RealizedLpFee[]>;
    getL1Tokens(): L1Token[];
    getTokenInfoForL1Token(l1Token: string): L1Token | undefined;
    getLpTokenInfoForL1Token(l1Token: string): LpToken | undefined;
    getL1TokenInfoForL2Token(l2Token: string, chainId: number): L1Token | undefined;
    getTokenInfoForDeposit(deposit: Deposit): L1Token | undefined;
    getTokenInfo(chainId: number | string, tokenAddress: string): L1Token | undefined;
    areTokensEquivalent(tokenA: string, chainIdA: number, tokenB: string, chainIdB: number, hubPoolBlock?: number): boolean;
    getSpokeActivationBlockForChain(chainId: number): number;
    isRootBundleValid(rootBundle: ProposedRootBundle, latestMainnetBlock: number): boolean;
    getRootBundleEvalBlockNumberContainingBlock(latestMainnetBlock: number, block: number, chain: number, chainIdListOverride?: number[]): number | undefined;
    getProposedRootBundlesInBlockRange(startingBlock: number, endingBlock: number): ProposedRootBundle[];
    getCancelledRootBundlesInBlockRange(startingBlock: number, endingBlock: number): CancelledRootBundle[];
    getDisputedRootBundlesInBlockRange(startingBlock: number, endingBlock: number): DisputedRootBundle[];
    getLatestProposedRootBundle(): ProposedRootBundle;
    getFollowingRootBundle(currentRootBundle: ProposedRootBundle): ProposedRootBundle | undefined;
    getExecutedLeavesForRootBundle(rootBundle: ProposedRootBundle, latestMainnetBlockToSearch: number): ExecutedRootBundle[];
    getValidatedRootBundles(latestMainnetBlock?: number): ProposedRootBundle[];
    getLatestFullyExecutedRootBundle(latestMainnetBlock: number): ProposedRootBundle | undefined;
    getEarliestFullyExecutedRootBundle(latestMainnetBlock: number, startBlock?: number): ProposedRootBundle | undefined;
    getNthFullyExecutedRootBundle(n: number, startBlock?: number): ProposedRootBundle | undefined;
    getLatestBundleEndBlockForChain(chainIdList: number[], latestMainnetBlock: number, chainId: number): number;
    getNextBundleStartBlockNumber(chainIdList: number[], latestMainnetBlock: number, chainId: number): number;
    getRunningBalanceBeforeBlockForChain(block: number, chain: number, l1Token: string): TokenRunningBalance;
    getRunningBalanceForToken(l1Token: string, executedRootBundle: ExecutedRootBundle): TokenRunningBalance;
    _update(eventNames: HubPoolEvent[]): Promise<HubPoolUpdate>;
    update(eventsToQuery?: HubPoolEvent[]): Promise<void>;
    protected getBundleEndBlockForChain(proposeRootBundleEvent: ProposedRootBundle, chainId: number, chainIdList: number[]): number;
}
export {};
