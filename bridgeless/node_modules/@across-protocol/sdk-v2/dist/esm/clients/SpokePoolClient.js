import { __assign, __awaiter, __extends, __generator, __spreadArray } from "tslib";
import { BigNumber, ethers } from "ethers";
import { groupBy } from "lodash";
import { bnZero, MAX_BIG_INT, assign, getDepositOutputAmount, getFillOutputAmount, getRelayDataHash, getTotalFilledAmount, isDefined, isV2Deposit, isV2SpeedUp, isV3SpeedUp, toBN, } from "../utils";
import { paginatedEventQuery, sortEventsAscending, sortEventsAscendingInPlace, spreadEvent, spreadEventWithBlockNumber, } from "../utils/EventUtils";
import { filledSameDeposit, validateFillForDeposit } from "../utils/FlowUtils";
import { ZERO_ADDRESS } from "../constants";
import { getNetworkName } from "../utils/NetworkUtils";
import { getBlockRangeForDepositId, getDepositIdAtBlock } from "../utils/SpokeUtils";
import { BaseAbstractClient } from "./BaseAbstractClient";
/**
 * SpokePoolClient is a client for the SpokePool contract. It is responsible for querying the SpokePool contract
 * for events and storing them in memory. It also provides some convenience methods for querying the stored events.
 */
var SpokePoolClient = /** @class */ (function (_super) {
    __extends(SpokePoolClient, _super);
    /**
     * Creates a new SpokePoolClient.
     * @param logger A logger instance.
     * @param spokePool The SpokePool contract instance that this client will query.
     * @param hubPoolClient An optional HubPoolClient instance. This is used to fetch spoke data that is not stored on the SpokePool contract but is stored on the HubPool contract.
     * @param chainId The chain ID of the chain that this client is querying.
     * @param deploymentBlock The block number that the SpokePool contract was deployed at.
     * @param eventSearchConfig An optional EventSearchConfig object that controls how far back in history the client will search for events. If not provided, the client will only search for events from the deployment block.
     */
    function SpokePoolClient(logger, spokePool, 
    // Can be excluded. This disables some deposit validation.
    hubPoolClient, chainId, deploymentBlock, eventSearchConfig) {
        if (eventSearchConfig === void 0) { eventSearchConfig = { fromBlock: 0, maxBlockLookBack: 0 }; }
        var _this = _super.call(this) || this;
        _this.logger = logger;
        _this.spokePool = spokePool;
        _this.hubPoolClient = hubPoolClient;
        _this.chainId = chainId;
        _this.deploymentBlock = deploymentBlock;
        _this.eventSearchConfig = eventSearchConfig;
        _this.currentTime = 0;
        _this.oldestTime = 0;
        _this.depositHashes = {};
        _this.depositHashesToFills = {};
        _this.speedUps = {};
        _this.slowFillRequests = {};
        _this.depositRoutes = {};
        _this.tokensBridged = [];
        _this.rootBundleRelays = [];
        _this.relayerRefundExecutions = [];
        _this.earlyDeposits = [];
        _this.queryableEventNames = [];
        _this.earliestDepositIdQueried = Number.MAX_SAFE_INTEGER;
        _this.latestDepositIdQueried = 0;
        _this.firstDepositIdForSpokePool = Number.MAX_SAFE_INTEGER;
        _this.lastDepositIdForSpokePool = Number.MAX_SAFE_INTEGER;
        _this.fills = {};
        _this.firstBlockToSearch = eventSearchConfig.fromBlock;
        _this.latestBlockSearched = 0;
        _this.queryableEventNames = Object.keys(_this._queryableEventNames());
        return _this;
    }
    SpokePoolClient.prototype._queryableEventNames = function () {
        var _this = this;
        var knownEventNames = [
            "FundsDeposited",
            "RequestedSpeedUpDeposit",
            "FilledRelay",
            "EnabledDepositRoute",
            "TokensBridged",
            "RelayedRootBundle",
            "ExecutedRelayerRefundRoot",
            "V3FundsDeposited",
            "RequestedSpeedUpV3Deposit",
            "RequestedV3SlowFill",
            "FilledV3Relay",
        ];
        return Object.fromEntries(this.spokePool.interface.fragments
            .filter(function (_a) {
            var name = _a.name, type = _a.type;
            return type === "event" && knownEventNames.includes(name);
        })
            .map(function (_a) {
            var name = _a.name;
            return [name, _this.spokePool.filters[name]()];
        }));
    };
    /**
     * Retrieves a list of deposits from the SpokePool contract destined for the given destination chain ID.
     * @param destinationChainId The destination chain ID.
     * @returns A list of deposits.
     */
    SpokePoolClient.prototype.getDepositsForDestinationChain = function (destinationChainId) {
        return Object.values(this.depositHashes).filter(function (deposit) { return deposit.destinationChainId === destinationChainId; });
    };
    /**
     * Retrieves a list of deposits from the SpokePool contract that are associated with this spoke pool.
     * @returns A list of deposits.
     * @note This method returns all deposits, regardless of destination chain ID in sorted order.
     */
    SpokePoolClient.prototype.getDeposits = function (filter) {
        var deposits = Object.values(this.depositHashes);
        if (isDefined(filter)) {
            var fromBlock_1 = filter.fromBlock, toBlock_1 = filter.toBlock;
            deposits = deposits.filter(function (_a) {
                var blockNumber = _a.blockNumber;
                return blockNumber >= fromBlock_1 && toBlock_1 >= blockNumber;
            });
        }
        return sortEventsAscendingInPlace(deposits);
    };
    /**
     * Retrieves a list of the tokens that have been bridged.
     * @returns A list of tokens.
     */
    SpokePoolClient.prototype.getTokensBridged = function () {
        return this.tokensBridged;
    };
    /**
     * Retrieves a mapping of tokens and their associated destination chain IDs that can be bridged.
     * @returns A mapping of tokens and their associated destination chain IDs in a nested mapping.
     */
    SpokePoolClient.prototype.getDepositRoutes = function () {
        return this.depositRoutes;
    };
    /**
     * Determines whether a deposit route is enabled for the given origin token and destination chain ID.
     * @param originToken The origin token address.
     * @param destinationChainId The destination chain ID.
     * @returns True if the deposit route is enabled, false otherwise.
     */
    SpokePoolClient.prototype.isDepositRouteEnabled = function (originToken, destinationChainId) {
        var _a, _b;
        return (_b = (_a = this.depositRoutes[originToken]) === null || _a === void 0 ? void 0 : _a[destinationChainId]) !== null && _b !== void 0 ? _b : false;
    };
    /**
     * Retrieves a list of all the available origin tokens that can be bridged.
     * @returns A list of origin tokens.
     */
    SpokePoolClient.prototype.getAllOriginTokens = function () {
        return Object.keys(this.depositRoutes);
    };
    /**
     * Retrieves a list of fills from the SpokePool contract.
     * @returns A list of fills.
     */
    SpokePoolClient.prototype.getFills = function () {
        return sortEventsAscendingInPlace(Object.values(this.fills).flat());
    };
    /**
     * Retrieves a list of fills from a specific origin chain ID.
     * @param originChainId The origin chain ID.
     * @returns A list of fills.
     */
    SpokePoolClient.prototype.getFillsForOriginChain = function (originChainId) {
        return this.fills[originChainId] || [];
    };
    /**
     * Retrieves a list of fills from a specific relayer address.
     * @param relayer The relayer address.
     * @returns A list of fills.
     */
    SpokePoolClient.prototype.getFillsForRelayer = function (relayer) {
        return this.getFills().filter(function (fill) { return fill.relayer === relayer; });
    };
    /**
     * Retrieves a list of fills from a given block range.
     * @param startingBlock The starting block number.
     * @param endingBlock The ending block number.
     * @returns A list of fills.
     */
    SpokePoolClient.prototype.getFillsWithBlockInRange = function (startingBlock, endingBlock) {
        return this.getFills().filter(function (fill) { return fill.blockNumber >= startingBlock && fill.blockNumber <= endingBlock; });
    };
    /**
     * Retrieves a list of root bundle relays from the SpokePool contract.
     * @returns A list of root bundle relays.
     */
    SpokePoolClient.prototype.getRootBundleRelays = function () {
        return this.rootBundleRelays;
    };
    /**
     * Retrieves the ID of the latest root bundle.
     * @returns The ID of the latest root bundle. This will be 0 if no root bundles have been relayed.
     */
    SpokePoolClient.prototype.getLatestRootBundleId = function () {
        var _a;
        return this.rootBundleRelays.length > 0
            ? ((_a = this.rootBundleRelays[this.rootBundleRelays.length - 1]) === null || _a === void 0 ? void 0 : _a.rootBundleId) + 1
            : 0;
    };
    /**
     * Retrieves a list of relayer refund executions from the SpokePool contract.
     * @returns A list of relayer refund executions.
     */
    SpokePoolClient.prototype.getRelayerRefundExecutions = function () {
        return this.relayerRefundExecutions;
    };
    /**
     * Retrieves a mapping of token addresses to relayer addresses to the amount of refunds that have been executed.
     * @returns A mapping of token addresses to relayer addresses to the amount of refunds that have been executed.
     */
    SpokePoolClient.prototype.getExecutedRefunds = function (relayerRefundRoot) {
        var bundle = this.getRootBundleRelays().find(function (bundle) { return bundle.relayerRefundRoot === relayerRefundRoot; });
        if (bundle === undefined) {
            return {};
        }
        var executedRefundLeaves = this.getRelayerRefundExecutions().filter(function (leaf) { return leaf.rootBundleId === bundle.rootBundleId; });
        var executedRefunds = {};
        for (var _i = 0, executedRefundLeaves_1 = executedRefundLeaves; _i < executedRefundLeaves_1.length; _i++) {
            var refundLeaf = executedRefundLeaves_1[_i];
            var tokenAddress = refundLeaf.l2TokenAddress;
            if (executedRefunds[tokenAddress] === undefined) {
                executedRefunds[tokenAddress] = {};
            }
            var executedTokenRefunds = executedRefunds[tokenAddress];
            for (var i = 0; i < refundLeaf.refundAddresses.length; i++) {
                var relayer = refundLeaf.refundAddresses[i];
                var refundAmount = refundLeaf.refundAmounts[i];
                if (executedTokenRefunds[relayer] === undefined) {
                    executedTokenRefunds[relayer] = ethers.constants.Zero;
                }
                executedTokenRefunds[relayer] = executedTokenRefunds[relayer].add(refundAmount);
            }
        }
        return executedRefunds;
    };
    /**
     * Appends a speed up signature to a specific deposit.
     * @param deposit The deposit to append the speed up signature to.
     * @returns A new deposit instance with the speed up signature appended to the deposit.
     */
    SpokePoolClient.prototype.appendMaxSpeedUpSignatureToDeposit = function (deposit) {
        var _a;
        var depositId = deposit.depositId, depositor = deposit.depositor;
        var depositorSpeedUps = (_a = this.speedUps[depositor]) === null || _a === void 0 ? void 0 : _a[depositId];
        if (!isDefined(depositorSpeedUps)) {
            return deposit;
        }
        if (isV2Deposit(deposit)) {
            var v2SpeedUps = depositorSpeedUps.filter((isV2SpeedUp));
            if (v2SpeedUps.length === 0) {
                return deposit;
            }
            var maxSpeedUp_1 = v2SpeedUps.reduce(function (prev, current) {
                return prev.newRelayerFeePct.gt(current.newRelayerFeePct) ? prev : current;
            });
            // We assume that the depositor authorises SpeedUps in isolation of each other, which keeps the relayer
            // logic simple: find the SpeedUp with the highest relayerFeePct, and use all of its fields
            if (!maxSpeedUp_1 || maxSpeedUp_1.newRelayerFeePct.lte(deposit.relayerFeePct)) {
                return deposit;
            }
            // Return deposit with updated params from the speedup with the highest updated relayer fee pct.
            var updatedDeposit_1 = __assign(__assign({}, deposit), { speedUpSignature: maxSpeedUp_1.depositorSignature, newRelayerFeePct: maxSpeedUp_1.newRelayerFeePct, updatedRecipient: maxSpeedUp_1.updatedRecipient, updatedMessage: maxSpeedUp_1.updatedMessage });
            return updatedDeposit_1;
        }
        var v3SpeedUps = depositorSpeedUps.filter((isV3SpeedUp));
        if (v3SpeedUps.length === 0) {
            return deposit;
        }
        var maxSpeedUp = v3SpeedUps.reduce(function (prev, current) {
            return prev.updatedOutputAmount.lt(current.updatedOutputAmount) ? prev : current;
        });
        // We assume that the depositor authorises SpeedUps in isolation of each other, which keeps the relayer
        // logic simple: find the SpeedUp with the lowest updatedOutputAmount, and use all of its fields.
        if (maxSpeedUp.updatedOutputAmount.gte(deposit.outputAmount)) {
            return deposit;
        }
        // Return deposit with updated params from the speedup with the lowest updated output amount.
        var updatedDeposit = __assign(__assign({}, deposit), { speedUpSignature: maxSpeedUp.depositorSignature, updatedOutputAmount: maxSpeedUp.updatedOutputAmount, updatedRecipient: maxSpeedUp.updatedRecipient, updatedMessage: maxSpeedUp.updatedMessage });
        return updatedDeposit;
    };
    /**
     * Find a deposit based on its deposit ID.
     * @notice If evaluating a fill, be sure to verify it against the resulting deposit.
     * @param depositId The unique ID of the deposit being queried.
     * @returns The corresponding deposit if found, undefined otherwise.
     */
    SpokePoolClient.prototype.getDeposit = function (depositId) {
        var depositHash = this.getDepositHash({ depositId: depositId, originChainId: this.chainId });
        return this.depositHashes[depositHash];
    };
    /**
     * Find a SlowFillRequested event based on its deposit RelayData.
     * @param relayData RelayData field for the SlowFill request.
     * @returns The corresponding SlowFIllRequest event if found, otherwise undefined.
     */
    SpokePoolClient.prototype.getSlowFillRequest = function (relayData) {
        var hash = getRelayDataHash(relayData, this.chainId);
        return this.slowFillRequests[hash];
    };
    /**
     * Retrieves a list of slow fill requests for deposits from a specific origin chain ID.
     * @param originChainId The origin chain ID.
     * @returns A list of slow fill requests.
     */
    SpokePoolClient.prototype.getSlowFillRequestsForOriginChain = function (originChainId) {
        return Object.values(this.slowFillRequests).filter(function (e) { return e.originChainId === originChainId; });
    };
    /**
     * Find a corresponding deposit for a given fill.
     * @param fill The fill to find a corresponding deposit for.
     * @returns The corresponding deposit if found, undefined otherwise.
     */
    SpokePoolClient.prototype.getDepositForFill = function (fill, fillFieldsToIgnore) {
        if (fillFieldsToIgnore === void 0) { fillFieldsToIgnore = []; }
        var depositWithMatchingDepositId = this.depositHashes[this.getDepositHash(fill)];
        return validateFillForDeposit(fill, depositWithMatchingDepositId, fillFieldsToIgnore)
            ? depositWithMatchingDepositId
            : undefined;
    };
    /**
     * @dev TODO This function is a bit of a hack for now and its dangerous to leave public because it allows the caller to
     * manipulate internal data that was set at update() time. This is a workaround the current structure where UBAClient
     * is dependent on SpokePoolClient, but one of the SpokePoolClient's internal data structures, `deposits` is dependent
     * on the UBA client state being updated in order to have set correct realizedLpFeePcts. This function is currently
     * designed to be called by the UBA client for each deposit that is loaded and have it reset the realizedLpFeePct
     * equal to the depositBalancingFee plus the LP fee.
     */
    SpokePoolClient.prototype.updateDepositRealizedLpFeePct = function (event, realizedLpFeePct) {
        this.depositHashes[this.getDepositHash(event)] = __assign(__assign({}, this.depositHashes[this.getDepositHash(event)]), { realizedLpFeePct: realizedLpFeePct });
    };
    /**
     * Find the unfilled amount for a given deposit. This is the full deposit amount minus the total filled amount.
     * @param deposit The deposit to find the unfilled amount for.
     * @param fillCount The number of fills that have been applied to this deposit.
     * @param invalidFills The invalid fills that have been applied to this deposit.
     * @returns The unfilled amount.
     */
    SpokePoolClient.prototype.getValidUnfilledAmountForDeposit = function (deposit) {
        var outputAmount = getDepositOutputAmount(deposit);
        var fillsForDeposit = this.depositHashesToFills[this.getDepositHash(deposit)];
        // If no fills then the full amount is remaining.
        if (fillsForDeposit === undefined || fillsForDeposit.length === 0) {
            return { unfilledAmount: toBN(outputAmount), fillCount: 0, invalidFills: [] };
        }
        var _a = fillsForDeposit.reduce(function (groupedFills, fill) {
            if (validateFillForDeposit(fill, deposit)) {
                groupedFills.validFills.push(fill);
            }
            else {
                groupedFills.invalidFills.push(fill);
            }
            return groupedFills;
        }, { validFills: [], invalidFills: [] }), validFills = _a.validFills, invalidFills = _a.invalidFills;
        // Log any invalid deposits with same deposit id but different params.
        var invalidFillsForDeposit = invalidFills.filter(function (x) { return x.depositId === deposit.depositId; });
        if (invalidFillsForDeposit.length > 0) {
            this.logger.warn({
                at: "SpokePoolClient",
                chainId: this.chainId,
                message: "Invalid fills found matching deposit ID",
                deposit: deposit,
                invalidFills: Object.fromEntries(invalidFillsForDeposit.map(function (x) { return [x.relayer, x]; })),
                notificationPath: "across-invalid-fills",
            });
        }
        // If all fills are invalid we can consider this unfilled.
        if (validFills.length === 0) {
            return { unfilledAmount: toBN(outputAmount), fillCount: 0, invalidFills: invalidFills };
        }
        // Order fills by totalFilledAmount and then return the first fill's full deposit amount minus total filled amount.
        var fillsOrderedByTotalFilledAmount = validFills.sort(function (fillA, fillB) {
            var totalFilledA = getTotalFilledAmount(fillA);
            var totalFilledB = getTotalFilledAmount(fillB);
            return totalFilledB.gt(totalFilledA) ? 1 : totalFilledB.lt(totalFilledA) ? -1 : 0;
        });
        var lastFill = fillsOrderedByTotalFilledAmount[0];
        return {
            unfilledAmount: getFillOutputAmount(lastFill).sub(getTotalFilledAmount(lastFill)),
            fillCount: validFills.length,
            invalidFills: invalidFills,
        };
    };
    /**
     * Formulate a hash for a given deposit or fill
     * @param event The deposit or fill to formulate a hash for.
     * @returns The hash.
     * @note This hash is used to match deposits and fills together.
     * @note This hash takes the form of: `${depositId}-${originChainId}`.
     */
    SpokePoolClient.prototype.getDepositHash = function (event) {
        return "".concat(event.depositId, "-").concat(event.originChainId);
    };
    /**
     * Find the block range that contains the deposit ID. This is a binary search that searches for the block range
     * that contains the deposit ID.
     * @param targetDepositId The target deposit ID to search for.
     * @param initLow The initial lower bound of the block range to search.
     * @param initHigh The initial upper bound of the block range to search.
     * @param maxSearches The maximum number of searches to perform. This is used to prevent infinite loops.
     * @returns The block range that contains the deposit ID.
     * @note  // We want to find the block range that satisfies these conditions:
     *        // - the low block has deposit count <= targetDepositId
     *        // - the high block has a deposit count > targetDepositId.
     *        // This way the caller can search for a FundsDeposited event between [low, high] that will always
     *        // contain the event emitted when deposit ID was incremented to targetDepositId + 1. This is the same transaction
     *        // where the deposit with deposit ID = targetDepositId was created.
     */
    SpokePoolClient.prototype._getBlockRangeForDepositId = function (targetDepositId, initLow, initHigh, maxSearches) {
        return getBlockRangeForDepositId(targetDepositId, initLow, initHigh, maxSearches, this);
    };
    /**
     * Finds the deposit id at a specific block number.
     * @param blockTag The block number to search for the deposit ID at.
     * @returns The deposit ID.
     */
    SpokePoolClient.prototype._getDepositIdAtBlock = function (blockTag) {
        return getDepositIdAtBlock(this.spokePool, blockTag);
    };
    /**
     * Queries the SpokePool contract for a list of historical fills that match the given fill and deposit.
     * @param fill The fill to match.
     * @param deposit The deposit to match.
     * @param toBlock The block number to search up to.
     * @returns A list of fills that match the given fill and deposit.
     */
    SpokePoolClient.prototype.queryHistoricalMatchingFills = function (fill, deposit, toBlock) {
        return __awaiter(this, void 0, void 0, function () {
            var searchConfig;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        searchConfig = {
                            fromBlock: this.deploymentBlock,
                            toBlock: toBlock,
                            maxBlockLookBack: this.eventSearchConfig.maxBlockLookBack,
                        };
                        return [4 /*yield*/, this.queryFillsInBlockRange(fill, searchConfig)];
                    case 1: return [2 /*return*/, (_a.sent()).filter(function (_fill) {
                            return validateFillForDeposit(_fill, deposit);
                        })];
                }
            });
        });
    };
    /**
     * Queries the SpokePool contract for a list of fills that match the given fill.
     * @param fill The fill to match.
     * @param searchConfig The search configuration.
     * @returns A Promise that resolves to a list of fills that match the given fill.
     */
    SpokePoolClient.prototype.queryFillsInBlockRange = function (matchingFill, searchConfig) {
        return __awaiter(this, void 0, void 0, function () {
            var query, fills;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, paginatedEventQuery(this.spokePool, this.spokePool.filters.FilledRelay(undefined, // amount
                        undefined, // totalFilledAmount
                        undefined, // fillAmount
                        undefined, // repaymentChainId
                        matchingFill.originChainId, // originChainId
                        undefined, // destinationChainId
                        undefined, // relayerFeePct
                        undefined, // realizedLpFeePct
                        matchingFill.depositId, // depositId
                        undefined, // destinationToken
                        undefined, // relayer
                        matchingFill.depositor, // depositor
                        undefined, // recipient
                        undefined, // message
                        undefined // updatableRelayData
                        ), searchConfig)];
                    case 1:
                        query = _a.sent();
                        fills = query.map(function (event) { return spreadEventWithBlockNumber(event); });
                        return [2 /*return*/, sortEventsAscending(fills.filter(function (_fill) { return filledSameDeposit(_fill, matchingFill); }))];
                }
            });
        });
    };
    /**
     * @notice Return maximum of fill deadline buffer at start and end of block range. This is a contract
     * immutable state variable so we can't query other events to find its updates.
     * @dev V3 deposits have a fill deadline which can be set to a maximum of fillDeadlineBuffer + deposit.block.timestamp.
     * Therefore, we cannot evaluate a block range for expired deposits if the spoke pool client doesn't return us
     * deposits whose block.timestamp is within fillDeadlineBuffer of the end block time. As a conservative check,
     * we verify that the time between the end block timestamp and the first timestamp queried by the
     * spoke pool client is greater than the maximum of the fill deadline buffers at the start and end of the block
     * range. We assume the fill deadline buffer wasn't changed more than once within a bundle.
     * @param startBlock start block
     * @param endBlock end block
     * @returns maximum of fill deadline buffer at start and end block
     */
    SpokePoolClient.prototype.getMaxFillDeadlineInRange = function (startBlock, endBlock) {
        return __awaiter(this, void 0, void 0, function () {
            var fillDeadlineBuffers;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.spokePool.fillDeadlineBuffer({ blockTag: startBlock }),
                            this.spokePool.fillDeadlineBuffer({ blockTag: endBlock }),
                        ])];
                    case 1:
                        fillDeadlineBuffers = _a.sent();
                        return [2 /*return*/, Math.max(fillDeadlineBuffers[0], fillDeadlineBuffers[1])];
                }
            });
        });
    };
    /**
     * Performs an update to refresh the state of this client. This will query the SpokePool contract for new events
     * and store them in memory. This method is the primary method for updating the state of this client.
     * @param eventsToQuery An optional list of events to query. If not provided, all events will be queried.
     * @returns A Promise that resolves to a SpokePoolUpdate object.
     */
    SpokePoolClient.prototype._update = function (eventsToQuery) {
        return __awaiter(this, void 0, void 0, function () {
            var firstDepositId, searchConfig, _a, eventSearchConfigs, timerStart, _b, numberOfDeposits, currentTime, oldestTime, events, errMsg;
            var _c;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        firstDepositId = this.firstDepositIdForSpokePool;
                        if (!(firstDepositId === Number.MAX_SAFE_INTEGER)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.spokePool.numberOfDeposits({ blockTag: this.deploymentBlock })];
                    case 1:
                        firstDepositId = _d.sent();
                        if (isNaN(firstDepositId) || firstDepositId < 0) {
                            throw new Error("SpokePoolClient::update: Invalid first deposit id (".concat(firstDepositId, ")"));
                        }
                        _d.label = 2;
                    case 2:
                        _c = {
                            fromBlock: this.firstBlockToSearch
                        };
                        _a = this.eventSearchConfig.toBlock;
                        if (_a) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.spokePool.provider.getBlockNumber()];
                    case 3:
                        _a = (_d.sent());
                        _d.label = 4;
                    case 4:
                        searchConfig = (_c.toBlock = _a,
                            _c.maxBlockLookBack = this.eventSearchConfig.maxBlockLookBack,
                            _c);
                        if (searchConfig.fromBlock > searchConfig.toBlock) {
                            this.log("warn", "Invalid update() searchConfig.", { searchConfig: searchConfig });
                            return [2 /*return*/, { success: false }];
                        }
                        eventSearchConfigs = eventsToQuery.map(function (eventName) {
                            if (!_this.queryableEventNames.includes(eventName)) {
                                throw new Error("SpokePoolClient: Cannot query unrecognised SpokePool event name: ".concat(eventName));
                            }
                            var _searchConfig = __assign({}, searchConfig); // shallow copy
                            // By default, an event's query range is controlled by the `eventSearchConfig` passed in during instantiation.
                            // However, certain events have special overriding requirements to their search ranges:
                            // - EnabledDepositRoute: The full history is always required, so override the requested fromBlock.
                            if (eventName === "EnabledDepositRoute" && !_this.isUpdated) {
                                _searchConfig.fromBlock = _this.deploymentBlock;
                            }
                            return {
                                filter: _this._queryableEventNames()[eventName],
                                searchConfig: _searchConfig,
                            };
                        });
                        this.log("debug", "Updating SpokePool client for chain ".concat(this.chainId), {
                            eventsToQuery: eventsToQuery,
                            searchConfig: searchConfig,
                            spokePool: this.spokePool.address,
                        });
                        timerStart = Date.now();
                        return [4 /*yield*/, Promise.all(__spreadArray([
                                this.spokePool.numberOfDeposits({ blockTag: searchConfig.toBlock }),
                                this.spokePool.getCurrentTime({ blockTag: searchConfig.toBlock }),
                                this.spokePool.getCurrentTime({ blockTag: Math.max(searchConfig.fromBlock, this.deploymentBlock) })
                            ], eventSearchConfigs.map(function (config) { return paginatedEventQuery(_this.spokePool, config.filter, config.searchConfig); }), true))];
                    case 5:
                        _b = _d.sent(), numberOfDeposits = _b[0], currentTime = _b[1], oldestTime = _b[2], events = _b.slice(3);
                        this.log("debug", "Time to query new events from RPC for ".concat(this.chainId, ": ").concat(Date.now() - timerStart, " ms"));
                        if (!BigNumber.isBigNumber(currentTime) || currentTime.lt(this.currentTime)) {
                            errMsg = BigNumber.isBigNumber(currentTime)
                                ? "currentTime: ".concat(currentTime, " < ").concat(toBN(this.currentTime))
                                : "currentTime is not a BigNumber: ".concat(JSON.stringify(currentTime));
                            throw new Error("SpokePoolClient::update: ".concat(errMsg));
                        }
                        // Sort all events to ensure they are stored in a consistent order.
                        events.forEach(function (events) { return sortEventsAscendingInPlace(events); });
                        return [2 /*return*/, {
                                success: true,
                                currentTime: currentTime.toNumber(),
                                oldestTime: oldestTime.toNumber(),
                                firstDepositId: firstDepositId,
                                latestDepositId: Math.max(numberOfDeposits - 1, 0),
                                searchEndBlock: searchConfig.toBlock,
                                events: events,
                            }];
                }
            });
        });
    };
    SpokePoolClient.prototype._isEarlyDeposit = function (depositEvent, currentTime) {
        return depositEvent.args.quoteTimestamp > currentTime;
    };
    SpokePoolClient.prototype.isV3DepositEvent = function (event) {
        return isDefined(event.args.inputToken);
    };
    SpokePoolClient.prototype.isV3FillEvent = function (event) {
        return isDefined(event.args.inputToken);
    };
    /**
     * A wrapper over the `_update` method that handles errors and logs. This method additionally calls into the
     * HubPoolClient to update the state of this client with data from the HubPool contract.
     * @param eventsToQuery An optional list of events to query. If not provided, all events will be queried.
     * @returns A Promise that resolves to a SpokePoolUpdate object.
     * @note This method is the primary method for updating the state of this client externally.
     * @see _update
     */
    SpokePoolClient.prototype.update = function (eventsToQuery) {
        var _a, _b, _c, _d, _e, _f;
        if (eventsToQuery === void 0) { eventsToQuery = this.queryableEventNames; }
        return __awaiter(this, void 0, void 0, function () {
            var update, queryResults, currentTime, oldestTime, searchEndBlock, _i, _g, event_1, _h, _j, earlyDeposits, _k, v2DepositEvents, depositEvents, dataForQuoteTime, _l, _m, _o, index, event_2, rawDeposit, deposit, _p, quoteBlockNumber, realizedLpFeePct, speedUpEvents, _q, speedUpEvents_1, event_3, speedUp, depositHash, depositDataAssociatedWithSpeedUp, slowFillRequests, _r, slowFillRequests_1, event_4, slowFillRequest, relayDataHash, fillEvents, _s, fillEvents_1, event_5, fill, enableDepositsEvents, _t, enableDepositsEvents_1, event_6, enableDeposit, relayedRootBundleEvents, _u, relayedRootBundleEvents_1, event_7, refundEvents, _v, refundEvents_1, event_8, executedRefund;
            var _this = this;
            return __generator(this, function (_w) {
                switch (_w.label) {
                    case 0:
                        if (this.hubPoolClient !== null && !this.hubPoolClient.isUpdated) {
                            throw new Error("HubPoolClient not updated");
                        }
                        return [4 /*yield*/, this._update(eventsToQuery)];
                    case 1:
                        update = _w.sent();
                        if (!update.success) {
                            // This failure only occurs if the RPC searchConfig is miscomputed, and has only been seen in the hardhat test
                            // environment. Normal failures will throw instead. This is therefore an unfortunate workaround until we can
                            // understand why we see this in test. @todo: Resolve.
                            return [2 /*return*/];
                        }
                        queryResults = update.events, currentTime = update.currentTime, oldestTime = update.oldestTime, searchEndBlock = update.searchEndBlock;
                        if (eventsToQuery.includes("TokensBridged")) {
                            for (_i = 0, _g = queryResults[eventsToQuery.indexOf("TokensBridged")]; _i < _g.length; _i++) {
                                event_1 = _g[_i];
                                this.tokensBridged.push(spreadEventWithBlockNumber(event_1));
                            }
                        }
                        if (!(eventsToQuery.includes("FundsDeposited") || eventsToQuery.includes("V3FundsDeposited"))) return [3 /*break*/, 3];
                        _h = groupBy(__spreadArray(__spreadArray([], this.earlyDeposits, true), ((_a = queryResults[eventsToQuery.indexOf("FundsDeposited")]) !== null && _a !== void 0 ? _a : []), true), function (depositEvent) { return (_this._isEarlyDeposit(depositEvent, currentTime) ? "earlyDeposits" : "v2DepositEvents"); }), _j = _h.earlyDeposits, earlyDeposits = _j === void 0 ? [] : _j, _k = _h.v2DepositEvents, v2DepositEvents = _k === void 0 ? [] : _k;
                        if (earlyDeposits.length > 0) {
                            this.logger.debug({
                                at: "SpokePoolClient#update",
                                message: "Deferring ".concat(earlyDeposits.length, " early v2 deposit events."),
                                currentTime: currentTime,
                                deposits: earlyDeposits.map(function (_a) {
                                    var args = _a.args, transactionHash = _a.transactionHash;
                                    return ({ depositId: args.depositId, transactionHash: transactionHash });
                                }),
                            });
                        }
                        this.earlyDeposits = earlyDeposits;
                        depositEvents = __spreadArray(__spreadArray([], v2DepositEvents, true), ((_b = queryResults[eventsToQuery.indexOf("V3FundsDeposited")]) !== null && _b !== void 0 ? _b : []), true);
                        if (depositEvents.length > 0) {
                            this.log("debug", "Using ".concat(depositEvents.length, " newly queried deposit events for chain ").concat(this.chainId), {
                                earliestEvent: depositEvents[0].blockNumber,
                            });
                        }
                        return [4 /*yield*/, this.batchComputeRealizedLpFeePct(depositEvents)];
                    case 2:
                        dataForQuoteTime = _w.sent();
                        for (_l = 0, _m = Array.from(depositEvents.entries()); _l < _m.length; _l++) {
                            _o = _m[_l], index = _o[0], event_2 = _o[1];
                            rawDeposit = spreadEventWithBlockNumber(event_2);
                            deposit = void 0;
                            _p = dataForQuoteTime[index], quoteBlockNumber = _p.quoteBlock, realizedLpFeePct = _p.realizedLpFeePct;
                            if (this.isV3DepositEvent(event_2)) {
                                deposit = __assign(__assign({}, rawDeposit), { originChainId: this.chainId });
                                deposit.realizedLpFeePct = undefined;
                                deposit.quoteBlockNumber = quoteBlockNumber;
                                if (deposit.outputToken === ZERO_ADDRESS) {
                                    deposit.outputToken = this.getDestinationTokenForDeposit(deposit);
                                }
                            }
                            else {
                                deposit = __assign({}, rawDeposit);
                                deposit.realizedLpFeePct = realizedLpFeePct;
                                deposit.quoteBlockNumber = quoteBlockNumber;
                                deposit.destinationToken = this.getDestinationTokenForDeposit(deposit);
                            }
                            if (this.depositHashes[this.getDepositHash(deposit)] !== undefined) {
                                continue;
                            }
                            assign(this.depositHashes, [this.getDepositHash(deposit)], deposit);
                            if (deposit.depositId < this.earliestDepositIdQueried) {
                                this.earliestDepositIdQueried = deposit.depositId;
                            }
                            if (deposit.depositId > this.latestDepositIdQueried) {
                                this.latestDepositIdQueried = deposit.depositId;
                            }
                        }
                        _w.label = 3;
                    case 3:
                        // TODO: When validating fills with deposits for the purposes of UBA flows, do we need to consider
                        // speed ups as well? For example, do we need to also consider that the speed up is before the fill
                        // timestamp to be applied for the fill? My brain hurts.
                        // Update deposits with speed up requests from depositor.
                        if (eventsToQuery.includes("RequestedSpeedUpDeposit") || eventsToQuery.includes("RequestedSpeedUpV3Deposit")) {
                            speedUpEvents = __spreadArray(__spreadArray([], ((_c = queryResults[eventsToQuery.indexOf("RequestedSpeedUpDeposit")]) !== null && _c !== void 0 ? _c : []), true), ((_d = queryResults[eventsToQuery.indexOf("RequestedSpeedUpV3Deposit")]) !== null && _d !== void 0 ? _d : []), true);
                            for (_q = 0, speedUpEvents_1 = speedUpEvents; _q < speedUpEvents_1.length; _q++) {
                                event_3 = speedUpEvents_1[_q];
                                speedUp = __assign(__assign({}, spreadEvent(event_3.args)), { originChainId: this.chainId });
                                assign(this.speedUps, [speedUp.depositor, speedUp.depositId], [speedUp]);
                                depositHash = this.getDepositHash(speedUp);
                                depositDataAssociatedWithSpeedUp = this.depositHashes[depositHash];
                                if (isDefined(depositDataAssociatedWithSpeedUp)) {
                                    this.depositHashes[depositHash] = this.appendMaxSpeedUpSignatureToDeposit(depositDataAssociatedWithSpeedUp);
                                }
                            }
                        }
                        if (eventsToQuery.includes("RequestedV3SlowFill")) {
                            slowFillRequests = queryResults[eventsToQuery.indexOf("RequestedV3SlowFill")];
                            for (_r = 0, slowFillRequests_1 = slowFillRequests; _r < slowFillRequests_1.length; _r++) {
                                event_4 = slowFillRequests_1[_r];
                                slowFillRequest = __assign(__assign({}, spreadEventWithBlockNumber(event_4)), { destinationChainId: this.chainId });
                                relayDataHash = getRelayDataHash(slowFillRequest, this.chainId);
                                if (this.slowFillRequests[relayDataHash] !== undefined) {
                                    continue;
                                }
                                this.slowFillRequests[relayDataHash] = slowFillRequest;
                            }
                        }
                        if (eventsToQuery.includes("FilledRelay") || eventsToQuery.includes("FilledV3Relay")) {
                            fillEvents = __spreadArray(__spreadArray([], ((_e = queryResults[eventsToQuery.indexOf("FilledRelay")]) !== null && _e !== void 0 ? _e : []), true), ((_f = queryResults[eventsToQuery.indexOf("FilledV3Relay")]) !== null && _f !== void 0 ? _f : []), true);
                            if (fillEvents.length > 0) {
                                this.log("debug", "Using ".concat(fillEvents.length, " newly queried fill events for chain ").concat(this.chainId), {
                                    earliestEvent: fillEvents[0].blockNumber,
                                });
                            }
                            // @note The type assertions here suppress errors that might arise due to incomplete types. For now, verify via
                            // test that the types are complete. A broader change in strategy for safely unpacking events will be introduced.
                            for (_s = 0, fillEvents_1 = fillEvents; _s < fillEvents_1.length; _s++) {
                                event_5 = fillEvents_1[_s];
                                fill = this.isV3FillEvent(event_5)
                                    ? __assign(__assign({}, spreadEventWithBlockNumber(event_5)), { destinationChainId: this.chainId }) : __assign({}, spreadEventWithBlockNumber(event_5));
                                assign(this.fills, [fill.originChainId], [fill]);
                                assign(this.depositHashesToFills, [this.getDepositHash(fill)], [fill]);
                            }
                        }
                        if (eventsToQuery.includes("EnabledDepositRoute")) {
                            enableDepositsEvents = queryResults[eventsToQuery.indexOf("EnabledDepositRoute")];
                            for (_t = 0, enableDepositsEvents_1 = enableDepositsEvents; _t < enableDepositsEvents_1.length; _t++) {
                                event_6 = enableDepositsEvents_1[_t];
                                enableDeposit = spreadEvent(event_6.args);
                                assign(this.depositRoutes, [enableDeposit.originToken, enableDeposit.destinationChainId], enableDeposit.enabled);
                            }
                        }
                        if (eventsToQuery.includes("RelayedRootBundle")) {
                            relayedRootBundleEvents = queryResults[eventsToQuery.indexOf("RelayedRootBundle")];
                            for (_u = 0, relayedRootBundleEvents_1 = relayedRootBundleEvents; _u < relayedRootBundleEvents_1.length; _u++) {
                                event_7 = relayedRootBundleEvents_1[_u];
                                this.rootBundleRelays.push(spreadEventWithBlockNumber(event_7));
                            }
                        }
                        if (eventsToQuery.includes("ExecutedRelayerRefundRoot")) {
                            refundEvents = queryResults[eventsToQuery.indexOf("ExecutedRelayerRefundRoot")];
                            for (_v = 0, refundEvents_1 = refundEvents; _v < refundEvents_1.length; _v++) {
                                event_8 = refundEvents_1[_v];
                                executedRefund = spreadEventWithBlockNumber(event_8);
                                executedRefund.l2TokenAddress = SpokePoolClient.getExecutedRefundLeafL2Token(executedRefund.chainId, executedRefund.l2TokenAddress);
                                this.relayerRefundExecutions.push(executedRefund);
                            }
                        }
                        // Next iteration should start off from where this one ended.
                        this.currentTime = currentTime;
                        if (this.oldestTime === 0)
                            this.oldestTime = oldestTime; // Set oldest time only after the first update.
                        this.firstDepositIdForSpokePool = update.firstDepositId;
                        this.latestBlockSearched = searchEndBlock;
                        this.lastDepositIdForSpokePool = update.latestDepositId;
                        this.firstBlockToSearch = searchEndBlock + 1;
                        this.eventSearchConfig.toBlock = undefined; // Caller can re-set on subsequent updates if necessary
                        this.isUpdated = true;
                        this.log("debug", "SpokePool client for chain ".concat(this.chainId, " updated!"), {
                            nextFirstBlockToSearch: this.firstBlockToSearch,
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves the l2TokenAddress for a given executed refund leaf.
     * @param chainId The chain ID of the executed refund leaf.
     * @param eventL2Token The l2TokenAddress of the executed refund leaf.
     * @returns The l2TokenAddress of the executed refund leaf.
     */
    SpokePoolClient.getExecutedRefundLeafL2Token = function (chainId, eventL2Token) {
        // If execution of WETH refund leaf occurred on an OVM spoke pool, then we'll convert its l2Token from the native
        // token address to the wrapped token address. This is because the OVM_SpokePool modifies the l2TokenAddress prop
        // in _bridgeTokensToHubPool before emitting the ExecutedRelayerRefundLeaf event.
        // Here is the contract code referenced:
        // - https://github.com/across-protocol/contracts-v2/blob/954528a4620863d1c868e54a370fd8556d5ed05c/contracts/Ovm_SpokePool.sol#L142
        if ((chainId === 10 || chainId === 8453) &&
            eventL2Token.toLowerCase() === "0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000") {
            return "0x4200000000000000000000000000000000000006";
        }
        else if (chainId === 288 && eventL2Token.toLowerCase() === "0x4200000000000000000000000000000000000006") {
            return "0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000";
        }
        else {
            return eventL2Token;
        }
    };
    /**
     * Computes the realized LP fee percentage for a given deposit.
     * @param depositEvent The deposit event to compute the realized LP fee percentage for.
     * @returns The realized LP fee percentage.
     */
    SpokePoolClient.prototype.computeRealizedLpFeePct = function (depositEvent) {
        return __awaiter(this, void 0, void 0, function () {
            var lpFee;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.batchComputeRealizedLpFeePct([depositEvent])];
                    case 1:
                        lpFee = (_a.sent())[0];
                        return [2 /*return*/, lpFee];
                }
            });
        });
    };
    /**
     * Computes the realized LP fee percentage for a batch of deposits.
     * @dev Computing in batch opens up for efficiencies, e.g. in quoteTimestamp -> blockNumber resolution.
     * @param depositEvents The array of deposit events to compute the realized LP fee percentage for.
     * @returns The array of realized LP fee percentages and associated HubPool block numbers.
     */
    SpokePoolClient.prototype.batchComputeRealizedLpFeePct = function (depositEvents) {
        return __awaiter(this, void 0, void 0, function () {
            var realizedLpFeePct_1, quoteBlock_1, deposits, _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        // If no hub pool client, we're using this for testing. Set quote block very high so that if it's ever
                        // used to look up a configuration for a block, it will always match with the latest configuration.
                        if (this.hubPoolClient === null) {
                            realizedLpFeePct_1 = bnZero;
                            quoteBlock_1 = MAX_BIG_INT.toNumber();
                            return [2 /*return*/, depositEvents.map(function () {
                                    return { realizedLpFeePct: realizedLpFeePct_1, quoteBlock: quoteBlock_1 };
                                })];
                        }
                        deposits = depositEvents.map(function (event) {
                            var _a, _b;
                            var inputToken, inputAmount;
                            // For v3 deposits, leave payment chain ID undefined so we don't compute lp fee since we don't have the
                            // payment chain ID until we match this deposit with a fill.
                            var _paymentChainId;
                            if (_this.isV3DepositEvent(event)) {
                                (_a = event.args, inputToken = _a.inputToken, inputAmount = _a.inputAmount);
                            }
                            else {
                                // Coerce v2 deposit objects into V3 format.
                                (_b = event.args, inputToken = _b.originToken, inputAmount = _b.amount);
                                _paymentChainId = Number(event.args.destinationChainId);
                            }
                            return {
                                inputToken: inputToken,
                                inputAmount: inputAmount,
                                originChainId: _this.chainId,
                                paymentChainId: _paymentChainId,
                                quoteTimestamp: event.args.quoteTimestamp,
                            };
                        });
                        if (!(deposits.length > 0)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.hubPoolClient.batchComputeRealizedLpFeePct(deposits)];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _a = [];
                        _b.label = 3;
                    case 3: return [2 /*return*/, _a];
                }
            });
        });
    };
    /**
     * Retrieves the destination token for a given deposit.
     * @param deposit The deposit to retrieve the destination token for.
     * @returns The destination token.
     */
    SpokePoolClient.prototype.getDestinationTokenForDeposit = function (deposit) {
        // If there is no rate model client return address(0).
        if (!this.hubPoolClient) {
            return ZERO_ADDRESS;
        }
        return this.hubPoolClient.getL2TokenForDeposit(deposit);
    };
    /**
     * Performs a log for a specific level, message and data.
     * @param level The log level.
     * @param message The log message.
     * @param data Optional data to log.
     */
    SpokePoolClient.prototype.log = function (level, message, data) {
        this.logger[level](__assign({ at: "SpokePoolClient", chainId: this.chainId, message: message }, data));
    };
    /**
     * Retrieves the current time from the SpokePool contract.
     * @returns The current time, which will be 0 if there has been no update() yet.
     */
    SpokePoolClient.prototype.getCurrentTime = function () {
        return this.currentTime;
    };
    /**
     * Retrieves the oldest time searched on the SpokePool contract.
     * @returns The oldest time searched, which will be 0 if there has been no update() yet.
     */
    SpokePoolClient.prototype.getOldestTime = function () {
        return this.oldestTime;
    };
    /**
     * Finds a deposit for a given deposit ID, destination chain ID and depositor address. This method will search for
     * the deposit in the SpokePool contract and return it if found. If the deposit is not found, this method will
     * perform a binary search to find the block range that contains the deposit ID and then perform an eth_getLogs
     * call to find the deposit.
     * @param depositId The deposit ID to find.
     * @param destinationChainId The destination chain ID to find.
     * @param depositor The depositor address to find.
     * @returns The deposit if found.
     * @note This method is used to find deposits that are outside of the search range of this client.
     */
    SpokePoolClient.prototype.findDeposit = function (depositId, destinationChainId, depositor) {
        return __awaiter(this, void 0, void 0, function () {
            var searchBounds, tStart, query, tStop, event, srcChain, dstChain, partialDeposit, _a, realizedLpFeePct, quoteBlockNumber, deposit;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._getBlockRangeForDepositId(depositId, this.deploymentBlock, this.latestBlockSearched, 7)];
                    case 1:
                        searchBounds = _b.sent();
                        tStart = Date.now();
                        return [4 /*yield*/, paginatedEventQuery(this.spokePool, this.spokePool.filters.FundsDeposited(null, null, destinationChainId, null, depositId, null, null, null, depositor, null), {
                                fromBlock: searchBounds.low,
                                toBlock: searchBounds.high,
                                maxBlockLookBack: this.eventSearchConfig.maxBlockLookBack,
                            })];
                    case 2:
                        query = _b.sent();
                        tStop = Date.now();
                        event = query.find(function (deposit) { return deposit.args.depositId === depositId; });
                        if (event === undefined) {
                            srcChain = getNetworkName(this.chainId);
                            dstChain = getNetworkName(destinationChainId);
                            throw new Error("Could not find deposit ".concat(depositId, " for ").concat(dstChain, " fill") +
                                " between ".concat(srcChain, " blocks [").concat(searchBounds.low, ", ").concat(searchBounds.high, "]"));
                        }
                        partialDeposit = spreadEventWithBlockNumber(event);
                        return [4 /*yield*/, this.batchComputeRealizedLpFeePct([event])];
                    case 3:
                        _a = (_b.sent())[0], realizedLpFeePct = _a.realizedLpFeePct, quoteBlockNumber = _a.quoteBlock;
                        deposit = __assign(__assign({}, partialDeposit), { realizedLpFeePct: realizedLpFeePct, destinationToken: this.getDestinationTokenForDeposit(partialDeposit), quoteBlockNumber: quoteBlockNumber });
                        this.logger.debug({
                            at: "SpokePoolClient#findDeposit",
                            message: "Located deposit outside of SpokePoolClient's search range",
                            deposit: deposit,
                            elapsedMs: tStop - tStart,
                        });
                        return [2 /*return*/, deposit];
                }
            });
        });
    };
    SpokePoolClient.prototype.findDepositV3 = function (depositId, destinationChainId, depositor) {
        return __awaiter(this, void 0, void 0, function () {
            var searchBounds, tStart, query, tStop, event, srcChain, dstChain, partialDeposit, quoteBlockNumber, deposit;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getBlockRangeForDepositId(depositId, this.deploymentBlock, this.latestBlockSearched, 7)];
                    case 1:
                        searchBounds = _a.sent();
                        tStart = Date.now();
                        return [4 /*yield*/, paginatedEventQuery(this.spokePool, this.spokePool.filters.V3FundsDeposited(null, null, null, null, destinationChainId, depositId, null, null, null, depositor, null, null, null), {
                                fromBlock: searchBounds.low,
                                toBlock: searchBounds.high,
                                maxBlockLookBack: this.eventSearchConfig.maxBlockLookBack,
                            })];
                    case 2:
                        query = _a.sent();
                        tStop = Date.now();
                        event = query.find(function (deposit) { return deposit.args.depositId === depositId; });
                        if (event === undefined) {
                            srcChain = getNetworkName(this.chainId);
                            dstChain = getNetworkName(destinationChainId);
                            throw new Error("Could not find deposit ".concat(depositId, " for ").concat(dstChain, " fill") +
                                " between ".concat(srcChain, " blocks [").concat(searchBounds.low, ", ").concat(searchBounds.high, "]"));
                        }
                        partialDeposit = spreadEventWithBlockNumber(event);
                        return [4 /*yield*/, this.batchComputeRealizedLpFeePct([event])];
                    case 3:
                        quoteBlockNumber = (_a.sent())[0].quoteBlock;
                        deposit = __assign(__assign({}, partialDeposit), { originChainId: this.chainId, quoteBlockNumber: quoteBlockNumber, outputToken: partialDeposit.outputToken === ZERO_ADDRESS
                                ? this.getDestinationTokenForDeposit(__assign(__assign({}, partialDeposit), { originChainId: this.chainId }))
                                : partialDeposit.outputToken });
                        this.logger.debug({
                            at: "SpokePoolClient#findDepositV3",
                            message: "Located V3 deposit outside of SpokePoolClient's search range",
                            deposit: deposit,
                            elapsedMs: tStop - tStart,
                        });
                        return [2 /*return*/, deposit];
                }
            });
        });
    };
    return SpokePoolClient;
}(BaseAbstractClient));
export { SpokePoolClient };
//# sourceMappingURL=SpokePoolClient.js.map