import { __awaiter, __extends, __generator } from "tslib";
import assert from "assert";
import { BaseHTTPAdapter } from "./baseAdapter";
var PriceFeed = /** @class */ (function (_super) {
    __extends(PriceFeed, _super);
    function PriceFeed(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.name, name = _c === void 0 ? "DefiLlama" : _c, _d = _b.host, host = _d === void 0 ? "coins.llama.fi" : _d, _e = _b.timeout, timeout = _e === void 0 ? 5000 : _e, _f = _b.retries, retries = _f === void 0 ? 2 : _f, _g = _b.minConfidence, minConfidence = _g === void 0 ? 0.9 : _g;
        var _this = _super.call(this, name, host, { timeout: timeout, retries: retries }) || this;
        assert(minConfidence >= 0.0 && minConfidence <= 1.0);
        _this._minConfidence = minConfidence;
        return _this;
    }
    Object.defineProperty(PriceFeed.prototype, "minConfidence", {
        get: function () {
            return this._minConfidence;
        },
        set: function (minConfidence) {
            assert(minConfidence >= 0.0 && minConfidence <= 1.0);
            this._minConfidence = minConfidence;
        },
        enumerable: false,
        configurable: true
    });
    PriceFeed.prototype.getPriceByAddress = function (address, currency) {
        if (currency === void 0) { currency = "usd"; }
        return __awaiter(this, void 0, void 0, function () {
            var price;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getPricesByAddress([address], currency)];
                    case 1:
                        price = _a.sent();
                        return [2 /*return*/, price[0]];
                }
            });
        });
    };
    PriceFeed.prototype.getPricesByAddress = function (addresses, currency) {
        if (currency === void 0) { currency = "usd"; }
        return __awaiter(this, void 0, void 0, function () {
            var path, response, tokenPrices;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (currency != "usd")
                            throw new Error("Currency ".concat(currency, " not supported by ").concat(this.name));
                        path = "prices/current/" + addresses.map(function (address) { return "ethereum:".concat(address.toLowerCase()); }).join();
                        return [4 /*yield*/, this.query(path, {})];
                    case 1:
                        response = _a.sent();
                        if (!this.validateResponse(response))
                            throw new Error("Unexpected ".concat(this.name, " response: ").concat(JSON.stringify(response)));
                        tokenPrices = Object.fromEntries(Object.entries(response.coins).map(function (_a) {
                            var identifier = _a[0], tokenPrice = _a[1];
                            return [identifier.split(":")[1], tokenPrice];
                        }));
                        return [2 /*return*/, addresses
                                .filter(function (address) {
                                var _a;
                                return (((_a = tokenPrices[address.toLowerCase()]) === null || _a === void 0 ? void 0 : _a.confidence) || 0.0) >= _this.minConfidence;
                            })
                                .map(function (address) {
                                var _a = tokenPrices[address.toLowerCase()], price = _a.price, timestamp = _a.timestamp;
                                return { address: address, price: price, timestamp: timestamp };
                            })];
                }
            });
        });
    };
    PriceFeed.prototype.validateResponse = function (response) {
        if (response === null || typeof response !== "object")
            return false;
        var coins = response.coins;
        if (coins === null || typeof coins !== "object")
            return false;
        return Object.entries(coins).every(function (_a) {
            var address = _a[0], tokenPrice = _a[1];
            // prettier-ignore
            return (/[a-z]+:0[xX][0-9a-fA-F]{40}/.exec(address) !== undefined
                && typeof tokenPrice === "object"
                && typeof tokenPrice.symbol === "string"
                && !isNaN(tokenPrice.decimals)
                && (tokenPrice.decimals > 0 && tokenPrice.decimals <= 18)
                && !isNaN(tokenPrice.price)
                && !isNaN(tokenPrice.timestamp)
                && !isNaN(tokenPrice.confidence));
        });
    };
    return PriceFeed;
}(BaseHTTPAdapter));
export { PriceFeed };
//# sourceMappingURL=defiLlama.js.map