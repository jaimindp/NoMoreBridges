import { __awaiter, __generator } from "tslib";
import assert from "assert";
import axios from "axios";
var BaseHTTPAdapter = /** @class */ (function () {
    function BaseHTTPAdapter(name, host, _a) {
        var _b = _a.timeout, timeout = _b === void 0 ? 1000 : _b, _c = _a.retries, retries = _c === void 0 ? 1 : _c;
        this.name = name;
        this.host = host;
        this._retries = 0;
        this._timeout = 0;
        this.retries = retries;
        this.timeout = timeout; // ms
    }
    Object.defineProperty(BaseHTTPAdapter.prototype, "retries", {
        get: function () {
            return this._retries;
        },
        set: function (retries) {
            assert(retries >= 0);
            this._retries = retries;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BaseHTTPAdapter.prototype, "timeout", {
        get: function () {
            return this._timeout;
        },
        set: function (timeout) {
            assert(timeout >= 0);
            this._timeout = timeout;
        },
        enumerable: false,
        configurable: true
    });
    BaseHTTPAdapter.prototype.query = function (path, urlArgs) {
        return __awaiter(this, void 0, void 0, function () {
            var url, args, errs, tries, err_1, errMsg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = "https://".concat(this.host, "/").concat(path !== null && path !== void 0 ? path : "");
                        args = {
                            timeout: this.timeout,
                            params: urlArgs !== null && urlArgs !== void 0 ? urlArgs : {},
                        };
                        errs = [];
                        tries = 0;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 6]);
                        return [4 /*yield*/, axios(url, args)];
                    case 2: return [2 /*return*/, (_a.sent()).data];
                    case 3:
                        err_1 = _a.sent();
                        errMsg = axios.isAxiosError(err_1) || err_1 instanceof Error ? err_1.message : "unknown error";
                        errs.push(errMsg);
                        if (!(++tries <= this.retries)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.sleep(Math.pow(1.5, tries) * 1000)];
                    case 4:
                        _a.sent(); // simple backoff
                        _a.label = 5;
                    case 5: return [3 /*break*/, 6];
                    case 6:
                        if (tries <= this.retries) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: throw new Error("".concat(this.name, " price lookup failure (").concat(errs.join(", "), ")"));
                }
            });
        });
    };
    BaseHTTPAdapter.prototype.sleep = function (ms) {
        return new Promise(function (r) { return setTimeout(r, ms); });
    };
    return BaseHTTPAdapter;
}());
export { BaseHTTPAdapter };
//# sourceMappingURL=baseAdapter.js.map