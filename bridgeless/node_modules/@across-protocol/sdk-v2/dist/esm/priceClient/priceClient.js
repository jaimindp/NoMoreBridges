import { __awaiter, __generator } from "tslib";
import assert from "assert";
export function msToS(ms) {
    return Math.floor(ms / 1000);
}
// PriceClient aggregates various user-configured price feeds/sources and retains them for a
// configurable time period. External price lookups are performed according to an ordered list that
// is supplied during instantiation. The PriceClient will iterate over the list until a complete set
// of prices has been retrieved from a single source. External price lookups will opportunistically
// request new prices for _all_ previously requested tokens. Price lookups into PriceClient will be
// served out of its local cache if the token price is less than maxPriceAge seconds. This helps to
// suppress external price lookups and can help to mitigate rate-limiting by external providers.
// See README.md for further information and usage guidelines.
var PriceClient = /** @class */ (function () {
    function PriceClient(logger, priceFeeds) {
        this.logger = logger;
        this.priceFeeds = priceFeeds;
        this.name = "PriceClient";
        this._maxPriceAge = 300; // seconds
        this.prices = {};
        assert(logger, "No logging instance supplied.");
        assert(priceFeeds.length > 0, "No price feeds supplied.");
    }
    Object.defineProperty(PriceClient.prototype, "maxPriceAge", {
        get: function () {
            return this._maxPriceAge;
        },
        set: function (age) {
            assert(age >= 0);
            this.logger.debug({
                at: "PriceClient#maxPriceAge",
                message: "Setting maxPriceAge (S) ".concat(this._maxPriceAge, " => ").concat(age, "."),
            });
            this._maxPriceAge = age;
        },
        enumerable: false,
        configurable: true
    });
    PriceClient.prototype.listPriceFeeds = function () {
        return this.priceFeeds.map(function (priceFeed) { return priceFeed.name; });
    };
    PriceClient.prototype.getPriceByAddress = function (address, currency) {
        if (currency === void 0) { currency = "usd"; }
        return __awaiter(this, void 0, void 0, function () {
            var tokenPrices;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getPricesByAddress([address], currency)];
                    case 1:
                        tokenPrices = _a.sent();
                        return [2 /*return*/, tokenPrices[0]];
                }
            });
        });
    };
    // note: Input addresses are *always* converted to lower case for storage as
    // keys in the PriceClient cache. Adapters will therefore always receive
    // addresses in lower case form.
    PriceClient.prototype.getPricesByAddress = function (addresses, currency) {
        if (currency === void 0) { currency = "usd"; }
        return __awaiter(this, void 0, void 0, function () {
            var priceCache, now, missed;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        assert(this.priceFeeds.length > 0, "No price feeds are registered.");
                        priceCache = this.getPriceCache(currency);
                        now = msToS(Date.now());
                        missed = {};
                        addresses.forEach(function (address) {
                            var _a;
                            var addr = address.toLowerCase();
                            var tokenPrice = (_a = priceCache[addr]) !== null && _a !== void 0 ? _a : { price: 0, timestamp: 0 };
                            priceCache[addr] = tokenPrice; // Update priceCache if necessary;
                            var age = now - tokenPrice.timestamp;
                            if (age > _this.maxPriceAge) {
                                missed[address] = age;
                            }
                        });
                        if (!(Object.keys(missed).length > 0)) return [3 /*break*/, 2];
                        this.logger.debug({
                            at: "PriceClient#getPricesByAddress",
                            message: "".concat(currency.toUpperCase(), " cache miss (age > ").concat(this.maxPriceAge, " S)."),
                            tokens: missed,
                        });
                        return [4 /*yield*/, this.updatePrices(currency)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, addresses.map(function (address) {
                            var _a = priceCache[address.toLowerCase()], price = _a.price, timestamp = _a.timestamp;
                            return { address: address, price: price, timestamp: timestamp };
                        })];
                }
            });
        });
    };
    PriceClient.prototype.expireCache = function (currency) {
        var priceCache = this.getPriceCache(currency);
        Object.values(priceCache).forEach(function (token) { return (token.timestamp = 0); });
        this.logger.debug({ at: "PriceClient#expireCache", message: "Expired ".concat(currency, " cache.") });
    };
    PriceClient.prototype.getPriceCache = function (currency) {
        if (this.prices[currency] === undefined)
            this.prices[currency] = {};
        return this.prices[currency];
    };
    PriceClient.prototype.updatePrices = function (currency) {
        return __awaiter(this, void 0, void 0, function () {
            var priceCache, addresses, _i, _a, priceFeed, prices, err_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        priceCache = this.getPriceCache(currency);
                        addresses = Object.keys(priceCache);
                        _i = 0, _a = this.priceFeeds;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 7];
                        priceFeed = _a[_i];
                        this.logger.debug({
                            at: "PriceClient#updatePrices",
                            message: "Looking up prices via ".concat(priceFeed.name, "."),
                            tokens: addresses,
                        });
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 5, , 6]);
                        return [4 /*yield*/, priceFeed.getPricesByAddress(addresses, currency)];
                    case 3:
                        prices = _b.sent();
                        return [4 /*yield*/, this.updateCache(priceCache, prices, addresses)];
                    case 4:
                        addresses = _b.sent();
                        if (addresses.length === 0)
                            return [3 /*break*/, 7]; // All done
                        return [3 /*break*/, 6];
                    case 5:
                        err_1 = _b.sent();
                        this.logger.debug({
                            at: "PriceClient#updatePrices",
                            message: "Price lookup against ".concat(priceFeed.name, " failed (").concat(err_1, ")."),
                            tokens: addresses,
                        });
                        return [3 /*break*/, 6];
                    case 6:
                        _i++;
                        return [3 /*break*/, 1];
                    case 7:
                        if (addresses.length !== 0) {
                            this.logger.debug({
                                at: "PriceClient#updatePrices",
                                message: "Unable to resolve some token prices.",
                                priceFeeds: this.listPriceFeeds(),
                                tokens: addresses,
                            });
                            throw new Error("Price lookup failed against all price feeds (".concat(this.listPriceFeeds().join(", "), ")"));
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    PriceClient.prototype.updateCache = function (priceCache, prices, expected) {
        var _this = this;
        var _a, _b;
        var updated = [];
        var skipped = {}; // Includes reason for skipping
        var now = msToS(Date.now());
        expected.forEach(function (address) {
            var addr = address.toLowerCase(); // for internal priceCache lookup.
            var tokenPrice = prices.find(function (price) { var _a; return ((_a = price === null || price === void 0 ? void 0 : price.address) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === addr; });
            if (tokenPrice === undefined) {
                skipped[address] = "Not included in price feed response.";
            }
            else if (tokenPrice.timestamp > now) {
                skipped[address] = "Token price timestamp is too new (timestamp ".concat(tokenPrice.timestamp, ").");
            }
            else if (tokenPrice.timestamp >= priceCache[addr].timestamp) {
                var price = tokenPrice.price, timestamp = tokenPrice.timestamp;
                // Drop the address; we sub it in when returning to the caller.
                // @todo: Do we care if the token price is older than maxPriceAge?
                priceCache[addr] = { price: price, timestamp: timestamp };
                updated.push(tokenPrice);
            }
            else if (tokenPrice.timestamp === priceCache[addr].timestamp) {
                _this.logger.debug({
                    at: "PriceClient#updateCache",
                    message: "No new price available for token ".concat(address, "."),
                    token: tokenPrice,
                });
            }
        });
        this.logger.debug({
            at: "PriceClient#updateCache",
            message: "Updated ".concat((_a = updated.length) !== null && _a !== void 0 ? _a : 0, " price(s), skipped ").concat((_b = Object.keys(skipped).length) !== null && _b !== void 0 ? _b : 0, "."),
            updated: updated,
            skipped: skipped,
        });
        return Object.keys(skipped);
    };
    return PriceClient;
}());
export { PriceClient };
//# sourceMappingURL=priceClient.js.map