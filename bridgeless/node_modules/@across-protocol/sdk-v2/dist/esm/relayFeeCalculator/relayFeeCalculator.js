import { __assign, __awaiter, __generator } from "tslib";
import assert from "assert";
import { bnZero, fixedPointAdjustment, toBNWei, nativeToToken, toBN, min, max, percent, MAX_BIG_INT, isDefined, isV2Deposit, getDepositInputToken, getDepositOutputAmount, getTokenInformationFromAddress, } from "../utils";
import { DEFAULT_SIMULATED_RELAYER_ADDRESS, TOKEN_SYMBOLS_MAP } from "../constants";
export var expectedCapitalCostsKeys = ["lowerBound", "upperBound", "cutoff", "decimals"];
export var DEFAULT_LOGGER = {
    debug: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return console.debug(args);
    },
    info: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return console.info(args);
    },
    warn: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return console.warn(args);
    },
    error: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return console.error(args);
    },
};
// Small amount to simulate filling with. Should be low enough to guarantee a successful fill.
var safeOutputAmount = toBN(100);
var RelayFeeCalculator = /** @class */ (function () {
    function RelayFeeCalculator(config, logger, destinationChainId) {
        assert(config, "config must be provided");
        if ("queries" in config) {
            this.queries = config.queries;
        }
        else {
            assert(destinationChainId !== undefined, "destinationChainId must be provided if queriesMap is provided");
            assert(config.queriesMap[destinationChainId], "No queries provided for destination chain");
            this.queries = config.queriesMap[destinationChainId];
        }
        this.gasDiscountPercent = config.gasDiscountPercent || 0;
        this.capitalDiscountPercent = config.capitalDiscountPercent || 0;
        this.feeLimitPercent = config.feeLimitPercent || 0;
        this.nativeTokenDecimals = config.nativeTokenDecimals || 18;
        assert(this.gasDiscountPercent >= 0 && this.gasDiscountPercent <= 100, "gasDiscountPercent must be between 0 and 100 percent");
        assert(this.capitalDiscountPercent >= 0 && this.capitalDiscountPercent <= 100, "capitalDiscountPercent must be between 0 and 100 percent");
        assert(this.feeLimitPercent >= 0 && this.feeLimitPercent <= 100, "feeLimitPercent must be between 0 and 100 percent");
        this.capitalCostsConfig = Object.fromEntries(Object.entries(config.capitalCostsConfig).map(function (_a) {
            var token = _a[0], capitalCosts = _a[1];
            return [token.toUpperCase(), RelayFeeCalculator.validateAndTransformCapitalCostsConfigOverride(capitalCosts)];
        }));
        assert(Object.keys(this.capitalCostsConfig).length > 0, "capitalCostsConfig must have at least one entry");
        this.logger = logger || DEFAULT_LOGGER;
    }
    /**
     * Type guard to check if a config is a CapitalCostConfigOverride or a CapitalCostConfig.
     * @param config CapitalCostConfig or CapitalCostConfigOverride
     * @returns true if the config is a CapitalCostConfigOverride, false otherwise.
     * @private
     * @dev This is a type guard that is used to check if a config is a CapitalCostConfigOverride or a CapitalCostConfig.
     * This is needed because the config can be either a CapitalCostConfig or a CapitalCostConfigOverride. If it's a
     * CapitalCostConfig, then we need to convert it to a CapitalCostConfigOverride with the default config set with no route
     * overrides.
     */
    RelayFeeCalculator.capitalCostConfigIsOverride = function (config) {
        return config.default !== undefined;
    };
    /**
     * Validates a CapitalCostConfigOverride or a CapitalCostConfig.
     * @param capitalCosts CapitalCostConfig or CapitalCostConfigOverride
     * @returns CapitalCostConfigOverride
     */
    RelayFeeCalculator.validateAndTransformCapitalCostsConfigOverride = function (capitalCosts) {
        // We need to first convert the config to a baseline type. This is because the config can be either a CapitalCostConfig
        // or a CapitalCostConfigOverride. If it's a CapitalCostConfig, then we need to convert it to a CapitalCostConfigOverride with
        // the default config set with no route overrides.
        var config = this.capitalCostConfigIsOverride(capitalCosts)
            ? capitalCosts
            : { default: capitalCosts };
        // Validate the default config.
        this.validateCapitalCostsConfig(config.default);
        // Iterate over all the route overrides and validate them.
        for (var _i = 0, _a = Object.values(config.routeOverrides || {}); _i < _a.length; _i++) {
            var toChainIdRoutes = _a[_i];
            for (var _b = 0, _c = Object.values(toChainIdRoutes); _b < _c.length; _b++) {
                var override = _c[_b];
                this.validateCapitalCostsConfig(override);
            }
        }
        return config;
    };
    /**
     * Validates a CapitalCostConfig.
     * @param capitalCosts CapitalCostConfig
     */
    RelayFeeCalculator.validateCapitalCostsConfig = function (capitalCosts) {
        assert(toBN(capitalCosts.upperBound).lt(toBNWei("0.01")), "upper bound must be < 1%");
        assert(toBN(capitalCosts.lowerBound).lte(capitalCosts.upperBound), "lower bound must be <= upper bound");
        assert(capitalCosts.decimals > 0 && capitalCosts.decimals <= 18, "invalid decimals");
    };
    RelayFeeCalculator.prototype.getTokenPrice = function (tokenSymbol) {
        return this.queries.getTokenPrice(tokenSymbol);
    };
    /**
     * Calculate the gas fee as a % of the amount to relay.
     * @param deposit A valid deposit object to reason about
     * @param amountToRelay The amount that we should fill the deposit for
     * @param simulateZeroFill Whether to simulate a zero fill for the gas cost simulation
     *        A fill of 1 wei which would result in a slow/partial fill.
     *        You should do this if you're not worried about simulating a proper fill of a deposit
     *        with a message or if you are worried a fill amount that could exceed the balance of
     *        the relayer.
     * @param relayerAddress The relayer that will be used for the gas cost simulation
     * @param _tokenPrice The token price for normalizing fees
     * @returns The fee as a % of the amount to relay.
     * @note Setting simulateZeroFill to true will result on the gas costs being estimated
     *       on a zero fill. However, the percentage will be returned as a percentage of the
     *       amount to relay. This is useful for determining the maximum gas fee % that a
     *       relayer may need to make on a regular fill. You will get differing results if
     *       a message & recipient contract is provided as this function may not simulate with
     *       the correct parameters to see a full fill.
     */
    RelayFeeCalculator.prototype.gasFeePercent = function (deposit, amountToRelay, simulateZeroFill, relayerAddress, _tokenPrice, tokenMapping) {
        if (simulateZeroFill === void 0) { simulateZeroFill = false; }
        if (relayerAddress === void 0) { relayerAddress = DEFAULT_SIMULATED_RELAYER_ADDRESS; }
        if (tokenMapping === void 0) { tokenMapping = TOKEN_SYMBOLS_MAP; }
        return __awaiter(this, void 0, void 0, function () {
            var inputToken, token, simulatedAmount, getGasCosts, getTokenPrice, _a, tokenGasCost, tokenPrice, gasFeesInToken;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (toBN(amountToRelay).eq(bnZero))
                            return [2 /*return*/, MAX_BIG_INT];
                        inputToken = getDepositInputToken(deposit);
                        token = getTokenInformationFromAddress(inputToken, tokenMapping);
                        if (!isDefined(token)) {
                            throw new Error("Could not find token information for ".concat(inputToken));
                        }
                        simulatedAmount = simulateZeroFill ? safeOutputAmount : toBN(amountToRelay);
                        deposit = isV2Deposit(deposit)
                            ? __assign(__assign({}, deposit), { amount: simulatedAmount }) : __assign(__assign({}, deposit), { outputAmount: simulatedAmount });
                        getGasCosts = this.queries.getGasCosts(deposit, simulatedAmount, relayerAddress).catch(function (error) {
                            _this.logger.error({
                                at: "sdk-v2/gasFeePercent",
                                message: "Error while fetching gas costs",
                                error: error,
                                simulateZeroFill: simulateZeroFill,
                                deposit: deposit,
                            });
                            throw error;
                        });
                        getTokenPrice = this.queries.getTokenPrice(token.symbol).catch(function (error) {
                            _this.logger.error({
                                at: "sdk-v2/gasFeePercent",
                                message: "Error while fetching token price",
                                error: error,
                                destinationChainId: deposit.destinationChainId,
                                inputToken: inputToken,
                            });
                            throw error;
                        });
                        return [4 /*yield*/, Promise.all([
                                getGasCosts,
                                _tokenPrice !== undefined ? _tokenPrice : getTokenPrice,
                            ])];
                    case 1:
                        _a = _b.sent(), tokenGasCost = _a[0].tokenGasCost, tokenPrice = _a[1];
                        gasFeesInToken = nativeToToken(tokenGasCost, tokenPrice, token.decimals, this.nativeTokenDecimals);
                        return [2 /*return*/, percent(gasFeesInToken, amountToRelay.toString())];
                }
            });
        });
    };
    // Note: these variables are unused now, but may be needed in future versions of this function that are more complex.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    RelayFeeCalculator.prototype.capitalFeePercent = function (_amountToRelay, _tokenSymbol, _originRoute, _destinationRoute) {
        var _a, _b, _c;
        // If amount is 0, then the capital fee % should be the max 100%
        if (toBN(_amountToRelay).eq(toBN(0)))
            return MAX_BIG_INT;
        // V0: Ensure that there is a capital fee available for the token.
        // If not, then we should throw an error because this is indicative
        // of a misconfiguration.
        var tokenCostConfig = this.capitalCostsConfig[_tokenSymbol.toUpperCase()];
        if (!isDefined(tokenCostConfig)) {
            this.logger.error({
                at: "sdk-v2/capitalFeePercent",
                message: "No capital fee available for token ".concat(_tokenSymbol),
            });
            throw new Error("No capital cost config available for token ".concat(_tokenSymbol));
        }
        // V1: Charge fee that scales with size. This will charge a fee % based on a linear fee curve with a "kink" at a
        // cutoff in the same units as _amountToRelay. Before the kink, the fee % will increase linearly from a lower
        // bound to an upper bound. After the kink, the fee % increase will be fixed, and slowly approach the upper bound
        // for very large amount inputs.
        else {
            var config = isDefined(_originRoute) && isDefined(_destinationRoute)
                ? (_c = (_b = (_a = tokenCostConfig.routeOverrides) === null || _a === void 0 ? void 0 : _a[_originRoute]) === null || _b === void 0 ? void 0 : _b[_destinationRoute]) !== null && _c !== void 0 ? _c : tokenCostConfig.default
                : tokenCostConfig.default;
            // Scale amount "y" to 18 decimals.
            var y = toBN(_amountToRelay).mul(toBNWei("1", 18 - config.decimals));
            // At a minimum, the fee will be equal to lower bound fee * y
            var minCharge = toBN(config.lowerBound).mul(y).div(fixedPointAdjustment);
            // Charge an increasing marginal fee % up to min(cutoff, y). If y is very close to the cutoff, the fee %
            // will be equal to half the sum of (upper bound + lower bound).
            var yTriangle = min(config.cutoff, y);
            // triangleSlope is slope of fee curve from lower bound to upper bound. If cutoff is 0, slope is 0.
            // triangleCharge is interval of curve from 0 to y for curve = triangleSlope * y
            var triangleSlope = toBN(config.cutoff).eq(toBN(0))
                ? toBN(0)
                : toBN(config.upperBound).sub(config.lowerBound).mul(fixedPointAdjustment).div(config.cutoff);
            var triangleHeight = triangleSlope.mul(yTriangle).div(fixedPointAdjustment);
            var triangleCharge = triangleHeight.mul(yTriangle).div(toBNWei(2));
            // For any amounts above the cutoff, the marginal fee % will not increase but will be fixed at the upper bound
            // value.
            var yRemainder = max(toBN(0), y.sub(config.cutoff));
            var remainderCharge = yRemainder.mul(toBN(config.upperBound).sub(config.lowerBound)).div(fixedPointAdjustment);
            return minCharge.add(triangleCharge).add(remainderCharge).mul(fixedPointAdjustment).div(y);
        }
    };
    /**
     * Retrieves the relayer fee details for a deposit.
     * @param deposit A valid deposit object to reason about
     * @param amountToRelay The amount that the relayer would simulate a fill for
     * @param simulateZeroFill Whether to simulate a zero fill for the gas cost simulation
     *       For simulateZeroFill: A fill of 1 wei which would result in a slow/partial fill.
     *       You should do this if you're not worried about simulating a proper fill of a deposit
     *       with a message or if you are worried a fill amount that could exceed the balance of
     *       the relayer.
     * @param relayerAddress The relayer that will be used for the gas cost simulation
     * @param _tokenPrice The token price for normalizing fees
     * @returns A resulting `RelayerFeeDetails` object
     */
    RelayFeeCalculator.prototype.relayerFeeDetails = function (deposit, amountToRelay, simulateZeroFill, relayerAddress, _tokenPrice) {
        if (simulateZeroFill === void 0) { simulateZeroFill = false; }
        if (relayerAddress === void 0) { relayerAddress = DEFAULT_SIMULATED_RELAYER_ADDRESS; }
        return __awaiter(this, void 0, void 0, function () {
            var inputToken, token, gasFeePercent, gasFeeTotal, capitalFeePercent, capitalFeeTotal, relayFeePercent, relayFeeTotal, maxGasFeePercent, minDeposit, isAmountTooLow;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // If the amount to relay is not provided, then we
                        // should use the full deposit amount.
                        amountToRelay !== null && amountToRelay !== void 0 ? amountToRelay : (amountToRelay = getDepositOutputAmount(deposit));
                        inputToken = getDepositInputToken(deposit);
                        token = getTokenInformationFromAddress(inputToken);
                        if (!isDefined(token)) {
                            throw new Error("Could not find token information for ".concat(inputToken));
                        }
                        return [4 /*yield*/, this.gasFeePercent(deposit, amountToRelay, simulateZeroFill, relayerAddress, _tokenPrice)];
                    case 1:
                        gasFeePercent = _a.sent();
                        gasFeeTotal = gasFeePercent.mul(amountToRelay).div(fixedPointAdjustment);
                        capitalFeePercent = this.capitalFeePercent(amountToRelay, token.symbol, deposit.originChainId.toString(), deposit.destinationChainId.toString());
                        capitalFeeTotal = capitalFeePercent.mul(amountToRelay).div(fixedPointAdjustment);
                        relayFeePercent = gasFeePercent.add(capitalFeePercent);
                        relayFeeTotal = gasFeeTotal.add(capitalFeeTotal);
                        maxGasFeePercent = max(toBNWei(this.feeLimitPercent / 100).sub(capitalFeePercent), toBN(0));
                        if (maxGasFeePercent.eq(toBN(0))) {
                            minDeposit = MAX_BIG_INT;
                            isAmountTooLow = true;
                        }
                        else {
                            minDeposit = gasFeeTotal.mul(fixedPointAdjustment).div(maxGasFeePercent);
                            isAmountTooLow = toBN(amountToRelay).lt(minDeposit);
                        }
                        return [2 /*return*/, {
                                amountToRelay: amountToRelay.toString(),
                                tokenSymbol: token.symbol,
                                gasFeePercent: gasFeePercent.toString(),
                                gasFeeTotal: gasFeeTotal.toString(),
                                gasDiscountPercent: this.gasDiscountPercent,
                                capitalFeePercent: capitalFeePercent.toString(),
                                capitalFeeTotal: capitalFeeTotal.toString(),
                                capitalDiscountPercent: this.capitalDiscountPercent,
                                relayFeePercent: relayFeePercent.toString(),
                                relayFeeTotal: relayFeeTotal.toString(),
                                feeLimitPercent: this.feeLimitPercent,
                                maxGasFeePercent: maxGasFeePercent.toString(),
                                minDeposit: minDeposit.toString(),
                                isAmountTooLow: isAmountTooLow,
                            }];
                }
            });
        });
    };
    return RelayFeeCalculator;
}());
export { RelayFeeCalculator };
//# sourceMappingURL=relayFeeCalculator.js.map