import { __awaiter, __generator } from "tslib";
import { SpokePool__factory } from "../../typechain";
import { Coingecko } from "../../coingecko";
import { CHAIN_IDs, DEFAULT_SIMULATED_RELAYER_ADDRESS } from "../../constants";
import { createUnsignedFillRelayTransactionFromDeposit, estimateTotalGasRequiredByUnsignedTransaction, isV2Deposit, populateV3Relay, toBN, } from "../../utils";
/**
 * A unified QueryBase for querying gas costs, token prices, and decimals of various tokens
 * on a blockchain.
 */
var QueryBase = /** @class */ (function () {
    /**
     * Instantiates a QueryBase instance
     * @param provider A valid Ethers.js provider
     * @param symbolMapping A mapping to valid ERC20 tokens and their respective characteristics
     * @param spokePoolAddress The valid address of the Spoke Pool deployment
     * @param usdcAddress The valid token address of the USDC ERC-20 token
     * @param simulatedRelayerAddress The address that these queries will reference as the sender. Note: This address must be approved for USDC
     * @param gasMarkup A multiplier that is applied to the total gas estimate
     * @param logger A logging utility to report logs
     * @param coingeckoProApiKey An optional CoinGecko API key that links to a PRO account
     * @param fixedGasPrice Overrides the gas price with a fixed value. Note: primarily used for the Boba blockchain
     * @param coingeckoBaseCurrency The basis currency that CoinGecko will use to resolve pricing
     */
    function QueryBase(provider, symbolMapping, spokePoolAddress, simulatedRelayerAddress, gasMarkup, logger, coingeckoProApiKey, fixedGasPrice, coingeckoBaseCurrency) {
        if (coingeckoBaseCurrency === void 0) { coingeckoBaseCurrency = "eth"; }
        this.provider = provider;
        this.symbolMapping = symbolMapping;
        this.spokePoolAddress = spokePoolAddress;
        this.simulatedRelayerAddress = simulatedRelayerAddress;
        this.gasMarkup = gasMarkup;
        this.logger = logger;
        this.coingeckoProApiKey = coingeckoProApiKey;
        this.fixedGasPrice = fixedGasPrice;
        this.coingeckoBaseCurrency = coingeckoBaseCurrency;
        this.spokePool = SpokePool__factory.connect(spokePoolAddress, provider);
    }
    /**
     * Retrieves the current gas costs of performing a fillRelay contract at the referenced SpokePool.
     * @param deposit Deposit instance (v2 or v3).
     * @param amountToRelay Amount of the deposit to fill.
     * @param relayerAddress Relayer address to simulate with.
     * @returns The gas estimate for this function call (multplied with the optional buffer).
     */
    QueryBase.prototype.getGasCosts = function (deposit, fillAmount, relayer) {
        if (relayer === void 0) { relayer = DEFAULT_SIMULATED_RELAYER_ADDRESS; }
        relayer !== null && relayer !== void 0 ? relayer : (relayer = this.simulatedRelayerAddress);
        return isV2Deposit(deposit)
            ? this.getV2GasCosts(deposit, fillAmount, relayer)
            : this.getV3GasCosts(deposit, relayer);
    };
    /**
     * Retrieves the current gas costs of performing a fillRelay contract at the referenced SpokePool
     * @param deposit V2Deposit instance.
     * @param amountToRelay Amount of the deposit to fill.
     * @param relayer Relayer address to simulate with.
     * @returns The gas estimate for this function call (multplied with the optional buffer).
     */
    QueryBase.prototype.getV2GasCosts = function (deposit, amountToRelay, relayer) {
        return __awaiter(this, void 0, void 0, function () {
            var tx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, createUnsignedFillRelayTransactionFromDeposit(this.spokePool, deposit, toBN(amountToRelay), relayer)];
                    case 1:
                        tx = _a.sent();
                        return [2 /*return*/, estimateTotalGasRequiredByUnsignedTransaction(tx, relayer, this.provider, this.gasMarkup, this.fixedGasPrice)];
                }
            });
        });
    };
    /**
     * Retrieves the current gas costs of performing a fillV3Relay contract at the referenced SpokePool.
     * @param deposit V3Deposit instance.
     * @param relayer Relayer address to simulate with.
     * @returns The gas estimate for this function call (multplied with the optional buffer).
     */
    QueryBase.prototype.getV3GasCosts = function (deposit, relayer) {
        return __awaiter(this, void 0, void 0, function () {
            var tx;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, populateV3Relay(this.spokePool, deposit, relayer)];
                    case 1:
                        tx = _a.sent();
                        return [2 /*return*/, estimateTotalGasRequiredByUnsignedTransaction(tx, relayer, this.provider, this.gasMarkup, this.fixedGasPrice)];
                }
            });
        });
    };
    /**
     * Retrieves the current price of a token
     * @param tokenSymbol A valid [CoinGecko-ID](https://api.coingecko.com/api/v3/coins/list)
     * @returns The resolved token price within the specified coingeckoBaseCurrency
     */
    QueryBase.prototype.getTokenPrice = function (tokenSymbol) {
        return __awaiter(this, void 0, void 0, function () {
            var coingeckoInstance, _a, price;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.symbolMapping[tokenSymbol])
                            throw new Error("".concat(tokenSymbol, " does not exist in mapping"));
                        coingeckoInstance = Coingecko.get(this.logger, this.coingeckoProApiKey);
                        return [4 /*yield*/, coingeckoInstance.getCurrentPriceByContract(this.symbolMapping[tokenSymbol].addresses[CHAIN_IDs.MAINNET], this.coingeckoBaseCurrency)];
                    case 1:
                        _a = _b.sent(), price = _a[1];
                        return [2 /*return*/, price];
                }
            });
        });
    };
    /**
     * Resolves the number of decimal places a token can have
     * @param tokenSymbol A valid Across-Enabled Token ID
     * @returns The number of decimals of precision for the corresponding tokenSymbol
     */
    QueryBase.prototype.getTokenDecimals = function (tokenSymbol) {
        if (!this.symbolMapping[tokenSymbol])
            throw new Error("".concat(tokenSymbol, " does not exist in mapping"));
        return this.symbolMapping[tokenSymbol].decimals;
    };
    return QueryBase;
}());
export default QueryBase;
//# sourceMappingURL=baseQuery.js.map