import { __assign } from "tslib";
import { MerkleTree } from "@across-protocol/contracts-v2/dist/utils/MerkleTree";
import { ethers } from "ethers";
var MerkleDistributor = /** @class */ (function () {
    function MerkleDistributor() {
    }
    /**
     * Generate the Merkle root and the proofs for a collection of recipients.
     *
     * @param recipients An object which describes the recipients
     * @param windowIndex Parameter to specify an window index. This allows using the same smart contract for multiple token distributions.
     */
    MerkleDistributor.createMerkleDistributionProofs = function (recipients, windowIndex) {
        var merkleTree = new MerkleTree(recipients, MerkleDistributor.createLeaf);
        var recipientsWithProofs = recipients.reduce(function (acc, recipient) {
            var _a;
            return __assign(__assign({}, acc), (_a = {}, _a[recipient.account] = __assign(__assign({}, recipient), { proof: merkleTree.getHexProof(recipient), windowIndex: windowIndex }), _a));
        }, {});
        return { recipientsWithProofs: recipientsWithProofs, merkleRoot: merkleTree.getHexRoot() };
    };
    /**
     * Encode the account address, the amount and the account index into a Merkle Tree leaf.
     * It is equivalent to Solidity's keccak256(abi.encode(account, amount))
     * @param recipient The recipient of the token distribution
     * @returns The Merkle Tree leaf
     */
    MerkleDistributor.createLeaf = function (recipient) {
        var account = recipient.account, amount = recipient.amount, accountIndex = recipient.accountIndex;
        return ethers.utils.solidityKeccak256(["address", "uint256", "uint256"], [account, amount, accountIndex]);
    };
    return MerkleDistributor;
}());
export { MerkleDistributor };
//# sourceMappingURL=MerkleDistributor.js.map