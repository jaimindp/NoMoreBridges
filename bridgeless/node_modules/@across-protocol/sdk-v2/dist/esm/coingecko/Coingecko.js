import { __awaiter, __generator } from "tslib";
import axios from "axios";
import assert from "assert";
import get from "lodash.get";
import { retry } from "../utils";
export function msToS(ms) {
    return Math.floor(ms / 1000);
}
// Singleton Coingecko class.
var Coingecko = /** @class */ (function () {
    function Coingecko(host, proHost, logger, apiKey) {
        this.host = host;
        this.proHost = proHost;
        this.logger = logger;
        this.apiKey = apiKey;
        this._maxPriceAge = 300; // seconds
        // Retry configuration.
        this.retryDelay = 1;
        this.numRetries = 0; // Most failures are due to 429 rate-limiting, so there is no point in retrying.
        this.basicApiTimeout = 500; // ms
        this.prices = {};
    }
    Coingecko.get = function (logger, apiKey) {
        if (!this.instance)
            this.instance = new Coingecko("https://api.coingecko.com/api/v3", "https://pro-api.coingecko.com/api/v3", logger, apiKey);
        return this.instance;
    };
    Object.defineProperty(Coingecko.prototype, "maxPriceAge", {
        get: function () {
            return this._maxPriceAge;
        },
        set: function (age) {
            assert(age >= 0);
            this.logger.debug({
                at: "Coingecko#maxPriceAge",
                message: "Setting maxPriceAge (S) ".concat(this._maxPriceAge, " => ").concat(age, "."),
            });
            this._maxPriceAge = age;
        },
        enumerable: false,
        configurable: true
    });
    // Fetch historic prices for a `contract` denominated in `currency` between timestamp `from` and `to`. Note timestamps
    // are assumed to be js timestamps and are converted to unixtimestamps by dividing by 1000.
    Coingecko.prototype.getHistoricContractPrices = function (contract, from, to, currency) {
        if (currency === void 0) { currency = "usd"; }
        return __awaiter(this, void 0, void 0, function () {
            var _from, _to, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        assert(contract, "requires contract address");
                        assert(currency, "requires currency symbol");
                        assert(from, "requires from timestamp");
                        assert(to, "requires to timestamp");
                        _from = msToS(from);
                        _to = msToS(to);
                        return [4 /*yield*/, this.call("coins/ethereum/contract/".concat(contract.toLowerCase(), "/market_chart/range/?vs_currency=").concat(currency, "&from=").concat(_from, "&to=").concat(_to))];
                    case 1:
                        result = _a.sent();
                        // fyi timestamps are returned in ms in contrast to the current price endpoint
                        if (result.prices)
                            return [2 /*return*/, result.prices];
                        throw new Error("Something went wrong fetching coingecko prices!");
                }
            });
        });
    };
    Coingecko.prototype.getContractDetails = function (contract_address, platform_id) {
        if (platform_id === void 0) { platform_id = "ethereum"; }
        return this.call("coins/".concat(platform_id, "/contract/").concat(contract_address.toLowerCase()));
    };
    Coingecko.prototype.getCurrentPriceByContract = function (contract_address, currency, platform_id) {
        if (currency === void 0) { currency = "usd"; }
        if (platform_id === void 0) { platform_id = "ethereum"; }
        return __awaiter(this, void 0, void 0, function () {
            var priceCache, now, tokenPrice;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        priceCache = this.getPriceCache(currency, platform_id);
                        now = msToS(Date.now());
                        tokenPrice = priceCache[contract_address];
                        if (!(tokenPrice === undefined || tokenPrice.timestamp + this.maxPriceAge <= now)) return [3 /*break*/, 2];
                        if (this.maxPriceAge > 0) {
                            this.logger.debug({
                                at: "Coingecko#getCurrentPriceByContract",
                                message: "Cache miss on ".concat(platform_id, "/").concat(currency, " for ").concat(contract_address),
                                maxPriceAge: this.maxPriceAge,
                                tokenPrice: tokenPrice,
                            });
                        }
                        return [4 /*yield*/, this.getContractPrices([contract_address], currency, platform_id)];
                    case 1:
                        _a.sent();
                        tokenPrice = priceCache[contract_address];
                        return [3 /*break*/, 3];
                    case 2:
                        this.logger.debug({
                            at: "Coingecko#getCurrentPriceByContract",
                            message: "Cache hit on token ".concat(contract_address, " (age ").concat(now - tokenPrice.timestamp, " S)."),
                            price: tokenPrice,
                        });
                        _a.label = 3;
                    case 3:
                        assert(tokenPrice !== undefined);
                        return [2 /*return*/, [tokenPrice.timestamp.toString(), tokenPrice.price]];
                }
            });
        });
    };
    // Return an array of spot prices for an array of collateral addresses in one async call. Note we might in future
    // This was adapted from packages/merkle-distributor/kpi-options-helpers/calculate-uma-tvl.ts
    Coingecko.prototype.getContractPrices = function (addresses, currency, platform_id) {
        if (currency === void 0) { currency = "usd"; }
        if (platform_id === void 0) { platform_id = "ethereum"; }
        return __awaiter(this, void 0, void 0, function () {
            var priceCache, contract_addresses, result, err_1, errMsg, updated;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        priceCache = this.getPriceCache(currency, platform_id);
                        // Pre-populate price cache with requested token addresses
                        addresses.forEach(function (addr) {
                            if (priceCache[addr] === undefined) {
                                priceCache[addr] = { address: addr, price: 0, timestamp: 0 };
                            }
                        });
                        contract_addresses = Object.keys(priceCache);
                        assert(contract_addresses.length > 0, "Must supply at least 1 contract address");
                        this.logger.debug({
                            at: "Coingecko#getContractPrices",
                            message: "Updating ".concat(platform_id, "/").concat(currency, " token prices."),
                            tokens: contract_addresses,
                        });
                        result = {};
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.call("simple/token_price/".concat(platform_id, "?contract_addresses=").concat(contract_addresses.join("%2C"), "&vs_currencies=").concat(currency, "&include_last_updated_at=true"))];
                    case 2:
                        // Coingecko expects a comma-delimited (%2c) list.
                        result = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        errMsg = "Failed to retrieve ".concat(platform_id, "/").concat(currency, " prices (").concat(err_1, ")");
                        this.logger.debug({
                            at: "Coingecko#getCurrentPriceByContract",
                            message: errMsg,
                            tokens: contract_addresses,
                        });
                        throw new Error(errMsg);
                    case 4:
                        updated = [];
                        contract_addresses.forEach(function (addr) {
                            var cgPrice = result[addr.toLowerCase()];
                            if (cgPrice === undefined) {
                                _this.logger.debug({
                                    at: "Coingecko#getContractPrices",
                                    message: "Token ".concat(addr, " not included in CoinGecko response."),
                                });
                            }
                            else if (cgPrice.last_updated_at > priceCache[addr].timestamp) {
                                priceCache[addr] = {
                                    address: addr,
                                    price: cgPrice[currency],
                                    timestamp: cgPrice.last_updated_at,
                                };
                                updated.push(addr);
                            }
                            else if (cgPrice.last_updated_at === priceCache[addr].timestamp) {
                                _this.logger.debug({
                                    at: "Coingecko#getContractPrices",
                                    message: "No new price available for token ".concat(addr, "."),
                                    token: cgPrice,
                                });
                            }
                        });
                        if (updated.length > 0) {
                            this.logger.debug({
                                at: "Coingecko#updatePriceCache",
                                message: "Updated ".concat(platform_id, "/").concat(currency, " token price cache."),
                                tokens: updated,
                            });
                        }
                        return [2 /*return*/, addresses.map(function (addr) { return priceCache[addr]; })];
                }
            });
        });
    };
    Coingecko.prototype.getPlatforms = function () {
        return this.call("asset_platforms");
    };
    Coingecko.prototype.call = function (path) {
        var _this = this;
        var sendRequest = function () { return __awaiter(_this, void 0, void 0, function () {
            var proHost, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        proHost = this.proHost;
                        if (!(this.apiKey === undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._callBasic(path)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        _a.trys.push([2, 4, , 6]);
                        return [4 /*yield*/, this._callBasic(path, this.basicApiTimeout)];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        err_2 = _a.sent();
                        this.logger.debug({
                            at: "sdk-v2/coingecko",
                            message: "Basic CG url request failed, falling back to CG PRO host ".concat(proHost),
                            errMessage: err_2.message,
                        });
                        return [4 /*yield*/, this._callPro(path)];
                    case 5: return [2 /*return*/, _a.sent()];
                    case 6: return [2 /*return*/];
                }
            });
        }); };
        // Note: If a pro API key is configured, there is no need to retry as the Pro API will act as the basic's fall back.
        return retry(sendRequest, this.apiKey === undefined ? this.numRetries : 0, this.retryDelay);
    };
    Coingecko.prototype.getPriceCache = function (currency, platform_id) {
        if (this.prices[platform_id] === undefined)
            this.prices[platform_id] = {};
        if (this.prices[platform_id][currency] === undefined)
            this.prices[platform_id][currency] = {};
        return this.prices[platform_id][currency];
    };
    Coingecko.prototype._callBasic = function (path, timeout) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result, err_3, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = "".concat(this.host, "/").concat(path);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, axios(url, { timeout: timeout })];
                    case 2:
                        result = _a.sent();
                        return [2 /*return*/, result.data];
                    case 3:
                        err_3 = _a.sent();
                        msg = get(err_3, "response.data.error", get(err_3, "response.statusText", err_3.message));
                        throw new Error(msg);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Coingecko.prototype._callPro = function (path) {
        return __awaiter(this, void 0, void 0, function () {
            var url, result, err_4, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = "".concat(this.proHost, "/").concat(path);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, axios(url, { params: { x_cg_pro_api_key: this.apiKey } })];
                    case 2:
                        result = _a.sent();
                        return [2 /*return*/, result.data];
                    case 3:
                        err_4 = _a.sent();
                        msg = get(err_4, "response.data.error", get(err_4, "response.statusText", err_4.message));
                        throw new Error(msg);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return Coingecko;
}());
export { Coingecko };
//# sourceMappingURL=Coingecko.js.map