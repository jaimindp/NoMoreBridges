import { L2Provider } from "@eth-optimism/sdk/dist/interfaces/l2-provider";
import Decimal from "decimal.js";
import { BigNumber, PopulatedTransaction, providers } from "ethers";
import { Deposit } from "../interfaces";
import { TypedMessage } from "../interfaces/TypedData";
import { SpokePool } from "../typechain";
import { BigNumberish, BN } from "./BigNumberUtils";
export type Decimalish = string | number | Decimal;
export declare const AddressZero = "0x0000000000000000000000000000000000000000";
export declare const MAX_BIG_INT: BigNumber;
/**
 * toBNWei.
 *
 * @param {BigNumberish} num
 * @param {number} decimals
 * @returns {BN}
 */
export declare const toBNWei: (num: BigNumberish, decimals?: number) => BN;
/**
 * fromWei.
 *
 * @param {BigNumberish} num
 * @param {number} decimals
 * @returns {string}
 */
export declare const fromWei: (num: BigNumberish, decimals?: number) => string;
/**
 * min.
 *
 * @param {BigNumberish} a
 * @param {BigNumberish} b
 * @returns {BN}
 */
export declare function min(a: BigNumberish, b: BigNumberish): BN;
/**
 * max.
 *
 * @param {BigNumberish} a
 * @param {BigNumberish} b
 * @returns {BN}
 */
export declare function max(a: BigNumberish, b: BigNumberish): BN;
export declare const fixedPointAdjustment: BigNumber;
/**
 * Convert an amount of native gas token into a token given price and token decimals.
 *
 * @param {BigNumberish} fromAmount - Amount of native gas token to convert.
 * @param {string | number} [ price=1 ] - The price as native gas token per token, ie how much native gas token can 1 token buy.
 * @param {} [ toDecimals=18 ] - Number of decimals for the token currency.
 * @param {} [ nativeDecimals=18 ] - Number of decimals for the native token currency.
 * @returns {string} The number of tokens denominated in token decimals in the smallest unit (wei).
 */
export declare function nativeToToken(fromAmount: BigNumberish, price?: string | number, toDecimals?: number, nativeDecimals?: number): string;
/**
 * Convert a gas amount and gas price to wei.
 *
 * @param {number} gas - gas amount.
 * @param {BigNumberish} gasPrice - gas price in gwei.
 * @returns {BigNumber} - total fees in wei.
 */
export declare const gasCost: (gas: BigNumberish, gasPrice: BigNumberish) => BigNumber;
/**
 * getGasFees. Low level pure function call to calculate gas fees.
 *
 * @param {number} gas - The gast cost for transfer, use constants defined in file.
 * @param {BigNumberish} gasPrice - Estimated gas price in wei.
 * @param {string | number} [price = 1] - The price of the token in native gas token, how much native gas token can 1 token buy.
 * @param {number} [decimals=18] - Number of decimals of token.
 * @returns {string} - The value of fees native to the token provided, in its smallest unit.
 */
export declare function calculateGasFees(gas: number, gasPrice: BigNumberish, price?: string | number, decimals?: number): string;
/**
 * percent.
 *
 * @param {BigNumberish} numerator
 * @param {BigNumberish} denominator
 * @returns {BN}
 */
export declare function percent(numerator: BigNumberish, denominator: BigNumberish): BN;
/**
 * calcContinuousCompoundInterest. From https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=0&t=1&given_data_last=find_r&action=solve
 * Returns a yearly interest rate if start/end amount had been continuously compounded over the period elapsed. Multiply result by 100 for a %.
 *
 * @param {string} startAmount
 * @param {string} endAmount
 * @param {string} periodsElapsed
 * @param {string} periodsPerYear
 */
export declare const calcContinuousCompoundInterest: (startAmount: Decimalish, endAmount: Decimalish, periodsElapsed: Decimalish, periodsPerYear: Decimalish) => string;
/**
 * calcPeriodicCompoundInterest. Taken from https://www.calculatorsoup.com/calculators/financial/compound-interest-calculator.php?given_data=find_r&A=2&P=1&n=365&t=1&given_data_last=find_r&action=solve
 * This will return a periodically compounded interest rate for 1 year. Multiply result by 100 for a %.
 *
 * @param {string} startAmount - Starting amount or price
 * @param {string} endAmount - Ending amount or price
 * @param {string} periodsElapsed - How many periods elapsed for the start and end amount.
 * @param {string} periodsPerYear - How many periods in 1 year.
 */
export declare const calcPeriodicCompoundInterest: (startAmount: Decimalish, endAmount: Decimalish, periodsElapsed: Decimalish, periodsPerYear: Decimalish) => string;
/**
 * calcApr. Simple apr calculation based on extrapolating the difference for a short period over a year.
 *
 * @param {Decimalish} startAmount - Starting amount or price
 * @param {Decimalish} endAmount - Ending amount or price
 * @param {Decimalish} periodsElapsed - periods elapsed from start to end
 * @param {Decimalish} periodsPerYear - periods per year
 */
export declare const calcApr: (startAmount: Decimalish, endAmount: Decimalish, periodsElapsed: Decimalish, periodsPerYear: Decimalish) => string;
/**
 * Takes two values and returns a list of number intervals
 *
 * @example
 * ```js
 * getSamplesBetween(1, 9, 3) //returns [[1, 3], [4, 7], [8, 9]]
 * ```
 */
export declare const getSamplesBetween: (min: number, max: number, size: number) => number[][];
/**
 * A promise that resolves after a specified number of seconds
 * @param seconds The number of seconds to wait
 */
export declare function delay(seconds: number): Promise<unknown>;
/**
 * Attempt to retry a function call a number of times with a delay between each attempt
 * @param call The function to call
 * @param times The number of times to retry
 * @param delayS The number of seconds to delay between each attempt
 * @returns The result of the function call.
 */
export declare function retry<T>(call: () => Promise<T>, times: number, delayS: number): Promise<T>;
export type TransactionCostEstimate = {
    nativeGasCost: BigNumber;
    tokenGasCost: BigNumber;
};
/**
 * Estimates the total gas cost required to submit an unsigned (populated) transaction on-chain.
 * @param unsignedTx The unsigned transaction that this function will estimate.
 * @param senderAddress The address that the transaction will be submitted from.
 * @param provider A valid ethers provider - will be used to reason the gas price.
 * @param gasMarkup Markup on the estimated gas cost. For example, 0.2 will increase this resulting value 1.2x.
 * @param gasPrice A manually provided gas price - if set, this function will not resolve the current gas price.
 * @returns Estimated cost in units of gas and the underlying gas token (gasPrice * estimatedGasUnits).
 */
export declare function estimateTotalGasRequiredByUnsignedTransaction(unsignedTx: PopulatedTransaction, senderAddress: string, provider: providers.Provider | L2Provider<providers.Provider>, gasMarkup: number, gasPrice?: BigNumberish): Promise<TransactionCostEstimate>;
/**
 * Create an unsigned transaction to fill a relay. This function is used to simulate the gas cost of filling a relay.
 * @param spokePool A valid SpokePool contract instance
 * @param fillToSimulate The fill that this function will use to populate the unsigned transaction
 * @returns An unsigned transaction that can be used to simulate the gas cost of filling a relay
 */
export declare function createUnsignedFillRelayTransactionFromDeposit(spokePool: SpokePool, deposit: Deposit, amountToFill: BN, relayerAddress: string): Promise<PopulatedTransaction>;
export type UpdateDepositDetailsMessageType = {
    UpdateDepositDetails: [
        {
            name: "depositId";
            type: "uint32";
        },
        {
            name: "originChainId";
            type: "uint256";
        },
        {
            name: "updatedRelayerFeePct";
            type: "int64";
        },
        {
            name: "updatedRecipient";
            type: "address";
        },
        {
            name: "updatedMessage";
            type: "bytes";
        }
    ];
};
export type UpdateV3DepositDetailsMessageType = {
    UpdateDepositDetails: [
        {
            name: "depositId";
            type: "uint32";
        },
        {
            name: "originChainId";
            type: "uint256";
        },
        {
            name: "updatedOutputAmount";
            type: "uint256";
        },
        {
            name: "updatedRecipient";
            type: "address";
        },
        {
            name: "updatedMessage";
            type: "bytes";
        }
    ];
};
/**
 * Utility function to get EIP-712 compliant typed data that can be signed with the JSON-RPC method
 * `eth_signedTypedDataV4` in MetaMask (https://docs.metamask.io/guide/signing-data.html). The resulting signature
 * can then be used to call the method `speedUpDeposit` of a `SpokePool.sol` contract.
 * @param depositId The deposit ID to speed up.
 * @param originChainId The chain ID of the origin chain.
 * @param updatedRelayerFeePct The new relayer fee percentage.
 * @param updatedRecipient The new recipient address.
 * @param updatedMessage The new message that should be provided to the recipient.
 * @return EIP-712 compliant typed data.
 */
export declare function getUpdateDepositTypedData(depositId: number, originChainId: number, updatedRelayerFeePct: BigNumber, updatedRecipient: string, updatedMessage: string): TypedMessage<UpdateDepositDetailsMessageType>;
export declare function getUpdateV3DepositTypedData(depositId: number, originChainId: number, updatedOutputAmount: BigNumber, updatedRecipient: string, updatedMessage: string): TypedMessage<UpdateV3DepositDetailsMessageType>;
export declare function randomAddress(): string;
