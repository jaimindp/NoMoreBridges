import { __spreadArray } from "tslib";
import { getV2RelayHash, getV3RelayHash } from "./SpokeUtils";
import { isV2Deposit, isV2RelayData, isV3Deposit, isV2Fill, isV3Fill } from "./V3Utils";
export var FILL_DEPOSIT_COMPARISON_KEYS = [
    "depositId",
    "originChainId",
    "destinationChainId",
    "depositor",
    "recipient",
    "message",
];
export var V2_DEPOSIT_COMPARISON_KEYS = __spreadArray(__spreadArray([], FILL_DEPOSIT_COMPARISON_KEYS, true), [
    "amount",
    "destinationToken",
    "relayerFeePct",
    "realizedLpFeePct",
], false);
export var V3_DEPOSIT_COMPARISON_KEYS = __spreadArray(__spreadArray([], FILL_DEPOSIT_COMPARISON_KEYS, true), [
    "inputToken",
    "inputAmount",
    "outputToken",
    "outputAmount",
    "fillDeadline",
    "exclusivityDeadline",
    "exclusiveRelayer",
], false);
export function filledSameDeposit(fillA, fillB) {
    // Don't bother hashing obvious mismatches.
    if (fillA.depositId !== fillB.depositId) {
        return false;
    }
    if (isV2Fill(fillA) && isV2Fill(fillB)) {
        return getV2RelayHash(fillA) === getV2RelayHash(fillB);
    }
    else if (isV3Fill(fillA) && isV3Fill(fillB)) {
        var chainA = fillA.destinationChainId;
        var chainB = fillB.destinationChainId;
        return getV3RelayHash(fillA, chainA) === getV3RelayHash(fillB, chainB);
    }
    return false;
}
export function validateFillForDeposit(relayData, // V2Deposit, V3Fill, SlowFillRequest...
deposit, fillFieldsToIgnore) {
    if (fillFieldsToIgnore === void 0) { fillFieldsToIgnore = []; }
    if (deposit === undefined) {
        return false;
    }
    return isV2RelayData(relayData)
        ? validateV2FillForDeposit(relayData, deposit, fillFieldsToIgnore)
        : validateV3FillForDeposit(relayData, deposit);
}
function validateV2FillForDeposit(fill, deposit, fillFieldsToIgnore) {
    if (fillFieldsToIgnore === void 0) { fillFieldsToIgnore = []; }
    if (!isV2Deposit(deposit)) {
        return false;
    }
    return V2_DEPOSIT_COMPARISON_KEYS.every(function (key) {
        var _a;
        if (fillFieldsToIgnore.includes(key)) {
            return true;
        }
        return fill[key] !== undefined && fill[key].toString() === ((_a = deposit[key]) === null || _a === void 0 ? void 0 : _a.toString());
    });
}
function validateV3FillForDeposit(fill, deposit) {
    if (!isV3Deposit(deposit)) {
        return false;
    }
    return getV3RelayHash(fill, fill.destinationChainId) === getV3RelayHash(deposit, deposit.destinationChainId);
}
//# sourceMappingURL=FlowUtils.js.map