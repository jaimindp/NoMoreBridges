import { FillType, } from "../interfaces";
import { fixedPointAdjustment } from "./common";
// Lowest ConfigStore version where the V3 model is in effect. The version update to the following value should take
// place atomically with the SpokePool upgrade to V3 so that the dataworker knows what kind of MerkleLeaves to propose
// in root bundles (i.e. SlowFillLeaf has different shapes). The dataworker/relayer code can use the following isV3()
// function to separate logic for calling V3 vs. legacy methods.
export var V3_MIN_CONFIG_STORE_VERSION = 3;
export function isV3(version) {
    return version >= V3_MIN_CONFIG_STORE_VERSION;
}
// Can be used with specific types, and will fully verify that the descriminating key is exclusive to the former.
// Example usage:
// let a: Fill = ...;
// if (isType<V2Fill, V3Fill>(a, "destinationToken")) {
//
// }
export function isType(input, key) {
    return input[key] !== undefined;
}
// Slightly less safe than isType. Used in wrapper functions due to limitations of typescript.
function unsafeIsType(input, key) {
    return input[key] !== undefined;
}
export function isV2Deposit(deposit) {
    return unsafeIsType(deposit, "originToken");
}
export function isV3Deposit(deposit) {
    return unsafeIsType(deposit, "inputToken");
}
export function isV2SpeedUp(speedUp) {
    return unsafeIsType(speedUp, "newRelayerFeePct");
}
export function isV3SpeedUp(speedUp) {
    return unsafeIsType(speedUp, "updatedOutputAmount");
}
export function isV2Fill(fill) {
    return unsafeIsType(fill, "destinationToken");
}
export function isV3Fill(fill) {
    return unsafeIsType(fill, "inputToken");
}
export function isV2RelayData(relayData) {
    return unsafeIsType(relayData, "destinationToken");
}
export function isV3RelayData(relayData) {
    return unsafeIsType(relayData, "outputToken");
}
export function isSlowFill(fill) {
    return isV2Fill(fill) ? fill.updatableRelayData.isSlowRelay : fill.relayExecutionInfo.fillType === FillType.SlowFill;
}
export function isV2SlowFillLeaf(slowFillLeaf) {
    return unsafeIsType(slowFillLeaf, "payoutAdjustmentPct");
}
export function isV3SlowFillLeaf(slowFillLeaf) {
    return unsafeIsType(slowFillLeaf, "updatedOutputAmount");
}
export function getDepositInputToken(deposit) {
    return isV2Deposit(deposit) ? deposit.originToken : deposit.inputToken;
}
export function getDepositOutputToken(deposit) {
    return unsafeIsType(deposit, "destinationToken") ? deposit.destinationToken : deposit.outputToken;
}
export function getDepositInputAmount(deposit) {
    return unsafeIsType(deposit, "amount") ? deposit.amount : deposit.inputAmount;
}
export function getDepositOutputAmount(deposit) {
    return unsafeIsType(deposit, "amount") ? deposit.amount : deposit.outputAmount;
}
export function getFillOutputToken(fill) {
    return unsafeIsType(fill, "destinationToken") ? fill.destinationToken : fill.outputToken;
}
// Returns the total output amount for a unique fill hash.
export function getFillOutputAmount(fill) {
    return unsafeIsType(fill, "amount") ? fill.amount : fill.outputAmount;
}
// Returns the amount filled by a particular fill event.
export function getFillAmount(fill) {
    return unsafeIsType(fill, "fillAmount") ? fill.fillAmount : fill.outputAmount;
}
// Returns the cumulative amount filled for a unique fill hash.
export function getTotalFilledAmount(fill) {
    return unsafeIsType(fill, "totalFilledAmount") ? fill.totalFilledAmount : fill.outputAmount;
}
export function getRelayDataOutputToken(relayData) {
    return isV2RelayData(relayData) ? relayData.destinationToken : relayData.outputToken;
}
export function getRelayDataOutputAmount(relayData) {
    return unsafeIsType(relayData, "amount") ? relayData.amount : relayData.outputAmount;
}
export function getSlowFillLeafChainId(leaf) {
    return unsafeIsType(leaf, "chainId") ? leaf.chainId : leaf.relayData.destinationChainId;
}
export function getSlowFillLeafLpFeePct(leaf) {
    return unsafeIsType(leaf, "updatedOutputAmount")
        ? leaf.relayData.inputAmount.sub(leaf.updatedOutputAmount).mul(fixedPointAdjustment).div(leaf.relayData.inputAmount)
        : leaf.relayData.realizedLpFeePct;
}
//# sourceMappingURL=V3Utils.js.map