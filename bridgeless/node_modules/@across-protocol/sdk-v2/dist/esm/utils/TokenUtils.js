import { __awaiter, __generator } from "tslib";
import { Contract } from "ethers";
import * as constants from "../constants";
import { ERC20__factory } from "../typechain";
import { getNetworkName } from "./NetworkUtils";
import { isDefined } from "./TypeGuards";
var TOKEN_SYMBOLS_MAP = constants.TOKEN_SYMBOLS_MAP, CHAIN_IDs = constants.CHAIN_IDs;
export function fetchTokenInfo(address, signerOrProvider) {
    return __awaiter(this, void 0, void 0, function () {
        var token, _a, symbol, decimals;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    token = new Contract(address, ERC20__factory.abi, signerOrProvider);
                    return [4 /*yield*/, Promise.all([token.symbol(), token.decimals()])];
                case 1:
                    _a = _b.sent(), symbol = _a[0], decimals = _a[1];
                    return [2 /*return*/, { address: address, symbol: symbol, decimals: decimals }];
            }
        });
    });
}
export var getL2TokenAddresses = function (l1TokenAddress, l1ChainId) {
    var _a;
    if (l1ChainId === void 0) { l1ChainId = CHAIN_IDs.MAINNET; }
    return (_a = Object.values(TOKEN_SYMBOLS_MAP).find(function (details) {
        return details.addresses[l1ChainId] === l1TokenAddress;
    })) === null || _a === void 0 ? void 0 : _a.addresses;
};
/**
 * Resolve a token symbol to an L1Token description on a particular chain ID.
 * @notice Not to be confused with the HubPool's internal view on the supported origin/destination token for a chain.
 * @param symbol Symbol to query.
 * @param chainId Chain ID to query on.
 * @returns Symbol, decimals and contract address on the requested chain.
 */
export function resolveSymbolOnChain(chainId, symbol) {
    // @dev Suppress tsc complaints by casting symbol to the expected type.
    var token = TOKEN_SYMBOLS_MAP[symbol];
    if (!isDefined(token) || !isDefined(token.addresses[chainId])) {
        var network = getNetworkName(chainId);
        throw new Error("Unable to find token ".concat(symbol, " on ").concat(network, " (chain ID ").concat(chainId));
    }
    var decimals = token.decimals, addresses = token.addresses;
    var address = addresses[chainId];
    return { symbol: symbol, decimals: decimals, address: address };
}
/**
 * Returns the contract address for a given token symbol and chainId.
 * @param symbol A case-insensitive token symbol.
 * @param chainId The chainId to resolve the contract address for.
 * @param tokenMapping A parameter to determine where to source token information. Defaults to the constants-v2 variant.
 * @returns The contract address for the given token symbol and chainId, or undefined if the token symbol is not supported.
 */
export var resolveContractFromSymbol = function (symbol, chainId, tokenMapping) {
    var _a;
    if (tokenMapping === void 0) { tokenMapping = TOKEN_SYMBOLS_MAP; }
    return (_a = Object.values(tokenMapping).find(function (details) {
        return details.symbol.toLowerCase() === symbol.toLowerCase();
    })) === null || _a === void 0 ? void 0 : _a.addresses[Number(chainId)];
};
export function getTokenInformationFromAddress(address, tokenMapping) {
    if (tokenMapping === void 0) { tokenMapping = TOKEN_SYMBOLS_MAP; }
    var details = Object.values(tokenMapping).find(function (details) {
        return Object.values(details.addresses).some(function (t) { return t.toLowerCase() === address.toLowerCase(); });
    });
    return isDefined(details)
        ? {
            decimals: details.decimals,
            symbol: details.symbol,
            address: address,
        }
        : undefined;
}
/**
 * Retrieves the ERC20 balance for a given address and token address.
 * @param address The address to retrieve the balance for.
 * @param tokenAddress The token address
 * @param signerOrProvider A valid ethers.js Signer or Provider object.
 * @param blockTag The block tag to retrieve the balance at.
 * @returns The balance of the given address for the given token address.
 */
export function getTokenBalance(address, tokenAddress, signerOrProvider, blockTag) {
    if (blockTag === void 0) { blockTag = "latest"; }
    var token = ERC20__factory.connect(tokenAddress, signerOrProvider);
    return token.balanceOf(address, { blockTag: blockTag });
}
//# sourceMappingURL=TokenUtils.js.map