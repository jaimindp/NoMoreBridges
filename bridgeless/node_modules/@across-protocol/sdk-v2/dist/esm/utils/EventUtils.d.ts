import { Result } from "@ethersproject/abi";
import { SortableEvent } from "../interfaces";
import { Contract, Event, EventFilter } from "ethers";
export declare function spreadEvent(args?: Result): any;
export interface EventSearchConfig {
    fromBlock: number;
    toBlock: number;
    maxBlockLookBack?: number;
}
export declare function paginatedEventQuery(contract: Contract, filter: EventFilter, searchConfig: EventSearchConfig, retryCount?: number): Promise<Event[]>;
/**
 * @dev Warning: this is a specialized function!! Its functionality is not obvious.
 * This function attempts to return block ranges to repeat ranges as much as possible. To do so, it may include blocks that
 * are outside the provided range. The guarantee is that it will always include _at least_ the blocks requested.
 * @param eventSearchConfig contains fromBlock, toBlock, and maxBlockLookBack.
 * The range is inclusive, so the results will include events in the fromBlock and in the toBlock.
 * maxBlockLookback defined the maximum number of blocks to search. Because the range is inclusive, the maximum diff
 * in the returned pairs is maxBlockLookBack - 1. This is a bit non-intuitive here, but this is meant so that this
 * parameter more closely aligns with the more commonly understood definition of a max query range that node providers
 * use.
 * @returns an array of disjoint fromBlock, toBlock ranges that should be queried. These cover at least the entire
 * input range, but can include blocks outside of the desired range, so results should be filtered. Results
 * are ordered from smallest to largest.
 */
export declare function getPaginatedBlockRanges({ fromBlock, toBlock, maxBlockLookBack, }: EventSearchConfig): [number, number][];
export declare function spreadEventWithBlockNumber(event: Event): SortableEvent;
export declare function sortEventsAscending<T extends SortableEvent>(events: T[]): T[];
export declare function sortEventsAscendingInPlace<T extends SortableEvent>(events: T[]): T[];
export declare function sortEventsDescending<T extends SortableEvent>(events: T[]): T[];
export declare function sortEventsDescendingInPlace<T extends SortableEvent>(events: T[]): T[];
export declare function isEventOlder<T extends SortableEvent>(ex: T, ey: T): boolean;
export declare function getTransactionHashes(events: SortableEvent[]): string[];
