import { __awaiter, __generator } from "tslib";
import assert from "assert";
import { utils as ethersUtils } from "ethers";
import { CHAIN_IDs, ZERO_ADDRESS } from "../constants";
import { FillStatus } from "../interfaces";
import { isDefined } from "./TypeGuards";
import { isV2RelayData } from "./V3Utils";
import { getNetworkName } from "./NetworkUtils";
/**
 * @param spokePool SpokePool Contract instance.
 * @param deposit V3Deopsit instance.
 * @param repaymentChainId Optional repaymentChainId (defaults to destinationChainId).
 * @returns An Ethers UnsignedTransaction instance.
 */
export function populateV3Relay(spokePool, deposit, relayer, repaymentChainId) {
    if (repaymentChainId === void 0) { repaymentChainId = deposit.destinationChainId; }
    var v3RelayData = {
        depositor: deposit.depositor,
        recipient: deposit.recipient,
        exclusiveRelayer: deposit.exclusiveRelayer,
        inputToken: deposit.inputToken,
        outputToken: deposit.outputToken,
        inputAmount: deposit.inputAmount,
        outputAmount: deposit.outputAmount,
        originChainId: deposit.originChainId,
        depositId: deposit.depositId,
        fillDeadline: deposit.fillDeadline,
        exclusivityDeadline: deposit.exclusivityDeadline,
        message: deposit.message,
    };
    if (isDefined(deposit.speedUpSignature)) {
        assert(isDefined(deposit.updatedRecipient) && deposit.updatedRecipient !== ZERO_ADDRESS);
        assert(isDefined(deposit.updatedOutputAmount));
        assert(isDefined(deposit.updatedMessage));
        return spokePool.populateTransaction.fillV3RelayWithUpdatedDeposit(v3RelayData, repaymentChainId, deposit.updatedOutputAmount, deposit.updatedRecipient, deposit.updatedMessage, deposit.speedUpSignature, { from: relayer });
    }
    return spokePool.populateTransaction.fillV3Relay(v3RelayData, repaymentChainId, { from: relayer });
}
/**
 * Find the block range that contains the deposit ID. This is a binary search that searches for the block range
 * that contains the deposit ID.
 * @param targetDepositId The target deposit ID to search for.
 * @param initLow The initial lower bound of the block range to search.
 * @param initHigh The initial upper bound of the block range to search.
 * @param maxSearches The maximum number of searches to perform. This is used to prevent infinite loops.
 * @returns The block range that contains the deposit ID.
 * @note  // We want to find the block range that satisfies these conditions:
 *        // - the low block has deposit count <= targetDepositId
 *        // - the high block has a deposit count > targetDepositId.
 *        // This way the caller can search for a FundsDeposited event between [low, high] that will always
 *        // contain the event emitted when deposit ID was incremented to targetDepositId + 1. This is the same transaction
 *        // where the deposit with deposit ID = targetDepositId was created.
 */
export function getBlockRangeForDepositId(targetDepositId, initLow, initHigh, maxSearches, spokePool) {
    return __awaiter(this, void 0, void 0, function () {
        var deploymentBlock, queriedIds, _getDepositIdAtBlock, _a, highestDepositIdInRange, lowestDepositIdInRange, low, high, searches, mid, midDepositId, accountedIdByMidBlock;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    deploymentBlock = spokePool.deploymentBlock;
                    // Set the initial high block to the most recent block number or the initial high block, whichever is smaller.
                    initHigh = Math.min(initHigh, spokePool.latestBlockSearched);
                    // We will now set a list of sanity checks to ensure that the binary search will not fail
                    // due to invalid input parameters.
                    // If any of these sanity checks fail, then we will throw an error.
                    [
                        // Sanity check to ensure that the spoke pool client is updated
                        [spokePool.isUpdated, "Spoke pool client is not updated"],
                        // Sanity check to ensure that initHigh is greater than or equal to initLow.
                        [initLow <= initHigh, "Binary search failed because low > high"],
                        // Sanity check to ensure that init Low is greater than or equal to zero.
                        [initLow >= deploymentBlock, "Binary search failed because low must be >= deploymentBlock"],
                        // Sanity check to ensure that maxSearches is greater than zero.
                        [maxSearches > 0, "maxSearches must be > 0"],
                        // Sanity check to ensure that deploymentBlock is greater than or equal to zero.
                        [deploymentBlock >= 0, "deploymentBlock must be >= 0"],
                    ].forEach(function (_a) {
                        var condition = _a[0], errorMessage = _a[1];
                        // If the condition is false, then we will throw an error.
                        if (!condition) {
                            throw new Error(errorMessage);
                        }
                    });
                    queriedIds = {};
                    _getDepositIdAtBlock = function (blockNumber) { return __awaiter(_this, void 0, void 0, function () {
                        var _a, _b, _c;
                        var _d;
                        return __generator(this, function (_e) {
                            switch (_e.label) {
                                case 0:
                                    if (!((_d = queriedIds[blockNumber]) !== null && _d !== void 0)) return [3 /*break*/, 1];
                                    _a = _d;
                                    return [3 /*break*/, 3];
                                case 1:
                                    _b = queriedIds;
                                    _c = blockNumber;
                                    return [4 /*yield*/, spokePool._getDepositIdAtBlock(blockNumber)];
                                case 2:
                                    _a = (_b[_c] = _e.sent());
                                    _e.label = 3;
                                case 3:
                                    _a;
                                    return [2 /*return*/, queriedIds[blockNumber]];
                            }
                        });
                    }); };
                    return [4 /*yield*/, Promise.all([
                            _getDepositIdAtBlock(initHigh),
                            _getDepositIdAtBlock(Math.max(deploymentBlock, initLow - 1)),
                        ])];
                case 1:
                    _a = _b.sent(), highestDepositIdInRange = _a[0], lowestDepositIdInRange = _a[1];
                    // If the deposit ID at the initial high block is less than the target deposit ID, then we know that
                    // the target deposit ID must be greater than the initial high block, so we can throw an error.
                    if (highestDepositIdInRange <= targetDepositId) {
                        // initLow   = 5: Deposits Num: 10
                        //                                     // targetId = 11  <- fail (triggers this error)          // 10 <= 11
                        //                                     // targetId = 10  <- fail (triggers this error)          // 10 <= 10
                        //                                     // targetId = 09  <- pass (does not trigger this error)  // 10 <= 09
                        throw new Error("Target depositId is greater than the initial high block (".concat(targetDepositId, " > ").concat(highestDepositIdInRange, ")"));
                    }
                    // If the deposit ID at the initial low block is greater than the target deposit ID, then we know that
                    // the target deposit ID must be less than the initial low block, so we can throw an error.
                    if (lowestDepositIdInRange > targetDepositId) {
                        // initLow   = 5: Deposits Num: 10
                        // initLow-1 = 4: Deposits Num:  2
                        //                                     // targetId = 1 <- fail (triggers this error)
                        //                                     // targetId = 2 <- pass (does not trigger this error)
                        //                                     // targetId = 3 <- pass (does not trigger this error)
                        throw new Error("Target depositId is less than the initial low block (".concat(targetDepositId, " > ").concat(lowestDepositIdInRange, ")"));
                    }
                    low = initLow;
                    high = initHigh;
                    searches = 0;
                    _b.label = 2;
                case 2:
                    mid = Math.floor((low + high) / 2);
                    return [4 /*yield*/, _getDepositIdAtBlock(mid)];
                case 3:
                    midDepositId = _b.sent();
                    accountedIdByMidBlock = midDepositId - 1;
                    // If our target deposit ID is less than the smallest range of our
                    // midpoint deposit ID range, then we know that the target deposit ID
                    // must be in the lower half of the block range.
                    if (targetDepositId <= accountedIdByMidBlock) {
                        high = mid;
                    }
                    // If our target deposit ID is greater than the largest range of our
                    // midpoint deposit ID range, then we know that the target deposit ID
                    // must be in the upper half of the block range.
                    else {
                        low = mid + 1;
                    }
                    _b.label = 4;
                case 4:
                    if (++searches <= maxSearches && low < high) return [3 /*break*/, 2];
                    _b.label = 5;
                case 5:
                    // Sanity check to ensure that our low was not greater than our high.
                    if (low > high) {
                        throw new Error("Binary search failed (".concat(low, " > ").concat(high, "). SHOULD NEVER HAPPEN (but here we are)"));
                    }
                    // We've either found the block range or we've exceeded the maximum number of searches.
                    // In either case, the block range is [low, high] so we can return it.
                    return [2 /*return*/, { low: low, high: high }];
            }
        });
    });
}
/**
 * Finds the deposit id at a specific block number.
 * @param blockTag The block number to search for the deposit ID at.
 * @returns The deposit ID.
 */
export function getDepositIdAtBlock(contract, blockTag) {
    return __awaiter(this, void 0, void 0, function () {
        var depositIdAtBlock;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, contract.numberOfDeposits({ blockTag: blockTag })];
                case 1:
                    depositIdAtBlock = _a.sent();
                    // Sanity check to ensure that the deposit ID is an integer and is greater than or equal to zero.
                    if (!Number.isInteger(depositIdAtBlock) || depositIdAtBlock < 0) {
                        throw new Error("Invalid deposit count");
                    }
                    return [2 /*return*/, depositIdAtBlock];
            }
        });
    });
}
/**
 * Compute the RelayData hash for a fill. This can be used to determine the fill status.
 * @param relayData RelayData information that is used to complete a fill.
 * @param destinationChainId Supplementary destination chain ID required by V3 hashes.
 * @returns The corresponding RelayData hash.
 */
export function getRelayDataHash(relayData, destinationChainId) {
    if (isV2RelayData(relayData)) {
        // If destinationChainId was supplied, ensure it matches relayData.
        assert(!isDefined(destinationChainId) || destinationChainId === relayData.destinationChainId);
        return getV2RelayHash(relayData);
    }
    // V3RelayData does not include destinationChainId, so it must be supplied separately for v3 types.
    assert(isDefined(destinationChainId));
    return getV3RelayHash(relayData, destinationChainId);
}
/**
 * Compute the RelayData hash for a fill. This can be used to determine the fill amount.
 * @note Only compatible with Across v2 data types.
 * @param relayData V2RelayData information that is used to complete a fill.
 * @returns The corresponding RelayData hash.
 */
export function getV2RelayHash(relayData) {
    return ethersUtils.keccak256(ethersUtils.defaultAbiCoder.encode([
        "tuple(" +
            "address depositor," +
            "address recipient," +
            "address destinationToken," +
            "uint256 amount," +
            "uint256 originChainId," +
            "uint256 destinationChainId," +
            "int64 realizedLpFeePct," +
            "int64 relayerFeePct," +
            "uint32 depositId," +
            "bytes message" +
            ")",
    ], [relayData]));
}
/**
 * Compute the RelayData hash for a fill. This can be used to determine the fill status.
 * @note Only compatible with Across v3 data types.
 * @param relayData V3RelayData information that is used to complete a fill.
 * @param destinationChainId Supplementary destination chain ID required by V3 hashes.
 * @returns The corresponding RelayData hash.
 */
export function getV3RelayHash(relayData, destinationChainId) {
    return ethersUtils.keccak256(ethersUtils.defaultAbiCoder.encode([
        "tuple(" +
            "address depositor," +
            "address recipient," +
            "address exclusiveRelayer," +
            "address inputToken," +
            "address outputToken," +
            "uint256 inputAmount," +
            "uint256 outputAmount," +
            "uint256 originChainId," +
            "uint32 depositId," +
            "uint32 fillDeadline," +
            "uint32 exclusivityDeadline," +
            "bytes message" +
            ")",
        "uint256 destinationChainId",
    ], [relayData, destinationChainId]));
}
export function getV3RelayHashFromEvent(e) {
    return getV3RelayHash(e, e.destinationChainId);
}
/**
 * Find the amount filled for a deposit at a particular block.
 * @param spokePool SpokePool contract instance.
 * @param relayData Deposit information that is used to complete a fill.
 * @param blockTag Block tag (numeric or "latest") to query at.
 * @returns The amount filled for the specified deposit at the requested block (or latest).
 */
export function relayFillStatus(spokePool, relayData, blockTag, destinationChainId) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, hash, _fillStatus, fillStatus, originChainId, depositId;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!(destinationChainId !== null && destinationChainId !== void 0)) return [3 /*break*/, 1];
                    _a = destinationChainId;
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, spokePool.chainId()];
                case 2:
                    _a = (destinationChainId = _b.sent());
                    _b.label = 3;
                case 3:
                    _a;
                    hash = getRelayDataHash(relayData, destinationChainId);
                    return [4 /*yield*/, spokePool.fillStatuses(hash, { blockTag: blockTag })];
                case 4:
                    _fillStatus = _b.sent();
                    fillStatus = Number(_fillStatus);
                    if (![FillStatus.Unfilled, FillStatus.RequestedSlowFill, FillStatus.Filled].includes(fillStatus)) {
                        originChainId = relayData.originChainId, depositId = relayData.depositId;
                        throw new Error("relayFillStatus: Unexpected fillStatus for ".concat(originChainId, " deposit ").concat(depositId));
                    }
                    return [2 /*return*/, fillStatus];
            }
        });
    });
}
/**
 * Find the block at which a fill was completed.
 * @todo After SpokePool upgrade, this function can be simplified to use the FillStatus enum.
 * @param spokePool SpokePool contract instance.
 * @param relayData Deposit information that is used to complete a fill.
 * @param lowBlockNumber The lower bound of the search. Must be bounded by SpokePool deployment.
 * @param highBlocknumber Optional upper bound for the search.
 * @returns The block number at which the relay was completed, or undefined.
 */
export function findFillBlock(spokePool, relayData, lowBlockNumber, highBlockNumber) {
    return __awaiter(this, void 0, void 0, function () {
        var provider, _a, destinationChainId, _b, _c, _d, initialFillStatus, finalFillStatus, depositId, originChainId, _e, srcChain, dstChain, midBlockNumber, fillStatus;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    provider = spokePool.provider;
                    if (!(highBlockNumber !== null && highBlockNumber !== void 0)) return [3 /*break*/, 1];
                    _a = highBlockNumber;
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, provider.getBlockNumber()];
                case 2:
                    _a = (highBlockNumber = _f.sent());
                    _f.label = 3;
                case 3:
                    _a;
                    assert(highBlockNumber > lowBlockNumber, "Block numbers out of range (".concat(lowBlockNumber, " > ").concat(highBlockNumber, ")"));
                    if (!Object.values(CHAIN_IDs).includes(relayData.originChainId)) return [3 /*break*/, 5];
                    return [4 /*yield*/, provider.getNetwork()];
                case 4:
                    _b = (_f.sent()).chainId;
                    return [3 /*break*/, 7];
                case 5:
                    _c = Number;
                    return [4 /*yield*/, spokePool.chainId()];
                case 6:
                    _b = _c.apply(void 0, [_f.sent()]);
                    _f.label = 7;
                case 7:
                    destinationChainId = _b;
                    assert(relayData.originChainId !== destinationChainId, "Origin & destination chain IDs must not be equal (".concat(destinationChainId, ")"));
                    return [4 /*yield*/, Promise.all([
                            relayFillStatus(spokePool, relayData, lowBlockNumber, destinationChainId),
                            relayFillStatus(spokePool, relayData, highBlockNumber, destinationChainId),
                        ])];
                case 8:
                    _d = (_f.sent()).map(Number), initialFillStatus = _d[0], finalFillStatus = _d[1];
                    if (finalFillStatus !== FillStatus.Filled) {
                        return [2 /*return*/, undefined]; // Wasn't filled within the specified block range.
                    }
                    // Was filled earlier than the specified lowBlock. This is an error by the caller.
                    if (initialFillStatus === FillStatus.Filled) {
                        depositId = relayData.depositId, originChainId = relayData.originChainId;
                        _e = [getNetworkName(originChainId), getNetworkName(destinationChainId)], srcChain = _e[0], dstChain = _e[1];
                        throw new Error("".concat(srcChain, " deposit ").concat(depositId, " filled on ").concat(dstChain, " before block ").concat(lowBlockNumber));
                    }
                    _f.label = 9;
                case 9:
                    midBlockNumber = Math.floor((highBlockNumber + lowBlockNumber) / 2);
                    return [4 /*yield*/, relayFillStatus(spokePool, relayData, midBlockNumber, destinationChainId)];
                case 10:
                    fillStatus = _f.sent();
                    if (fillStatus === FillStatus.Filled) {
                        highBlockNumber = midBlockNumber;
                    }
                    else {
                        lowBlockNumber = midBlockNumber + 1;
                    }
                    _f.label = 11;
                case 11:
                    if (lowBlockNumber < highBlockNumber) return [3 /*break*/, 9];
                    _f.label = 12;
                case 12: return [2 /*return*/, lowBlockNumber];
            }
        });
    });
}
//# sourceMappingURL=SpokeUtils.js.map