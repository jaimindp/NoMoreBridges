import { __awaiter, __generator } from "tslib";
import { DEFAULT_CACHING_SAFE_LAG, DEFAULT_CACHING_TTL } from "../constants";
import { assert } from "./LogUtils";
import { composeRevivers, objectWithBigNumberReviver } from "./ReviverUtils";
import { getV3RelayHashFromEvent } from "./SpokeUtils";
import { getCurrentTime } from "./TimeUtils";
import { isDefined } from "./TypeGuards";
import { isV2Deposit, isV2Fill } from "./V3Utils";
export function shouldCache(eventTimestamp, latestTime, cachingMaxAge) {
    assert(eventTimestamp.toString().length === 10, "eventTimestamp must be in seconds");
    assert(latestTime.toString().length === 10, "eventTimestamp must be in seconds");
    return latestTime - eventTimestamp >= cachingMaxAge;
}
/**
 * Calls the cache's get method and returns the result if it is defined, otherwise returns undefined.
 * @param key The key to get from the cache.
 * @param cache The cache to get the key from.
 * @returns The value associated with the key in the cache, or undefined if the key is not in the cache.
 */
export function getDepositInCache(key, cache) {
    return __awaiter(this, void 0, void 0, function () {
        var depositRaw;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, cache.get(key)];
                case 1:
                    depositRaw = _a.sent();
                    return [2 /*return*/, isDefined(depositRaw) ? JSON.parse(depositRaw, composeRevivers(objectWithBigNumberReviver)) : undefined];
            }
        });
    });
}
export function setDepositInCache(deposit, currentChainTime, cache, expirySeconds, timeToCache) {
    if (expirySeconds === void 0) { expirySeconds = DEFAULT_CACHING_TTL; }
    if (timeToCache === void 0) { timeToCache = DEFAULT_CACHING_SAFE_LAG; }
    return __awaiter(this, void 0, void 0, function () {
        var currentTimeInSeconds;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    currentTimeInSeconds = getCurrentTime();
                    // We should first confirm that neither the deposit's quoteTimestamp nor the currentChainTime
                    // are in the future. If they are, we should not cache the deposit.
                    if (deposit.quoteTimestamp > currentTimeInSeconds || currentChainTime > currentTimeInSeconds) {
                        return [2 /*return*/];
                    }
                    if (!shouldCache(deposit.quoteTimestamp, currentChainTime, timeToCache)) return [3 /*break*/, 2];
                    return [4 /*yield*/, cache.set(getDepositKey(deposit), JSON.stringify(deposit), expirySeconds)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    });
}
/**
 * Resolves the key for caching a bridge event.
 * @param bridgeEvent The depositId, and originChainId are used to generate the key for v2, and the
 * full V3 relay hash is used for v3 events..
 * @returns The key for caching the event.
 */
export function getDepositKey(bridgeEvent) {
    if (isV2Deposit(bridgeEvent) || isV2Fill(bridgeEvent)) {
        return "deposit_".concat(bridgeEvent.originChainId, "_").concat(bridgeEvent.depositId);
    }
    else {
        var relayHash = getV3RelayHashFromEvent(bridgeEvent);
        return "deposit_".concat(bridgeEvent.originChainId, "_").concat(bridgeEvent.depositId, "_").concat(relayHash);
    }
}
//# sourceMappingURL=CachingUtils.js.map