import { __awaiter, __generator } from "tslib";
import assert from "assert";
import { DEFAULT_CACHING_TTL, EMPTY_MESSAGE } from "../constants";
import { getNetworkName } from "./NetworkUtils";
import { getDepositInCache, getDepositKey, setDepositInCache } from "./CachingUtils";
import { validateFillForDeposit } from "./FlowUtils";
import { getCurrentTime } from "./TimeUtils";
import { isDefined } from "./TypeGuards";
import { isDepositFormedCorrectly } from "./ValidatorUtils";
import { isV2Deposit, isV2Fill, isV3Deposit } from "./V3Utils";
// Load a deposit for a fill if the fill's deposit ID is outside this client's search range.
// This can be used by the Dataworker to determine whether to give a relayer a refund for a fill
// of a deposit older or younger than its fixed lookback.
export var InvalidFill;
(function (InvalidFill) {
    InvalidFill[InvalidFill["DepositIdInvalid"] = 0] = "DepositIdInvalid";
    InvalidFill[InvalidFill["DepositIdNotFound"] = 1] = "DepositIdNotFound";
    InvalidFill[InvalidFill["FillMismatch"] = 2] = "FillMismatch";
})(InvalidFill || (InvalidFill = {}));
/**
 * Attempts to resolve a deposit for a fill. If the fill's deposit Id is within the spoke pool client's search range,
 * the deposit is returned immediately. Otherwise, the deposit is queried first from the provided cache, and if it is
 * not found in the cache, it is queried from the spoke pool client. If the deposit is found, it is cached before
 * being returned.
 * @param spokePoolClient The spoke pool client to use to query the deposit.
 * @param fill The fill to resolve a deposit for.
 * @param cache An optional cache to use to store the deposit. Optional.
 * @returns The deposit for the fill, or undefined if the deposit could not be found.
 * @throws If the fill's origin chain ID does not match the spoke pool client's chain ID.
 * @throws If the spoke pool client has not been updated.
 */
export function queryHistoricalDepositForFill(spokePoolClient, fill, cache) {
    return __awaiter(this, void 0, void 0, function () {
        var depositId, lowId, highId, deposit_1, deposit, cachedDeposit;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (fill.originChainId !== spokePoolClient.chainId) {
                        throw new Error("OriginChainId mismatch (".concat(fill.originChainId, " != ").concat(spokePoolClient.chainId, ")"));
                    }
                    // We need to update client so we know the first and last deposit ID's queried for this spoke pool client, as well
                    // as the global first and last deposit ID's for this spoke pool.
                    if (!spokePoolClient.isUpdated) {
                        throw new Error("SpokePoolClient must be updated before querying historical deposits");
                    }
                    depositId = fill.depositId;
                    lowId = spokePoolClient.firstDepositIdForSpokePool, highId = spokePoolClient.lastDepositIdForSpokePool;
                    if (depositId < lowId || depositId > highId) {
                        return [2 /*return*/, {
                                found: false,
                                code: InvalidFill.DepositIdInvalid,
                                reason: "Deposit ID ".concat(depositId, " is outside of SpokePool bounds [").concat(lowId, ",").concat(highId, "]."),
                            }];
                    }
                    (lowId = spokePoolClient.earliestDepositIdQueried, highId = spokePoolClient.latestDepositIdQueried);
                    if (depositId >= lowId && depositId <= highId) {
                        deposit_1 = spokePoolClient.getDeposit(depositId);
                        if (isDefined(deposit_1) && validateFillForDeposit(fill, deposit_1)) {
                            return [2 /*return*/, { found: true, deposit: deposit_1 }];
                        }
                        return [2 /*return*/, {
                                found: false,
                                code: isDefined(deposit_1) ? InvalidFill.FillMismatch : InvalidFill.DepositIdNotFound,
                                reason: "Deposit ID ".concat(depositId, " not found in SpokePoolClient event buffer."),
                            }];
                    }
                    if (!cache) return [3 /*break*/, 2];
                    return [4 /*yield*/, getDepositInCache(getDepositKey(fill), cache)];
                case 1:
                    cachedDeposit = _a.sent();
                    // We only want to warn and remove the cached deposit if it
                    //    A: exists
                    //    B: is not formed correctly
                    if (isDefined(cachedDeposit) && !isDepositFormedCorrectly(cachedDeposit)) {
                        spokePoolClient.logger.warn({
                            at: "[SDK]:DepositUtils#queryHistoricalDepositForFill",
                            message: "Cached deposit was not formed correctly, removing from cache",
                            fill: fill,
                            cachedDeposit: cachedDeposit,
                        });
                        // By setting this value to undefined, we eventually have to pull
                        // the deposit from our spoke pool client. Because this new deposit
                        // is formed correctly, we will cache it below.
                        cachedDeposit = undefined;
                    }
                    _a.label = 2;
                case 2:
                    if (!isDefined(cachedDeposit)) return [3 /*break*/, 3];
                    deposit = cachedDeposit;
                    return [3 /*break*/, 9];
                case 3:
                    if (!isV2Fill(fill)) return [3 /*break*/, 5];
                    return [4 /*yield*/, spokePoolClient.findDeposit(fill.depositId, fill.destinationChainId, fill.depositor)];
                case 4:
                    deposit = _a.sent();
                    return [3 /*break*/, 7];
                case 5: return [4 /*yield*/, spokePoolClient.findDepositV3(fill.depositId, fill.destinationChainId, fill.depositor)];
                case 6:
                    deposit = _a.sent();
                    _a.label = 7;
                case 7:
                    if (!cache) return [3 /*break*/, 9];
                    return [4 /*yield*/, setDepositInCache(deposit, getCurrentTime(), cache, DEFAULT_CACHING_TTL)];
                case 8:
                    _a.sent();
                    _a.label = 9;
                case 9:
                    if (validateFillForDeposit(fill, deposit)) {
                        return [2 /*return*/, { found: true, deposit: deposit }];
                    }
                    return [2 /*return*/, {
                            found: false,
                            code: InvalidFill.FillMismatch,
                            reason: "Fill is not valid for ".concat(getNetworkName(deposit.originChainId), " deposit ").concat(depositId),
                        }];
            }
        });
    });
}
/**
 * Determines if a message is empty or not.
 * @param message The message to check.
 * @returns True if the message is empty, false otherwise.
 */
export function isMessageEmpty(message) {
    if (message === void 0) { message = EMPTY_MESSAGE; }
    return message === "" || message === "0x";
}
/**
 * Determines if a deposit was updated via a speed-up transaction.
 * @param deposit Deposit to evaluate.
 * @returns True if the deposit was updated, otherwise false.
 */
export function isDepositSpedUp(deposit) {
    // prettier-ignore
    return (isDefined(deposit.speedUpSignature) &&
        ((isV2Deposit(deposit) && isDefined(deposit.newRelayerFeePct)) ||
            (isV3Deposit(deposit) && isDefined(deposit.updatedOutputAmount))));
}
/**
 * Resolves the applicable message for a deposit.
 * @param deposit Deposit to evaluate.
 * @returns Original or updated message string, depending on whether the depositor updated the deposit.
 */
export function resolveDepositMessage(deposit) {
    var message = isDepositSpedUp(deposit) ? deposit.updatedMessage : deposit.message;
    assert(isDefined(message)); // Appease tsc about the updatedMessage being possibly undefined.
    return message;
}
//# sourceMappingURL=DepositUtils.js.map