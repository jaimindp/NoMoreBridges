"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils/utils");
const utils_2 = require("../../utils/utils");
const utils_3 = require("./utils");
const consts = __importStar(require("../constants"));
const SpokePool_Fixture_1 = require("../fixtures/SpokePool.Fixture");
const MerkleLib_utils_1 = require("../MerkleLib.utils");
require("dotenv").config();
let spokePool, weth;
let owner, dataWorker, recipient;
// Associates an array of L2 tokens to fill relays with.
let l2Tokens;
let leaves;
let tree;
// Relay params that do not affect tests and we can conveniently hardcode:
const ORIGIN_CHAIN_ID = "0";
const FEE_PCT = "0";
// Constants caller can tune to modify gas tests.
const LEAF_COUNT = 10;
const RELAY_AMOUNT = (0, utils_1.toBNWei)("1");
// Construct tree with LEAF_COUNT leaves. Each relay will have a deposit ID equal to its index in the array of relays.
async function constructSimpleTree(depositor, recipient, destinationTokens, universalRelayAmount) {
    // Each refund amount mapped to one refund address.
    (0, utils_1.expect)(destinationTokens.length).to.equal(LEAF_COUNT);
    const slowFills = [];
    for (let i = 0; i < LEAF_COUNT; i++) {
        slowFills.push({
            relayData: {
                depositor,
                recipient,
                destinationToken: destinationTokens[i],
                amount: (0, utils_1.toBN)(universalRelayAmount),
                originChainId: ORIGIN_CHAIN_ID,
                destinationChainId: consts.destinationChainId.toString(),
                realizedLpFeePct: (0, utils_1.toBN)(FEE_PCT),
                relayerFeePct: (0, utils_1.toBN)(FEE_PCT),
                depositId: i.toString(),
                message: "0x",
            },
            payoutAdjustmentPct: (0, utils_1.toBN)(0),
        });
    }
    const tree = await (0, MerkleLib_utils_1.buildSlowRelayTree)(slowFills);
    return { leaves: slowFills, tree };
}
describe("Gas Analytics: SpokePool Slow Relay Root Execution", function () {
    before(async function () {
        if (!process.env.GAS_TEST_ENABLED)
            this.skip();
    });
    beforeEach(async function () {
        [owner, dataWorker, recipient] = await utils_1.ethers.getSigners();
        ({ spokePool, weth } = await (0, SpokePool_Fixture_1.spokePoolFixture)());
        // Deploy test tokens for each chain ID
        l2Tokens = [];
        for (let i = 0; i < LEAF_COUNT; i++) {
            const token = await (0, utils_3.deployErc20)(owner, `Test Token #${i}`, `T-${i}`);
            l2Tokens.push(token);
            // Seed spoke pool with amount needed to cover all relay fills for L2 token.
            await token.connect(owner).mint(spokePool.address, RELAY_AMOUNT.mul((0, utils_1.toBN)(2)));
            await (0, utils_2.seedWallet)(owner, [token], weth, RELAY_AMOUNT.mul((0, utils_1.toBN)(2)));
            await token.connect(owner).approve(spokePool.address, consts.maxUint256);
            await (0, utils_3.warmSpokePool)(spokePool, owner, dataWorker, token.address, RELAY_AMOUNT, RELAY_AMOUNT, 0);
        }
        // Seed pool with WETH for WETH tests
        await (0, utils_2.seedContract)(spokePool, owner, [], weth, RELAY_AMOUNT.mul(LEAF_COUNT).mul((0, utils_1.toBN)(2)));
        await weth.connect(owner).approve(spokePool.address, consts.maxUint256);
        await (0, utils_3.warmSpokePool)(spokePool, owner, dataWorker, weth.address, RELAY_AMOUNT, RELAY_AMOUNT, 0);
    });
    describe(`(ERC20) Tree with ${LEAF_COUNT} leaves`, function () {
        beforeEach(async function () {
            // Change relay amount so we don't send tokens from the pool and the root is different.
            const initTree = await constructSimpleTree(owner.address, recipient.address, l2Tokens.map((token) => token.address), (0, utils_1.toBN)(1));
            // Store new tree.
            await spokePool.connect(owner).relayRootBundle(consts.mockRelayerRefundRoot, initTree.tree.getHexRoot());
            // Execute 1 leaf from initial tree to warm state storage.
            await spokePool
                .connect(dataWorker)
                .executeSlowRelayLeaf(owner.address, recipient.address, l2Tokens[0].address, "1", ORIGIN_CHAIN_ID, FEE_PCT, FEE_PCT, "0", "0", "0x", "0", initTree.tree.getHexProof(initTree.leaves[0]));
            const simpleTree = await constructSimpleTree(owner.address, recipient.address, l2Tokens.map((token) => token.address), RELAY_AMOUNT);
            leaves = simpleTree.leaves;
            tree = simpleTree.tree;
        });
        it("Relay proposal", async function () {
            const txn = await spokePool.connect(owner).relayRootBundle(consts.mockRelayerRefundRoot, tree.getHexRoot());
            console.log(`relayRootBundle-gasUsed: ${(await txn.wait()).gasUsed}`);
        });
        it("Executing 1 leaf", async function () {
            const leafIndexToExecute = 0;
            await spokePool.connect(owner).relayRootBundle(consts.mockRelayerRefundRoot, tree.getHexRoot());
            // Execute second root bundle with index 1:
            const txn = await spokePool
                .connect(dataWorker)
                .executeSlowRelayLeaf(owner.address, recipient.address, l2Tokens[0].address, RELAY_AMOUNT, ORIGIN_CHAIN_ID, FEE_PCT, FEE_PCT, "0", "1", "0x", "0", tree.getHexProof(leaves[leafIndexToExecute]));
            const receipt = await txn.wait();
            console.log(`executeSlowRelayLeaf-gasUsed: ${receipt.gasUsed}`);
        });
        it("Executing all leaves", async function () {
            await spokePool.connect(owner).relayRootBundle(consts.mockRelayerRefundRoot, tree.getHexRoot());
            const txns = [];
            for (let i = 0; i < LEAF_COUNT; i++) {
                txns.push(await spokePool
                    .connect(dataWorker)
                    .executeSlowRelayLeaf(owner.address, recipient.address, l2Tokens[i].address, RELAY_AMOUNT, ORIGIN_CHAIN_ID, FEE_PCT, FEE_PCT, i, "1", "0x", "0", tree.getHexProof(leaves[i])));
            }
            // Compute average gas costs.
            const receipts = await Promise.all(txns.map((_txn) => _txn.wait()));
            const gasUsed = receipts.map((_receipt) => _receipt.gasUsed).reduce((x, y) => x.add(y));
            console.log(`(average) executeSlowRelayLeaf-gasUsed: ${gasUsed.div(LEAF_COUNT)}`);
        });
        it("Executing all leaves using multicall", async function () {
            await spokePool.connect(owner).relayRootBundle(consts.mockRelayerRefundRoot, tree.getHexRoot());
            const multicallData = leaves.map((leaf, i) => {
                return spokePool.interface.encodeFunctionData("executeSlowRelayLeaf", [
                    owner.address,
                    recipient.address,
                    l2Tokens[i].address,
                    RELAY_AMOUNT,
                    ORIGIN_CHAIN_ID,
                    FEE_PCT,
                    FEE_PCT,
                    i,
                    "1",
                    "0x",
                    "0",
                    tree.getHexProof(leaf),
                ]);
            });
            const receipt = await (await spokePool.connect(dataWorker).multicall(multicallData)).wait();
            console.log(`(average) executeSlowRelayLeaf-gasUsed: ${receipt.gasUsed.div(LEAF_COUNT)}`);
        });
    });
    describe(`(WETH) Tree with ${LEAF_COUNT} leaves`, function () {
        beforeEach(async function () {
            // Change relay amount so we don't send tokens from the pool and the root is different.
            const initTree = await constructSimpleTree(owner.address, recipient.address, Array(LEAF_COUNT).fill(weth.address), (0, utils_1.toBN)(1));
            // Store new tree.
            await spokePool.connect(owner).relayRootBundle(consts.mockRelayerRefundRoot, initTree.tree.getHexRoot());
            // Execute 1 leaf from initial tree to warm state storage.
            await spokePool
                .connect(dataWorker)
                .executeSlowRelayLeaf(owner.address, recipient.address, weth.address, "1", ORIGIN_CHAIN_ID, FEE_PCT, FEE_PCT, "0", "0", "0x", "0", initTree.tree.getHexProof(initTree.leaves[0]));
            const simpleTree = await constructSimpleTree(owner.address, recipient.address, Array(LEAF_COUNT).fill(weth.address), RELAY_AMOUNT);
            leaves = simpleTree.leaves;
            tree = simpleTree.tree;
        });
        it("Executing 1 leaf", async function () {
            const leafIndexToExecute = 0;
            await spokePool.connect(owner).relayRootBundle(consts.mockRelayerRefundRoot, tree.getHexRoot());
            // Execute second root bundle with index 1:
            const txn = await spokePool
                .connect(dataWorker)
                .executeSlowRelayLeaf(owner.address, recipient.address, weth.address, RELAY_AMOUNT, ORIGIN_CHAIN_ID, FEE_PCT, FEE_PCT, "0", "1", "0x", "0", tree.getHexProof(leaves[leafIndexToExecute]));
            const receipt = await txn.wait();
            console.log(`executeSlowRelayLeaf-gasUsed: ${receipt.gasUsed}`);
        });
    });
});
