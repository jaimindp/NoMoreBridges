"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.warmSpokePool = exports.sendRelay = exports.constructRelayParams = exports.sendDeposit = exports.deployErc20 = void 0;
const utils_1 = require("../../utils/utils");
const consts = __importStar(require("../constants"));
const SpokePool_Fixture_1 = require("../fixtures/SpokePool.Fixture");
async function deployErc20(signer, tokenName, tokenSymbol) {
    const erc20 = await (await (0, utils_1.getContractFactory)("ExpandedERC20", signer)).deploy(tokenName, tokenSymbol, 18);
    await erc20.addMember(consts.TokenRolesEnum.MINTER, signer.address);
    return erc20;
}
exports.deployErc20 = deployErc20;
async function sendDeposit(spokePool, depositor, originToken, amount, maxCount) {
    const quoteTimestamp = (await spokePool.getCurrentTime()).toNumber();
    return await spokePool.connect(depositor).deposit(...(0, SpokePool_Fixture_1.getDepositParams)({
        recipient: depositor.address,
        originToken,
        destinationChainId: 1,
        amount,
        relayerFeePct: (0, utils_1.toBN)("0"),
        quoteTimestamp,
        maxCount,
    }));
}
exports.sendDeposit = sendDeposit;
function constructRelayParams(depositor, recipient, relayTokenAddress, depositId, relayAmount) {
    const { relayData } = (0, SpokePool_Fixture_1.getRelayHash)(depositor, recipient, depositId, 1, consts.destinationChainId, relayTokenAddress);
    return (0, SpokePool_Fixture_1.getFillRelayParams)(relayData, relayAmount, relayAmount.eq(relayData.amount) ? consts.repaymentChainId : consts.destinationChainId);
}
exports.constructRelayParams = constructRelayParams;
async function sendRelay(_spokePool, _relayer, _depositor, _recipient, tokenAddress, relayAmount, depositId) {
    return await _spokePool
        .connect(_relayer)
        .fillRelay(...constructRelayParams(_depositor, _recipient, tokenAddress, depositId, relayAmount));
}
exports.sendRelay = sendRelay;
async function warmSpokePool(_spokePool, _depositor, _recipient, _currencyAddress, _depositAmount, _relayAmount, _depositId) {
    await (0, SpokePool_Fixture_1.enableRoutes)(_spokePool, [
        {
            originToken: _currencyAddress,
            destinationChainId: 1,
        },
    ]);
    await sendDeposit(_spokePool, _depositor, _currencyAddress, _depositAmount);
    await sendRelay(_spokePool, _depositor, _depositor.address, _recipient.address, _currencyAddress, _relayAmount, _depositId);
}
exports.warmSpokePool = warmSpokePool;
