"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils/utils");
const utils_2 = require("../../utils/utils");
const utils_3 = require("./utils");
const consts = __importStar(require("../constants"));
const SpokePool_Fixture_1 = require("../fixtures/SpokePool.Fixture");
const MerkleLib_utils_1 = require("../MerkleLib.utils");
require("dotenv").config();
let spokePool, weth;
let owner, dataWorker, recipient;
// Associates an array of L2 tokens to sends refunds.
let destinationChainIds;
let l2Tokens;
let refundAddresses;
let amountsToReturn;
let leaves;
let tree;
// Constants caller can tune to modify gas tests.
const REFUND_LEAF_COUNT = 10;
const REFUNDS_PER_LEAF = 10;
const REFUND_AMOUNT = (0, utils_1.toBNWei)("10");
// Regarding the block limit, the max limit is 30 million gas, the expected block gas limit is 15 million, so
// we'll target 12 million gas as a conservative upper-bound. This test script will fail if executing a leaf with
// `STRESS_TEST_REFUND_COUNT` number of refunds is not within the [TARGET_GAS_LOWER_BOUND, TARGET_GAS_UPPER_BOUND]
// gas usage range.
const TARGET_GAS_UPPER_BOUND = 12000000;
const TARGET_GAS_LOWER_BOUND = 3000000;
// Note: I can't get this to work with a gas >> 5mil without the transaction timing out. This is why I've set
// the lower bound to 6mil instead of a tighter 10mil.
const STRESS_TEST_REFUND_COUNT = 600;
// Construct tree with REFUND_LEAF_COUNT leaves, each containing REFUNDS_PER_LEAF refunds.
async function constructSimpleTree(_destinationChainIds, _l2Tokens, _amountsToReturn, _universalRefundAmount, refundAddresses // Should be same length as REFUNDS_PER_LEAF
) {
    // Each refund amount mapped to one refund address.
    (0, utils_1.expect)(refundAddresses.length).to.equal(REFUNDS_PER_LEAF);
    // Each refund has 1 dest. chain ID, 1 amount to return, and 1 L2 token.
    (0, utils_1.expect)(_destinationChainIds.length).to.equal(REFUND_LEAF_COUNT);
    (0, utils_1.expect)(_amountsToReturn.length).to.equal(REFUND_LEAF_COUNT);
    (0, utils_1.expect)(_l2Tokens.length).to.equal(REFUND_LEAF_COUNT);
    const _refundAmounts = [];
    const _refundAddresses = [];
    for (let i = 0; i < REFUND_LEAF_COUNT; i++) {
        _refundAmounts[i] = [];
        _refundAddresses[i] = [];
        for (let j = 0; j < REFUNDS_PER_LEAF; j++) {
            _refundAmounts[i].push(_universalRefundAmount);
            _refundAddresses[i].push(refundAddresses[j]);
        }
    }
    const leaves = (0, MerkleLib_utils_1.buildRelayerRefundLeaves)(_destinationChainIds, _amountsToReturn, _l2Tokens, _refundAddresses, _refundAmounts);
    const tree = await (0, MerkleLib_utils_1.buildRelayerRefundTree)(leaves);
    return { leaves, tree };
}
describe("Gas Analytics: SpokePool Relayer Refund Leaf Execution", function () {
    before(async function () {
        if (!process.env.GAS_TEST_ENABLED)
            this.skip();
    });
    beforeEach(async function () {
        [owner, dataWorker, recipient] = await utils_1.ethers.getSigners();
        ({ spokePool, weth } = await (0, SpokePool_Fixture_1.spokePoolFixture)());
        const destinationChainId = Number(await spokePool.chainId());
        destinationChainIds = Array(REFUND_LEAF_COUNT).fill(destinationChainId);
        amountsToReturn = Array(REFUND_LEAF_COUNT).fill((0, utils_1.toBNWei)("1"));
        refundAddresses = Array(REFUNDS_PER_LEAF).fill(recipient.address);
        // Deploy test tokens for each chain ID
        l2Tokens = [];
        for (let i = 0; i < REFUND_LEAF_COUNT; i++) {
            const token = await (0, utils_3.deployErc20)(owner, `Test Token #${i}`, `T-${i}`);
            l2Tokens.push(token);
            // Seed spoke pool with amount needed to cover all refunds for L2 token, which is used for 1 refund leaf.
            // Note: Mint more than needed for this test to simulate production, otherwise reported gas costs
            // will be better because a storage slot is deleted.
            const totalRefundAmount = REFUND_AMOUNT.mul(REFUNDS_PER_LEAF);
            await token.connect(owner).mint(spokePool.address, totalRefundAmount.mul((0, utils_2.toBN)(5)));
            await (0, utils_2.seedWallet)(owner, [token], weth, totalRefundAmount.mul((0, utils_2.toBN)(5)));
            await token.connect(owner).approve(spokePool.address, consts.maxUint256);
            await (0, utils_3.warmSpokePool)(spokePool, owner, recipient, token.address, totalRefundAmount, totalRefundAmount, 0);
        }
        // Seed pool with WETH for WETH tests
        await (0, utils_2.seedContract)(spokePool, owner, [], weth, REFUND_AMOUNT.mul(REFUNDS_PER_LEAF).mul(REFUND_LEAF_COUNT).mul((0, utils_2.toBN)(5)));
        await weth.connect(owner).approve(spokePool.address, consts.maxUint256);
        await (0, utils_3.warmSpokePool)(spokePool, owner, dataWorker, weth.address, REFUND_AMOUNT.mul(REFUNDS_PER_LEAF), REFUND_AMOUNT.mul(REFUNDS_PER_LEAF), 0);
    });
    describe(`(ERC20) Tree with ${REFUND_LEAF_COUNT} leaves, each containing ${REFUNDS_PER_LEAF} refunds`, function () {
        beforeEach(async function () {
            // Change refund amount to 0 so we don't send tokens from the pool and the root is different.
            const initTree = await constructSimpleTree(destinationChainIds, l2Tokens.map((token) => token.address), amountsToReturn, (0, utils_1.toBNWei)("0"), refundAddresses);
            // Store new tree.
            await spokePool.connect(owner).relayRootBundle(initTree.tree.getHexRoot(), // relayer refund root. Generated from the merkle tree constructed before.
            consts.mockSlowRelayRoot);
            // Execute 1 leaf from initial tree to warm state storage.
            await spokePool
                .connect(dataWorker)
                .executeRelayerRefundLeaf(0, initTree.leaves[0], initTree.tree.getHexProof(initTree.leaves[0]));
            const simpleTree = await constructSimpleTree(destinationChainIds, l2Tokens.map((token) => token.address), amountsToReturn, REFUND_AMOUNT, refundAddresses);
            leaves = simpleTree.leaves;
            tree = simpleTree.tree;
        });
        it("Relay proposal", async function () {
            const txn = await spokePool.connect(owner).relayRootBundle(tree.getHexRoot(), consts.mockSlowRelayRoot);
            console.log(`relayRootBundle-gasUsed: ${(await txn.wait()).gasUsed}`);
        });
        it("Executing 1 leaf", async function () {
            const leafIndexToExecute = 0;
            await spokePool.connect(owner).relayRootBundle(tree.getHexRoot(), consts.mockSlowRelayRoot);
            // Execute second root bundle with index 1:
            const txn = await spokePool
                .connect(dataWorker)
                .executeRelayerRefundLeaf(1, leaves[leafIndexToExecute], tree.getHexProof(leaves[leafIndexToExecute]));
            const receipt = await txn.wait();
            console.log(`executeRelayerRefundLeaf-gasUsed: ${receipt.gasUsed}`);
        });
        it("Executing all leaves", async function () {
            await spokePool.connect(owner).relayRootBundle(tree.getHexRoot(), consts.mockSlowRelayRoot);
            const txns = [];
            for (let i = 0; i < REFUND_LEAF_COUNT; i++) {
                txns.push(await spokePool.connect(dataWorker).executeRelayerRefundLeaf(1, leaves[i], tree.getHexProof(leaves[i])));
            }
            // Compute average gas costs.
            const receipts = await Promise.all(txns.map((_txn) => _txn.wait()));
            const gasUsed = receipts.map((_receipt) => _receipt.gasUsed).reduce((x, y) => x.add(y));
            console.log(`(average) executeRelayerRefundLeaf-gasUsed: ${gasUsed.div(REFUND_LEAF_COUNT)}`);
        });
        it("Executing all leaves using multicall", async function () {
            await spokePool.connect(owner).relayRootBundle(tree.getHexRoot(), consts.mockSlowRelayRoot);
            const multicallData = leaves.map((leaf) => {
                return spokePool.interface.encodeFunctionData("executeRelayerRefundLeaf", [1, leaf, tree.getHexProof(leaf)]);
            });
            const receipt = await (await spokePool.connect(dataWorker).multicall(multicallData)).wait();
            console.log(`(average) executeRelayerRefundLeaf-gasUsed: ${receipt.gasUsed.div(REFUND_LEAF_COUNT)}`);
        });
    });
    describe(`(WETH): Relayer Refund tree with ${REFUND_LEAF_COUNT} leaves, each containing ${REFUNDS_PER_LEAF} refunds`, function () {
        beforeEach(async function () {
            // Change refund amount to 0 so we don't send tokens from the pool and the root is different.
            const initTree = await constructSimpleTree(destinationChainIds, Array(REFUND_LEAF_COUNT).fill(weth.address), amountsToReturn, (0, utils_1.toBNWei)("0"), refundAddresses);
            // Store new tree.
            await spokePool.connect(owner).relayRootBundle(initTree.tree.getHexRoot(), // relayer refund root. Generated from the merkle tree constructed before.
            consts.mockSlowRelayRoot);
            // Execute 1 leaf from initial tree to warm state storage.
            await spokePool
                .connect(dataWorker)
                .executeRelayerRefundLeaf(0, initTree.leaves[0], initTree.tree.getHexProof(initTree.leaves[0]));
            const simpleTree = await constructSimpleTree(destinationChainIds, Array(REFUND_LEAF_COUNT).fill(weth.address), amountsToReturn, REFUND_AMOUNT, refundAddresses);
            leaves = simpleTree.leaves;
            tree = simpleTree.tree;
        });
        it("Executing 1 leaf", async function () {
            const leafIndexToExecute = 0;
            await spokePool.connect(owner).relayRootBundle(tree.getHexRoot(), consts.mockSlowRelayRoot);
            // Execute second root bundle with index 1:
            const txn = await spokePool
                .connect(dataWorker)
                .executeRelayerRefundLeaf(1, leaves[leafIndexToExecute], tree.getHexProof(leaves[leafIndexToExecute]));
            const receipt = await txn.wait();
            console.log(`executeRelayerRefundLeaf-gasUsed: ${receipt.gasUsed}`);
        });
        it(`Stress Test: 1 leaf contains ${STRESS_TEST_REFUND_COUNT} refunds with amount > 0`, async function () {
            // This test should inform the limit # refunds that we would allow a RelayerRefundLeaf to contain to avoid
            // publishing a leaf that is unexecutable due to the block gas limit.
            // Note: Since the SpokePool is deployed on L2s we care specifically about L2 block gas limits.
            // - Optimism: 15mil cap, soon to be raised to 30mil when they upgrade to London.
            // - Arbitrum: uses different units when reasoning about gas (but with the nitro upgrade those will then be
            //   closer to Ethereum). You can do about the same amount of computation per second on the chain; each
            //   transaction can use up to 2.5m arbgas in computation.
            // - Polygon: same as L1
            // Regarding the block limit, the max limit is 30 million gas, the expected block gas limit is 15 million, so
            // we'll target 12 million gas as a conservative upper-bound.
            await (0, utils_2.seedContract)(spokePool, owner, [], weth, (0, utils_2.toBN)(STRESS_TEST_REFUND_COUNT).mul(REFUND_AMOUNT).mul((0, utils_2.toBN)(10)));
            // Create tree with 1 large leaf.
            const bigLeaves = (0, MerkleLib_utils_1.buildRelayerRefundLeaves)([destinationChainIds[0]], [(0, utils_1.toBNWei)("1")], // Set amount to return > 0 to better simulate long execution path of _executeRelayerRefundLeaf
            [weth.address], [Array(STRESS_TEST_REFUND_COUNT).fill(recipient.address)], [Array(STRESS_TEST_REFUND_COUNT).fill(REFUND_AMOUNT)]);
            const bigLeafTree = await (0, MerkleLib_utils_1.buildRelayerRefundTree)(bigLeaves);
            await spokePool.connect(owner).relayRootBundle(bigLeafTree.getHexRoot(), consts.mockSlowRelayRoot);
            // Estimate the transaction gas and set it (plus some buffer) explicitly as the transaction's gas limit. This is
            // done because ethers.js' default gas limit setting doesn't seem to always work and sometimes overestimates
            // it and throws something like:
            // "InvalidInputError: Transaction gas limit is X and exceeds block gas limit of 30000000"
            const gasEstimate = await spokePool
                .connect(dataWorker)
                .estimateGas.executeRelayerRefundLeaf(1, bigLeaves[0], bigLeafTree.getHexProof(bigLeaves[0]));
            const txn = await spokePool
                .connect(dataWorker)
                .executeRelayerRefundLeaf(1, bigLeaves[0], bigLeafTree.getHexProof(bigLeaves[0]), {
                gasLimit: gasEstimate.mul((0, utils_2.toBN)("1.2")),
            });
            const receipt = await txn.wait();
            console.log(`executeRelayerRefundLeaf-gasUsed: ${receipt.gasUsed}`);
            (0, utils_1.expect)(Number(receipt.gasUsed)).to.be.lessThanOrEqual(TARGET_GAS_UPPER_BOUND);
            (0, utils_1.expect)(Number(receipt.gasUsed)).to.be.greaterThanOrEqual(TARGET_GAS_LOWER_BOUND);
        });
    });
});
