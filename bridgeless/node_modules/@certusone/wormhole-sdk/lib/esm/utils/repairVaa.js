var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ethers } from "ethers";
import { CONTRACTS } from "./consts";
import { Implementation__factory } from "../ethers-contracts";
import { parseVaa } from "../vaa";
import { hexToUint8Array } from "./array";
import { keccak256 } from "../utils";
const ETHEREUM_CORE_BRIDGE = CONTRACTS["MAINNET"].ethereum.core;
function hex(x) {
    return ethers.utils.hexlify(x, { allowMissingPrefix: true });
}
export function getCurrentGuardianSet(provider) {
    return __awaiter(this, void 0, void 0, function* () {
        let result = {
            index: 0,
            keys: [],
            expiry: 0,
        };
        const core = Implementation__factory.connect(ETHEREUM_CORE_BRIDGE, provider);
        const index = yield core.getCurrentGuardianSetIndex();
        const guardianSet = yield core.getGuardianSet(index);
        result.index = index;
        result.keys = guardianSet[0];
        result.expiry = guardianSet[1];
        return result;
    });
}
/**
 *
 * Takes in a hexstring representation of a signed vaa and a guardian set.
 * Attempts to remove invalid guardian signatures, update total remaining
 * valid signatures, and update the guardian set index
 * @throws if not enough valid signatures remain
 **/
export function repairVaa(vaaHex, guardianSetData) {
    const guardianSetIndex = guardianSetData.index;
    const currentGuardianSet = guardianSetData.keys;
    const minNumSignatures = Math.floor((2.0 * currentGuardianSet.length) / 3.0) + 1;
    const version = vaaHex.slice(0, 2);
    const parsedVaa = parseVaa(hexToUint8Array(vaaHex));
    const numSignatures = parsedVaa.guardianSignatures.length;
    const digest = keccak256(parsedVaa.hash).toString("hex");
    var validSignatures = [];
    // take each signature, check if valid against hash & current guardian set
    parsedVaa.guardianSignatures.forEach((signature) => {
        try {
            const vaaGuardianPublicKey = ethers.utils.recoverAddress(hex(digest), hex(signature.signature.toString("hex")));
            const currentIndex = signature.index;
            const currentGuardianPublicKey = currentGuardianSet[currentIndex];
            if (currentGuardianPublicKey === vaaGuardianPublicKey) {
                validSignatures.push(signature);
            }
        }
        catch (_) { }
    });
    // re-construct vaa with signatures that remain
    const numRepairedSignatures = validSignatures.length;
    if (numRepairedSignatures < minNumSignatures) {
        throw new Error(`There are not enough valid signatures to repair.`);
    }
    const repairedSignatures = validSignatures
        .sort(function (a, b) {
        return a.index - b.index;
    })
        .map((signature) => {
        return `${signature.index
            .toString(16)
            .padStart(2, "0")}${signature.signature.toString("hex")}`;
    })
        .join("");
    const newSignatureBody = `${version}${guardianSetIndex
        .toString(16)
        .padStart(8, "0")}${numRepairedSignatures
        .toString(16)
        .padStart(2, "0")}${repairedSignatures}`;
    const repairedVaa = `${newSignatureBody}${vaaHex.slice(12 + numSignatures * 132)}`;
    return repairedVaa;
}
/**
 *
 * Takes in a hexstring representation of a signed vaa and an eth provider.
 * Attempts to query eth core contract and retrieve current guardian set.
 * Then attempts to repair the vaa.
 **/
export function repairVaaWithCurrentGuardianSet(vaaHex, provider) {
    return __awaiter(this, void 0, void 0, function* () {
        const guardianSetData = yield getCurrentGuardianSet(provider);
        return repairVaa(vaaHex, guardianSetData);
    });
}
