"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.repairVaaWithCurrentGuardianSet = exports.repairVaa = exports.getCurrentGuardianSet = void 0;
const ethers_1 = require("ethers");
const consts_1 = require("./consts");
const ethers_contracts_1 = require("../ethers-contracts");
const vaa_1 = require("../vaa");
const array_1 = require("./array");
const utils_1 = require("../utils");
const ETHEREUM_CORE_BRIDGE = consts_1.CONTRACTS["MAINNET"].ethereum.core;
function hex(x) {
    return ethers_1.ethers.utils.hexlify(x, { allowMissingPrefix: true });
}
function getCurrentGuardianSet(provider) {
    return __awaiter(this, void 0, void 0, function* () {
        let result = {
            index: 0,
            keys: [],
            expiry: 0,
        };
        const core = ethers_contracts_1.Implementation__factory.connect(ETHEREUM_CORE_BRIDGE, provider);
        const index = yield core.getCurrentGuardianSetIndex();
        const guardianSet = yield core.getGuardianSet(index);
        result.index = index;
        result.keys = guardianSet[0];
        result.expiry = guardianSet[1];
        return result;
    });
}
exports.getCurrentGuardianSet = getCurrentGuardianSet;
/**
 *
 * Takes in a hexstring representation of a signed vaa and a guardian set.
 * Attempts to remove invalid guardian signatures, update total remaining
 * valid signatures, and update the guardian set index
 * @throws if not enough valid signatures remain
 **/
function repairVaa(vaaHex, guardianSetData) {
    const guardianSetIndex = guardianSetData.index;
    const currentGuardianSet = guardianSetData.keys;
    const minNumSignatures = Math.floor((2.0 * currentGuardianSet.length) / 3.0) + 1;
    const version = vaaHex.slice(0, 2);
    const parsedVaa = vaa_1.parseVaa(array_1.hexToUint8Array(vaaHex));
    const numSignatures = parsedVaa.guardianSignatures.length;
    const digest = utils_1.keccak256(parsedVaa.hash).toString("hex");
    var validSignatures = [];
    // take each signature, check if valid against hash & current guardian set
    parsedVaa.guardianSignatures.forEach((signature) => {
        try {
            const vaaGuardianPublicKey = ethers_1.ethers.utils.recoverAddress(hex(digest), hex(signature.signature.toString("hex")));
            const currentIndex = signature.index;
            const currentGuardianPublicKey = currentGuardianSet[currentIndex];
            if (currentGuardianPublicKey === vaaGuardianPublicKey) {
                validSignatures.push(signature);
            }
        }
        catch (_) { }
    });
    // re-construct vaa with signatures that remain
    const numRepairedSignatures = validSignatures.length;
    if (numRepairedSignatures < minNumSignatures) {
        throw new Error(`There are not enough valid signatures to repair.`);
    }
    const repairedSignatures = validSignatures
        .sort(function (a, b) {
        return a.index - b.index;
    })
        .map((signature) => {
        return `${signature.index
            .toString(16)
            .padStart(2, "0")}${signature.signature.toString("hex")}`;
    })
        .join("");
    const newSignatureBody = `${version}${guardianSetIndex
        .toString(16)
        .padStart(8, "0")}${numRepairedSignatures
        .toString(16)
        .padStart(2, "0")}${repairedSignatures}`;
    const repairedVaa = `${newSignatureBody}${vaaHex.slice(12 + numSignatures * 132)}`;
    return repairedVaa;
}
exports.repairVaa = repairVaa;
/**
 *
 * Takes in a hexstring representation of a signed vaa and an eth provider.
 * Attempts to query eth core contract and retrieve current guardian set.
 * Then attempts to repair the vaa.
 **/
function repairVaaWithCurrentGuardianSet(vaaHex, provider) {
    return __awaiter(this, void 0, void 0, function* () {
        const guardianSetData = yield getCurrentGuardianSet(provider);
        return repairVaa(vaaHex, guardianSetData);
    });
}
exports.repairVaaWithCurrentGuardianSet = repairVaaWithCurrentGuardianSet;
