"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTransferPayload = exports.parseNFTPayload = exports.METADATA_REPLACE = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const vaa_1 = require("../vaa");
exports.METADATA_REPLACE = new RegExp("\u0000", "g");
// note: actual first byte is message type
//     0   [u8; 32] token_address
//     32  u16      token_chain
//     34  [u8; 32] symbol
//     66  [u8; 32] name
//     98  u256     tokenId
//     130 u8       uri_len
//     131 [u8;len] uri
//     ?   [u8; 32] recipient
//     ?   u16      recipient_chain
function parseNFTPayload(payload) {
    const parsed = vaa_1.parseNftTransferPayload(payload);
    return {
        originAddress: parsed.tokenAddress.toString("hex"),
        originChain: parsed.tokenChain,
        symbol: parsed.symbol,
        name: parsed.name,
        tokenId: bignumber_1.BigNumber.from(parsed.tokenId),
        uri: parsed.uri,
        targetAddress: parsed.to.toString("hex"),
        targetChain: parsed.toChain,
    };
}
exports.parseNFTPayload = parseNFTPayload;
//     0   u256     amount
//     32  [u8; 32] token_address
//     64  u16      token_chain
//     66  [u8; 32] recipient
//     98  u16      recipient_chain
//     100 u256     fee
function parseTransferPayload(payload) {
    const parsed = vaa_1.parseTokenTransferPayload(payload);
    return {
        amount: parsed.amount,
        originAddress: parsed.tokenAddress.toString("hex"),
        originChain: parsed.tokenChain,
        targetAddress: parsed.to.toString("hex"),
        targetChain: parsed.toChain,
        fee: parsed.fee === null ? undefined : parsed.fee,
        fromAddress: parsed.fromAddress === null
            ? undefined
            : parsed.fromAddress.toString("hex"),
    };
}
exports.parseTransferPayload = parseTransferPayload;
