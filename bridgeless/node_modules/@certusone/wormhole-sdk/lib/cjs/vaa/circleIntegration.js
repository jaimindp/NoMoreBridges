"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCircleIntegrationDepositWithPayload = exports.CircleIntegrationPayload = void 0;
const anchor_1 = require("@project-serum/anchor");
var CircleIntegrationPayload;
(function (CircleIntegrationPayload) {
    CircleIntegrationPayload[CircleIntegrationPayload["DepositWithPayload"] = 1] = "DepositWithPayload";
})(CircleIntegrationPayload = exports.CircleIntegrationPayload || (exports.CircleIntegrationPayload = {}));
function parseCircleIntegrationDepositWithPayload(payload) {
    const payloadType = payload.readUInt8(0);
    if (payloadType != CircleIntegrationPayload.DepositWithPayload) {
        throw new Error("not circle integration payload VAA");
    }
    const tokenAddress = payload.subarray(1, 33);
    const amount = BigInt(new anchor_1.BN(payload.subarray(33, 65)).toString());
    const sourceDomain = payload.readUInt32BE(65);
    const targetDomain = payload.readUInt32BE(69);
    const nonce = payload.readBigUInt64BE(73);
    const fromAddress = payload.subarray(81, 113);
    const mintRecipient = payload.subarray(113, 145);
    const payloadLen = payload.readUInt16BE(145);
    const depositPayload = payload.subarray(147);
    return {
        payloadType,
        tokenAddress,
        amount,
        sourceDomain,
        targetDomain,
        nonce,
        fromAddress,
        mintRecipient,
        payloadLen,
        depositPayload,
    };
}
exports.parseCircleIntegrationDepositWithPayload = parseCircleIntegrationDepositWithPayload;
