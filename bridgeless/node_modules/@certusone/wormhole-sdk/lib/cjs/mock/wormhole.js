"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockEthereumEmitter = exports.MockEmitter = exports.MockGuardians = void 0;
const utils_1 = require("../utils");
const misc_1 = require("./misc");
const SIGNATURE_PAYLOAD_LEN = 66;
class MockGuardians {
    constructor(setIndex, keys) {
        this.setIndex = setIndex;
        this.signers = keys.map((key, index) => {
            return { index, key };
        });
    }
    getPublicKeys() {
        return this.signers.map((guardian) => misc_1.ethPrivateToPublic(guardian.key));
    }
    updateGuardianSetIndex(setIndex) {
        this.setIndex = setIndex;
    }
    addSignatures(message, guardianIndices) {
        if (guardianIndices.length == 0) {
            throw Error("guardianIndices.length == 0");
        }
        const signers = this.signers.filter((signer) => guardianIndices.includes(signer.index));
        const sigStart = 6;
        const numSigners = signers.length;
        const signedVaa = Buffer.alloc(sigStart + SIGNATURE_PAYLOAD_LEN * numSigners + message.length);
        signedVaa.write(message.toString("hex"), sigStart + SIGNATURE_PAYLOAD_LEN * numSigners, "hex");
        signedVaa.writeUInt8(1, 0);
        signedVaa.writeUInt32BE(this.setIndex, 1);
        signedVaa.writeUInt8(numSigners, 5);
        // signatures
        const hash = utils_1.keccak256(utils_1.keccak256(message));
        for (let i = 0; i < numSigners; ++i) {
            const signer = signers.at(i);
            if (signer == undefined) {
                throw Error("signer == undefined");
            }
            const signature = misc_1.ethSignWithPrivate(signer.key, hash);
            const start = sigStart + i * SIGNATURE_PAYLOAD_LEN;
            signedVaa.writeUInt8(signer.index, start);
            signedVaa.write(signature.r.toString(16).padStart(64, "0"), start + 1, "hex");
            signedVaa.write(signature.s.toString(16).padStart(64, "0"), start + 33, "hex");
            signedVaa.writeUInt8(signature.recoveryParam, start + 65);
        }
        return signedVaa;
    }
}
exports.MockGuardians = MockGuardians;
class MockEmitter {
    constructor(emitterAddress, chain, startSequence) {
        this.chain = chain;
        const address = Buffer.from(emitterAddress, "hex");
        if (address.length != 32) {
            throw Error("emitterAddress.length != 32");
        }
        this.address = address;
        this.sequence = startSequence == undefined ? 0 : startSequence;
    }
    publishMessage(nonce, payload, consistencyLevel, timestamp, uptickSequence = true) {
        if (uptickSequence) {
            ++this.sequence;
        }
        const message = Buffer.alloc(51 + payload.length);
        message.writeUInt32BE(timestamp == undefined ? 0 : timestamp, 0);
        message.writeUInt32BE(nonce, 4);
        message.writeUInt16BE(this.chain, 8);
        message.write(this.address.toString("hex"), 10, "hex");
        message.writeBigUInt64BE(BigInt(this.sequence), 42);
        message.writeUInt8(consistencyLevel, 50);
        message.write(payload.toString("hex"), 51, "hex");
        return message;
    }
}
exports.MockEmitter = MockEmitter;
class MockEthereumEmitter extends MockEmitter {
    constructor(emitterAddress, chain) {
        super(emitterAddress, chain == undefined ? 2 : chain);
    }
}
exports.MockEthereumEmitter = MockEthereumEmitter;
