/// <reference types="node" />
import { BigNumber, ethers } from "ethers";
export declare enum RelayerPayloadId {
    Delivery = 1,
    Redelivery = 2
}
export declare enum ExecutionInfoVersion {
    EVM_V1 = 0
}
export declare enum DeliveryStatus {
    WaitingForVAA = "Waiting for VAA",
    PendingDelivery = "Pending Delivery",
    DeliverySuccess = "Delivery Success",
    ReceiverFailure = "Receiver Failure",
    ThisShouldNeverHappen = "This should never happen. Contact Support."
}
export declare enum RefundStatus {
    RefundSent = "Refund Sent",
    RefundFail = "Refund Fail",
    CrossChainRefundSent = "Cross Chain Refund Sent",
    CrossChainRefundFailProviderNotSupported = "Cross Chain Refund Fail - Provider does not support the refund chain",
    CrossChainRefundFailNotEnough = "Cross Chain Refund Fail - Refund too low for cross chain refund",
    RefundAddressNotProvided = "No refund address provided",
    InvalidRefundStatus = "Invalid refund status"
}
export declare function parseRefundStatus(index: number): RefundStatus;
export declare enum KeyType {
    VAA = 1,
    CCTP = 2
}
export interface MessageKey {
    keyType: KeyType | number;
    key: ethers.BytesLike;
}
export interface VaaKey {
    chainId: number;
    emitterAddress: Buffer;
    sequence: BigNumber;
}
export interface CCTPKey {
    domain: number;
    nonce: ethers.BigNumber;
}
export interface CCTPMessage {
    message: Buffer;
    signature: Buffer;
}
export interface DeliveryInstruction {
    targetChainId: number;
    targetAddress: Buffer;
    payload: Buffer;
    requestedReceiverValue: BigNumber;
    extraReceiverValue: BigNumber;
    encodedExecutionInfo: Buffer;
    refundChainId: number;
    refundAddress: Buffer;
    refundDeliveryProvider: Buffer;
    sourceDeliveryProvider: Buffer;
    senderAddress: Buffer;
    messageKeys: MessageKey[];
}
export interface RedeliveryInstruction {
    deliveryVaaKey: VaaKey;
    targetChainId: number;
    newRequestedReceiverValue: BigNumber;
    newEncodedExecutionInfo: Buffer;
    newSourceDeliveryProvider: Buffer;
    newSenderAddress: Buffer;
}
declare type StringLeaves<Type> = string | string[] | {
    [P in keyof Type]: StringLeaves<Type[P]>;
};
export declare type DeliveryInstructionPrintable = {
    [Property in keyof Omit<DeliveryInstruction, "messageKeys">]: StringLeaves<DeliveryInstruction[Property]>;
} & {
    messageKeys: ReturnType<typeof messageKeyPrintable>[];
};
export declare type RedeliveryInstructionPrintable = {
    [Property in keyof RedeliveryInstruction]: StringLeaves<RedeliveryInstruction[Property]>;
};
export interface EVMExecutionInfoV1 {
    gasLimit: BigNumber;
    targetChainRefundPerGasUnused: BigNumber;
}
export declare enum VaaKeyType {
    EMITTER_SEQUENCE = 0,
    VAAHASH = 1
}
export declare function parseWormholeRelayerPayloadType(stringPayload: string | Buffer | Uint8Array): RelayerPayloadId;
export declare function createVaaKey(chainId: number, emitterAddress: Buffer, sequence: number | BigNumber): VaaKey;
export declare function parseWormholeRelayerSend(bytes: Buffer): DeliveryInstruction;
export declare function parseMessageKey(_bytes: ethers.utils.BytesLike, idx: number): [MessageKey, number];
export declare function packMessageKey(key: MessageKey): string;
export declare function parseCCTPKey(_bytes: ethers.BytesLike): CCTPKey;
export declare function packCCTPKey(key: CCTPKey): string;
export declare function parseVaaKey(_bytes: ethers.BytesLike): VaaKey;
export declare function packVaaKey(vaaKey: VaaKey): string;
export declare function packCCTPMessage(message: CCTPMessage): string;
export declare function parseCCTPMessage(bytes: ethers.BytesLike): CCTPMessage;
export declare function parseEVMExecutionInfoV1(bytes: Buffer, idx: number): [EVMExecutionInfoV1, number];
export declare function packEVMExecutionInfoV1(info: EVMExecutionInfoV1): string;
export declare function parseWormholeRelayerResend(bytes: Buffer): RedeliveryInstruction;
export declare function executionInfoToString(encodedExecutionInfo: Buffer): string;
export declare function deliveryInstructionsPrintable(ix: DeliveryInstruction): DeliveryInstructionPrintable;
export declare function messageKeyPrintable(ix: MessageKey): StringLeaves<(VaaKey | CCTPKey | {
    key: string;
}) & {
    keyType: number;
}>;
export declare function vaaKeyPrintable(ix: VaaKey): StringLeaves<VaaKey>;
export declare function cctpKeyPrintable(ix: CCTPKey): StringLeaves<CCTPKey>;
export declare function redeliveryInstructionPrintable(ix: RedeliveryInstruction): RedeliveryInstructionPrintable;
export declare type DeliveryOverrideArgs = {
    newReceiverValue: BigNumber;
    newExecutionInfo: Buffer;
    redeliveryHash: Buffer;
};
export declare function packOverrides(overrides: DeliveryOverrideArgs): string;
export declare function parseOverrideInfoFromDeliveryEvent(bytes: Buffer): DeliveryOverrideArgs;
export declare function dbg<T>(x: T, msg?: string): T;
export {};
