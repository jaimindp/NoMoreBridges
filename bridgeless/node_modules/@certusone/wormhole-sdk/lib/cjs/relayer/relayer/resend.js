"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resend = exports.resendRaw = void 0;
const utils_1 = require("../../utils");
const vaa_1 = require("../../vaa");
const consts_1 = require("../consts");
const structs_1 = require("../structs");
const helpers_1 = require("./helpers");
const rpc_1 = require("../../rpc");
function resendRaw(signer, sourceChain, targetChain, environment, vaaKey, newGasLimit, newReceiverValue, deliveryProviderAddress, overrides, wormholeRelayerAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        const provider = signer.provider;
        if (!provider)
            throw Error("No provider on signer");
        const wormholeRelayer = consts_1.getWormholeRelayer(sourceChain, environment, signer, wormholeRelayerAddress);
        return wormholeRelayer.resendToEvm(helpers_1.vaaKeyToVaaKeyStruct(vaaKey), utils_1.CHAINS[targetChain], newReceiverValue, newGasLimit, deliveryProviderAddress, overrides);
    });
}
exports.resendRaw = resendRaw;
function resend(signer, sourceChain, targetChain, environment, vaaKey, newGasLimit, newReceiverValue, deliveryProviderAddress, wormholeRPCs, overrides, extraGrpcOpts = {}, optionalParams) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetChainId = utils_1.CHAINS[targetChain];
        const originalVAA = yield rpc_1.getSignedVAAWithRetry(wormholeRPCs, vaaKey.chainId, vaaKey.emitterAddress.toString("hex"), vaaKey.sequence.toBigInt().toString(), extraGrpcOpts, 2000, 4);
        if (!originalVAA.vaaBytes)
            throw Error("original VAA not found");
        const originalVAAparsed = structs_1.parseWormholeRelayerSend(vaa_1.parseVaa(Buffer.from(originalVAA.vaaBytes)).payload);
        if (!originalVAAparsed)
            throw Error("original VAA not a valid delivery VAA.");
        const [originalExecutionInfo] = structs_1.parseEVMExecutionInfoV1(originalVAAparsed.encodedExecutionInfo, 0);
        const originalGasLimit = originalExecutionInfo.gasLimit;
        const originalRefund = originalExecutionInfo.targetChainRefundPerGasUnused;
        const originalReceiverValue = originalVAAparsed.requestedReceiverValue;
        const originalTargetChain = originalVAAparsed.targetChainId;
        if (originalTargetChain != targetChainId) {
            throw Error(`Target chain of original VAA (${originalTargetChain}) does not match target chain of resend (${targetChainId})`);
        }
        if (newReceiverValue < originalReceiverValue) {
            throw Error(`New receiver value too low. Minimum is ${originalReceiverValue.toString()}`);
        }
        if (newGasLimit < originalGasLimit) {
            throw Error(`New gas limit too low. Minimum is ${originalReceiverValue.toString()}`);
        }
        const wormholeRelayer = consts_1.getWormholeRelayer(sourceChain, environment, signer, optionalParams === null || optionalParams === void 0 ? void 0 : optionalParams.wormholeRelayerAddress);
        const [deliveryPrice, refundPerUnitGas] = yield wormholeRelayer["quoteEVMDeliveryPrice(uint16,uint256,uint256,address)"](targetChainId, newReceiverValue || 0, newGasLimit, deliveryProviderAddress);
        const value = yield ((overrides === null || overrides === void 0 ? void 0 : overrides.value) || 0);
        if (!deliveryPrice.eq(value)) {
            throw new Error(`Expected a payment of ${deliveryPrice.toString()} wei; received ${value.toString()} wei`);
        }
        if (refundPerUnitGas < originalRefund) {
            throw Error(`New refund per unit gas too low. Minimum is ${originalRefund.toString()}.`);
        }
        return resendRaw(signer, sourceChain, targetChain, environment, vaaKey, newGasLimit, newReceiverValue, deliveryProviderAddress, overrides, optionalParams === null || optionalParams === void 0 ? void 0 : optionalParams.wormholeRelayerAddress);
    });
}
exports.resend = resend;
