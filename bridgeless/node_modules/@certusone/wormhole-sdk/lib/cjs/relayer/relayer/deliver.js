"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchAdditionalMessages = exports.extractDeliveryArguments = exports.deliveryBudget = exports.deliver = exports.manualDelivery = void 0;
const ethers_1 = require("ethers");
const ethers_contracts_1 = require("../../ethers-contracts");
const utils_1 = require("../../utils");
const vaa_1 = require("../../vaa");
const consts_1 = require("../consts");
const structs_1 = require("../structs");
const helpers_1 = require("./helpers");
const info_1 = require("./info");
function manualDelivery(sourceChain, sourceTransaction, infoRequest, getQuoteOnly, overrides, signer) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const info = yield info_1.getWormholeRelayerInfo(sourceChain, sourceTransaction, infoRequest);
        const environment = (infoRequest === null || infoRequest === void 0 ? void 0 : infoRequest.environment) || "MAINNET";
        const sourceProvider = (infoRequest === null || infoRequest === void 0 ? void 0 : infoRequest.sourceChainProvider) ||
            helpers_1.getDefaultProvider(environment, sourceChain);
        const receipt = yield sourceProvider.getTransactionReceipt(sourceTransaction);
        const wormholeRelayerAddress = ((_a = infoRequest === null || infoRequest === void 0 ? void 0 : infoRequest.wormholeRelayerAddresses) === null || _a === void 0 ? void 0 : _a.get(sourceChain)) ||
            consts_1.getWormholeRelayerAddress(sourceChain, environment);
        const response = yield (yield helpers_1.getWormscanInfo(environment, info.sourceChain, info.sourceDeliverySequenceNumber, wormholeRelayerAddress)).json();
        const signedVaa = response.data.vaa;
        const signedVaaBuffer = Buffer.from(signedVaa, "base64");
        const result = {
            quote: deliveryBudget(info.deliveryInstruction, overrides),
            targetChain: utils_1.CHAIN_ID_TO_NAME[info.deliveryInstruction.targetChainId],
            txHash: undefined,
        };
        if (getQuoteOnly) {
            return result;
        }
        else {
            if (!signer) {
                throw new Error("no signer provided");
            }
            const deliveryReceipt = yield deliver(signedVaaBuffer, signer, environment, overrides, sourceChain, receipt);
            result.txHash = deliveryReceipt.transactionHash;
            return result;
        }
    });
}
exports.manualDelivery = manualDelivery;
function deliver(deliveryVaa, signer, environment = "MAINNET", overrides, sourceChain, sourceReceipt) {
    return __awaiter(this, void 0, void 0, function* () {
        const { budget, deliveryInstruction, deliveryHash } = extractDeliveryArguments(deliveryVaa, overrides);
        const additionalMessages = yield fetchAdditionalMessages(deliveryInstruction.messageKeys, environment, sourceChain, sourceReceipt);
        const wormholeRelayerAddress = consts_1.getWormholeRelayerAddress(utils_1.toChainName(deliveryInstruction.targetChainId), environment);
        const wormholeRelayer = ethers_contracts_1.IWormholeRelayer__factory.connect(wormholeRelayerAddress, signer);
        const gasEstimate = yield wormholeRelayer.estimateGas.deliver(additionalMessages, deliveryVaa, signer.getAddress(), overrides ? structs_1.packOverrides(overrides) : new Uint8Array(), { value: budget });
        const tx = yield wormholeRelayer.deliver(additionalMessages, deliveryVaa, signer.getAddress(), overrides ? structs_1.packOverrides(overrides) : new Uint8Array(), { value: budget, gasLimit: gasEstimate.mul(2) });
        const rx = yield tx.wait();
        return rx;
    });
}
exports.deliver = deliver;
function deliveryBudget(delivery, overrides) {
    const receiverValue = (overrides === null || overrides === void 0 ? void 0 : overrides.newReceiverValue)
        ? overrides.newReceiverValue
        : delivery.requestedReceiverValue.add(delivery.extraReceiverValue);
    const getMaxRefund = (encodedDeliveryInfo) => {
        const [deliveryInfo] = structs_1.parseEVMExecutionInfoV1(encodedDeliveryInfo, 0);
        return deliveryInfo.targetChainRefundPerGasUnused.mul(deliveryInfo.gasLimit);
    };
    const maxRefund = getMaxRefund((overrides === null || overrides === void 0 ? void 0 : overrides.newExecutionInfo)
        ? overrides.newExecutionInfo
        : delivery.encodedExecutionInfo);
    return receiverValue.add(maxRefund);
}
exports.deliveryBudget = deliveryBudget;
function extractDeliveryArguments(vaa, overrides) {
    const parsedVaa = vaa_1.parseVaa(vaa);
    const payloadType = structs_1.parseWormholeRelayerPayloadType(parsedVaa.payload);
    if (payloadType !== structs_1.RelayerPayloadId.Delivery) {
        throw new Error(`Expected delivery payload type, got ${structs_1.RelayerPayloadId[payloadType]}`);
    }
    const deliveryInstruction = structs_1.parseWormholeRelayerSend(parsedVaa.payload);
    const budget = deliveryBudget(deliveryInstruction, overrides);
    return {
        budget,
        deliveryInstruction: deliveryInstruction,
        deliveryHash: parsedVaa.hash.toString("hex"),
    };
}
exports.extractDeliveryArguments = extractDeliveryArguments;
function fetchAdditionalMessages(additionalMessageKeys, environment, sourceChain, sourceReceipt) {
    return __awaiter(this, void 0, void 0, function* () {
        const messages = yield Promise.all(additionalMessageKeys.map((messageKey) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (messageKey.keyType === 1) {
                const vaaKey = structs_1.parseVaaKey(messageKey.key);
                const signedVaa = (_a = (yield yield (yield helpers_1.getWormscanInfo(environment, utils_1.CHAIN_ID_TO_NAME[vaaKey.chainId], vaaKey.sequence.toNumber(), "0x" + vaaKey.emitterAddress.toString("hex"))).json()).data) === null || _a === void 0 ? void 0 : _a.vaa;
                if (!signedVaa) {
                    throw new Error(`No signed VAA available on WormScan for vaaKey ${JSON.stringify(vaaKey)}`);
                }
                return Buffer.from(signedVaa, "base64");
            }
            else if (messageKey.keyType === 2) {
                const cctpKey = structs_1.parseCCTPKey(messageKey.key);
                if (!sourceReceipt)
                    throw new Error("No source receipt provided - needed to obtain CCTP message");
                if (!environment)
                    throw new Error("No environment provided - needed to obtain CCTP message");
                if (!sourceChain)
                    throw new Error("No source chain provided - needed to obtain CCTP message");
                const response = yield helpers_1.getCCTPMessageLogURL(cctpKey, sourceChain, sourceReceipt, environment);
                // Try to get attestation
                const attestationResponse = yield fetch((response === null || response === void 0 ? void 0 : response.url) || "");
                const attestationResponseJson = yield attestationResponse.json();
                const attestation = attestationResponseJson.attestation;
                if (!attestation) {
                    throw new Error(`Unable to get attestation from Circle, for cctp key ${JSON.stringify(cctpKey)}, message ${response === null || response === void 0 ? void 0 : response.message}`);
                }
                return Buffer.from(new ethers_1.ethers.utils.AbiCoder()
                    .encode(["bytes", "bytes"], [(response === null || response === void 0 ? void 0 : response.message) || [], attestation])
                    .substring(2), "hex");
            }
            else {
                throw new Error(`Message key type unknown: ${messageKey.keyType} (messageKey ${messageKey.key})`);
            }
        })));
        return messages;
    });
}
exports.fetchAdditionalMessages = fetchAdditionalMessages;
