"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateWrappedOnSui = exports.updateWrappedOnAptos = exports.updateWrappedOnNear = exports.updateWrappedOnAlgorand = exports.updateWrappedOnSolana = exports.updateWrappedOnXpla = exports.updateWrappedOnTerra = exports.updateWrappedOnEth = void 0;
const sui_js_1 = require("@mysten/sui.js");
const _1 = require(".");
const ethers_contracts_1 = require("../ethers-contracts");
const sui_1 = require("../sui");
function updateWrappedOnEth(tokenBridgeAddress, signer, signedVAA, overrides = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const bridge = ethers_contracts_1.Bridge__factory.connect(tokenBridgeAddress, signer);
        const v = yield bridge.updateWrapped(signedVAA, overrides);
        const receipt = yield v.wait();
        return receipt;
    });
}
exports.updateWrappedOnEth = updateWrappedOnEth;
exports.updateWrappedOnTerra = _1.createWrappedOnTerra;
exports.updateWrappedOnXpla = _1.createWrappedOnXpla;
exports.updateWrappedOnSolana = _1.createWrappedOnSolana;
exports.updateWrappedOnAlgorand = _1.createWrappedOnAlgorand;
exports.updateWrappedOnNear = _1.createWrappedOnNear;
exports.updateWrappedOnAptos = _1.createWrappedOnAptos;
function updateWrappedOnSui(provider, coreBridgeStateObjectId, tokenBridgeStateObjectId, coinPackageId, attestVAA, coreBridgePackageId, tokenBridgePackageId) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        [coreBridgePackageId, tokenBridgePackageId] = yield Promise.all([
            coreBridgePackageId
                ? Promise.resolve(coreBridgePackageId)
                : sui_1.getPackageId(provider, coreBridgeStateObjectId),
            tokenBridgePackageId
                ? Promise.resolve(tokenBridgePackageId)
                : sui_1.getPackageId(provider, tokenBridgeStateObjectId),
        ]);
        // Get coin metadata
        const coinType = sui_1.getWrappedCoinType(coinPackageId);
        const coinMetadataObjectId = (_a = (yield provider.getCoinMetadata({ coinType }))) === null || _a === void 0 ? void 0 : _a.id;
        if (!coinMetadataObjectId) {
            throw new Error(`Coin metadata object not found for coin type ${coinType}.`);
        }
        // Get verified VAA
        const tx = new sui_js_1.TransactionBlock();
        const [vaa] = tx.moveCall({
            target: `${coreBridgePackageId}::vaa::parse_and_verify`,
            arguments: [
                tx.object(coreBridgeStateObjectId),
                tx.pure(sui_1.uint8ArrayToBCS(attestVAA)),
                tx.object(sui_js_1.SUI_CLOCK_OBJECT_ID),
            ],
        });
        // Get TokenBridgeMessage
        const [message] = tx.moveCall({
            target: `${tokenBridgePackageId}::vaa::verify_only_once`,
            arguments: [tx.object(tokenBridgeStateObjectId), vaa],
        });
        // Construct complete registration payload
        tx.moveCall({
            target: `${tokenBridgePackageId}::create_wrapped::update_attestation`,
            arguments: [
                tx.object(tokenBridgeStateObjectId),
                tx.object(coinMetadataObjectId),
                message,
            ],
            typeArguments: [coinType],
        });
        return tx;
    });
}
exports.updateWrappedOnSui = updateWrappedOnSui;
