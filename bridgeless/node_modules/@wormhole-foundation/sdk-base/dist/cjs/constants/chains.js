"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.toChain = exports.toChainId = exports.asChainId = exports.assertChain = exports.assertChainId = exports.isChainId = exports.isChain = exports.chainIdToChain = exports.chainToChainId = exports.chains = exports.chainIds = void 0;
const utils_1 = require("../utils");
const mapping_1 = require("../utils/mapping");
// prettier-ignore
const chainIdAndChainEntries = [
    //Unlike the old sdk, we are not including an "Unset" chain with chainId 0 here because:
    //  * no other types would be associated with it (such as contracts or a platform)
    //  * avoids awkward "chain but not 'Unset'" checks
    //  * "off" is not a TV channel either
    //Instead we'll use `null` for chain and 0 as the chainId where appropriate (e.g. governance VAAs)
    [1, "Solana"],
    [2, "Ethereum"],
    [3, "Terra"],
    [4, "Bsc"],
    [5, "Polygon"],
    [6, "Avalanche"],
    [7, "Oasis"],
    [8, "Algorand"],
    [9, "Aurora"],
    [10, "Fantom"],
    [11, "Karura"],
    [12, "Acala"],
    [13, "Klaytn"],
    [14, "Celo"],
    [15, "Near"],
    [16, "Moonbeam"],
    [17, "Neon"],
    [18, "Terra2"],
    [19, "Injective"],
    [20, "Osmosis"],
    [21, "Sui"],
    [22, "Aptos"],
    [23, "Arbitrum"],
    [24, "Optimism"],
    [25, "Gnosis"],
    [26, "Pythnet"],
    [28, "Xpla"],
    [29, "Btc"],
    [30, "Base"],
    [32, "Sei"],
    [33, "Rootstock"],
    [3104, "Wormchain"],
    [4000, "Cosmoshub"],
    [4001, "Evmos"],
    [4002, "Kujira"],
    [4003, "Neutron"],
    [4004, "Celestia"],
    [4005, "Stargaze"],
    [4007, "Dymension"],
    [10002, "Sepolia"],
    [10003, "ArbitrumSepolia"],
    [10004, "BaseSepolia"],
    [10005, "OptimismSepolia"],
    [10006, "Holesky"],
];
_a = (0, utils_1.zip)(chainIdAndChainEntries), exports.chainIds = _a[0], exports.chains = _a[1];
exports.chainToChainId = (0, mapping_1.constMap)(chainIdAndChainEntries, [1, 0]);
exports.chainIdToChain = (0, mapping_1.constMap)(chainIdAndChainEntries);
const isChain = (chain) => exports.chainToChainId.has(chain);
exports.isChain = isChain;
const isChainId = (chainId) => exports.chainIdToChain.has(chainId);
exports.isChainId = isChainId;
function assertChainId(chainId) {
    if (!(0, exports.isChainId)(chainId))
        throw Error(`Unknown Wormhole chain id: ${chainId}`);
}
exports.assertChainId = assertChainId;
function assertChain(chain) {
    if (!(0, exports.isChain)(chain))
        throw Error(`Unknown Wormhole chain: ${chain}`);
}
exports.assertChain = assertChain;
//safe assertion that allows chaining
const asChainId = (chainId) => {
    assertChainId(chainId);
    return chainId;
};
exports.asChainId = asChainId;
const toChainId = (chain) => {
    switch (typeof chain) {
        case "string":
            if ((0, exports.isChain)(chain))
                return (0, exports.chainToChainId)(chain);
            break;
        case "number":
            if ((0, exports.isChainId)(chain))
                return chain;
            break;
    }
    throw Error(`Cannot convert to ChainId: ${chain}`);
};
exports.toChainId = toChainId;
const toChain = (chain) => {
    switch (typeof chain) {
        case "string":
            if ((0, exports.isChain)(chain))
                return chain;
            break;
        case "number":
            if ((0, exports.isChainId)(chain))
                return (0, exports.chainIdToChain)(chain);
            break;
        case "bigint":
            if ((0, exports.isChainId)(Number(chain)))
                return (0, exports.chainIdToChain)(Number(chain));
            break;
    }
    throw Error(`Cannot convert to Chain: ${chain}`);
};
exports.toChain = toChain;
//# sourceMappingURL=chains.js.map