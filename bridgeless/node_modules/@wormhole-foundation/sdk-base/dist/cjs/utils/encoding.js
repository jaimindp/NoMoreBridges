"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytes = exports.bignum = exports.b58 = exports.b64 = exports.hex = exports.stripPrefix = exports.bech32 = void 0;
const base_1 = require("@scure/base");
var base_2 = require("@scure/base");
Object.defineProperty(exports, "bech32", { enumerable: true, get: function () { return base_2.bech32; } });
/** Utility method to strip a given prefix, frequently used to remove '0x' from an address */
const stripPrefix = (prefix, str) => str.startsWith(prefix) ? str.slice(prefix.length) : str;
exports.stripPrefix = stripPrefix;
const isHexRegex = /^(?:0x)?[0-9a-fA-F]+$/;
/** Base16/Hex encoding and decoding utilities */
exports.hex = {
    valid: (input) => isHexRegex.test(input),
    decode: (input) => base_1.base16.decode((0, exports.stripPrefix)("0x", input).toUpperCase()),
    encode: (input, prefix = false) => {
        input = typeof input === "string" ? exports.bytes.encode(input) : input;
        return (prefix ? "0x" : "") + base_1.base16.encode(input).toLowerCase();
    },
};
// regex string to check if the input could possibly be base64 encoded.
// WARNING: There are clear text strings that are NOT base64 encoded that will pass this check.
const isB64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
/** Base64 encoding and decoding utilities */
exports.b64 = {
    valid: (input) => isB64Regex.test(input),
    decode: base_1.base64.decode,
    encode: (input) => base_1.base64.encode(typeof input === "string" ? exports.bytes.encode(input) : input),
};
/** Base58 encoding and decoding utilities */
exports.b58 = {
    decode: base_1.base58.decode,
    encode: (input) => base_1.base58.encode(typeof input === "string" ? exports.bytes.encode(input) : input),
};
/** BigInt encoding and decoding utilities */
exports.bignum = {
    decode: (input) => {
        if (typeof input !== "string")
            input = exports.hex.encode(input, true);
        if (input === "" || input === "0x")
            return 0n;
        return BigInt(input);
    },
    encode: (input, prefix = false) => exports.bignum.toString(input, prefix),
    toString: (input, prefix = false) => {
        let str = input.toString(16);
        str = str.length % 2 === 1 ? (str = "0" + str) : str;
        if (prefix)
            return "0x" + str;
        return str;
    },
    toBytes: (input, length) => {
        const b = exports.hex.decode(exports.bignum.toString(typeof input === "number" ? BigInt(input) : input));
        if (!length)
            return b;
        return exports.bytes.zpad(b, length);
    },
};
/** Uint8Array encoding and decoding utilities */
exports.bytes = {
    encode: (value) => new TextEncoder().encode(value),
    decode: (value) => new TextDecoder().decode(value),
    equals: (lhs, rhs) => lhs.length === rhs.length && lhs.every((v, i) => v === rhs[i]),
    zpad: (arr, length, padStart = true) => padStart
        ? exports.bytes.concat(new Uint8Array(length - arr.length), arr)
        : exports.bytes.concat(arr, new Uint8Array(length - arr.length)),
    concat: (...args) => {
        const length = args.reduce((acc, curr) => acc + curr.length, 0);
        const result = new Uint8Array(length);
        let offset = 0;
        args.forEach((arg) => {
            result.set(arg, offset);
            offset += arg.length;
        });
        return result;
    },
};
//# sourceMappingURL=encoding.js.map