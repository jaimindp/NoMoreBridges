import { base16, base64, base58 } from "@scure/base";
export { bech32 } from "@scure/base";
/** Utility method to strip a given prefix, frequently used to remove '0x' from an address */
export const stripPrefix = (prefix, str) => str.startsWith(prefix) ? str.slice(prefix.length) : str;
const isHexRegex = /^(?:0x)?[0-9a-fA-F]+$/;
/** Base16/Hex encoding and decoding utilities */
export const hex = {
    valid: (input) => isHexRegex.test(input),
    decode: (input) => base16.decode(stripPrefix("0x", input).toUpperCase()),
    encode: (input, prefix = false) => {
        input = typeof input === "string" ? bytes.encode(input) : input;
        return (prefix ? "0x" : "") + base16.encode(input).toLowerCase();
    },
};
// regex string to check if the input could possibly be base64 encoded.
// WARNING: There are clear text strings that are NOT base64 encoded that will pass this check.
const isB64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
/** Base64 encoding and decoding utilities */
export const b64 = {
    valid: (input) => isB64Regex.test(input),
    decode: base64.decode,
    encode: (input) => base64.encode(typeof input === "string" ? bytes.encode(input) : input),
};
/** Base58 encoding and decoding utilities */
export const b58 = {
    decode: base58.decode,
    encode: (input) => base58.encode(typeof input === "string" ? bytes.encode(input) : input),
};
/** BigInt encoding and decoding utilities */
export const bignum = {
    decode: (input) => {
        if (typeof input !== "string")
            input = hex.encode(input, true);
        if (input === "" || input === "0x")
            return 0n;
        return BigInt(input);
    },
    encode: (input, prefix = false) => bignum.toString(input, prefix),
    toString: (input, prefix = false) => {
        let str = input.toString(16);
        str = str.length % 2 === 1 ? (str = "0" + str) : str;
        if (prefix)
            return "0x" + str;
        return str;
    },
    toBytes: (input, length) => {
        const b = hex.decode(bignum.toString(typeof input === "number" ? BigInt(input) : input));
        if (!length)
            return b;
        return bytes.zpad(b, length);
    },
};
/** Uint8Array encoding and decoding utilities */
export const bytes = {
    encode: (value) => new TextEncoder().encode(value),
    decode: (value) => new TextDecoder().decode(value),
    equals: (lhs, rhs) => lhs.length === rhs.length && lhs.every((v, i) => v === rhs[i]),
    zpad: (arr, length, padStart = true) => padStart
        ? bytes.concat(new Uint8Array(length - arr.length), arr)
        : bytes.concat(arr, new Uint8Array(length - arr.length)),
    concat: (...args) => {
        const length = args.reduce((acc, curr) => acc + curr.length, 0);
        const result = new Uint8Array(length);
        let offset = 0;
        args.forEach((arg) => {
            result.set(arg, offset);
            offset += arg.length;
        });
        return result;
    },
};
//# sourceMappingURL=encoding.js.map