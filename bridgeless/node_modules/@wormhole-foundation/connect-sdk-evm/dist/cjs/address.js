"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmAddress = exports.EvmZeroAddress = void 0;
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
const ethers_1 = require("ethers");
const types_1 = require("./types");
exports.EvmZeroAddress = ethers_1.ethers.ZeroAddress;
class EvmAddress {
    static byteSize = 20;
    static platform = types_1._platform;
    type = 'Native';
    // stored as checksum address
    address;
    constructor(address) {
        if (EvmAddress.instanceof(address)) {
            const a = address;
            this.address = a.address;
            return;
        }
        if (typeof address === 'string') {
            if (!EvmAddress.isValidAddress(address))
                throw new Error(`Invalid EVM address, expected ${EvmAddress.byteSize}-byte hex string but got ${address}`);
            this.address = ethers_1.ethers.getAddress(address);
        }
        else if (address instanceof Uint8Array) {
            if (address.length !== EvmAddress.byteSize)
                throw new Error(`Invalid EVM address, expected ${EvmAddress.byteSize} bytes but got ${address.length}`);
            this.address = ethers_1.ethers.getAddress(ethers_1.ethers.hexlify(address));
        }
        else if (connect_sdk_1.UniversalAddress.instanceof(address)) {
            // If its a universal address and we want it to be an ethereum address,
            // we need to chop off the first 12 bytes of padding
            const addressBytes = address.toUint8Array();
            // double check to make sure there are no non zero bytes
            if (addressBytes.slice(0, 12).some((v) => {
                v !== 0;
            }))
                throw new Error(`Invalid EVM address ${address}`);
            const suffix = connect_sdk_1.encoding.hex.encode(addressBytes.slice(12));
            this.address = ethers_1.ethers.getAddress(suffix);
        }
        else
            throw new Error(`Invalid EVM address ${address}`);
    }
    unwrap() {
        return this.address;
    }
    toString() {
        return this.address;
    }
    toNative() {
        return this;
    }
    toUint8Array() {
        return ethers_1.ethers.getBytes(this.address);
    }
    toUniversalAddress() {
        return new connect_sdk_1.UniversalAddress(ethers_1.ethers.zeroPadValue(this.address, connect_sdk_1.UniversalAddress.byteSize));
    }
    static isValidAddress(address) {
        return ethers_1.ethers.isAddress(address);
    }
    static instanceof(address) {
        return address.constructor.platform === EvmAddress.platform;
    }
    equals(other) {
        if (EvmAddress.instanceof(other)) {
            return other.address === this.address;
        }
        else {
            return other.equals(this.toUniversalAddress());
        }
    }
}
exports.EvmAddress = EvmAddress;
(0, connect_sdk_1.registerNative)(types_1._platform, EvmAddress);
//# sourceMappingURL=address.js.map