"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomaticMockRoute = void 0;
const __1 = require("../..");
const route_1 = require("../route");
async function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
class AutomaticMockRoute extends route_1.AutomaticRoute {
    NATIVE_GAS_DROPOFF_SUPPORTED = true;
    static meta = {
        name: "AutomaticFauxBridge",
    };
    static supportedNetworks() {
        return ["Mainnet", "Testnet"];
    }
    static supportedChains(network) {
        return ["Solana", "Ethereum"];
    }
    static async supportedSourceTokens(fromChain) {
        await delay(250);
        return [(0, __1.nativeTokenId)(fromChain.chain)];
    }
    static async supportedDestinationTokens(sourceToken, fromChain, toChain) {
        await delay(250);
        return [(0, __1.nativeTokenId)(toChain.chain)];
    }
    static isProtocolSupported(chain) {
        return true;
    }
    async isAvailable() {
        return true;
    }
    async validate(params) {
        await delay(250);
        return {
            valid: true,
            params: { ...params, options: this.getDefaultOptions() },
        };
    }
    async quote(params) {
        await delay(1000);
        const fakeQuote = {
            sourceToken: {
                token: this.request.source.id,
                amount: __1.amount.parse(params.amount, this.request.source.decimals),
            },
            destinationToken: {
                token: this.request.destination.id,
                amount: __1.amount.parse(params.amount, this.request.destination.decimals),
            },
            relayFee: {
                token: this.request.source.id,
                amount: __1.amount.parse("0.01", this.request.source.decimals),
            },
        };
        return fakeQuote;
    }
    async initiate(sender, params) {
        await delay(1000);
        const fakeTxId = this.request.from.chain === "Solana"
            ? __1.encoding.b58.encode(new Uint8Array(64))
            : __1.encoding.hex.encode(new Uint8Array(32));
        const fakeReceipt = {
            from: this.request.from.chain,
            to: this.request.to.chain,
            state: __1.TransferState.SourceInitiated,
            originTxs: [{ chain: sender.chain(), txid: fakeTxId }],
        };
        return fakeReceipt;
    }
    async *track(receipt, timeout) {
        await delay(1000);
        const fakeReceipt = {
            ...receipt,
            state: __1.TransferState.DestinationInitiated,
            attestation: {
                id: {},
            },
        };
        yield fakeReceipt;
    }
    getDefaultOptions() {
        return {};
    }
}
exports.AutomaticMockRoute = AutomaticMockRoute;
//# sourceMappingURL=automatic.js.map