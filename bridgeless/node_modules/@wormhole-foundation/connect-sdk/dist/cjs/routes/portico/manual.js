"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PorticoRoute = exports.BPS_PER_HUNDRED_PERCENT = exports.SLIPPAGE_BPS = void 0;
const __1 = require("../..");
const route_1 = require("../route");
const utils_1 = require("./utils");
exports.SLIPPAGE_BPS = 15n; // 0.15%
exports.BPS_PER_HUNDRED_PERCENT = 10000n;
class PorticoRoute extends route_1.ManualRoute {
    async isSupported() {
        return (this.request.fromChain.supportsPorticoBridge() && this.request.toChain.supportsPorticoBridge());
    }
    getDefaultOptions() {
        return {};
    }
    async validate(params) {
        try {
            if ((0, __1.chainToPlatform)(this.request.from.chain) !== "Evm" ||
                (0, __1.chainToPlatform)(this.request.to.chain) !== "Evm") {
                throw new Error("Only EVM chains are supported");
            }
            const { fromChain, toChain, source, destination } = this.request;
            const { network } = fromChain;
            // This may be "native" but we want the token that can actually be bridged
            const [, sourceToken] = (0, __1.resolveWrappedToken)(network, fromChain.chain, source.id);
            const [, destinationToken] = (0, __1.resolveWrappedToken)(network, toChain.chain, destination.id);
            const canonicalSourceToken = (0, utils_1.getTransferrableToken)(network, sourceToken.chain, (0, __1.canonicalAddress)(sourceToken));
            const canonicalDestinationToken = (0, utils_1.getTransferrableToken)(network, destinationToken.chain, (0, __1.canonicalAddress)(destinationToken));
            const validatedParams = {
                amount: params.amount,
                options: params.options ?? this.getDefaultOptions(),
                normalizedParams: {
                    amount: this.request.normalizeAmount(params.amount),
                    canonicalSourceToken,
                    canonicalDestinationToken,
                    sourceToken,
                    destinationToken,
                },
            };
            const quote = await this.quote(validatedParams);
            if (quote.destinationToken.amount < 0) {
                throw new Error("Amount too low for slippage and fee, would result in negative destination amount");
            }
            validatedParams.quote = quote;
            return { valid: true, params: validatedParams };
        }
        catch (e) {
            return { valid: false, error: e, params: params };
        }
    }
    async quote(params) {
        const swapAmounts = await this.quoteUniswap(params);
        const fromPorticoBridge = await this.request.fromChain.getPorticoBridge();
        const fee = await fromPorticoBridge.quoteRelay(params.normalizedParams.canonicalDestinationToken.address, params.normalizedParams.destinationToken);
        const quote = {
            swapAmounts,
            relayerFee: fee,
        };
        return {
            sourceToken: {
                token: params.normalizedParams.sourceToken,
                amount: params.normalizedParams.amount,
            },
            destinationToken: {
                token: params.normalizedParams.destinationToken,
                amount: quote.swapAmounts.minAmountFinish - fee,
            },
            relayFee: {
                token: params.normalizedParams.destinationToken,
                amount: fee,
            },
            quote,
        };
    }
    async initiate(sender, params) {
        const sourceToken = (0, __1.isTokenId)(this.request.source.id)
            ? this.request.source.id.address
            : this.request.source.id;
        const destToken = (0, __1.isTokenId)(this.request.destination.id)
            ? this.request.destination?.id
            : this.request.destination.id;
        const fromPorticoBridge = await this.request.fromChain.getPorticoBridge();
        const xfer = fromPorticoBridge.transfer(this.request.from.address, this.request.to, sourceToken, params.normalizedParams.amount, destToken, params.quote.quote);
        const txids = await (0, __1.signSendWait)(this.request.fromChain, xfer, sender);
        const receipt = {
            originTxs: txids,
            state: __1.TransferState.SourceInitiated,
            from: this.request.from.chain,
            to: this.request.to.chain,
        };
        return receipt;
    }
    async *track(receipt, timeout) {
        if (!(0, __1.isSourceInitiated)(receipt))
            throw new Error("Source must be initiated");
        const { txid } = receipt.originTxs[receipt.originTxs.length - 1];
        const vaa = await this.wh.getVaaByTxHash(txid, "TokenBridge:TransferWithPayload", timeout);
        if (!vaa)
            throw new Error("No VAA found for transaction: " + txid);
        const parsed = __1.PorticoBridge.deserializePayload(vaa.payload.payload);
        yield { ...receipt, vaa, parsed };
    }
    async complete(signer, receipt) {
        if (!(0, __1.isAttested)(receipt))
            throw new Error("Source must be attested");
        const toPorticoBridge = await this.request.toChain.getPorticoBridge();
        const sender = __1.Wormhole.chainAddress(signer.chain(), signer.address());
        const xfer = toPorticoBridge.redeem(sender.address, receipt.attestation.attestation);
        return await (0, __1.signSendWait)(this.request.toChain, xfer, signer);
    }
    async quoteUniswap(params) {
        const fromPorticoBridge = await this.request.fromChain.getPorticoBridge();
        const startQuote = await fromPorticoBridge.quoteSwap(params.normalizedParams.sourceToken.address, params.normalizedParams.canonicalSourceToken.address, params.normalizedParams.amount);
        const startSlippage = (startQuote * exports.SLIPPAGE_BPS) / exports.BPS_PER_HUNDRED_PERCENT;
        if (startSlippage >= startQuote)
            throw new Error("Start slippage too high");
        const toPorticoBridge = await this.request.toChain.getPorticoBridge();
        const minAmountStart = startQuote - startSlippage;
        const finishQuote = await toPorticoBridge.quoteSwap(params.normalizedParams.canonicalDestinationToken.address, params.normalizedParams.destinationToken.address, minAmountStart);
        const finishSlippage = (finishQuote * exports.SLIPPAGE_BPS) / exports.BPS_PER_HUNDRED_PERCENT;
        if (finishSlippage >= finishQuote)
            throw new Error("Finish slippage too high");
        const minAmountFinish = finishQuote - finishSlippage;
        const amountFinishQuote = await toPorticoBridge.quoteSwap(params.normalizedParams.canonicalDestinationToken.address, params.normalizedParams.destinationToken.address, startQuote);
        // the expected receive amount is the amount out from the swap
        // minus 5bps slippage
        const amountFinishSlippage = (amountFinishQuote * 5n) / exports.BPS_PER_HUNDRED_PERCENT;
        if (amountFinishSlippage >= amountFinishQuote)
            throw new Error("Amount finish slippage too high");
        const amountFinish = amountFinishQuote - amountFinishSlippage;
        if (amountFinish <= minAmountFinish)
            throw new Error("Amount finish too low");
        return {
            minAmountStart: minAmountStart,
            minAmountFinish: minAmountFinish,
            amountFinish: amountFinish,
        };
    }
}
exports.PorticoRoute = PorticoRoute;
//# sourceMappingURL=manual.js.map