"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveWrappedToken = exports.getOriginalEthereumAddress = exports.validateCreateOrderResponse = exports.parseFlagSet = exports.parsePorticoPayload = exports.parseTradeParameters = exports.isEqualCaseInsensitive = exports.parseInt = exports.parseAddress = exports.getContracts = void 0;
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
const abis_1 = require("./abis");
const consts_1 = require("./consts");
const getContracts = (chain) => {
    if (!(chain in consts_1.CONTRACTS))
        throw new Error(`Contracts not found for ${chain}`);
    return consts_1.CONTRACTS[chain];
};
exports.getContracts = getContracts;
const parseAddress = (buffer) => {
    console.log(buffer.toString("hex"));
    return new connect_sdk_1.UniversalAddress(buffer).toNative("Ethereum").toString();
};
exports.parseAddress = parseAddress;
const parseInt = (buffer) => {
    return connect_sdk_1.encoding.bignum.decode(buffer);
};
exports.parseInt = parseInt;
const isEqualCaseInsensitive = (a, b) => {
    return a.toLowerCase() === b.toLowerCase();
};
exports.isEqualCaseInsensitive = isEqualCaseInsensitive;
const parseTradeParameters = (buffer) => {
    return {
        flagSet: (0, exports.parseFlagSet)(buffer),
        startTokenAddress: (0, exports.parseAddress)(buffer.subarray(32, 64)),
        canonAssetAddress: (0, exports.parseAddress)(buffer.subarray(64, 96)),
        finalTokenAddress: (0, exports.parseAddress)(buffer.subarray(98, 130)),
        recipientAddress: (0, exports.parseAddress)(buffer.subarray(130, 162)),
        destinationPorticoAddress: (0, exports.parseAddress)(buffer.subarray(160, 192)),
        amountSpecified: (0, exports.parseInt)(buffer.subarray(192, 224)),
        minAmountStart: (0, exports.parseInt)(buffer.subarray(224, 256)),
        minAmountFinish: (0, exports.parseInt)(buffer.subarray(256, 288)),
        relayerFee: (0, exports.parseInt)(buffer.subarray(288, 320)),
    };
};
exports.parseTradeParameters = parseTradeParameters;
const parsePorticoPayload = (buffer) => {
    return {
        flagSet: (0, exports.parseFlagSet)(buffer),
        finalTokenAddress: (0, exports.parseAddress)(buffer.subarray(32, 64)),
        recipientAddress: (0, exports.parseAddress)(buffer.subarray(64, 96)),
        canonAssetAmount: (0, exports.parseInt)(buffer.subarray(96, 128)),
        minAmountFinish: (0, exports.parseInt)(buffer.subarray(128, 160)),
        relayerFee: (0, exports.parseInt)(buffer.subarray(160, 192)),
    };
};
exports.parsePorticoPayload = parsePorticoPayload;
const parseFlagSet = (buffer) => {
    return {
        recipientChain: buffer.readUInt16LE(0),
        bridgeNonce: buffer.readUInt32LE(2),
        feeTierStart: buffer.readUintLE(6, 3),
        feeTierFinish: buffer.readUintLE(9, 3),
        shouldWrapNative: !!(buffer.readUInt8(31) & (1 << 0)),
        shouldUnwrapNative: !!(buffer.readUInt8(31) & (1 << 1)),
    };
};
exports.parseFlagSet = parseFlagSet;
/**
 * Validates that the response from the order creation API matches the request
 * throws an error if there is a mismatch
 */
const validateCreateOrderResponse = (response, request) => {
    if (!(0, exports.isEqualCaseInsensitive)(request.porticoAddress || "", response.transactionTarget)) {
        throw new Error("portico address mismatch");
    }
    const decoded = abis_1.porticoAbi.decodeFunctionData("start", response.transactionData);
    if (decoded.length !== 1 || decoded[0].length !== 10) {
        throw new Error("decoded length mismatch");
    }
    const flagSetBuffer = Buffer.from(decoded[0][0].slice(2), "hex");
    if (flagSetBuffer.length !== 32) {
        throw new Error("flag set length mismatch");
    }
    const { recipientChain, feeTierStart, feeTierFinish, shouldWrapNative, shouldUnwrapNative } = (0, exports.parseFlagSet)(flagSetBuffer);
    if (recipientChain !== request.destinationChainId) {
        throw new Error("recipient chain mismatch");
    }
    if (feeTierStart !== request.feeTierStart) {
        throw new Error("fee tier start mismatch");
    }
    if (feeTierFinish !== request.feeTierEnd) {
        throw new Error("fee tier end mismatch");
    }
    if (shouldWrapNative !== request.shouldWrapNative) {
        throw new Error("should wrap native mismatch");
    }
    if (shouldUnwrapNative !== request.shouldUnwrapNative) {
        throw new Error("should unwrap native mismatch");
    }
    const startTokenAddress = decoded[0][1];
    if (!(0, exports.isEqualCaseInsensitive)(startTokenAddress, request.startingToken)) {
        throw new Error("start token address mismatch");
    }
    // const startTokenId = Wormhole.chainAddress(toChain(request.startingChainId), startTokenAddress);
    // const canonicalTokenAddress: string = decoded[0][2];
    // if (!isEqualCaseInsensitive(canonicalTokenAddress, getOriginalAddress("Mainnet", startTokenId))) {
    //   throw new Error("canonical token address mismatch");
    // }
    const finalTokenAddress = decoded[0][3];
    if (!(0, exports.isEqualCaseInsensitive)(finalTokenAddress, request.destinationToken)) {
        throw new Error("final token address mismatch");
    }
    const recipientAddress = decoded[0][4];
    if (!(0, exports.isEqualCaseInsensitive)(recipientAddress, request.destinationAddress)) {
        throw new Error("recipient address mismatch");
    }
    const destinationPorticoAddress = decoded[0][5];
    if (!(0, exports.isEqualCaseInsensitive)(destinationPorticoAddress, request.destinationPorticoAddress || "")) {
        throw new Error("destination portico address mismatch");
    }
    const amountSpecified = decoded[0][6];
    if (amountSpecified.toString() !== request.startingTokenAmount) {
        throw new Error("amount mismatch");
    }
    const minAmountStart = decoded[0][7];
    if (minAmountStart.toString() !== request.minAmountStart) {
        throw new Error("min amount start mismatch");
    }
    const minAmountFinish = decoded[0][8];
    if (minAmountFinish.toString() !== request.minAmountEnd) {
        throw new Error("min amount finish mismatch");
    }
    const relayerFee = decoded[0][9];
    if (relayerFee.toString() !== request.relayerFee) {
        throw new Error("relayer fee mismatch");
    }
};
exports.validateCreateOrderResponse = validateCreateOrderResponse;
// For a given token, return the corresponding address native to Ethereum
// Only considers local cache
const getOriginalEthereumAddress = (network, token) => {
    if (token.chain === "Ethereum")
        return token;
    const tokenAddress = (0, connect_sdk_1.canonicalAddress)(token);
    const tokenData = connect_sdk_1.tokens.getTokenByAddress(network, token.chain, tokenAddress);
    if (!tokenData)
        throw new Error("Could not find token symbol for " + tokenAddress);
    const originalToken = connect_sdk_1.tokens.getCanonicalToken(network, token.chain, tokenData.symbol);
    if (!originalToken)
        throw new Error("Could not find original token for " + tokenAddress);
    if (originalToken.chain !== "Ethereum")
        throw new Error("Original token does not come from Ethereum");
    return connect_sdk_1.Wormhole.chainAddress(originalToken.chain, originalToken.address);
};
exports.getOriginalEthereumAddress = getOriginalEthereumAddress;
function resolveWrappedToken(network, chain, token) {
    const isNative = token === "native";
    if (isNative) {
        const nativeToken = connect_sdk_1.tokens.getNativeToken(network, chain);
        if (!nativeToken)
            throw new Error("Invalid destination token");
        const wrappedKey = nativeToken.wrapped;
        const wrappedToken = connect_sdk_1.tokens.getTokenByKey(network, chain, wrappedKey.address);
        if (!wrappedToken)
            throw new Error("Invalid wrapped token key: " + wrappedKey);
        const destNativeWrapped = connect_sdk_1.Wormhole.chainAddress(chain, wrappedToken.address);
        return [true, destNativeWrapped];
    }
    return [false, token];
}
exports.resolveWrappedToken = resolveWrappedToken;
//# sourceMappingURL=utils.js.map