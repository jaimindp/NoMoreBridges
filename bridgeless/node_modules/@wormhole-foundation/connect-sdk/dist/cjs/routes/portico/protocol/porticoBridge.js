"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PorticoBridge = void 0;
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
const connect_sdk_evm_1 = require("@wormhole-foundation/connect-sdk-evm");
const axios_1 = __importDefault(require("axios"));
const ethers_1 = require("ethers");
const abis_1 = require("./abis");
const consts_1 = require("./consts");
const utils_1 = require("./utils");
class PorticoBridge {
    context;
    chainId;
    porticoAddress;
    uniswapAddress;
    constructor(context) {
        this.context = context;
        const { portico: porticoAddress, uniswapQuoterV2: uniswapAddress } = (0, utils_1.getContracts)(this.context.chain);
        this.porticoAddress = porticoAddress;
        this.uniswapAddress = uniswapAddress;
        this.chainId = connect_sdk_1.nativeChainIds.networkChainToNativeChainId.get(context.network, context.chain);
    }
    async *transfer(transfer) {
        const { from: sender, to: receiver, source: token, destination: destToken, amount } = transfer;
        const { minAmountStart, minAmountFinish } = transfer.swapAmounts;
        if (minAmountStart === 0n)
            throw new Error("Invalid min swap amount");
        if (minAmountFinish === 0n)
            throw new Error("Invalid min swap amount");
        const senderAddress = (0, connect_sdk_1.canonicalAddress)(sender);
        const receiverAddress = (0, connect_sdk_1.canonicalAddress)(receiver);
        const [isStartTokenNative, startToken] = (0, utils_1.resolveWrappedToken)(this.context.network, this.context.chain, token);
        const [isFinalTokenNative, finalToken] = (0, utils_1.resolveWrappedToken)(this.context.network, receiver.chain, destToken);
        const startTokenAddress = (0, connect_sdk_1.canonicalAddress)(startToken);
        const finalTokenAddress = (0, connect_sdk_1.canonicalAddress)(finalToken);
        const destinationPorticoAddress = (0, utils_1.getContracts)(receiver.chain).portico;
        const core = await this.context.getWormholeCore();
        const messageFee = await core.getMessageFee();
        const receiverChainId = connect_sdk_1.nativeChainIds.networkChainToNativeChainId.get(this.context.network, receiver.chain);
        // Create the order
        const request = {
            startingChainId: Number(this.chainId),
            startingToken: startTokenAddress,
            startingTokenAmount: amount.toString(),
            destinationToken: finalTokenAddress,
            destinationAddress: receiverAddress,
            destinationChainId: Number(receiverChainId),
            relayerFee: transfer.relayerFee,
            feeTierStart: consts_1.FEE_TIER,
            feeTierEnd: consts_1.FEE_TIER,
            minAmountStart: minAmountStart.toString(),
            minAmountEnd: minAmountFinish.toString(),
            bridgeNonce: new Date().valueOf(),
            shouldWrapNative: isStartTokenNative,
            shouldUnwrapNative: isFinalTokenNative,
            porticoAddress: this.porticoAddress,
            destinationPorticoAddress,
        };
        const createOrderResult = await this.createOrder(request);
        // Approve the token if necessary
        if (!isStartTokenNative)
            yield* this.approve(this.context, startTokenAddress, senderAddress, amount, this.porticoAddress);
        const tx = {
            to: this.porticoAddress,
            data: createOrderResult.transactionData,
            value: messageFee + (isStartTokenNative ? amount : 0n),
        };
        yield this.createUnsignedTransaction((0, connect_sdk_evm_1.addFrom)(tx, senderAddress), "PorticoBridge.Transfer");
    }
    // Post the order to the portico API
    async createOrder(request) {
        try {
            const response = await axios_1.default.post(consts_1.CREATE_ORDER_API_URL, request);
            // Validate the response, not strictly necessary but if some details are wrong we want to know
            (0, utils_1.validateCreateOrderResponse)(response.data, request);
            return response.data;
        }
        catch (e) {
            if (axios_1.default.isAxiosError(e)) {
                const message = `${e.response?.statusText}: ${e.response?.data.message}`;
                throw new Error(`Could not create order: ${message},`);
            }
            throw e;
        }
    }
    async *approve(fromChain, token, senderAddr, amount, contract) {
        const tokenContract = connect_sdk_evm_1.EvmPlatform.getTokenImplementation(await fromChain.getRpc(), token);
        const allowance = await tokenContract.allowance(senderAddr, contract);
        if (allowance < amount) {
            const txReq = await tokenContract.approve.populateTransaction(contract, amount);
            yield this.createUnsignedTransaction((0, connect_sdk_evm_1.addFrom)(txReq, senderAddr), "PorticoBridge.Approve");
        }
    }
    async *redeem(chain, vaa, signer) {
        const contract = new ethers_1.ethers.Contract(this.porticoAddress, ["function receiveMessageAndSwap(bytes)"], await chain.getRpc());
        const txReq = await contract
            .getFunction("receiveMessageAndSwap")
            .populateTransaction((0, connect_sdk_1.serialize)(vaa));
        yield this.createUnsignedTransaction((0, connect_sdk_evm_1.addFrom)(txReq, signer.address()), "PorticoBridge.Redeem");
    }
    async getUniswapQuote(tokenIn, tokenOut, amountIn, fee) {
        if (tokenIn === tokenOut)
            return { amountOut: amountIn };
        const contract = new ethers_1.ethers.Contract(this.uniswapAddress, abis_1.uniswapQuoterV2Abi.fragments, await this.context.getRpc());
        //console.log(`quoteExactInputSingle(${[tokenIn, tokenOut, amountIn, fee, 0]})`);
        const result = await contract
            .getFunction("quoteExactInputSingle")
            .staticCall([tokenIn, tokenOut, amountIn, fee, 0]);
        return { amountOut: result[0] };
    }
    createUnsignedTransaction(txReq, description) {
        return new connect_sdk_evm_1.EvmUnsignedTransaction((0, connect_sdk_evm_1.addChainId)(txReq, this.chainId), this.context.network, this.context.chain, description, false);
    }
}
exports.PorticoBridge = PorticoBridge;
//# sourceMappingURL=porticoBridge.js.map