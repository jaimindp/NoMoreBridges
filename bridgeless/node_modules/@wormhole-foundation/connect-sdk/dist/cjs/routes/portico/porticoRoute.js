"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PorticoRoute = void 0;
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
const axios_1 = __importDefault(require("axios"));
const consts_1 = require("./protocol/consts");
const porticoBridge_1 = require("./protocol/porticoBridge");
const utils_1 = require("./protocol/utils");
require("@wormhole-foundation/connect-sdk-evm-tokenbridge");
class PorticoRoute extends connect_sdk_1.routes.ManualRoute {
    fromPorticoBridge;
    toPorticoBridge;
    constructor(wh, request) {
        super(wh, request);
        this.fromPorticoBridge = new porticoBridge_1.PorticoBridge(request.fromChain);
        this.toPorticoBridge = new porticoBridge_1.PorticoBridge(request.toChain);
    }
    async isSupported() {
        try {
            const { portico, uniswapQuoterV2 } = (0, utils_1.getContracts)(this.request.from.chain);
            return !!(portico && uniswapQuoterV2);
        }
        catch {
            return false;
        }
    }
    static getDefaultOptions() {
        return {};
    }
    async validate(params) {
        try {
            if ((0, connect_sdk_1.chainToPlatform)(this.request.from.chain) !== "Evm" ||
                (0, connect_sdk_1.chainToPlatform)(this.request.to.chain) !== "Evm") {
                throw new Error("Only EVM chains are supported");
            }
            const { fromChain, toChain, source, destination } = this.request;
            const { network } = fromChain;
            const [, startToken] = (0, utils_1.resolveWrappedToken)(network, fromChain.chain, source.id);
            const [, finishToken] = (0, utils_1.resolveWrappedToken)(network, toChain.chain, destination.id);
            const [startCanonicalToken, finishCanonicalToken] = [
                (0, utils_1.getOriginalEthereumAddress)(network, startToken),
                (0, utils_1.getOriginalEthereumAddress)(network, finishToken),
            ];
            // TODO: check token cache first?
            const ttb = await toChain.getTokenBridge();
            const canonicalWrappedToken = (await ttb.getWrappedAsset(finishCanonicalToken));
            const canonicalDestinationToken = {
                chain: this.request.to.chain,
                address: canonicalWrappedToken,
            };
            const options = params.options ?? PorticoRoute.getDefaultOptions();
            const validatedParams = {
                amount: params.amount,
                options,
                normalizedParams: {
                    amount: this.request.normalizeAmount(params.amount),
                    canonicalSourceToken: startCanonicalToken,
                    canonicalDestinationToken,
                    sourceToken: startToken,
                    destinationToken: finishToken,
                },
            };
            validatedParams.quote = await this.quote(validatedParams);
            return { valid: true, params: validatedParams };
        }
        catch (e) {
            return { valid: false, error: e, params: params };
        }
    }
    async quote(params) {
        const swapAmounts = await this.quoteUniswap(params);
        const fee = await this.quoteRelayer(params.normalizedParams.canonicalDestinationToken, params.normalizedParams.destinationToken);
        return { swapAmounts, relayerFee: fee.toString() };
    }
    async initiate(sender, params) {
        const request = this.toPorticoTransferRequest(params);
        const xfer = this.fromPorticoBridge.transfer(request);
        const txids = await (0, connect_sdk_1.signSendWait)(this.request.fromChain, xfer, sender);
        // TODO: wait for VAA?
        return { txids };
    }
    async *track(receipt, timeout) {
        const { txid } = receipt.txids[0];
        const vaa = await this.wh.getVaaByTxHash(txid, "TokenBridge:TransferWithPayload", timeout);
        if (!vaa)
            throw new Error("No VAA found for transaction: " + txid);
        const parsed = (0, utils_1.parsePorticoPayload)(Buffer.from(vaa.payload.payload));
        yield { ...receipt, vaa, parsed };
    }
    async complete(sender, receipt) {
        if (!receipt.vaa)
            throw new Error("No VAA in receipt");
        const chain = this.request.toChain;
        const xfer = this.toPorticoBridge.redeem(chain, receipt.vaa, sender);
        return await (0, connect_sdk_1.signSendWait)(chain, xfer, sender);
    }
    toPorticoTransferRequest(params) {
        return {
            from: this.request.from,
            to: this.request.to,
            source: this.request.source.id,
            destination: this.request.destination.id,
            amount: this.request.normalizeAmount(params.amount),
            ...params.options,
            ...params.quote,
        };
    }
    async quoteRelayer(from, to) {
        const targetChain = (0, connect_sdk_1.toChainId)(to.chain);
        const sourceToken = connect_sdk_1.encoding.hex.encode(from.address.toUniversalAddress().toUint8Array(), false);
        const targetToken = connect_sdk_1.encoding.hex.encode(to.address.toUniversalAddress().toUint8Array(), false);
        const request = { targetChain, sourceToken, targetToken };
        try {
            const response = await axios_1.default.post(consts_1.RELAYER_FEE_API_URL, request);
            return BigInt(response.data.fee);
        }
        catch (e) {
            if (axios_1.default.isAxiosError(e)) {
                throw new Error(`Error getting relayer fee: ${e.response?.statusText}`);
            }
            throw e;
        }
    }
    async quoteUniswap(params) {
        const startQuote = await this.fromPorticoBridge.getUniswapQuote((0, connect_sdk_1.canonicalAddress)(params.normalizedParams.sourceToken), (0, connect_sdk_1.canonicalAddress)(params.normalizedParams.canonicalSourceToken), params.normalizedParams.amount, consts_1.FEE_TIER);
        const startSlippage = (startQuote.amountOut * consts_1.SLIPPAGE_BPS) / consts_1.BPS_PER_HUNDRED_PERCENT;
        if (startSlippage >= startQuote.amountOut) {
            throw new Error("Start slippage too high");
        }
        const minAmountStart = startQuote.amountOut - startSlippage;
        const finishQuote = await this.toPorticoBridge.getUniswapQuote((0, connect_sdk_1.canonicalAddress)(params.normalizedParams.canonicalDestinationToken), (0, connect_sdk_1.canonicalAddress)(params.normalizedParams.destinationToken), minAmountStart, consts_1.FEE_TIER);
        const finishSlippage = (finishQuote.amountOut * consts_1.SLIPPAGE_BPS) / consts_1.BPS_PER_HUNDRED_PERCENT;
        if (finishSlippage >= finishQuote.amountOut) {
            throw new Error("Finish slippage too high");
        }
        const minAmountFinish = finishQuote.amountOut - finishSlippage;
        const amountFinishQuote = await this.toPorticoBridge.getUniswapQuote((0, connect_sdk_1.canonicalAddress)(params.normalizedParams.canonicalDestinationToken), (0, connect_sdk_1.canonicalAddress)(params.normalizedParams.destinationToken), startQuote.amountOut, // no slippage
        consts_1.FEE_TIER);
        // the expected receive amount is the amount out from the swap
        // minus 5bps slippage
        const amountFinishSlippage = (amountFinishQuote.amountOut * 5n) / consts_1.BPS_PER_HUNDRED_PERCENT;
        if (amountFinishSlippage >= amountFinishQuote.amountOut) {
            throw new Error("Amount finish slippage too high");
        }
        const amountFinish = amountFinishQuote.amountOut - amountFinishSlippage;
        if (amountFinish <= minAmountFinish) {
            throw new Error("Amount finish too low");
        }
        return {
            minAmountStart: minAmountStart,
            minAmountFinish: minAmountFinish,
            amountFinish: amountFinish,
        };
    }
}
exports.PorticoRoute = PorticoRoute;
//# sourceMappingURL=porticoRoute.js.map