"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBridgeRoute = void 0;
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const tokenTransfer_1 = require("../protocols/tokenTransfer");
const wormholeTransfer_1 = require("../wormholeTransfer");
const route_1 = require("./route");
class TokenBridgeRoute extends route_1.ManualRoute {
    async isSupported() {
        // No transfers to same chain
        if (this.request.from.chain === this.request.to.chain)
            return false;
        // No transfers to unsupported chains
        const fromChain = this.wh.getChain(this.request.from.chain);
        if (!fromChain.supportsTokenBridge())
            return false;
        const toChain = this.wh.getChain(this.request.to.chain);
        if (!toChain.supportsTokenBridge())
            return false;
        // If the destination token was set, and its different than what
        // we'd get from a token bridge transfer, then this route is not supported
        if (this.request.destination) {
            const destToken = await tokenTransfer_1.TokenTransfer.lookupDestinationToken(fromChain, toChain, this.request.source);
            if (!(0, sdk_definitions_1.isSameToken)(destToken, this.request.destination))
                return false;
        }
        return true;
    }
    async validate(options) {
        const transfer = this.toTransferDetails(options);
        try {
            await tokenTransfer_1.TokenTransfer.validateTransferDetails(this.wh, transfer);
            return { valid: true };
        }
        catch (e) {
            return { valid: false, error: e };
        }
    }
    getDefaultOptions() {
        return { payload: undefined };
    }
    async initiate(signer, options) {
        const fromChain = this.wh.getChain(this.request.from.chain);
        const transfer = this.toTransferDetails(options);
        const txids = await tokenTransfer_1.TokenTransfer.transfer(fromChain, transfer, signer);
        const msg = await tokenTransfer_1.TokenTransfer.getTransferMessage(fromChain, txids[txids.length - 1].txid);
        return {
            protocol: "TokenBridge",
            from: transfer.from.chain,
            to: transfer.to.chain,
            state: wormholeTransfer_1.TransferState.SourceFinalized,
            request: transfer,
            originTxs: txids,
            attestation: { id: msg },
        };
    }
    async complete(signer, receipt) {
        if (!(0, wormholeTransfer_1.isSourceFinalized)(receipt))
            throw new Error("The source must be finalized in order to complete the transfer");
        const toChain = this.wh.getChain(this.request.to.chain);
        const vaa = await tokenTransfer_1.TokenTransfer.getTransferVaa(this.wh, receipt.attestation.id);
        return await tokenTransfer_1.TokenTransfer.redeem(toChain, vaa, signer);
    }
    async *track(receipt) {
        return tokenTransfer_1.TokenTransfer.track(this.wh, receipt);
    }
    toTransferDetails(options) {
        return {
            token: this.request.source,
            amount: this.request.amount,
            from: this.request.from,
            to: this.request.to,
            ...options,
        };
    }
}
exports.TokenBridgeRoute = TokenBridgeRoute;
//# sourceMappingURL=tokenBridgeRoute.js.map