"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomaticTokenBridgeRoute = void 0;
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const tokenTransfer_1 = require("../protocols/tokenTransfer");
const wormholeTransfer_1 = require("../wormholeTransfer");
const route_1 = require("./route");
class AutomaticTokenBridgeRoute extends route_1.AutomaticRoute {
    NATIVE_GAS_DROPOFF_SUPPORTED = true;
    async isSupported() {
        // No transfers to same chain
        if (this.request.from.chain === this.request.to.chain)
            return false;
        // No transfers to unsupported chains
        const fromChain = this.wh.getChain(this.request.from.chain);
        if (!fromChain.supportsAutomaticTokenBridge())
            return false;
        const toChain = this.wh.getChain(this.request.to.chain);
        if (!toChain.supportsAutomaticTokenBridge())
            return false;
        const atb = await fromChain.getAutomaticTokenBridge();
        if ((0, sdk_definitions_1.isTokenId)(this.request.source) && !atb.isRegisteredToken(this.request.source.address))
            return false;
        // If the destination token was set, and its different than what
        // we'd get from a token bridge transfer, then this route is not supported
        if (this.request.destination) {
            const destToken = await tokenTransfer_1.TokenTransfer.lookupDestinationToken(fromChain, toChain, this.request.source);
            if (!(0, sdk_definitions_1.isSameToken)(destToken, this.request.destination))
                return false;
        }
        return true;
    }
    async isAvailable() {
        // TODO
        return true;
    }
    getDefaultOptions() {
        return { nativeGasDropoff: 0n };
    }
    async validate(options) {
        const transfer = this.toTransferDetails(options);
        try {
            await tokenTransfer_1.TokenTransfer.validateTransferDetails(this.wh, transfer);
            return { valid: true };
        }
        catch (e) {
            return { valid: false, error: e };
        }
    }
    async initiate(signer, options) {
        const fromChain = this.wh.getChain(this.request.from.chain);
        const transfer = this.toTransferDetails(options);
        const txids = await tokenTransfer_1.TokenTransfer.transfer(fromChain, transfer, signer);
        const msg = await tokenTransfer_1.TokenTransfer.getTransferMessage(fromChain, txids[txids.length - 1].txid);
        return {
            protocol: "AutomaticTokenBridge",
            from: transfer.from.chain,
            to: transfer.to.chain,
            state: wormholeTransfer_1.TransferState.SourceFinalized,
            request: transfer,
            originTxs: txids,
            attestation: { id: msg },
        };
    }
    async *track(receipt) {
        const tracker = tokenTransfer_1.TokenTransfer.track(this.wh, receipt);
        console.log("IN TRACK", receipt, tracker);
        return tracker;
    }
    toTransferDetails(options) {
        return {
            token: this.request.source,
            amount: this.request.amount,
            from: this.request.from,
            to: this.request.to,
            automatic: true,
            ...options,
        };
    }
}
exports.AutomaticTokenBridgeRoute = AutomaticTokenBridgeRoute;
//# sourceMappingURL=automaticTokenBridgeRoute.js.map