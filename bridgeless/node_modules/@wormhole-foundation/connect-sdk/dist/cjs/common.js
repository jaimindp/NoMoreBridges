"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signSendWait = void 0;
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
async function signSendWait(chain, xfer, signer) {
    const txHashes = [];
    if (!(0, sdk_definitions_1.isSigner)(signer))
        throw new Error("Invalid signer, not SignAndSendSigner or SignOnlySigner");
    const signSend = async (txns) => (0, sdk_definitions_1.isSignAndSendSigner)(signer)
        ? signer.signAndSend(txns)
        : chain.sendWait(await signer.sign(txns));
    let txbuff = [];
    for await (const tx of xfer) {
        // buffer transactions as long as they are
        // marked as parallelizable
        if (tx.parallelizable) {
            txbuff.push(tx);
        }
        else {
            // if we find one is not parallelizable
            // flush the buffer then sign and send the
            // current tx
            if (txbuff.length > 0) {
                txHashes.push(...(await signSend(txbuff)));
                txbuff = [];
            }
            // Note: it may be possible to group this tx with
            // those in the buffer if there are any but
            // the parallelizable flag alone is not enough to signal
            // if this is safe
            txHashes.push(...(await signSend([tx])));
        }
    }
    if (txbuff.length > 0) {
        txHashes.push(...(await signSend(txbuff)));
    }
    return txHashes.map((txid) => ({ chain: chain.chain, txid }));
}
exports.signSendWait = signSendWait;
//# sourceMappingURL=common.js.map