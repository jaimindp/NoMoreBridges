"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenTransferUtils = exports._mintable = exports._dedust = exports.scale = exports.truncate = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const config_1 = require("../../config");
const types_1 = require("../../types");
const wormhole_1 = require("../../wormhole");
const automatic_1 = require("./automatic");
const manual_1 = require("./manual");
// truncate the amount for over-the-wire max representation
const truncate = (amt, decimals) => decimals > 8 ? amt / 10n ** (decimals - 8n) : amt;
exports.truncate = truncate;
// scale by number of decimals, pair with truncate
const scale = (amt, decimals) => decimals > 8 ? amt * 10n ** (decimals - 8n) : amt;
exports.scale = scale;
// dedust for source using the number of decimals on the source chain
// but scale back to original decimals
const _dedust = (decimals) => (amt) => (0, exports.scale)((0, exports.truncate)(amt, decimals), decimals);
exports._dedust = _dedust;
// truncate and rescale to fit destination token
const _mintable = (srcDecimals, dstDecimals) => (amt) => (0, exports.scale)((0, exports.truncate)(amt, srcDecimals), dstDecimals);
exports._mintable = _mintable;
class TokenTransferUtils {
    static async from(wh, from, timeout = 6000, fromChain, toChain) {
        if ((0, sdk_definitions_1.isTokenTransferDetails)(from)) {
            fromChain = fromChain ?? wh.getChain(from.from.chain);
            toChain = toChain ?? wh.getChain(from.to.chain);
            // throws if invalid
            this.validateTransferDetails(wh, from, fromChain, toChain);
            // Apply hackery
            from = {
                ...from,
                ...(await this.destinationOverrides(fromChain, toChain, from)),
            };
            if (from.automatic) {
                return new automatic_1.AutomaticTokenTransfer(wh, from, fromChain, toChain);
            }
            else {
                return new manual_1.ManualTokenTransfer(wh, from, fromChain, toChain);
            }
        }
        let tt;
        if ((0, sdk_definitions_1.isWormholeMessageId)(from)) {
            tt = await this.fromIdentifier(wh, from, timeout);
        }
        else if ((0, sdk_definitions_1.isTransactionIdentifier)(from)) {
            tt = await this.fromTransaction(wh, from, timeout, fromChain);
        }
        else {
            throw new Error("Invalid `from` parameter for TokenTransfer");
        }
        tt.fromChain = fromChain ?? wh.getChain(tt.transfer.from.chain);
        tt.toChain = toChain ?? wh.getChain(tt.transfer.to.chain);
        await tt.fetchAttestation(timeout);
        return tt;
    }
    // init from the seq id
    static async fromIdentifier(wh, id, timeout) {
        const vaa = await this.getTransferVaa(wh, id, timeout);
        const automatic = vaa.protocolName === "AutomaticTokenBridge";
        // TODO: the `from.address` here is a lie, but we don't
        // immediately have enough info to get the _correct_ one
        let from = { chain: vaa.emitterChain, address: vaa.emitterAddress };
        let { token, to } = vaa.payload;
        const rescale = (amt, decimals) => decimals > 8 ? amt * 10n ** (decimals - 8n) : amt;
        const amount = rescale(token.amount, await wh.getDecimals(token.chain, token.address));
        let nativeGasAmount = 0n;
        if (automatic) {
            nativeGasAmount = vaa.payload.payload.toNativeTokenAmount;
            from = { chain: vaa.emitterChain, address: vaa.payload.from };
            to = { chain: vaa.payload.to.chain, address: vaa.payload.payload.targetRecipient };
        }
        const details = {
            token,
            amount,
            from,
            to,
            automatic,
            nativeGas: nativeGasAmount,
        };
        let tt;
        if (automatic) {
            tt = new automatic_1.AutomaticTokenTransfer(wh, details);
        }
        else {
            tt = new manual_1.ManualTokenTransfer(wh, details);
        }
        tt.receipt = {
            ...tt.receipt,
            state: types_1.TransferState.Attested,
            attestation: { id: id, attestation: vaa },
        };
        return tt;
    }
    static async fromTransaction(wh, from, timeout, fromChain) {
        fromChain = fromChain ?? wh.getChain(from.chain);
        const msg = await this.getTransferMessage(fromChain, from.txid, timeout);
        return await this.fromIdentifier(wh, msg, timeout);
    }
    static async getTransferMessage(chain, txid, timeout) {
        const whm = await wormhole_1.Wormhole.parseMessageFromTx(chain, txid, timeout);
        if (whm.length !== 1)
            throw new Error("Expected a single Wormhole Message, got: " + whm.length);
        return whm[0];
    }
    static async getTransferVaa(wh, key, timeout) {
        const vaa = typeof key === "string"
            ? await wh.getVaaByTxHash(key, sdk_definitions_1.TokenBridge.getTransferDiscriminator(), timeout)
            : await wh.getVaa(key, sdk_definitions_1.TokenBridge.getTransferDiscriminator(), timeout);
        if (!vaa)
            throw new Error(`No VAA available after retries exhausted`);
        // Check if its automatic and re-de-serialize
        if (vaa.payloadName === "TransferWithPayload") {
            const { chain, address } = vaa.payload.to;
            const { tokenBridgeRelayer } = wh.config.chains[chain].contracts;
            const relayerAddress = tokenBridgeRelayer ? (0, sdk_definitions_1.toUniversal)(chain, tokenBridgeRelayer) : null;
            // If the target address is the relayer address, expect its an automatic token bridge vaa
            if (!!relayerAddress && address.equals(relayerAddress)) {
                return (0, sdk_definitions_1.deserialize)("AutomaticTokenBridge:TransferWithRelay", (0, sdk_definitions_1.serialize)(vaa));
            }
        }
        return vaa;
    }
    // Lookup the token id for the destination chain given the source chain
    // and token id
    static async lookupDestinationToken(srcChain, dstChain, token) {
        // that will be minted when the transfer is redeemed
        let lookup;
        if ((0, sdk_definitions_1.isNative)(token.address)) {
            // if native, get the wrapped asset id
            lookup = await srcChain.getNativeWrappedTokenId();
        }
        else {
            try {
                const tb = await srcChain.getTokenBridge();
                // otherwise, check to see if it is a wrapped token locally
                lookup = await tb.getOriginalAsset(token.address);
            }
            catch (e) {
                // not a from-chain native wormhole-wrapped one
                lookup = token;
            }
        }
        // if the token id is actually native to the destination, return it
        if (lookup.chain === dstChain.chain) {
            return lookup;
        }
        // otherwise, figure out what the token address representing the wormhole-wrapped token we're transferring
        const dstTb = await dstChain.getTokenBridge();
        const dstAddress = await dstTb.getWrappedAsset(lookup);
        return { chain: dstChain.chain, address: dstAddress };
    }
    static validateTransferDetails(wh, transfer, fromChain, toChain) {
        if (transfer.amount === 0n)
            throw new Error("Amount cannot be 0");
        if (transfer.from.chain === transfer.to.chain)
            throw new Error("Cannot transfer to the same chain");
        fromChain = fromChain ?? wh.getChain(transfer.from.chain);
        toChain = toChain ?? wh.getChain(transfer.to.chain);
        if (transfer.automatic) {
            if (transfer.payload)
                throw new Error("Payload with automatic delivery is not supported");
            if (!fromChain.supportsAutomaticTokenBridge())
                throw new Error(`Automatic Token Bridge not supported on ${transfer.from.chain}`);
            if (!toChain.supportsAutomaticTokenBridge())
                throw new Error(`Automatic Token Bridge not supported on ${transfer.to.chain}`);
            const nativeGas = transfer.nativeGas ?? 0n;
            if (nativeGas > transfer.amount)
                throw new Error(`Native gas amount  > amount (${nativeGas} > ${transfer.amount})`);
        }
        else {
            if (transfer.nativeGas)
                throw new Error("Gas Dropoff is only supported for automatic transfers");
            if (!fromChain.supportsTokenBridge())
                throw new Error(`Token Bridge not supported on ${transfer.from.chain}`);
            if (!toChain.supportsTokenBridge())
                throw new Error(`Token Bridge not supported on ${transfer.to.chain}`);
        }
    }
    static async quoteTransfer(srcChain, dstChain, transfer) {
        const dstToken = await this.lookupDestinationToken(srcChain, dstChain, transfer.token);
        const srcToken = (0, sdk_definitions_1.isNative)(transfer.token.address)
            ? await srcChain.getNativeWrappedTokenId()
            : transfer.token;
        const dstDecimals = await dstChain.getDecimals(dstToken.address);
        const srcDecimals = await srcChain.getDecimals(srcToken.address);
        const dedust = (0, exports._dedust)(srcDecimals);
        const mintable = (0, exports._mintable)(srcDecimals, dstDecimals);
        // dedust for transfer over the bridge which truncates to 8 decimals
        let srcAmount = dedust(transfer.amount);
        let dstAmount = mintable(transfer.amount);
        if (!transfer.automatic) {
            return {
                sourceToken: { token: srcToken, amount: srcAmount },
                destinationToken: { token: dstToken, amount: dstAmount },
            };
        }
        // Otherwise automatic
        // If a native gas dropoff is requested, remove that from the amount they'll get
        const _nativeGas = transfer.nativeGas ? mintable(transfer.nativeGas) : 0n;
        dstAmount -= _nativeGas;
        // The fee is also removed from the amount transferred
        // quoted on the source chain
        const stb = await srcChain.getAutomaticTokenBridge();
        const fee = await stb.getRelayerFee(transfer.from.address, transfer.to, srcToken.address);
        dstAmount -= mintable(fee);
        // The expected destination gas can be pulled from the destination token bridge
        let destinationNativeGas = 0n;
        if (transfer.nativeGas) {
            const dtb = await dstChain.getAutomaticTokenBridge();
            destinationNativeGas = await dtb.nativeTokenAmount(dstToken.address, _nativeGas);
        }
        return {
            sourceToken: {
                token: srcToken,
                amount: srcAmount,
            },
            destinationToken: { token: dstToken, amount: dstAmount },
            relayFee: { token: srcToken, amount: fee },
            destinationNativeGas,
        };
    }
    static async isTransferComplete(toChain, receipt) {
        if (!(0, types_1.isAttested)(receipt))
            return false;
        const vaa = (0, sdk_definitions_1.deserialize)("TokenBridge:TransferWithPayload", (0, sdk_definitions_1.serialize)(receipt.attestation.attestation));
        const tb = await toChain.getTokenBridge();
        return tb.isTransferCompleted(vaa);
    }
    // AsyncGenerator fn that produces status updates through an async generator
    // eventually producing a receipt
    // can be called repeatedly so the receipt is updated as it moves through the
    // steps of the transfer
    static async *track(wh, receipt, timeout = config_1.DEFAULT_TASK_TIMEOUT, fromChain, toChain) {
        const start = Date.now();
        const leftover = (start, max) => Math.max(max - (Date.now() - start), 0);
        fromChain = fromChain ?? wh.getChain(receipt.from);
        toChain = toChain ?? wh.getChain(receipt.to);
        // Check the source chain for initiation transaction
        // and capture the message id
        if ((0, types_1.isSourceInitiated)(receipt)) {
            if (receipt.originTxs.length === 0)
                throw "Origin transactions required to fetch message id";
            const { txid } = receipt.originTxs[receipt.originTxs.length - 1];
            const msg = await this.getTransferMessage(fromChain, txid, leftover(start, timeout));
            receipt = {
                ...receipt,
                state: types_1.TransferState.SourceFinalized,
                attestation: { id: msg },
            };
            yield receipt;
        }
        // If the source is finalized, we need to fetch the signed attestation
        // so that we may deliver it to the destination chain
        // or at least track the transfer through its progress
        if ((0, types_1.isSourceFinalized)(receipt)) {
            if (!receipt.attestation.id)
                throw "Attestation id required to fetch attestation";
            const { id } = receipt.attestation;
            const attestation = await this.getTransferVaa(wh, id, leftover(start, timeout));
            receipt = {
                ...receipt,
                attestation: { id, attestation },
                state: types_1.TransferState.Attested,
            };
            yield receipt;
        }
        // First try to grab the tx status from the API
        // Note: this requires a subsequent async step on the backend
        // to have the dest txid populated, so it may be delayed by some time
        if ((0, types_1.isAttested)(receipt) || (0, types_1.isSourceFinalized)(receipt)) {
            if (!receipt.attestation.id)
                throw "Attestation id required to fetch redeem tx";
            const { id } = receipt.attestation;
            const txStatus = await wh.getTransactionStatus(id, leftover(start, timeout));
            if (txStatus && txStatus.globalTx?.destinationTx?.txHash) {
                const { chainId, txHash } = txStatus.globalTx.destinationTx;
                receipt = {
                    ...receipt,
                    destinationTxs: [{ chain: (0, sdk_base_1.toChain)(chainId), txid: txHash }],
                    state: types_1.TransferState.DestinationFinalized,
                };
            }
            yield receipt;
        }
        // Fall back to asking the destination chain if this VAA has been redeemed
        // Note: We do not get any destinationTxs with this method
        if ((0, types_1.isAttested)(receipt)) {
            if (!receipt.attestation.attestation)
                throw (0, types_1.ErrInvalidStateTransition)("Signed Attestation required to check for redeem");
            let isComplete = await this.isTransferComplete(toChain, receipt);
            if (isComplete) {
                receipt = {
                    ...receipt,
                    state: types_1.TransferState.DestinationFinalized,
                };
            }
            yield receipt;
        }
        yield receipt;
    }
    static async destinationOverrides(srcChain, dstChain, transfer) {
        const _transfer = { ...transfer };
        // Bit of (temporary) hackery until solana contracts support being
        // sent a VAA with the primary address
        // Note: Do _not_ override if automatic or if the destination token is native
        // gas token
        if (transfer.to.chain === "Solana" && !_transfer.automatic) {
            const destinationToken = await this.lookupDestinationToken(srcChain, dstChain, _transfer.token);
            // TODO: If the token is native, no need to overwrite the destination address check for native
            //if (!destinationToken.address.equals((await dstChain.getNativeWrappedTokenId()).address))
            _transfer.to = await dstChain.getTokenAccount(_transfer.to.address, destinationToken.address);
        }
        if (_transfer.to.chain === "Sei") {
            if (_transfer.to.chain === "Sei" && _transfer.payload)
                throw new Error("Arbitrary payloads unsupported for Sei");
            // For sei, we reserve the payload for a token transfer through the sei bridge.
            _transfer.payload = sdk_base_1.encoding.bytes.encode(JSON.stringify({
                basic_recipient: {
                    recipient: sdk_base_1.encoding.b64.encode(_transfer.to.address.toString()),
                },
            }));
            _transfer.to = wormhole_1.Wormhole.chainAddress(_transfer.to.chain, dstChain.config.contracts.translator);
        }
        return _transfer;
    }
}
exports.TokenTransferUtils = TokenTransferUtils;
TokenTransferUtils;
//# sourceMappingURL=utils.js.map