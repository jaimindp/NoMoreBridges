"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManualTokenTransfer = void 0;
const sdk_definitions_1 = require("@wormhole-foundation/sdk-definitions");
const common_1 = require("../../common");
const types_1 = require("../../types");
const tokenTransfer_1 = require("./tokenTransfer");
const utils_1 = require("./utils");
class ManualTokenTransfer extends tokenTransfer_1.TokenTransfer {
    getTransferState() {
        return this.receipt.state;
    }
    async initiateTransfer(signer) {
        if (!(0, types_1.isCreated)(this.receipt))
            throw (0, types_1.ErrInvalidStateTransition)("Expected transfer details to be created");
        const originTxs = await ManualTokenTransfer.transfer(this.fromChain, this.transfer, signer);
        const state = types_1.TransferState.SourceInitiated;
        this.receipt = { ...this.receipt, state, originTxs };
        return originTxs.map(({ txid }) => txid);
    }
    async fetchAttestation(timeout) {
        if (!(0, types_1.hasSourceInitiated)(this.receipt))
            throw (0, types_1.ErrInvalidStateTransition)("Expected source to be initiated");
        // We already have it, just return it
        if ((0, types_1.hasAttested)(this.receipt))
            return [this.receipt.attestation.id];
        // We dont have the message id yet, grab it
        if (!(0, types_1.hasSourceFinalized)(this.receipt)) {
            const { originTxs } = this.receipt;
            const txid = originTxs[originTxs.length - 1];
            const msgId = await utils_1.TokenTransferUtils.getTransferMessage(this.fromChain, txid.txid, timeout);
            this.receipt = {
                ...this.receipt,
                state: types_1.TransferState.SourceFinalized,
                attestation: { id: msgId },
            };
        }
        // No signed attestation yet, try to grab it
        if (!(0, types_1.hasAttested)(this.receipt)) {
            const vaa = await utils_1.TokenTransferUtils.getTransferVaa(this.wh, this.receipt.attestation.id, timeout);
            this.receipt = {
                ...this.receipt,
                state: types_1.TransferState.Attested,
                attestation: { id: this.receipt.attestation.id, attestation: vaa },
            };
        }
        return [this.receipt.attestation.id];
    }
    // finish the WormholeTransfer by submitting transactions to the destination chain
    // returns a transaction hash
    async completeTransfer(signer) {
        if (!(0, types_1.isAttested)(this.receipt))
            throw (0, types_1.ErrInvalidStateTransition)("Expected transfer to be attested");
        const { attestation: { attestation: vaa }, } = this.receipt;
        const destinationTxs = await ManualTokenTransfer.redeem(this.toChain, vaa, signer);
        this.receipt = {
            ...this.receipt,
            state: types_1.TransferState.DestinationInitiated,
            destinationTxs,
        };
        return this.receipt.destinationTxs.map(({ txid }) => txid);
    }
    static async transfer(chainCtx, transfer, signer) {
        const senderAddress = (0, sdk_definitions_1.toNative)(signer.chain(), signer.address());
        const tb = await chainCtx.getTokenBridge();
        const xfer = tb.transfer(senderAddress, transfer.to, transfer.token.address, transfer.amount, transfer.payload);
        return (0, common_1.signSendWait)(chainCtx, xfer, signer);
    }
    static async redeem(toChain, vaa, signer) {
        const signerAddress = (0, sdk_definitions_1.toNative)(signer.chain(), signer.address());
        const tb = await toChain.getTokenBridge();
        const xfer = tb.redeem(signerAddress, vaa);
        return (0, common_1.signSendWait)(toChain, xfer, signer);
    }
}
exports.ManualTokenTransfer = ManualTokenTransfer;
//# sourceMappingURL=manual.js.map