import { toNative, } from "@wormhole-foundation/sdk-definitions";
import { signSendWait } from "../../common";
import { ErrInvalidStateTransition, TransferState, hasAttested, hasSourceFinalized, hasSourceInitiated, isAttested, isCreated, } from "../../types";
import { TokenTransfer } from "./tokenTransfer";
import { TokenTransferUtils } from "./utils";
export class ManualTokenTransfer extends TokenTransfer {
    getTransferState() {
        return this.receipt.state;
    }
    async initiateTransfer(signer) {
        if (!isCreated(this.receipt))
            throw ErrInvalidStateTransition("Expected transfer details to be created");
        const originTxs = await ManualTokenTransfer.transfer(this.fromChain, this.transfer, signer);
        const state = TransferState.SourceInitiated;
        this.receipt = { ...this.receipt, state, originTxs };
        return originTxs.map(({ txid }) => txid);
    }
    async fetchAttestation(timeout) {
        if (!hasSourceInitiated(this.receipt))
            throw ErrInvalidStateTransition("Expected source to be initiated");
        // We already have it, just return it
        if (hasAttested(this.receipt))
            return [this.receipt.attestation.id];
        // We dont have the message id yet, grab it
        if (!hasSourceFinalized(this.receipt)) {
            const { originTxs } = this.receipt;
            const txid = originTxs[originTxs.length - 1];
            const msgId = await TokenTransferUtils.getTransferMessage(this.fromChain, txid.txid, timeout);
            this.receipt = {
                ...this.receipt,
                state: TransferState.SourceFinalized,
                attestation: { id: msgId },
            };
        }
        // No signed attestation yet, try to grab it
        if (!hasAttested(this.receipt)) {
            const vaa = await TokenTransferUtils.getTransferVaa(this.wh, this.receipt.attestation.id, timeout);
            this.receipt = {
                ...this.receipt,
                state: TransferState.Attested,
                attestation: { id: this.receipt.attestation.id, attestation: vaa },
            };
        }
        return [this.receipt.attestation.id];
    }
    // finish the WormholeTransfer by submitting transactions to the destination chain
    // returns a transaction hash
    async completeTransfer(signer) {
        if (!isAttested(this.receipt))
            throw ErrInvalidStateTransition("Expected transfer to be attested");
        const { attestation: { attestation: vaa }, } = this.receipt;
        const destinationTxs = await ManualTokenTransfer.redeem(this.toChain, vaa, signer);
        this.receipt = {
            ...this.receipt,
            state: TransferState.DestinationInitiated,
            destinationTxs,
        };
        return this.receipt.destinationTxs.map(({ txid }) => txid);
    }
    static async transfer(chainCtx, transfer, signer) {
        const senderAddress = toNative(signer.chain(), signer.address());
        const tb = await chainCtx.getTokenBridge();
        const xfer = tb.transfer(senderAddress, transfer.to, transfer.token.address, transfer.amount, transfer.payload);
        return signSendWait(chainCtx, xfer, signer);
    }
    static async redeem(toChain, vaa, signer) {
        const signerAddress = toNative(signer.chain(), signer.address());
        const tb = await toChain.getTokenBridge();
        const xfer = tb.redeem(signerAddress, vaa);
        return signSendWait(toChain, xfer, signer);
    }
}
//# sourceMappingURL=manual.js.map