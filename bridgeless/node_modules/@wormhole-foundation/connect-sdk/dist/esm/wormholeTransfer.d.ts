import { Chain, Network, Platform, PlatformToChains, ProtocolName } from "@wormhole-foundation/sdk-base";
import { AttestationId, AttestationReceipt, ChainContext, CircleTransferDetails, GatewayTransferDetails, Signer, TokenId, TokenTransferDetails, TransactionId, TxHash } from "@wormhole-foundation/sdk-definitions";
import { Wormhole } from "./wormhole";
export type TransferRequest<PN extends ProtocolName = ProtocolName> = PN extends "TokenBridge" | "AutomaticTokenBridge" ? TokenTransferDetails : PN extends "CircleBridge" | "AutomaticCircleBridge" ? CircleTransferDetails : PN extends "IbcBridge" ? GatewayTransferDetails : never;
export declare enum TransferState {
    Failed = -1,
    Created = 0,
    SourceInitiated = 1,
    SourceFinalized = 2,
    Attested = 3,
    DestinationInitiated = 4,
    DestinationFinalized = 5
}
interface BaseTransferReceipt<PN extends ProtocolName, SC extends Chain, DC extends Chain> {
    protocol: PN;
    from: SC;
    to: DC;
    request: TransferRequest<PN>;
    state: TransferState;
}
export interface CreatedTransferReceipt<PN extends ProtocolName, SC extends Chain = Chain, DC extends Chain = Chain> extends BaseTransferReceipt<PN, SC, DC> {
    state: TransferState.Created;
}
export interface SourceInitiatedTransferReceipt<PN extends ProtocolName, SC extends Chain = Chain, DC extends Chain = Chain> extends BaseTransferReceipt<PN, SC, DC> {
    state: TransferState.SourceInitiated;
    originTxs: TransactionId<SC>[];
}
export interface SourceFinalizedTransferReceipt<PN extends ProtocolName, SC extends Chain = Chain, DC extends Chain = Chain> extends BaseTransferReceipt<PN, SC, DC> {
    state: TransferState.SourceFinalized;
    originTxs: TransactionId<SC>[];
    attestation: AttestationReceipt<PN>;
}
export interface AttestedTransferReceipt<PN extends ProtocolName, SC extends Chain = Chain, DC extends Chain = Chain> extends BaseTransferReceipt<PN, SC, DC> {
    state: TransferState.Attested;
    originTxs: TransactionId<SC>[];
    attestation: Required<AttestationReceipt<PN>>;
}
export interface CompletedTransferReceipt<PN extends ProtocolName, SC extends Chain = Chain, DC extends Chain = Chain> extends BaseTransferReceipt<PN, SC, DC> {
    state: TransferState.DestinationInitiated | TransferState.DestinationFinalized;
    originTxs: TransactionId<SC>[];
    attestation: AttestationReceipt<PN>;
    destinationTxs?: TransactionId<DC>[];
}
export declare function isAttested<PN extends ProtocolName>(receipt: TransferReceipt<PN, Chain, Chain>): receipt is AttestedTransferReceipt<PN, Chain, Chain>;
export declare function isSourceInitiated<PN extends ProtocolName>(receipt: TransferReceipt<PN, Chain, Chain>): receipt is SourceInitiatedTransferReceipt<PN, Chain, Chain>;
export declare function isSourceFinalized<PN extends ProtocolName>(receipt: TransferReceipt<PN, Chain, Chain>): receipt is SourceFinalizedTransferReceipt<PN, Chain, Chain>;
export type TransferReceipt<PN extends ProtocolName, SC extends Chain = Chain, DC extends Chain = Chain> = CreatedTransferReceipt<PN, SC, DC> | SourceInitiatedTransferReceipt<PN, SC, DC> | SourceFinalizedTransferReceipt<PN, SC, DC> | AttestedTransferReceipt<PN, SC, DC> | CompletedTransferReceipt<PN, SC, DC>;
export type TransferQuote = {
    sourceToken: {
        token: TokenId;
        amount: bigint;
    };
    destinationToken: {
        token: TokenId;
        amount: bigint;
    };
    relayFee?: {
        token: TokenId;
        amount: bigint;
    };
    destinationNativeGas?: bigint;
};
export interface TransferProtocol<PN extends ProtocolName> {
    isTransferComplete<N extends Network, P extends Platform, C extends PlatformToChains<P>>(toChain: ChainContext<N, P, C>, attestation: AttestationId<PN>): Promise<boolean>;
    validateTransferDetails<N extends Network>(wh: Wormhole<N>, transfer: TransferRequest<PN>): Promise<void>;
    quoteTransfer(xfer: WormholeTransfer<PN>): Promise<TransferQuote>;
    getReceipt(xfer: WormholeTransfer<PN>): TransferReceipt<PN>;
    track<N extends Network>(wh: Wormhole<N>, xfer: WormholeTransfer<PN>, timeout: number): AsyncGenerator<TransferReceipt<PN>, unknown, unknown>;
}
export interface WormholeTransfer<PN extends ProtocolName> {
    transfer: TransferRequest<PN>;
    getTransferState(): TransferState;
    initiateTransfer(signer: Signer): Promise<TxHash[]>;
    fetchAttestation(timeout?: number): Promise<AttestationId[]>;
    completeTransfer(signer: Signer): Promise<TxHash[]>;
}
export {};
//# sourceMappingURL=wormholeTransfer.d.ts.map