import { Chain, ChainContext, Network, Signer, TokenId, TransactionId } from "../..";
import { ManualRoute, StaticRouteMethods } from "../route";
import { Quote, Receipt, TransferParams, ValidatedTransferParams, ValidationResult } from "../types";
type Op = {};
type R = Receipt;
type Q = Quote;
export declare class ManualMockRoute<N extends Network> extends ManualRoute<N, Op, R, Q> implements StaticRouteMethods<typeof ManualMockRoute> {
    static meta: {
        name: string;
    };
    static supportedNetworks(): Network[];
    static supportedChains(network: Network): Chain[];
    static supportedSourceTokens(fromChain: ChainContext<Network>): Promise<TokenId[]>;
    static supportedDestinationTokens<N extends Network>(sourceToken: TokenId, fromChain: ChainContext<N>, toChain: ChainContext<N>): Promise<TokenId[]>;
    static isProtocolSupported<N extends Network>(chain: ChainContext<N>): boolean;
    validate(params: TransferParams<Op>): Promise<ValidationResult<Op>>;
    quote(params: ValidatedTransferParams<Op>): Promise<Q>;
    initiate(sender: Signer, params: ValidatedTransferParams<Op>): Promise<R>;
    track(receipt: R, timeout?: number | undefined): AsyncGenerator<R>;
    complete(sender: Signer, receipt: R): Promise<TransactionId[]>;
    getDefaultOptions(): {};
}
export {};
//# sourceMappingURL=manual.d.ts.map