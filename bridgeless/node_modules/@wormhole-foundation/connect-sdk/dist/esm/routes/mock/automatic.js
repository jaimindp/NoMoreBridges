import { TransferState, encoding, nativeTokenId, amount, } from "../..";
import { AutomaticRoute } from "../route";
async function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
export class AutomaticMockRoute extends AutomaticRoute {
    NATIVE_GAS_DROPOFF_SUPPORTED = true;
    static meta = {
        name: "AutomaticFauxBridge",
    };
    static supportedNetworks() {
        return ["Mainnet", "Testnet"];
    }
    static supportedChains(network) {
        return ["Solana", "Ethereum"];
    }
    static async supportedSourceTokens(fromChain) {
        await delay(250);
        return [nativeTokenId(fromChain.chain)];
    }
    static async supportedDestinationTokens(sourceToken, fromChain, toChain) {
        await delay(250);
        return [nativeTokenId(toChain.chain)];
    }
    static isProtocolSupported(chain) {
        return true;
    }
    async isAvailable() {
        return true;
    }
    async validate(params) {
        await delay(250);
        return {
            valid: true,
            params: { ...params, options: this.getDefaultOptions() },
        };
    }
    async quote(params) {
        await delay(1000);
        const fakeQuote = {
            sourceToken: {
                token: this.request.source.id,
                amount: amount.parse(params.amount, this.request.source.decimals),
            },
            destinationToken: {
                token: this.request.destination.id,
                amount: amount.parse(params.amount, this.request.destination.decimals),
            },
            relayFee: {
                token: this.request.source.id,
                amount: amount.parse("0.01", this.request.source.decimals),
            },
        };
        return fakeQuote;
    }
    async initiate(sender, params) {
        await delay(1000);
        const fakeTxId = this.request.from.chain === "Solana"
            ? encoding.b58.encode(new Uint8Array(64))
            : encoding.hex.encode(new Uint8Array(32));
        const fakeReceipt = {
            from: this.request.from.chain,
            to: this.request.to.chain,
            state: TransferState.SourceInitiated,
            originTxs: [{ chain: sender.chain(), txid: fakeTxId }],
        };
        return fakeReceipt;
    }
    async *track(receipt, timeout) {
        await delay(1000);
        const fakeReceipt = {
            ...receipt,
            state: TransferState.DestinationInitiated,
            attestation: {
                id: {},
            },
        };
        yield fakeReceipt;
    }
    getDefaultOptions() {
        return {};
    }
}
//# sourceMappingURL=automatic.js.map