import { Chain, Network, amount } from "@wormhole-foundation/sdk-base";
import { ChainContext, Signer, TokenId } from "@wormhole-foundation/sdk-definitions";
import { AttestationReceipt } from "../../types";
import { AutomaticRoute, StaticRouteMethods } from "../route";
import { Quote, QuoteResult, Receipt, TransferParams, ValidatedTransferParams, ValidationResult } from "../types";
export declare namespace AutomaticTokenBridgeRoute {
    type Options = {
        nativeGas: number;
    };
    type NormalizedParams = {
        fee: amount.Amount;
        amount: amount.Amount;
        nativeGasAmount: amount.Amount;
    };
    interface ValidatedParams extends ValidatedTransferParams<Options> {
        normalizedParams: NormalizedParams;
    }
}
type Op = AutomaticTokenBridgeRoute.Options;
type Vp = AutomaticTokenBridgeRoute.ValidatedParams;
type Tp = TransferParams<Op>;
type Vr = ValidationResult<Op>;
type R = Receipt<AttestationReceipt<"AutomaticTokenBridge">>;
type QR = QuoteResult<Op, Vp>;
type Q = Quote<Op, Vp>;
export declare class AutomaticTokenBridgeRoute<N extends Network> extends AutomaticRoute<N, Op, Vp, R> implements StaticRouteMethods<typeof AutomaticTokenBridgeRoute> {
    NATIVE_GAS_DROPOFF_SUPPORTED: boolean;
    static meta: {
        name: string;
    };
    static supportedNetworks(): Network[];
    static supportedChains(network: Network): Chain[];
    static supportedSourceTokens(fromChain: ChainContext<Network>): Promise<TokenId[]>;
    static supportedDestinationTokens<N extends Network>(sourceToken: TokenId, fromChain: ChainContext<N>, toChain: ChainContext<N>): Promise<TokenId[]>;
    static isProtocolSupported<N extends Network>(chain: ChainContext<N>): boolean;
    getDefaultOptions(): Op;
    isAvailable(): Promise<boolean>;
    validate(params: Tp): Promise<Vr>;
    private normalizeTransferParams;
    quote(params: Vp): Promise<QR>;
    initiate(signer: Signer, quote: Q): Promise<R>;
    track(receipt: R, timeout?: number): AsyncGenerator<import("../../protocols/tokenTransfer").TokenTransferReceipt<"Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Acala" | "Arbitrum" | "Aurora" | "Avalanche" | "Base" | "Bsc" | "Celo" | "Ethereum" | "Fantom" | "Gnosis" | "Karura" | "Klaytn" | "Moonbeam" | "Neon" | "Oasis" | "Optimism" | "Polygon" | "Rootstock" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "Pythnet" | "Cosmoshub" | "Evmos" | "Injective" | "Kujira" | "Osmosis" | "Sei" | "Terra" | "Terra2" | "Wormchain" | "Xpla" | "Dymension" | "Neutron" | "Stargaze" | "Celestia", "Solana" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near" | "Acala" | "Arbitrum" | "Aurora" | "Avalanche" | "Base" | "Bsc" | "Celo" | "Ethereum" | "Fantom" | "Gnosis" | "Karura" | "Klaytn" | "Moonbeam" | "Neon" | "Oasis" | "Optimism" | "Polygon" | "Rootstock" | "Sepolia" | "ArbitrumSepolia" | "BaseSepolia" | "OptimismSepolia" | "Holesky" | "Pythnet" | "Cosmoshub" | "Evmos" | "Injective" | "Kujira" | "Osmosis" | "Sei" | "Terra" | "Terra2" | "Wormchain" | "Xpla" | "Dymension" | "Neutron" | "Stargaze" | "Celestia">, void, unknown>;
    private toTransferDetails;
}
export {};
//# sourceMappingURL=automatic.d.ts.map