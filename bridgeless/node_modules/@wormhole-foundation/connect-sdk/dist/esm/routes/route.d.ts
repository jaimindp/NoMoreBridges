import { Chain, Network } from "@wormhole-foundation/sdk-base";
import { ChainContext, Signer, TokenId, TransactionId } from "@wormhole-foundation/sdk-definitions";
import { Wormhole } from "../wormhole";
import { RouteTransferRequest } from "./request";
import { Options, Quote, QuoteResult, Receipt, TransferParams, ValidatedTransferParams, ValidationResult } from "./types";
export declare abstract class Route<N extends Network, OP extends Options = Options, VP extends ValidatedTransferParams<OP> = ValidatedTransferParams<OP>, R extends Receipt = Receipt> {
    wh: Wormhole<N>;
    request: RouteTransferRequest<N>;
    abstract readonly NATIVE_GAS_DROPOFF_SUPPORTED: boolean;
    abstract readonly IS_AUTOMATIC: boolean;
    constructor(wh: Wormhole<N>, request: RouteTransferRequest<N>);
    abstract validate(params: TransferParams<OP>): Promise<ValidationResult<OP>>;
    abstract quote(params: ValidatedTransferParams<OP>): Promise<QuoteResult<OP, VP>>;
    abstract initiate(sender: Signer, quote: Quote<OP, VP>): Promise<R>;
    abstract track(receipt: R, timeout?: number): AsyncGenerator<R>;
    transferUrl(txid: string): string;
    abstract getDefaultOptions(): OP;
}
export interface RouteMeta {
    name: string;
    logo?: string;
    support?: string;
    source?: string;
}
export interface RouteConstructor {
    new <N extends Network>(wh: Wormhole<N>, request: RouteTransferRequest<N>): Route<N>;
    readonly meta: RouteMeta;
    supportedNetworks(): Network[];
    supportedChains(network: Network): Chain[];
    isProtocolSupported<N extends Network>(chain: ChainContext<N>): boolean;
    supportedSourceTokens(fromChain: ChainContext<Network>): Promise<TokenId[]>;
    supportedDestinationTokens<N extends Network>(token: TokenId, fromChain: ChainContext<N>, toChain: ChainContext<N>): Promise<TokenId[]>;
}
export type StaticRouteMethods<I extends RouteConstructor> = InstanceType<I>;
export declare abstract class AutomaticRoute<N extends Network, OP extends Options = Options, VP extends ValidatedTransferParams<OP> = ValidatedTransferParams<OP>, R extends Receipt = Receipt> extends Route<N, OP, VP, R> {
    IS_AUTOMATIC: boolean;
    abstract isAvailable(): Promise<boolean>;
}
export declare function isAutomatic<N extends Network>(route: Route<N>): route is AutomaticRoute<N>;
export declare abstract class ManualRoute<N extends Network, OP extends Options = Options, VP extends ValidatedTransferParams<OP> = ValidatedTransferParams<OP>, R extends Receipt = Receipt> extends Route<N, OP, VP, R> {
    NATIVE_GAS_DROPOFF_SUPPORTED: boolean;
    IS_AUTOMATIC: boolean;
    abstract complete(sender: Signer, receipt: R): Promise<TransactionId[]>;
}
export declare function isManual<N extends Network>(route: Route<N>): route is ManualRoute<N>;
//# sourceMappingURL=route.d.ts.map