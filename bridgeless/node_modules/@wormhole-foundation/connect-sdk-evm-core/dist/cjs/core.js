"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmWormholeCore = void 0;
const connect_sdk_1 = require("@wormhole-foundation/connect-sdk");
const _1 = require(".");
const connect_sdk_evm_1 = require("@wormhole-foundation/connect-sdk-evm");
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
class EvmWormholeCore {
    network;
    chain;
    provider;
    contracts;
    chainId;
    coreAddress;
    core;
    coreIface;
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        this.chainId = sdk_base_1.nativeChainIds.networkChainToNativeChainId.get(network, chain);
        this.coreIface = _1.ethers_contracts.Implementation__factory.createInterface();
        const address = this.contracts.coreBridge;
        if (!address)
            throw new Error('Core bridge address not found');
        this.coreAddress = address;
        this.core = _1.ethers_contracts.Implementation__factory.connect(address, provider);
    }
    async getMessageFee() {
        return await this.core.messageFee.staticCall();
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await connect_sdk_evm_1.EvmPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        return new EvmWormholeCore(network, chain, provider, conf.contracts);
    }
    async *publishMessage(sender, message, nonce, consistencyLevel) {
        const senderAddr = new connect_sdk_evm_1.EvmAddress(sender).toString();
        const txReq = await this.core.publishMessage.populateTransaction(nonce, message, consistencyLevel);
        yield this.createUnsignedTx((0, connect_sdk_evm_1.addFrom)(txReq, senderAddr), 'WormholeCore.publishMessage');
    }
    async *verifyMessage(sender, vaa) {
        throw new Error('Not implemented.');
    }
    async parseTransaction(txid) {
        const receipt = await this.provider.getTransactionReceipt(txid);
        if (receipt === null)
            return [];
        return receipt.logs
            .filter((l) => {
            return l.address === this.coreAddress;
        })
            .map((log) => {
            const { topics, data } = log;
            const parsed = this.coreIface.parseLog({
                topics: topics.slice(),
                data,
            });
            if (parsed === null)
                return undefined;
            const emitterAddress = new connect_sdk_evm_1.EvmAddress(parsed.args['sender']);
            return {
                chain: this.chain,
                emitter: emitterAddress.toUniversalAddress(),
                sequence: parsed.args['sequence'],
            };
        })
            .filter(connect_sdk_1.isWormholeMessageId);
    }
    createUnsignedTx(txReq, description, parallelizable = false) {
        return new connect_sdk_evm_1.EvmUnsignedTransaction((0, connect_sdk_evm_1.addChainId)(txReq, this.chainId), this.network, this.chain, description, parallelizable);
    }
}
exports.EvmWormholeCore = EvmWormholeCore;
//# sourceMappingURL=core.js.map