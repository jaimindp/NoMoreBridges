import { isWormholeMessageId, } from '@wormhole-foundation/connect-sdk';
import { ethers_contracts } from '.';
import { EvmAddress, EvmPlatform, EvmUnsignedTransaction, addChainId, addFrom, } from '@wormhole-foundation/connect-sdk-evm';
import { nativeChainIds, } from '@wormhole-foundation/sdk-base';
export class EvmWormholeCore {
    network;
    chain;
    provider;
    contracts;
    chainId;
    coreAddress;
    core;
    coreIface;
    constructor(network, chain, provider, contracts) {
        this.network = network;
        this.chain = chain;
        this.provider = provider;
        this.contracts = contracts;
        this.chainId = nativeChainIds.networkChainToNativeChainId.get(network, chain);
        this.coreIface = ethers_contracts.Implementation__factory.createInterface();
        const address = this.contracts.coreBridge;
        if (!address)
            throw new Error('Core bridge address not found');
        this.coreAddress = address;
        this.core = ethers_contracts.Implementation__factory.connect(address, provider);
    }
    static async fromRpc(provider, config) {
        const [network, chain] = await EvmPlatform.chainFromRpc(provider);
        const conf = config[chain];
        if (conf.network !== network)
            throw new Error(`Network mismatch: ${conf.network} != ${network}`);
        return new EvmWormholeCore(network, chain, provider, conf.contracts);
    }
    async *publishMessage(sender, message, nonce, consistencyLevel) {
        const senderAddr = new EvmAddress(sender).toString();
        const txReq = await this.core.publishMessage.populateTransaction(nonce, message, consistencyLevel);
        yield this.createUnsignedTx(addFrom(txReq, senderAddr), 'WormholeCore.publishMessage');
    }
    async *verifyMessage(sender, vaa) {
        throw new Error('Not implemented.');
    }
    async parseTransaction(txid) {
        const receipt = await this.provider.getTransactionReceipt(txid);
        if (receipt === null)
            return [];
        return receipt.logs
            .filter((l) => {
            return l.address === this.coreAddress;
        })
            .map((log) => {
            const { topics, data } = log;
            const parsed = this.coreIface.parseLog({
                topics: topics.slice(),
                data,
            });
            if (parsed === null)
                return undefined;
            const emitterAddress = new EvmAddress(parsed.args['sender']);
            return {
                chain: this.chain,
                emitter: emitterAddress.toUniversalAddress(),
                sequence: parsed.args['sequence'],
            };
        })
            .filter(isWormholeMessageId);
    }
    createUnsignedTx(txReq, description, parallelizable = false) {
        return new EvmUnsignedTransaction(addChainId(txReq, this.chainId), this.network, this.chain, description, parallelizable);
    }
}
//# sourceMappingURL=wormholeCore.js.map