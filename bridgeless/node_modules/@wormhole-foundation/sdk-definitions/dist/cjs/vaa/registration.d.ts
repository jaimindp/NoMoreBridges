import { Layout } from "@wormhole-foundation/sdk-base";
declare global {
    namespace Wormhole {
        interface PayloadLiteralToLayoutMapping {
        }
    }
}
export type LayoutLiteral = keyof Wormhole.PayloadLiteralToLayoutMapping & string;
export type PayloadLiteral = LayoutLiteral | "Uint8Array";
export type LayoutOf<LL extends LayoutLiteral> = LL extends infer V extends LayoutLiteral ? Wormhole.PayloadLiteralToLayoutMapping[V] : never;
export type ProtocolName = string | null;
type ToLiteralFormat<PN extends ProtocolName, PayloadName extends string> = PN extends null ? PayloadName : `${PN}:${PayloadName}`;
export type ComposeLiteral<ProtocolN extends ProtocolName, PayloadN extends string, Literal> = ToLiteralFormat<ProtocolN, PayloadN> extends infer L extends Literal ? L : never;
export declare const composeLiteral: <ProtocolN extends ProtocolName, PayloadN extends string>(protocol: ProtocolN, payloadName: PayloadN) => ComposeLiteral<ProtocolN, PayloadN, PayloadLiteral>;
export declare const payloadFactory: Map<LayoutLiteral, Layout>;
export declare function registerPayloadType(protocol: ProtocolName, name: string, layout: Layout): void;
type AtLeast1<T> = readonly [T, ...T[]];
export type NamedPayloads = AtLeast1<readonly [string, Layout]>;
export type RegisterPayloadTypes<ProtocolN extends ProtocolName, NP extends NamedPayloads> = {
    readonly [E in NP[number] as ToLiteralFormat<ProtocolN, E[0]>]: E[1];
};
export declare function registerPayloadTypes(protocol: ProtocolName, payloads: NamedPayloads): void;
export {};
//# sourceMappingURL=registration.d.ts.map