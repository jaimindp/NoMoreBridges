"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blindDeserializePayload = exports.deserializePayload = exports.deserialize = exports.payloadDiscriminator = exports.serializePayload = exports.serialize = exports.payloadLiteralToPayloadItemLayout = exports.getPayloadLayout = void 0;
const sdk_base_1 = require("@wormhole-foundation/sdk-base");
const registration_1 = require("./registration");
const vaa_1 = require("./vaa");
const utils_1 = require("../utils");
function getPayloadLayout(layoutLiteral) {
    const layout = registration_1.payloadFactory.get(layoutLiteral);
    if (!layout)
        throw new Error(`No layout registered for payload type ${layoutLiteral}`);
    return layout;
}
exports.getPayloadLayout = getPayloadLayout;
function payloadLiteralToPayloadItemLayout(payloadLiteral) {
    return {
        name: "payload",
        binary: "bytes",
        ...(payloadLiteral === "Uint8Array" ? {} : { layout: getPayloadLayout(payloadLiteral) })
    };
}
exports.payloadLiteralToPayloadItemLayout = payloadLiteralToPayloadItemLayout;
function serialize(vaa) {
    const layout = [
        ...vaa_1.baseLayout,
        payloadLiteralToPayloadItemLayout(vaa.payloadLiteral),
    ];
    return (0, sdk_base_1.serializeLayout)(layout, vaa);
}
exports.serialize = serialize;
function serializePayload(payloadLiteral, payload) {
    if (payloadLiteral === "Uint8Array")
        return payload;
    const layout = getPayloadLayout(payloadLiteral);
    return (0, sdk_base_1.serializeLayout)(layout, payload);
}
exports.serializePayload = serializePayload;
function payloadDiscriminator(payloadLiterals, allowAmbiguous) {
    const literals = (() => {
        if (Array.isArray(payloadLiterals[0]))
            return payloadLiterals.flatMap(([protocol, payloadNames]) => payloadNames.map((name) => (0, registration_1.composeLiteral)(protocol, name)));
        if (typeof payloadLiterals[1] === "string")
            return payloadLiterals;
        const [protocol, payloadNames] = payloadLiterals;
        return payloadNames.map((name) => (0, registration_1.composeLiteral)(protocol, name));
    })();
    const discriminator = (0, sdk_base_1.layoutDiscriminator)(literals.map((literal) => getPayloadLayout(literal)), !!allowAmbiguous);
    return ((data) => {
        if (typeof data === "string")
            data = sdk_base_1.encoding.hex.decode(data);
        const cands = discriminator(data);
        return Array.isArray(cands)
            ? cands.map((c) => literals[c])
            : cands !== null
                ? literals[cands]
                : null;
    });
}
exports.payloadDiscriminator = payloadDiscriminator;
function deserialize(payloadDet, data) {
    if (typeof data === "string")
        data = sdk_base_1.encoding.hex.decode(data);
    const [header, envelopeOffset] = (0, sdk_base_1.deserializeLayout)(vaa_1.headerLayout, data, { consumeAll: false });
    //ensure that guardian signature indicies are unique and in ascending order - see:
    //https://github.com/wormhole-foundation/wormhole/blob/8e0cf4c31f39b5ba06b0f6cdb6e690d3adf3d6a3/ethereum/contracts/Messages.sol#L121
    for (let i = 1; i < header.signatures.length; ++i)
        if (header.signatures[i].guardianIndex <= header.signatures[i - 1].guardianIndex)
            throw new Error("Guardian signatures must be in ascending order of guardian set index");
    const [envelope, payloadOffset] = (0, sdk_base_1.deserializeLayout)(vaa_1.envelopeLayout, data, { offset: envelopeOffset, consumeAll: false });
    const [payloadLiteral, payload] = typeof payloadDet === "string"
        ? [
            payloadDet,
            deserializePayload(payloadDet, data, payloadOffset),
        ]
        : deserializePayload(payloadDet, data, payloadOffset);
    const [protocolName, payloadName] = (0, vaa_1.decomposeLiteral)(payloadLiteral);
    const hash = (0, utils_1.keccak256)(data.slice(envelopeOffset));
    return {
        protocolName,
        payloadName,
        payloadLiteral,
        ...header,
        ...envelope,
        payload,
        hash,
    };
}
exports.deserialize = deserialize;
function deserializePayload(payloadDet, data, offset = 0) {
    return (() => {
        if (typeof data === "string")
            data = sdk_base_1.encoding.hex.decode(data);
        if (payloadDet === "Uint8Array")
            return data.slice(offset);
        if (typeof payloadDet === "string")
            return (0, sdk_base_1.deserializeLayout)(getPayloadLayout(payloadDet), data, { offset });
        //kinda unfortunate that we have to slice here, future improvement would be passing an optional
        //  offset to the discriminator
        const candidate = payloadDet(data.slice(offset));
        if (candidate === null)
            throw new Error(`Encoded data does not match any of the given payload types - ${data}`);
        return [candidate, (0, sdk_base_1.deserializeLayout)(getPayloadLayout(candidate), data, { offset })];
    })();
}
exports.deserializePayload = deserializePayload;
exports.blindDeserializePayload = (() => {
    const rebuildDiscrimininator = () => {
        const layoutLiterals = Array.from(registration_1.payloadFactory.keys());
        const layouts = layoutLiterals.map((l) => registration_1.payloadFactory.get(l));
        return [layoutLiterals, (0, sdk_base_1.layoutDiscriminator)(layouts, true)];
    };
    let layoutLiterals = [];
    let discriminator = (_) => [];
    return (data) => {
        if (registration_1.payloadFactory.size !== layoutLiterals.length)
            [layoutLiterals, discriminator] = rebuildDiscrimininator();
        if (typeof data === "string")
            data = sdk_base_1.encoding.hex.decode(data);
        const candidates = discriminator(data).map((c) => layoutLiterals[c]);
        return candidates.reduce((acc, literal) => {
            try {
                acc.push([literal, deserializePayload(literal, data)]);
            }
            catch { }
            return acc;
        }, []);
    };
})();
//# sourceMappingURL=functions.js.map