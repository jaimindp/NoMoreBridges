import { Chain, ChainToPlatform, Network, Platform, tokens } from "@wormhole-foundation/sdk-base";
import { ChainAddress, UniversalOrNative } from "./address";
import { WormholeMessageId } from "./attestation";
import { PlatformContext } from "./platform";
import { ProtocolName } from "./protocol";
import { AutomaticCircleBridge, CircleBridge } from "./protocols/circleBridge";
import { WormholeCore } from "./protocols/core";
import { IbcBridge } from "./protocols/ibc";
import { PorticoBridge } from "./protocols/portico";
import { AutomaticTokenBridge, TokenBridge } from "./protocols/tokenBridge";
import { RpcConnection } from "./rpc";
import { ChainConfig, SignedTx, TokenAddress, TokenId } from "./types";
/**
 * A ChainContext provides a consistent interface for interacting with a chain.
 * It holds the configuration for the chain and cached RPC and protocol clients.
 *
 */
export declare abstract class ChainContext<N extends Network, C extends Chain = Chain, P extends Platform = ChainToPlatform<C>> {
    readonly network: N;
    readonly chain: C;
    readonly config: ChainConfig<N, C>;
    readonly platform: PlatformContext<N, P>;
    protected rpc?: RpcConnection<P>;
    protected coreBridge?: WormholeCore<N, C>;
    protected tokenBridge?: TokenBridge<N, C>;
    protected autoTokenBridge?: AutomaticTokenBridge<N, C>;
    protected circleBridge?: CircleBridge<N, C>;
    protected autoCircleBridge?: AutomaticCircleBridge<N, C>;
    protected ibcBridge?: IbcBridge<N, C>;
    protected porticoBridge?: PorticoBridge<N, C>;
    constructor(chain: C, platform: PlatformContext<N, P>, rpc?: RpcConnection<P>);
    /**
     * Get an RPC connection for this chain, uses the configuration passed in
     * the initial constructor
     *
     * @returns the RPC connection for this chain
     */
    getRpc(): Promise<RpcConnection<P>>;
    /**
     *  Get the number of decimals for a token
     *
     *  @param token the token to get the decimals for
     *  @returns the number of decimals for the token
     */
    getDecimals(token: TokenAddress<C>): Promise<number>;
    /**
     * Get the balance of a token for a given address
     *
     * @param walletAddr the address to get the balance for
     * @param token the token to get the balance for
     * @returns the balance of the token for the address
     *
     */
    getBalance(walletAddr: string, token: TokenAddress<C>): Promise<bigint | null>;
    /**
     * Get the latest block number seen by the chain according to the RPC
     *
     * @returns the latest block number
     */
    getLatestBlock(): Promise<number>;
    /**
     * Get the latest _finalized_ block number seen by the chain according to the RPC
     *
     * @returns the latest finalized block number
     */
    getLatestFinalizedBlock(): Promise<number>;
    /**
     * Parse the Wormhole Core messages from a transaction
     *
     * @param txid the transaction to parse
     * @returns the Wormhole Core messages emitted by the transaction
     */
    parseTransaction(txid: string): Promise<WormholeMessageId[]>;
    /**
     *  Send a transaction and wait for it to be confirmed
     *
     * @param stxns the signed transaction to send
     * @returns the transaction hashes of the sent transactions
     */
    sendWait(stxns: SignedTx[]): Promise<string[]>;
    /**
     * Get the token data from the local cache if available
     * @param symbol the symbol of the token to get
     * @returns the token data if available
     */
    getToken(symbol: tokens.TokenSymbol): tokens.Token | undefined;
    /**
     * Get the token id of the wrapped token for the native gas token
     *
     * @returns the wrapped token for the native gas token
     */
    getNativeWrappedTokenId(): Promise<TokenId<C>>;
    /**
     * Get the token account for a given address and token
     *
     * @remarks
     * This is really only useful in the context of Solana but in order
     * to provide a consistent interface, we provide it here.
     *
     * @param address the address to get the token account for
     * @param token the token to get the token account for
     * @returns the token account for the address and token
     */
    getTokenAccount(address: UniversalOrNative<C>, token: TokenAddress<C>): Promise<ChainAddress<C>>;
    /**
     * Check to see if a given protocol is supported by this chain
     * by checking if it is registered in the platform and the configuration
     * is available and correct
     *
     * @param protocolName the name of the Protocol to check for support
     * @returns a boolean indicating if this protocol is supported
     */
    supportsProtocol(protocolName: ProtocolName): boolean;
    /**
     * Check to see if the Wormhole Core protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Wormhole Core protocol
     */
    supportsWormholeCore: () => boolean;
    /**
     * Get the Wormhole Core protocol client for this chain
     * @returns the Wormhole Core protocol client for this chain
     */
    getWormholeCore(): Promise<WormholeCore<N, C>>;
    /**
     * Check to see if the Token Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Token Bridge protocol
     */
    supportsTokenBridge: () => boolean;
    /**
     * Get the Token Bridge protocol client for this chain
     * @returns the Token Bridge protocol client for this chain
     */
    getTokenBridge(): Promise<TokenBridge<N, C>>;
    /**
     * Check to see if the Automatic Token Bridge protocol is supported by this chain
     * @returns  a boolean indicating if this chain supports the Automatic Token Bridge protocol
     */
    supportsAutomaticTokenBridge: () => boolean;
    /**
     * Get the Automatic Token Bridge protocol client for this chain
     * @returns the Automatic Token Bridge protocol client for this chain
     */
    getAutomaticTokenBridge(): Promise<AutomaticTokenBridge<N, C>>;
    /**
     * Check to see if the Circle Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Circle Bridge protocol
     */
    supportsCircleBridge: () => boolean;
    /**
     * Get the Circle Bridge protocol client for this chain
     * @returns the Circle Bridge protocol client for this chain
     */
    getCircleBridge(): Promise<CircleBridge<N, C>>;
    /**
     * Check to see if the Automatic Circle Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Automatic Circle Bridge protocol
     */
    supportsAutomaticCircleBridge: () => boolean;
    /**
     * Get the Automatic Circle Bridge protocol client for this chain
     * @returns the Automatic Circle Bridge protocol client for this chain
     */
    getAutomaticCircleBridge(): Promise<AutomaticCircleBridge<N, C>>;
    /**
     * Check to see if the IBC Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the IBC Bridge protocol
     */
    supportsIbcBridge: () => boolean;
    /**
     * Get the IBC Bridge protocol client for this chain
     * @returns the IBC Bridge protocol client for this chain
     */
    getIbcBridge(): Promise<IbcBridge<N, C>>;
    /**
     * Check to see if the Portico Bridge protocol is supported by this chain
     * @returns a boolean indicating if this chain supports the Portico Bridge protocol
     */
    supportsPorticoBridge: () => boolean;
    /**
     * Get the Portico Bridge protocol client for this chain
     * @returns the Portico Bridge protocol client for this chain
     */
    getPorticoBridge(): Promise<PorticoBridge<N, C>>;
}
//# sourceMappingURL=chain.d.ts.map