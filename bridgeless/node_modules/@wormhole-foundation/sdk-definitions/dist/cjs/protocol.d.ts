import { Chain, Network, Platform } from "@wormhole-foundation/sdk-base";
import { RpcConnection } from "./rpc";
import { ChainsConfig } from "./types";
declare global {
    namespace Wormhole {
        interface ProtocolToPlatformMapping {
        }
    }
}
/** A string type representing the name of a protocol */
export type ProtocolName = keyof Wormhole.ProtocolToPlatformMapping;
type MappedProtocolPlatforms = keyof Wormhole.ProtocolToPlatformMapping[ProtocolName];
export type EmptyPlatformMap<P extends Platform, PN extends ProtocolName> = Map<P, ProtocolInitializer<P, PN>>;
export type ProtocolImplementation<T extends Platform, PN extends ProtocolName> = PN extends ProtocolName ? T extends MappedProtocolPlatforms ? Wormhole.ProtocolToPlatformMapping[PN][T] : any : never;
export interface ProtocolInitializer<P extends Platform, PN extends ProtocolName> {
    fromRpc(rpc: RpcConnection<P>, config: ChainsConfig<Network, P>): Promise<ProtocolImplementation<P, PN>>;
}
export type ProtocolFactoryMap<PN extends ProtocolName = ProtocolName, P extends Platform = Platform> = Map<PN, Map<P, ProtocolInitializer<P, PN>>>;
export declare function registerProtocol<P extends Platform, PN extends ProtocolName>(platform: P, protocol: PN, ctr: ProtocolInitializer<P, PN>): void;
export declare function protocolIsRegistered<T extends Platform | Chain, PN extends ProtocolName>(chainOrPlatform: T, protocol: PN): boolean;
export declare function getProtocolInitializer<P extends Platform, PN extends ProtocolName>(platform: P, protocol: PN): ProtocolInitializer<P, PN>;
export declare const create: <N extends "Mainnet" | "Testnet" | "Devnet", P extends "Evm" | "Solana" | "Cosmwasm" | "Btc" | "Algorand" | "Sui" | "Aptos" | "Near", PN extends keyof Wormhole.ProtocolToPlatformMapping, T>(platform: P, protocol: PN, rpc: any, config: ChainsConfig<N, P>) => Promise<T>;
export {};
//# sourceMappingURL=protocol.d.ts.map