import { encoding, layoutDiscriminator, serializeLayout, deserializeLayout, } from "@wormhole-foundation/sdk-base";
import { composeLiteral, payloadFactory, } from "./registration";
import { decomposeLiteral, headerLayout, envelopeLayout, baseLayout, } from "./vaa";
import { keccak256 } from "../utils";
export function getPayloadLayout(layoutLiteral) {
    const layout = payloadFactory.get(layoutLiteral);
    if (!layout)
        throw new Error(`No layout registered for payload type ${layoutLiteral}`);
    return layout;
}
export function payloadLiteralToPayloadItemLayout(payloadLiteral) {
    return {
        name: "payload",
        binary: "bytes",
        ...(payloadLiteral === "Uint8Array" ? {} : { layout: getPayloadLayout(payloadLiteral) })
    };
}
export function serialize(vaa) {
    const layout = [
        ...baseLayout,
        payloadLiteralToPayloadItemLayout(vaa.payloadLiteral),
    ];
    return serializeLayout(layout, vaa);
}
export function serializePayload(payloadLiteral, payload) {
    if (payloadLiteral === "Uint8Array")
        return payload;
    const layout = getPayloadLayout(payloadLiteral);
    return serializeLayout(layout, payload);
}
export function payloadDiscriminator(payloadLiterals, allowAmbiguous) {
    const literals = (() => {
        if (Array.isArray(payloadLiterals[0]))
            return payloadLiterals.flatMap(([protocol, payloadNames]) => payloadNames.map((name) => composeLiteral(protocol, name)));
        if (typeof payloadLiterals[1] === "string")
            return payloadLiterals;
        const [protocol, payloadNames] = payloadLiterals;
        return payloadNames.map((name) => composeLiteral(protocol, name));
    })();
    const discriminator = layoutDiscriminator(literals.map((literal) => getPayloadLayout(literal)), !!allowAmbiguous);
    return ((data) => {
        if (typeof data === "string")
            data = encoding.hex.decode(data);
        const cands = discriminator(data);
        return Array.isArray(cands)
            ? cands.map((c) => literals[c])
            : cands !== null
                ? literals[cands]
                : null;
    });
}
export function deserialize(payloadDet, data) {
    if (typeof data === "string")
        data = encoding.hex.decode(data);
    const [header, envelopeOffset] = deserializeLayout(headerLayout, data, { consumeAll: false });
    //ensure that guardian signature indicies are unique and in ascending order - see:
    //https://github.com/wormhole-foundation/wormhole/blob/8e0cf4c31f39b5ba06b0f6cdb6e690d3adf3d6a3/ethereum/contracts/Messages.sol#L121
    for (let i = 1; i < header.signatures.length; ++i)
        if (header.signatures[i].guardianIndex <= header.signatures[i - 1].guardianIndex)
            throw new Error("Guardian signatures must be in ascending order of guardian set index");
    const [envelope, payloadOffset] = deserializeLayout(envelopeLayout, data, { offset: envelopeOffset, consumeAll: false });
    const [payloadLiteral, payload] = typeof payloadDet === "string"
        ? [
            payloadDet,
            deserializePayload(payloadDet, data, payloadOffset),
        ]
        : deserializePayload(payloadDet, data, payloadOffset);
    const [protocolName, payloadName] = decomposeLiteral(payloadLiteral);
    const hash = keccak256(data.slice(envelopeOffset));
    return {
        protocolName,
        payloadName,
        payloadLiteral,
        ...header,
        ...envelope,
        payload,
        hash,
    };
}
export function deserializePayload(payloadDet, data, offset = 0) {
    return (() => {
        if (typeof data === "string")
            data = encoding.hex.decode(data);
        if (payloadDet === "Uint8Array")
            return data.slice(offset);
        if (typeof payloadDet === "string")
            return deserializeLayout(getPayloadLayout(payloadDet), data, { offset });
        //kinda unfortunate that we have to slice here, future improvement would be passing an optional
        //  offset to the discriminator
        const candidate = payloadDet(data.slice(offset));
        if (candidate === null)
            throw new Error(`Encoded data does not match any of the given payload types - ${data}`);
        return [candidate, deserializeLayout(getPayloadLayout(candidate), data, { offset })];
    })();
}
export const blindDeserializePayload = (() => {
    const rebuildDiscrimininator = () => {
        const layoutLiterals = Array.from(payloadFactory.keys());
        const layouts = layoutLiterals.map((l) => payloadFactory.get(l));
        return [layoutLiterals, layoutDiscriminator(layouts, true)];
    };
    let layoutLiterals = [];
    let discriminator = (_) => [];
    return (data) => {
        if (payloadFactory.size !== layoutLiterals.length)
            [layoutLiterals, discriminator] = rebuildDiscrimininator();
        if (typeof data === "string")
            data = encoding.hex.decode(data);
        const candidates = discriminator(data).map((c) => layoutLiterals[c]);
        return candidates.reduce((acc, literal) => {
            try {
                acc.push([literal, deserializePayload(literal, data)]);
            }
            catch { }
            return acc;
        }, []);
    };
})();
//# sourceMappingURL=functions.js.map