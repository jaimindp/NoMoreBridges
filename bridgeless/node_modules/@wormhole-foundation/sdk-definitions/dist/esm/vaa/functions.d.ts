import { LayoutLiteral, PayloadLiteral, LayoutOf, ProtocolName, ComposeLiteral } from "./registration";
import { VAA, DistributiveVAA, Payload, LayoutLiteralToPayload } from "./vaa";
export declare function getPayloadLayout<LL extends LayoutLiteral>(layoutLiteral: LL): LayoutOf<LL>;
export type PayloadLiteralToPayloadItemLayout<PL extends PayloadLiteral> = PL extends infer V ? V extends LayoutLiteral ? {
    name: "payload";
    binary: "bytes";
    layout: LayoutOf<V>;
} : V extends "Uint8Array" ? {
    name: "payload";
    binary: "bytes";
} : never : never;
export declare function payloadLiteralToPayloadItemLayout<PL extends PayloadLiteral>(payloadLiteral: PL): PayloadLiteralToPayloadItemLayout<PL>;
export declare function serialize<PL extends PayloadLiteral>(vaa: VAA<PL>): Uint8Array;
export declare function serializePayload<PL extends PayloadLiteral>(payloadLiteral: PL, payload: Payload<PL>): Uint8Array;
type AtLeast1<T> = readonly [T, ...T[]];
type AtLeast2<T> = readonly [T, T, ...T[]];
type Byteish = Uint8Array | string;
export type PayloadDiscriminator<LL extends LayoutLiteral = LayoutLiteral, AllowAmbiguous extends boolean = false> = (data: Byteish) => AllowAmbiguous extends false ? LL | null : readonly LL[];
type PayloadGroup = readonly [ProtocolName, AtLeast1<string>];
type PayloadGroupToLayoutLiterals<PG extends PayloadGroup> = ComposeLiteral<PG[0], PG[1][number], LayoutLiteral>;
type PayloadGroupsToLayoutLiteralsRecursive<PGA extends readonly PayloadGroup[]> = PGA extends readonly [infer PG extends PayloadGroup, ...infer T extends readonly PayloadGroup[]] ? PayloadGroupToLayoutLiterals<PG> | PayloadGroupsToLayoutLiteralsRecursive<T> : never;
type PayloadGroupsToLayoutLiterals<PGA extends readonly PayloadGroup[]> = PayloadGroupsToLayoutLiteralsRecursive<PGA> extends infer Value extends LayoutLiteral ? Value : never;
type LLDtoLLs<LLD extends AtLeast2<LayoutLiteral> | readonly [ProtocolName, AtLeast2<string>] | AtLeast2<PayloadGroup>> = LLD extends AtLeast2<LayoutLiteral> ? LLD[number] : LLD extends readonly [ProtocolName, AtLeast2<string>] ? PayloadGroupToLayoutLiterals<LLD> : LLD extends AtLeast2<PayloadGroup> ? PayloadGroupsToLayoutLiterals<LLD> : never;
export declare function payloadDiscriminator<const LLD extends AtLeast2<LayoutLiteral> | readonly [ProtocolName, AtLeast2<string>] | AtLeast2<PayloadGroup>, B extends boolean = false>(payloadLiterals: LLD, allowAmbiguous?: B): PayloadDiscriminator<LLDtoLLs<LLD>, B>;
type ExtractLiteral<T> = T extends PayloadDiscriminator<infer LL> ? LL : T;
export declare function deserialize<T extends PayloadLiteral | PayloadDiscriminator>(payloadDet: T, data: Byteish): DistributiveVAA<ExtractLiteral<T>>;
type DeserializedPair<LL extends LayoutLiteral = LayoutLiteral> = LL extends LayoutLiteral ? readonly [LL, LayoutLiteralToPayload<LL>] : never;
type DeserializePayloadReturn<T> = T extends infer PL extends PayloadLiteral ? Payload<PL> : T extends PayloadDiscriminator<infer LL> ? DeserializedPair<LL> : never;
export declare function deserializePayload<T extends PayloadLiteral | PayloadDiscriminator>(payloadDet: T, data: Byteish, offset?: number): DeserializePayloadReturn<T>;
export declare const blindDeserializePayload: (data: Byteish) => readonly DeserializedPair[];
export {};
//# sourceMappingURL=functions.d.ts.map