/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface OptimisticGovernorInterface extends ethers.utils.Interface {
  functions: {
    "EXPLANATION_KEY()": FunctionFragment;
    "PROPOSAL_HASH_KEY()": FunctionFragment;
    "RULES_KEY()": FunctionFragment;
    "assertionDisputedCallback(bytes32)": FunctionFragment;
    "assertionIds(bytes32)": FunctionFragment;
    "assertionResolvedCallback(bytes32,bool)": FunctionFragment;
    "avatar()": FunctionFragment;
    "bondAmount()": FunctionFragment;
    "collateral()": FunctionFragment;
    "deleteProposalOnUpgrade(bytes32)": FunctionFragment;
    "escalationManager()": FunctionFragment;
    "executeProposal(tuple[])": FunctionFragment;
    "finder()": FunctionFragment;
    "getCurrentTime()": FunctionFragment;
    "getGuard()": FunctionFragment;
    "getProposalBond()": FunctionFragment;
    "guard()": FunctionFragment;
    "identifier()": FunctionFragment;
    "liveness()": FunctionFragment;
    "optimisticOracleV3()": FunctionFragment;
    "owner()": FunctionFragment;
    "proposalHashes(bytes32)": FunctionFragment;
    "proposeTransactions(tuple[],bytes)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "rules()": FunctionFragment;
    "setAvatar(address)": FunctionFragment;
    "setCollateralAndBond(address,uint256)": FunctionFragment;
    "setEscalationManager(address)": FunctionFragment;
    "setGuard(address)": FunctionFragment;
    "setIdentifier(bytes32)": FunctionFragment;
    "setLiveness(uint64)": FunctionFragment;
    "setRules(string)": FunctionFragment;
    "setTarget(address)": FunctionFragment;
    "setUp(bytes)": FunctionFragment;
    "sync()": FunctionFragment;
    "target()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "EXPLANATION_KEY",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PROPOSAL_HASH_KEY",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "RULES_KEY", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "assertionDisputedCallback",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertionIds",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertionResolvedCallback",
    values: [BytesLike, boolean]
  ): string;
  encodeFunctionData(functionFragment: "avatar", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "bondAmount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "collateral",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deleteProposalOnUpgrade",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "escalationManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeProposal",
    values: [
      {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[]
    ]
  ): string;
  encodeFunctionData(functionFragment: "finder", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getCurrentTime",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getGuard", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getProposalBond",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "guard", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "identifier",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "liveness", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "optimisticOracleV3",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proposalHashes",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeTransactions",
    values: [
      {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "rules", values?: undefined): string;
  encodeFunctionData(functionFragment: "setAvatar", values: [string]): string;
  encodeFunctionData(
    functionFragment: "setCollateralAndBond",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setEscalationManager",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "setGuard", values: [string]): string;
  encodeFunctionData(
    functionFragment: "setIdentifier",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setLiveness",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "setRules", values: [string]): string;
  encodeFunctionData(functionFragment: "setTarget", values: [string]): string;
  encodeFunctionData(functionFragment: "setUp", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "sync", values?: undefined): string;
  encodeFunctionData(functionFragment: "target", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;

  decodeFunctionResult(
    functionFragment: "EXPLANATION_KEY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PROPOSAL_HASH_KEY",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "RULES_KEY", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "assertionDisputedCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertionIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertionResolvedCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "avatar", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bondAmount", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "collateral", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "deleteProposalOnUpgrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "escalationManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "finder", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getGuard", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getProposalBond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "guard", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "identifier", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liveness", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "optimisticOracleV3",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proposalHashes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeTransactions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rules", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setAvatar", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setCollateralAndBond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setEscalationManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setGuard", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setIdentifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setLiveness",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setRules", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setTarget", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setUp", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sync", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "target", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;

  events: {
    "AvatarSet(address,address)": EventFragment;
    "ChangedGuard(address)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "OptimisticGovernorDeployed(address,address,address)": EventFragment;
    "OptimisticOracleChanged(address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "ProposalDeleted(bytes32,bytes32)": EventFragment;
    "ProposalExecuted(bytes32,bytes32)": EventFragment;
    "SetCollateralAndBond(address,uint256)": EventFragment;
    "SetEscalationManager(address)": EventFragment;
    "SetIdentifier(bytes32)": EventFragment;
    "SetLiveness(uint64)": EventFragment;
    "SetRules(string)": EventFragment;
    "TargetSet(address,address)": EventFragment;
    "TransactionExecuted(bytes32,bytes32,uint256)": EventFragment;
    "TransactionsProposed(address,uint256,bytes32,tuple,bytes32,bytes,string,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AvatarSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ChangedGuard"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OptimisticGovernorDeployed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OptimisticOracleChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalDeleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetCollateralAndBond"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetEscalationManager"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetIdentifier"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetLiveness"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetRules"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TargetSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransactionsProposed"): EventFragment;
}

export type AvatarSetEvent = TypedEvent<
  [string, string] & { previousAvatar: string; newAvatar: string }
>;

export type ChangedGuardEvent = TypedEvent<[string] & { guard: string }>;

export type InitializedEvent = TypedEvent<[number] & { version: number }>;

export type OptimisticGovernorDeployedEvent = TypedEvent<
  [string, string, string] & { owner: string; avatar: string; target: string }
>;

export type OptimisticOracleChangedEvent = TypedEvent<
  [string] & { newOptimisticOracleV3: string }
>;

export type OwnershipTransferredEvent = TypedEvent<
  [string, string] & { previousOwner: string; newOwner: string }
>;

export type ProposalDeletedEvent = TypedEvent<
  [string, string] & { proposalHash: string; assertionId: string }
>;

export type ProposalExecutedEvent = TypedEvent<
  [string, string] & { proposalHash: string; assertionId: string }
>;

export type SetCollateralAndBondEvent = TypedEvent<
  [string, BigNumber] & { collateral: string; bondAmount: BigNumber }
>;

export type SetEscalationManagerEvent = TypedEvent<
  [string] & { escalationManager: string }
>;

export type SetIdentifierEvent = TypedEvent<[string] & { identifier: string }>;

export type SetLivenessEvent = TypedEvent<
  [BigNumber] & { liveness: BigNumber }
>;

export type SetRulesEvent = TypedEvent<[string] & { rules: string }>;

export type TargetSetEvent = TypedEvent<
  [string, string] & { previousTarget: string; newTarget: string }
>;

export type TransactionExecutedEvent = TypedEvent<
  [string, string, BigNumber] & {
    proposalHash: string;
    assertionId: string;
    transactionIndex: BigNumber;
  }
>;

export type TransactionsProposedEvent = TypedEvent<
  [
    string,
    BigNumber,
    string,
    [
      ([string, number, BigNumber, string] & {
        to: string;
        operation: number;
        value: BigNumber;
        data: string;
      })[],
      BigNumber
    ] & {
      transactions: ([string, number, BigNumber, string] & {
        to: string;
        operation: number;
        value: BigNumber;
        data: string;
      })[];
      requestTime: BigNumber;
    },
    string,
    string,
    string,
    BigNumber
  ] & {
    proposer: string;
    proposalTime: BigNumber;
    assertionId: string;
    proposal: [
      ([string, number, BigNumber, string] & {
        to: string;
        operation: number;
        value: BigNumber;
        data: string;
      })[],
      BigNumber
    ] & {
      transactions: ([string, number, BigNumber, string] & {
        to: string;
        operation: number;
        value: BigNumber;
        data: string;
      })[];
      requestTime: BigNumber;
    };
    proposalHash: string;
    explanation: string;
    rules: string;
    challengeWindowEnds: BigNumber;
  }
>;

export class OptimisticGovernor extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: OptimisticGovernorInterface;

  functions: {
    EXPLANATION_KEY(overrides?: CallOverrides): Promise<[string]>;

    PROPOSAL_HASH_KEY(overrides?: CallOverrides): Promise<[string]>;

    RULES_KEY(overrides?: CallOverrides): Promise<[string]>;

    assertionDisputedCallback(
      assertionId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    assertionIds(arg0: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    assertionResolvedCallback(
      assertionId: BytesLike,
      assertedTruthfully: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    avatar(overrides?: CallOverrides): Promise<[string]>;

    bondAmount(overrides?: CallOverrides): Promise<[BigNumber]>;

    collateral(overrides?: CallOverrides): Promise<[string]>;

    deleteProposalOnUpgrade(
      proposalHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    escalationManager(overrides?: CallOverrides): Promise<[string]>;

    executeProposal(
      transactions: {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    finder(overrides?: CallOverrides): Promise<[string]>;

    getCurrentTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    getGuard(overrides?: CallOverrides): Promise<[string] & { _guard: string }>;

    getProposalBond(overrides?: CallOverrides): Promise<[BigNumber]>;

    guard(overrides?: CallOverrides): Promise<[string]>;

    identifier(overrides?: CallOverrides): Promise<[string]>;

    liveness(overrides?: CallOverrides): Promise<[BigNumber]>;

    optimisticOracleV3(overrides?: CallOverrides): Promise<[string]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    proposalHashes(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    proposeTransactions(
      transactions: {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[],
      explanation: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    rules(overrides?: CallOverrides): Promise<[string]>;

    setAvatar(
      _avatar: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setCollateralAndBond(
      _collateral: string,
      _bondAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setEscalationManager(
      _escalationManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setGuard(
      _guard: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setIdentifier(
      _identifier: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setLiveness(
      _liveness: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setRules(
      _rules: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setTarget(
      _target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setUp(
      initializeParams: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sync(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    target(overrides?: CallOverrides): Promise<[string]>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  EXPLANATION_KEY(overrides?: CallOverrides): Promise<string>;

  PROPOSAL_HASH_KEY(overrides?: CallOverrides): Promise<string>;

  RULES_KEY(overrides?: CallOverrides): Promise<string>;

  assertionDisputedCallback(
    assertionId: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  assertionIds(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  assertionResolvedCallback(
    assertionId: BytesLike,
    assertedTruthfully: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  avatar(overrides?: CallOverrides): Promise<string>;

  bondAmount(overrides?: CallOverrides): Promise<BigNumber>;

  collateral(overrides?: CallOverrides): Promise<string>;

  deleteProposalOnUpgrade(
    proposalHash: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  escalationManager(overrides?: CallOverrides): Promise<string>;

  executeProposal(
    transactions: {
      to: string;
      operation: BigNumberish;
      value: BigNumberish;
      data: BytesLike;
    }[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  finder(overrides?: CallOverrides): Promise<string>;

  getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;

  getGuard(overrides?: CallOverrides): Promise<string>;

  getProposalBond(overrides?: CallOverrides): Promise<BigNumber>;

  guard(overrides?: CallOverrides): Promise<string>;

  identifier(overrides?: CallOverrides): Promise<string>;

  liveness(overrides?: CallOverrides): Promise<BigNumber>;

  optimisticOracleV3(overrides?: CallOverrides): Promise<string>;

  owner(overrides?: CallOverrides): Promise<string>;

  proposalHashes(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  proposeTransactions(
    transactions: {
      to: string;
      operation: BigNumberish;
      value: BigNumberish;
      data: BytesLike;
    }[],
    explanation: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  rules(overrides?: CallOverrides): Promise<string>;

  setAvatar(
    _avatar: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setCollateralAndBond(
    _collateral: string,
    _bondAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setEscalationManager(
    _escalationManager: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setGuard(
    _guard: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setIdentifier(
    _identifier: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setLiveness(
    _liveness: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setRules(
    _rules: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setTarget(
    _target: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setUp(
    initializeParams: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sync(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  target(overrides?: CallOverrides): Promise<string>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    EXPLANATION_KEY(overrides?: CallOverrides): Promise<string>;

    PROPOSAL_HASH_KEY(overrides?: CallOverrides): Promise<string>;

    RULES_KEY(overrides?: CallOverrides): Promise<string>;

    assertionDisputedCallback(
      assertionId: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    assertionIds(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    assertionResolvedCallback(
      assertionId: BytesLike,
      assertedTruthfully: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    avatar(overrides?: CallOverrides): Promise<string>;

    bondAmount(overrides?: CallOverrides): Promise<BigNumber>;

    collateral(overrides?: CallOverrides): Promise<string>;

    deleteProposalOnUpgrade(
      proposalHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    escalationManager(overrides?: CallOverrides): Promise<string>;

    executeProposal(
      transactions: {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[],
      overrides?: CallOverrides
    ): Promise<void>;

    finder(overrides?: CallOverrides): Promise<string>;

    getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;

    getGuard(overrides?: CallOverrides): Promise<string>;

    getProposalBond(overrides?: CallOverrides): Promise<BigNumber>;

    guard(overrides?: CallOverrides): Promise<string>;

    identifier(overrides?: CallOverrides): Promise<string>;

    liveness(overrides?: CallOverrides): Promise<BigNumber>;

    optimisticOracleV3(overrides?: CallOverrides): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    proposalHashes(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    proposeTransactions(
      transactions: {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[],
      explanation: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rules(overrides?: CallOverrides): Promise<string>;

    setAvatar(_avatar: string, overrides?: CallOverrides): Promise<void>;

    setCollateralAndBond(
      _collateral: string,
      _bondAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setEscalationManager(
      _escalationManager: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setGuard(_guard: string, overrides?: CallOverrides): Promise<void>;

    setIdentifier(
      _identifier: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    setLiveness(
      _liveness: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setRules(_rules: string, overrides?: CallOverrides): Promise<void>;

    setTarget(_target: string, overrides?: CallOverrides): Promise<void>;

    setUp(
      initializeParams: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    sync(overrides?: CallOverrides): Promise<void>;

    target(overrides?: CallOverrides): Promise<string>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AvatarSet(address,address)"(
      previousAvatar?: string | null,
      newAvatar?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousAvatar: string; newAvatar: string }
    >;

    AvatarSet(
      previousAvatar?: string | null,
      newAvatar?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousAvatar: string; newAvatar: string }
    >;

    "ChangedGuard(address)"(
      guard?: null
    ): TypedEventFilter<[string], { guard: string }>;

    ChangedGuard(guard?: null): TypedEventFilter<[string], { guard: string }>;

    "Initialized(uint8)"(
      version?: null
    ): TypedEventFilter<[number], { version: number }>;

    Initialized(
      version?: null
    ): TypedEventFilter<[number], { version: number }>;

    "OptimisticGovernorDeployed(address,address,address)"(
      owner?: string | null,
      avatar?: string | null,
      target?: null
    ): TypedEventFilter<
      [string, string, string],
      { owner: string; avatar: string; target: string }
    >;

    OptimisticGovernorDeployed(
      owner?: string | null,
      avatar?: string | null,
      target?: null
    ): TypedEventFilter<
      [string, string, string],
      { owner: string; avatar: string; target: string }
    >;

    "OptimisticOracleChanged(address)"(
      newOptimisticOracleV3?: string | null
    ): TypedEventFilter<[string], { newOptimisticOracleV3: string }>;

    OptimisticOracleChanged(
      newOptimisticOracleV3?: string | null
    ): TypedEventFilter<[string], { newOptimisticOracleV3: string }>;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousOwner: string; newOwner: string }
    >;

    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousOwner: string; newOwner: string }
    >;

    "ProposalDeleted(bytes32,bytes32)"(
      proposalHash?: BytesLike | null,
      assertionId?: BytesLike | null
    ): TypedEventFilter<
      [string, string],
      { proposalHash: string; assertionId: string }
    >;

    ProposalDeleted(
      proposalHash?: BytesLike | null,
      assertionId?: BytesLike | null
    ): TypedEventFilter<
      [string, string],
      { proposalHash: string; assertionId: string }
    >;

    "ProposalExecuted(bytes32,bytes32)"(
      proposalHash?: BytesLike | null,
      assertionId?: BytesLike | null
    ): TypedEventFilter<
      [string, string],
      { proposalHash: string; assertionId: string }
    >;

    ProposalExecuted(
      proposalHash?: BytesLike | null,
      assertionId?: BytesLike | null
    ): TypedEventFilter<
      [string, string],
      { proposalHash: string; assertionId: string }
    >;

    "SetCollateralAndBond(address,uint256)"(
      collateral?: string | null,
      bondAmount?: BigNumberish | null
    ): TypedEventFilter<
      [string, BigNumber],
      { collateral: string; bondAmount: BigNumber }
    >;

    SetCollateralAndBond(
      collateral?: string | null,
      bondAmount?: BigNumberish | null
    ): TypedEventFilter<
      [string, BigNumber],
      { collateral: string; bondAmount: BigNumber }
    >;

    "SetEscalationManager(address)"(
      escalationManager?: string | null
    ): TypedEventFilter<[string], { escalationManager: string }>;

    SetEscalationManager(
      escalationManager?: string | null
    ): TypedEventFilter<[string], { escalationManager: string }>;

    "SetIdentifier(bytes32)"(
      identifier?: BytesLike | null
    ): TypedEventFilter<[string], { identifier: string }>;

    SetIdentifier(
      identifier?: BytesLike | null
    ): TypedEventFilter<[string], { identifier: string }>;

    "SetLiveness(uint64)"(
      liveness?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { liveness: BigNumber }>;

    SetLiveness(
      liveness?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { liveness: BigNumber }>;

    "SetRules(string)"(
      rules?: null
    ): TypedEventFilter<[string], { rules: string }>;

    SetRules(rules?: null): TypedEventFilter<[string], { rules: string }>;

    "TargetSet(address,address)"(
      previousTarget?: string | null,
      newTarget?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousTarget: string; newTarget: string }
    >;

    TargetSet(
      previousTarget?: string | null,
      newTarget?: string | null
    ): TypedEventFilter<
      [string, string],
      { previousTarget: string; newTarget: string }
    >;

    "TransactionExecuted(bytes32,bytes32,uint256)"(
      proposalHash?: BytesLike | null,
      assertionId?: BytesLike | null,
      transactionIndex?: BigNumberish | null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { proposalHash: string; assertionId: string; transactionIndex: BigNumber }
    >;

    TransactionExecuted(
      proposalHash?: BytesLike | null,
      assertionId?: BytesLike | null,
      transactionIndex?: BigNumberish | null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { proposalHash: string; assertionId: string; transactionIndex: BigNumber }
    >;

    "TransactionsProposed(address,uint256,bytes32,tuple,bytes32,bytes,string,uint256)"(
      proposer?: string | null,
      proposalTime?: BigNumberish | null,
      assertionId?: BytesLike | null,
      proposal?: null,
      proposalHash?: null,
      explanation?: null,
      rules?: null,
      challengeWindowEnds?: null
    ): TypedEventFilter<
      [
        string,
        BigNumber,
        string,
        [
          ([string, number, BigNumber, string] & {
            to: string;
            operation: number;
            value: BigNumber;
            data: string;
          })[],
          BigNumber
        ] & {
          transactions: ([string, number, BigNumber, string] & {
            to: string;
            operation: number;
            value: BigNumber;
            data: string;
          })[];
          requestTime: BigNumber;
        },
        string,
        string,
        string,
        BigNumber
      ],
      {
        proposer: string;
        proposalTime: BigNumber;
        assertionId: string;
        proposal: [
          ([string, number, BigNumber, string] & {
            to: string;
            operation: number;
            value: BigNumber;
            data: string;
          })[],
          BigNumber
        ] & {
          transactions: ([string, number, BigNumber, string] & {
            to: string;
            operation: number;
            value: BigNumber;
            data: string;
          })[];
          requestTime: BigNumber;
        };
        proposalHash: string;
        explanation: string;
        rules: string;
        challengeWindowEnds: BigNumber;
      }
    >;

    TransactionsProposed(
      proposer?: string | null,
      proposalTime?: BigNumberish | null,
      assertionId?: BytesLike | null,
      proposal?: null,
      proposalHash?: null,
      explanation?: null,
      rules?: null,
      challengeWindowEnds?: null
    ): TypedEventFilter<
      [
        string,
        BigNumber,
        string,
        [
          ([string, number, BigNumber, string] & {
            to: string;
            operation: number;
            value: BigNumber;
            data: string;
          })[],
          BigNumber
        ] & {
          transactions: ([string, number, BigNumber, string] & {
            to: string;
            operation: number;
            value: BigNumber;
            data: string;
          })[];
          requestTime: BigNumber;
        },
        string,
        string,
        string,
        BigNumber
      ],
      {
        proposer: string;
        proposalTime: BigNumber;
        assertionId: string;
        proposal: [
          ([string, number, BigNumber, string] & {
            to: string;
            operation: number;
            value: BigNumber;
            data: string;
          })[],
          BigNumber
        ] & {
          transactions: ([string, number, BigNumber, string] & {
            to: string;
            operation: number;
            value: BigNumber;
            data: string;
          })[];
          requestTime: BigNumber;
        };
        proposalHash: string;
        explanation: string;
        rules: string;
        challengeWindowEnds: BigNumber;
      }
    >;
  };

  estimateGas: {
    EXPLANATION_KEY(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_HASH_KEY(overrides?: CallOverrides): Promise<BigNumber>;

    RULES_KEY(overrides?: CallOverrides): Promise<BigNumber>;

    assertionDisputedCallback(
      assertionId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    assertionIds(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    assertionResolvedCallback(
      assertionId: BytesLike,
      assertedTruthfully: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    avatar(overrides?: CallOverrides): Promise<BigNumber>;

    bondAmount(overrides?: CallOverrides): Promise<BigNumber>;

    collateral(overrides?: CallOverrides): Promise<BigNumber>;

    deleteProposalOnUpgrade(
      proposalHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    escalationManager(overrides?: CallOverrides): Promise<BigNumber>;

    executeProposal(
      transactions: {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    finder(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentTime(overrides?: CallOverrides): Promise<BigNumber>;

    getGuard(overrides?: CallOverrides): Promise<BigNumber>;

    getProposalBond(overrides?: CallOverrides): Promise<BigNumber>;

    guard(overrides?: CallOverrides): Promise<BigNumber>;

    identifier(overrides?: CallOverrides): Promise<BigNumber>;

    liveness(overrides?: CallOverrides): Promise<BigNumber>;

    optimisticOracleV3(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    proposalHashes(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proposeTransactions(
      transactions: {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[],
      explanation: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    rules(overrides?: CallOverrides): Promise<BigNumber>;

    setAvatar(
      _avatar: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setCollateralAndBond(
      _collateral: string,
      _bondAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setEscalationManager(
      _escalationManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setGuard(
      _guard: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setIdentifier(
      _identifier: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setLiveness(
      _liveness: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setRules(
      _rules: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setTarget(
      _target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setUp(
      initializeParams: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sync(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    target(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    EXPLANATION_KEY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PROPOSAL_HASH_KEY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    RULES_KEY(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    assertionDisputedCallback(
      assertionId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    assertionIds(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assertionResolvedCallback(
      assertionId: BytesLike,
      assertedTruthfully: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    avatar(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bondAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    collateral(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    deleteProposalOnUpgrade(
      proposalHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    escalationManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    executeProposal(
      transactions: {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    finder(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCurrentTime(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getGuard(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getProposalBond(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    guard(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    identifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    liveness(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    optimisticOracleV3(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposalHashes(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proposeTransactions(
      transactions: {
        to: string;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
      }[],
      explanation: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    rules(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAvatar(
      _avatar: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setCollateralAndBond(
      _collateral: string,
      _bondAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setEscalationManager(
      _escalationManager: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setGuard(
      _guard: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setIdentifier(
      _identifier: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setLiveness(
      _liveness: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setRules(
      _rules: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setTarget(
      _target: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setUp(
      initializeParams: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sync(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    target(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
