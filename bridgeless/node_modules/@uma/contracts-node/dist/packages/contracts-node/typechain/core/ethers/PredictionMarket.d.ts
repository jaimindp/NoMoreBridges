/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface PredictionMarketInterface extends ethers.utils.Interface {
  functions: {
    "assertMarket(bytes32,string)": FunctionFragment;
    "assertedMarkets(bytes32)": FunctionFragment;
    "assertionDisputedCallback(bytes32)": FunctionFragment;
    "assertionLiveness()": FunctionFragment;
    "assertionResolvedCallback(bytes32,bool)": FunctionFragment;
    "createOutcomeTokens(bytes32,uint256)": FunctionFragment;
    "currency()": FunctionFragment;
    "defaultIdentifier()": FunctionFragment;
    "finder()": FunctionFragment;
    "getMarket(bytes32)": FunctionFragment;
    "initializeMarket(string,string,string,uint256,uint256)": FunctionFragment;
    "markets(bytes32)": FunctionFragment;
    "oo()": FunctionFragment;
    "redeemOutcomeTokens(bytes32,uint256)": FunctionFragment;
    "settleOutcomeTokens(bytes32)": FunctionFragment;
    "unresolvable()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "assertMarket",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "assertedMarkets",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertionDisputedCallback",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "assertionLiveness",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "assertionResolvedCallback",
    values: [BytesLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "createOutcomeTokens",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "currency", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "defaultIdentifier",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "finder", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getMarket",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "initializeMarket",
    values: [string, string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "markets", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "oo", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "redeemOutcomeTokens",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "settleOutcomeTokens",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unresolvable",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "assertMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertedMarkets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertionDisputedCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertionLiveness",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assertionResolvedCallback",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createOutcomeTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "currency", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "defaultIdentifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "finder", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMarket", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "initializeMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "markets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "oo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redeemOutcomeTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "settleOutcomeTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unresolvable",
    data: BytesLike
  ): Result;

  events: {
    "MarketAsserted(bytes32,string,bytes32)": EventFragment;
    "MarketInitialized(bytes32,string,string,string,address,address,uint256,uint256)": EventFragment;
    "MarketResolved(bytes32)": EventFragment;
    "TokensCreated(bytes32,address,uint256)": EventFragment;
    "TokensRedeemed(bytes32,address,uint256)": EventFragment;
    "TokensSettled(bytes32,address,uint256,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "MarketAsserted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketInitialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MarketResolved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensRedeemed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensSettled"): EventFragment;
}

export type MarketAssertedEvent = TypedEvent<
  [string, string, string] & {
    marketId: string;
    assertedOutcome: string;
    assertionId: string;
  }
>;

export type MarketInitializedEvent = TypedEvent<
  [string, string, string, string, string, string, BigNumber, BigNumber] & {
    marketId: string;
    outcome1: string;
    outcome2: string;
    description: string;
    outcome1Token: string;
    outcome2Token: string;
    reward: BigNumber;
    requiredBond: BigNumber;
  }
>;

export type MarketResolvedEvent = TypedEvent<[string] & { marketId: string }>;

export type TokensCreatedEvent = TypedEvent<
  [string, string, BigNumber] & {
    marketId: string;
    account: string;
    tokensCreated: BigNumber;
  }
>;

export type TokensRedeemedEvent = TypedEvent<
  [string, string, BigNumber] & {
    marketId: string;
    account: string;
    tokensRedeemed: BigNumber;
  }
>;

export type TokensSettledEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber] & {
    marketId: string;
    account: string;
    payout: BigNumber;
    outcome1Tokens: BigNumber;
    outcome2Tokens: BigNumber;
  }
>;

export class PredictionMarket extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: PredictionMarketInterface;

  functions: {
    assertMarket(
      marketId: BytesLike,
      assertedOutcome: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    assertedMarkets(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string, string] & { asserter: string; marketId: string }>;

    assertionDisputedCallback(
      assertionId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    assertionLiveness(overrides?: CallOverrides): Promise<[BigNumber]>;

    assertionResolvedCallback(
      assertionId: BytesLike,
      assertedTruthfully: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    createOutcomeTokens(
      marketId: BytesLike,
      tokensToCreate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    currency(overrides?: CallOverrides): Promise<[string]>;

    defaultIdentifier(overrides?: CallOverrides): Promise<[string]>;

    finder(overrides?: CallOverrides): Promise<[string]>;

    getMarket(
      marketId: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        [
          boolean,
          string,
          string,
          string,
          BigNumber,
          BigNumber,
          string,
          string,
          string
        ] & {
          resolved: boolean;
          assertedOutcomeId: string;
          outcome1Token: string;
          outcome2Token: string;
          reward: BigNumber;
          requiredBond: BigNumber;
          outcome1: string;
          outcome2: string;
          description: string;
        }
      ]
    >;

    initializeMarket(
      outcome1: string,
      outcome2: string,
      description: string,
      reward: BigNumberish,
      requiredBond: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    markets(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        string
      ] & {
        resolved: boolean;
        assertedOutcomeId: string;
        outcome1Token: string;
        outcome2Token: string;
        reward: BigNumber;
        requiredBond: BigNumber;
        outcome1: string;
        outcome2: string;
        description: string;
      }
    >;

    oo(overrides?: CallOverrides): Promise<[string]>;

    redeemOutcomeTokens(
      marketId: BytesLike,
      tokensToRedeem: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    settleOutcomeTokens(
      marketId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    unresolvable(overrides?: CallOverrides): Promise<[string]>;
  };

  assertMarket(
    marketId: BytesLike,
    assertedOutcome: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  assertedMarkets(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<[string, string] & { asserter: string; marketId: string }>;

  assertionDisputedCallback(
    assertionId: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  assertionLiveness(overrides?: CallOverrides): Promise<BigNumber>;

  assertionResolvedCallback(
    assertionId: BytesLike,
    assertedTruthfully: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  createOutcomeTokens(
    marketId: BytesLike,
    tokensToCreate: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  currency(overrides?: CallOverrides): Promise<string>;

  defaultIdentifier(overrides?: CallOverrides): Promise<string>;

  finder(overrides?: CallOverrides): Promise<string>;

  getMarket(
    marketId: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      string,
      string
    ] & {
      resolved: boolean;
      assertedOutcomeId: string;
      outcome1Token: string;
      outcome2Token: string;
      reward: BigNumber;
      requiredBond: BigNumber;
      outcome1: string;
      outcome2: string;
      description: string;
    }
  >;

  initializeMarket(
    outcome1: string,
    outcome2: string,
    description: string,
    reward: BigNumberish,
    requiredBond: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  markets(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [
      boolean,
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      string,
      string,
      string
    ] & {
      resolved: boolean;
      assertedOutcomeId: string;
      outcome1Token: string;
      outcome2Token: string;
      reward: BigNumber;
      requiredBond: BigNumber;
      outcome1: string;
      outcome2: string;
      description: string;
    }
  >;

  oo(overrides?: CallOverrides): Promise<string>;

  redeemOutcomeTokens(
    marketId: BytesLike,
    tokensToRedeem: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  settleOutcomeTokens(
    marketId: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  unresolvable(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    assertMarket(
      marketId: BytesLike,
      assertedOutcome: string,
      overrides?: CallOverrides
    ): Promise<string>;

    assertedMarkets(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string, string] & { asserter: string; marketId: string }>;

    assertionDisputedCallback(
      assertionId: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    assertionLiveness(overrides?: CallOverrides): Promise<BigNumber>;

    assertionResolvedCallback(
      assertionId: BytesLike,
      assertedTruthfully: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    createOutcomeTokens(
      marketId: BytesLike,
      tokensToCreate: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    currency(overrides?: CallOverrides): Promise<string>;

    defaultIdentifier(overrides?: CallOverrides): Promise<string>;

    finder(overrides?: CallOverrides): Promise<string>;

    getMarket(
      marketId: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        string
      ] & {
        resolved: boolean;
        assertedOutcomeId: string;
        outcome1Token: string;
        outcome2Token: string;
        reward: BigNumber;
        requiredBond: BigNumber;
        outcome1: string;
        outcome2: string;
        description: string;
      }
    >;

    initializeMarket(
      outcome1: string,
      outcome2: string,
      description: string,
      reward: BigNumberish,
      requiredBond: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    markets(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [
        boolean,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        string,
        string,
        string
      ] & {
        resolved: boolean;
        assertedOutcomeId: string;
        outcome1Token: string;
        outcome2Token: string;
        reward: BigNumber;
        requiredBond: BigNumber;
        outcome1: string;
        outcome2: string;
        description: string;
      }
    >;

    oo(overrides?: CallOverrides): Promise<string>;

    redeemOutcomeTokens(
      marketId: BytesLike,
      tokensToRedeem: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    settleOutcomeTokens(
      marketId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unresolvable(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "MarketAsserted(bytes32,string,bytes32)"(
      marketId?: BytesLike | null,
      assertedOutcome?: null,
      assertionId?: BytesLike | null
    ): TypedEventFilter<
      [string, string, string],
      { marketId: string; assertedOutcome: string; assertionId: string }
    >;

    MarketAsserted(
      marketId?: BytesLike | null,
      assertedOutcome?: null,
      assertionId?: BytesLike | null
    ): TypedEventFilter<
      [string, string, string],
      { marketId: string; assertedOutcome: string; assertionId: string }
    >;

    "MarketInitialized(bytes32,string,string,string,address,address,uint256,uint256)"(
      marketId?: BytesLike | null,
      outcome1?: null,
      outcome2?: null,
      description?: null,
      outcome1Token?: null,
      outcome2Token?: null,
      reward?: null,
      requiredBond?: null
    ): TypedEventFilter<
      [string, string, string, string, string, string, BigNumber, BigNumber],
      {
        marketId: string;
        outcome1: string;
        outcome2: string;
        description: string;
        outcome1Token: string;
        outcome2Token: string;
        reward: BigNumber;
        requiredBond: BigNumber;
      }
    >;

    MarketInitialized(
      marketId?: BytesLike | null,
      outcome1?: null,
      outcome2?: null,
      description?: null,
      outcome1Token?: null,
      outcome2Token?: null,
      reward?: null,
      requiredBond?: null
    ): TypedEventFilter<
      [string, string, string, string, string, string, BigNumber, BigNumber],
      {
        marketId: string;
        outcome1: string;
        outcome2: string;
        description: string;
        outcome1Token: string;
        outcome2Token: string;
        reward: BigNumber;
        requiredBond: BigNumber;
      }
    >;

    "MarketResolved(bytes32)"(
      marketId?: BytesLike | null
    ): TypedEventFilter<[string], { marketId: string }>;

    MarketResolved(
      marketId?: BytesLike | null
    ): TypedEventFilter<[string], { marketId: string }>;

    "TokensCreated(bytes32,address,uint256)"(
      marketId?: BytesLike | null,
      account?: string | null,
      tokensCreated?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { marketId: string; account: string; tokensCreated: BigNumber }
    >;

    TokensCreated(
      marketId?: BytesLike | null,
      account?: string | null,
      tokensCreated?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { marketId: string; account: string; tokensCreated: BigNumber }
    >;

    "TokensRedeemed(bytes32,address,uint256)"(
      marketId?: BytesLike | null,
      account?: string | null,
      tokensRedeemed?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { marketId: string; account: string; tokensRedeemed: BigNumber }
    >;

    TokensRedeemed(
      marketId?: BytesLike | null,
      account?: string | null,
      tokensRedeemed?: null
    ): TypedEventFilter<
      [string, string, BigNumber],
      { marketId: string; account: string; tokensRedeemed: BigNumber }
    >;

    "TokensSettled(bytes32,address,uint256,uint256,uint256)"(
      marketId?: BytesLike | null,
      account?: string | null,
      payout?: null,
      outcome1Tokens?: null,
      outcome2Tokens?: null
    ): TypedEventFilter<
      [string, string, BigNumber, BigNumber, BigNumber],
      {
        marketId: string;
        account: string;
        payout: BigNumber;
        outcome1Tokens: BigNumber;
        outcome2Tokens: BigNumber;
      }
    >;

    TokensSettled(
      marketId?: BytesLike | null,
      account?: string | null,
      payout?: null,
      outcome1Tokens?: null,
      outcome2Tokens?: null
    ): TypedEventFilter<
      [string, string, BigNumber, BigNumber, BigNumber],
      {
        marketId: string;
        account: string;
        payout: BigNumber;
        outcome1Tokens: BigNumber;
        outcome2Tokens: BigNumber;
      }
    >;
  };

  estimateGas: {
    assertMarket(
      marketId: BytesLike,
      assertedOutcome: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    assertedMarkets(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    assertionDisputedCallback(
      assertionId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    assertionLiveness(overrides?: CallOverrides): Promise<BigNumber>;

    assertionResolvedCallback(
      assertionId: BytesLike,
      assertedTruthfully: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    createOutcomeTokens(
      marketId: BytesLike,
      tokensToCreate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    currency(overrides?: CallOverrides): Promise<BigNumber>;

    defaultIdentifier(overrides?: CallOverrides): Promise<BigNumber>;

    finder(overrides?: CallOverrides): Promise<BigNumber>;

    getMarket(
      marketId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initializeMarket(
      outcome1: string,
      outcome2: string,
      description: string,
      reward: BigNumberish,
      requiredBond: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    markets(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    oo(overrides?: CallOverrides): Promise<BigNumber>;

    redeemOutcomeTokens(
      marketId: BytesLike,
      tokensToRedeem: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    settleOutcomeTokens(
      marketId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    unresolvable(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    assertMarket(
      marketId: BytesLike,
      assertedOutcome: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    assertedMarkets(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assertionDisputedCallback(
      assertionId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    assertionLiveness(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    assertionResolvedCallback(
      assertionId: BytesLike,
      assertedTruthfully: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    createOutcomeTokens(
      marketId: BytesLike,
      tokensToCreate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    currency(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    defaultIdentifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    finder(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMarket(
      marketId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initializeMarket(
      outcome1: string,
      outcome2: string,
      description: string,
      reward: BigNumberish,
      requiredBond: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    markets(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oo(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    redeemOutcomeTokens(
      marketId: BytesLike,
      tokensToRedeem: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    settleOutcomeTokens(
      marketId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    unresolvable(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
