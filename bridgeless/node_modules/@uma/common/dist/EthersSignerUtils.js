"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMnemonicSigner = exports.getGckmsSigner = exports.getEthersSigner = void 0;
const args = require("minimist")(process.argv.slice(2));
const ethers_1 = require("ethers");
const GckmsConfig_1 = require("./gckms/GckmsConfig");
const utils_1 = require("./gckms/utils");
async function getEthersSigner() {
    if (!Object.keys(args).includes("wallet"))
        throw new Error("Must define mnemonic, privatekey or gckms for wallet");
    if (args.wallet === "mnemonic")
        return getMnemonicSigner();
    if (args.wallet === "privateKey")
        return getPrivateKeySigner();
    if (args.wallet === "gckms")
        return await getGckmsSigner();
    throw new Error("Invalid wallet type");
}
exports.getEthersSigner = getEthersSigner;
function getPrivateKeySigner() {
    if (!process.env.PRIVATE_KEY)
        throw new Error(`Wallet private key selected but no PRIVATE_KEY env set!`);
    return new ethers_1.Wallet(process.env.PRIVATE_KEY);
}
async function getGckmsSigner() {
    if (!args.keys && !process.env.GCKMS_WALLET)
        throw new Error(`Wallet GCKSM selected but no keys parameter or environment variable GCKMS_WALLET set! Set any of them first`);
    const privateKeys = await (0, utils_1.retrieveGckmsKeys)((0, GckmsConfig_1.getGckmsConfig)([args.keys ?? process.env.GCKMS_WALLET]));
    return new ethers_1.Wallet(privateKeys[0]); // GCKMS retrieveGckmsKeys returns multiple keys. For now we only support 1.
}
exports.getGckmsSigner = getGckmsSigner;
function getMnemonicSigner() {
    if (!process.env.MNEMONIC)
        throw new Error(`Wallet mnemonic selected but no MNEMONIC env set!`);
    return ethers_1.Wallet.fromMnemonic(process.env.MNEMONIC);
}
exports.getMnemonicSigner = getMnemonicSigner;
