import type { BN } from "./types";
import Web3 from "web3";
import type { provider as Provider } from "web3-core";
import { EventData, Contract } from "web3-eth-contract";
export interface TruffleInstance {
    [prop: string]: any;
}
export interface TruffleContract {
    setProvider: (provider: Provider) => void;
    at: (address: string) => Promise<TruffleInstance>;
    deployed: () => Promise<TruffleInstance>;
    new: (...args: any[]) => Promise<TruffleInstance>;
    link: (arg: any) => TruffleContract;
    detectNetwork: () => Promise<void>;
}
type CallResult = string | BN | {
    [key: string]: any;
};
/**
 * This is a hack to handle reverts for view/pure functions that don't actually revert on public networks.
 * See https://forum.openzeppelin.com/t/require-in-view-pure-functions-dont-revert-on-public-networks/1211 for more
 * info.
 * @param {Object} result Return value from calling a contract's view-only method.
 * @return null if the call reverted or the view method's result.
 */
export declare const revertWrapper: (result: CallResult) => null | CallResult;
/**
 * create a truffle contract from a json object, usually read in from an artifact.
 * @param {*} contractJsonObject json object representing a contract.
 * @param {Object} web3 instance. In unit tests this is globally accessible but when used in production needs injection.
 * @returns truffle contract instance
 */
export declare const createContractObjectFromJson: (contractJsonObject: {
    [key: string]: any;
}, _web3?: Web3) => TruffleContract;
/**
 * Helper to enable enables library linking on artifacts that were not compiled within this repo, such as artifacts
 * produced by an external project. Can also be useful if the artifact was compiled using ethers.
 * @param {object} artifact representing the compiled contract instance.
 * @param {string} libraryName to be found and replaced within the artifact.
 */
export declare const replaceLibraryBindingReferenceInArtitifact: <T>(artifact: T, libraryName: string) => T;
export type EventSearchOptions = {
    fromBlock: number;
    toBlock: number;
    filter?: any;
};
export type Web3Contract = Contract;
/**
 * Return all events between block range. Will paginate the event search using the `pageSize` if specified.
 * @param contract Contract to query.
 * @param eventName Event to query.
 * @param earliestBlockToQuery First block to query.
 * @param latestBlockToQuery Latest block to query.
 * @param pageSize Number of blocks to search for in each query. Determines how many web3 requests are sent to fetch
 * data for all blocks between `earliestBlockToQuery` and `latestBlockToQuery`.
 * @return array of event data.
 */
export declare function getEventsWithPaginatedBlockSearch(contract: Web3Contract, eventName: string, earliestBlockToQuery: number, latestBlockToQuery: number, pageSize?: number | null): Promise<{
    eventData: EventData[];
    web3RequestCount: number;
}>;
/**
 * Fetches specified contract event data for all input web3 providers. Returns false if any of the events found with
 * one provider are NOT matched exactly in ALL of the other providers' event arrays.
 * @param web3s Web3 providers to check for target event.
 * @param contractAbi Contract ABI to query target event on.
 * @param contractAddress Contract address to query target event on.
 * @param eventName Name of target event.
 * @param eventSearchOptions Target event search options. See here for more details: https://web3js.readthedocs.io/en/v1.5.2/web3-eth-contract.html#getpastevents
 * @returns Object containing success of event query, missing events not found in all providers, and all event data
 */
export declare function getEventsForMultipleProviders(web3s: Web3[], contractAbi: any[], contractAddress: string, eventName: string, eventSearchOptions: EventSearchOptions): Promise<{
    missingEvents: EventData[];
    events: EventData[];
}>;
export {};
