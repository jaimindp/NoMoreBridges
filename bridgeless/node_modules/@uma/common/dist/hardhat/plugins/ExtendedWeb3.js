"use strict";
// Plugin notes:
// The plugin adds 4 methods to the hre: getContract, findEvent, assertEventEmitted, assertEventNotEmitted.
// It requires the web3 hardhat plugin to work. All contract instantiations are web3, not truffle.
//
// getContract usage:
//   const { getContract } = hre;
//   const Voting = getContract("Voting");
//
//   // Get deployed voting contract for network.
//   const voting = await Voting.deployed();
//
//   // Create new Voting contract.
//   const voting = await Voting.new(arg1, arg2, ...).send({ from: accounts[0] });
//
//   // Instantiate voting contract at address.
//   const voting = Voting.at(someAddress);
//
// findEvent, assertEventEmitted, and assertEventNotEmitted usage:
//   const { findEvent, assertEventEmitted, assertEventNotEmitted } = hre;
//   ...
//   const result = voting.methods.someMethod(arg1, arg2, ...).send({ from: accounts[0] });
//   const matchOrUndefined = findEvent(result, voting, "SomeEventName",
//                            eventReturnValues => eventReturnValues.someValueICareAbout === 5);
//   await assertEventEmitted(result, voting, "SomeEventName",
//                            eventReturnValues => eventReturnValues.someValueICareAbout === 5);
//   await assertEventNotEmitted(result, voting, "SomeEventName",
//                            eventReturnValues => eventReturnValues.someValueICareAbout === 5);
//
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
// Copied from https://ethereum.stackexchange.com/a/85110/47801.
function linkBytecode(artifact, libraries) {
    let bytecode = artifact.bytecode;
    for (const [, fileReferences] of Object.entries(artifact.linkReferences)) {
        for (const [libName, fixups] of Object.entries(fileReferences)) {
            const addr = libraries[libName];
            if (addr === undefined) {
                continue;
            }
            for (const fixup of fixups) {
                bytecode =
                    bytecode.substr(0, 2 + fixup.start * 2) +
                        addr.substr(2) +
                        bytecode.substr(2 + (fixup.start + fixup.length) * 2);
            }
        }
    }
    return bytecode;
}
(0, config_1.extendEnvironment)((_hre) => {
    const hre = _hre;
    hre._artifactCache = {};
    hre.getContract = (name, artifactOverrides = {}) => {
        if (!hre._artifactCache[name]) {
            // Allows for the caller to bypass the hardhat lookup.
            // This is a bit of a hack and will not work for library linking unless linkReferences is provided.
            if (artifactOverrides.abi && artifactOverrides.bytecode)
                hre._artifactCache[name] = { contractName: name, ...artifactOverrides };
            else
                hre._artifactCache[name] = hre.artifacts.readArtifactSync(name);
        }
        const artifact = { ...hre._artifactCache[name], ...artifactOverrides };
        const deployed = async () => {
            const deployment = await hre.deployments.get(name);
            return new hre.web3.eth.Contract(artifact.abi, deployment.address);
        };
        const link = (libraries) => {
            artifact.bytecode = linkBytecode(artifact, libraries);
            return artifact.bytecode;
        };
        const newProp = (...args) => new hre.web3.eth.Contract(artifact.abi, undefined).deploy({ data: artifact.bytecode, arguments: args });
        const at = (address) => new hre.web3.eth.Contract(artifact.abi, address);
        return { ...artifact, deployed, link, new: newProp, at };
    };
    hre.findEvent = async (txnResult, contract, eventName, fn = () => true) => {
        // TODO: this can be improved by making sure the event falls in the correct transaction.
        const events = await contract.getPastEvents(eventName, {
            fromBlock: txnResult.blockNumber,
            toBlock: txnResult.blockNumber,
        });
        return {
            match: events.find((event) => fn(event.returnValues)),
            allEvents: events.map((event) => event.returnValues),
        };
    };
    hre.assertEventEmitted = async (txnResult, contract, eventName, fn) => {
        const { match, allEvents } = await hre.findEvent(txnResult, contract, eventName, fn);
        if (match === undefined) {
            throw new Error(`No matching events found. Events found:\n\n${allEvents.map((event) => JSON.stringify(event)).join("\n\n")}`);
        }
    };
    hre.assertEventNotEmitted = async (txnResult, contract, eventName, fn) => {
        const { match } = await hre.findEvent(txnResult, contract, eventName, fn);
        if (match !== undefined) {
            throw new Error(`Matching event found:\n\n${JSON.stringify(match)}`);
        }
    };
});
