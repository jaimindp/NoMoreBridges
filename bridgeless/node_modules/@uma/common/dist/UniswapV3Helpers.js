"use strict";
// This file contains a number of useful uniswap v3 helpers helper functions.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TICK_SPACINGS = exports.FeeAmount = exports.computePoolAddress = exports.getTickBitmapIndex = exports.getMaxTick = exports.getMinTick = exports.getTickFromPrice = exports.toBNWei = exports.encodePath = exports.getCurrentPrice = exports.decodePriceSqrt = exports.encodePriceSqrt = void 0;
const web3_1 = __importDefault(require("web3"));
const ethers_1 = require("ethers");
const UniswapV3Pool_json_1 = __importDefault(require("@uniswap/v3-core/artifacts/contracts/UniswapV3Pool.sol/UniswapV3Pool.json"));
const decimal_js_1 = __importDefault(require("decimal.js"));
const bignumber_js_1 = __importDefault(require("bignumber.js")); // Big number that comes with web3 does not support square root.
const ContractUtils_1 = require("./ContractUtils");
bignumber_js_1.default.config({ EXPONENTIAL_AT: 999999, DECIMAL_PLACES: 40 });
const { toBN, toWei } = web3_1.default.utils;
// Given a price defined in a ratio of reserve1 and reserve0 in x96, compute a price as sqrt(r1/r0) * 2^96
function encodePriceSqrt(reserve1, reserve0) {
    return new bignumber_js_1.default(reserve1.toString()).div(reserve0.toString()).sqrt().multipliedBy(new bignumber_js_1.default(2).pow(96)).integerValue(3);
}
exports.encodePriceSqrt = encodePriceSqrt;
// reverse x96 operation by compting (price/(2^96))^2
function decodePriceSqrt(priseSqrt) {
    return new bignumber_js_1.default(priseSqrt).dividedBy(new bignumber_js_1.default(2).pow(96)).pow(2);
}
exports.decodePriceSqrt = decodePriceSqrt;
// Fetch the decoded price from a uniswap pool from slot0.
async function getCurrentPrice(poolAddress, web3) {
    const pool = await (0, ContractUtils_1.createContractObjectFromJson)(UniswapV3Pool_json_1.default, web3).at(poolAddress);
    const slot0 = await pool.slot0();
    return decodePriceSqrt(slot0.sqrtPriceX96);
}
exports.getCurrentPrice = getCurrentPrice;
// Encode a path. Note that pools (and therefore paths) change when you use different fees.
function encodePath(path, fees) {
    const FEE_SIZE = 3;
    if (path.length != fees.length + 1) {
        throw new Error("path/fee lengths do not match");
    }
    let encoded = "0x";
    for (let i = 0; i < fees.length; i++) {
        // 20 byte encoding of the address
        encoded += path[i].slice(2);
        // 3 byte encoding of the fee
        encoded += fees[i].toString(16).padStart(2 * FEE_SIZE, "0");
    }
    // encode the final token
    encoded += path[path.length - 1].slice(2);
    return encoded.toLowerCase();
}
exports.encodePath = encodePath;
function toBNWei(input) {
    return toBN(toWei(input.toString()));
}
exports.toBNWei = toBNWei;
// The price in a pool, in terms of tick number, can be expressed as: p=1.0001^tick (taken from uniswapV3 white paper).
// Solving for the tick in terms of the price yields tickâ‰ˆ1.00005*ln(p) (calculated on wolframalpha). When creating a
// position, the tick needs to be a multiple of the TICK_SPACING for that particular fee. This method therefore computes
// a valid tick for a given price and poolFee.
function getTickFromPrice(price, poolFee) {
    return toBNWei(10000.5)
        .mul(toBNWei(new decimal_js_1.default(price.toString()).ln().toFixed(10)))
        .div(toBNWei(1))
        .divn(exports.TICK_SPACINGS[poolFee])
        .div(toBNWei(1))
        .muln(exports.TICK_SPACINGS[poolFee])
        .toString();
}
exports.getTickFromPrice = getTickFromPrice;
function getMinTick(tickSpacing) {
    return Math.ceil(-887272 / tickSpacing) * tickSpacing;
}
exports.getMinTick = getMinTick;
function getMaxTick(tickSpacing) {
    return Math.floor(887272 / tickSpacing) * tickSpacing;
}
exports.getMaxTick = getMaxTick;
function getTickBitmapIndex(tick, tickSpacing) {
    const intermediate = toBN(tick.toString()).div(toBN(tickSpacing.toString()));
    // see https://docs.soliditylang.org/en/v0.7.6/types.html#shifts
    if (intermediate.lt(toBN("0")))
        return intermediate
            .addn(1)
            .div(toBN("2").pow(toBN("8")))
            .subn(1);
    else
        return intermediate.shrn(8);
}
exports.getTickBitmapIndex = getTickBitmapIndex;
function computePoolAddress(factoryAddress, tokenA, tokenB, fee) {
    const POOL_BYTECODE_HASH = ethers_1.ethers.utils.keccak256(UniswapV3Pool_json_1.default.bytecode);
    const [token0, token1] = tokenA.toLowerCase() < tokenB.toLowerCase() ? [tokenA, tokenB] : [tokenB, tokenA];
    const constructorArgumentsEncoded = ethers_1.ethers.utils.defaultAbiCoder.encode(["address", "address", "uint24"], [token0, token1, fee]);
    const create2Inputs = [
        "0xff",
        factoryAddress,
        // salt
        ethers_1.ethers.utils.keccak256(constructorArgumentsEncoded),
        // init code hash
        POOL_BYTECODE_HASH,
    ];
    const sanitizedInputs = `0x${create2Inputs.map((i) => i.slice(2)).join("")}`;
    return ethers_1.ethers.utils.getAddress(`0x${ethers_1.ethers.utils.keccak256(sanitizedInputs).slice(-40)}`);
}
exports.computePoolAddress = computePoolAddress;
exports.FeeAmount = { LOW: 500, MEDIUM: 3000, HIGH: 10000 };
exports.TICK_SPACINGS = { [exports.FeeAmount.LOW]: 10, [exports.FeeAmount.MEDIUM]: 60, [exports.FeeAmount.HIGH]: 200 };
