"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConstructorParamsForContractVersion = exports.runTestForVersion = exports.getContractsNodePackageAliasForVerion = exports.CORE_CONTRACTS_NODE_VERSION_MAPPING = exports.TESTED_CONTRACT_VERSIONS = exports.SUPPORTED_CONTRACT_VERSIONS = void 0;
const web3_1 = __importDefault(require("web3"));
const lodash_1 = __importDefault(require("lodash"));
const assert_1 = __importDefault(require("assert"));
const Constants_1 = require("./Constants");
const { toWei, utf8ToHex, padRight } = web3_1.default.utils;
// Versions that production bots support.
exports.SUPPORTED_CONTRACT_VERSIONS = [
    { contractType: "ExpiringMultiParty", contractVersion: "2.0.1" },
    { contractType: "Perpetual", contractVersion: "2.0.1" },
];
// Versions that unit tests will test against. Note we dont test anything less than 2.0.1 as all older contracts have
// expired on mainnet.
exports.TESTED_CONTRACT_VERSIONS = [
    { contractType: "ExpiringMultiParty", contractVersion: "2.0.1" },
    { contractType: "Perpetual", contractVersion: "2.0.1" },
];
exports.CORE_CONTRACTS_NODE_VERSION_MAPPING = {
    "2.0.1": "0.1.0",
};
// Assumes that the contracts-node package alias is @uma/contracts-node-X-Y-Z.
// Typical workflow is:
// const { getAbi, getBytecode } = require(getContractsNodePackageAliasForVersion(versionString));
function getContractsNodePackageAliasForVerion(version) {
    if (version === "latest")
        return "@uma/contracts-node";
    const isKey = (input) => input in exports.CORE_CONTRACTS_NODE_VERSION_MAPPING;
    if (!isKey(version))
        throw new Error("Unknown version!");
    return `@uma/contracts-node-${exports.CORE_CONTRACTS_NODE_VERSION_MAPPING[version].split(".").join("-")}`;
}
exports.getContractsNodePackageAliasForVerion = getContractsNodePackageAliasForVerion;
/**
 * Used in conjunction with versionedIt within tests, this method will return true if the currentTestIterationVersion
 * is part of the SUPPORTED_CONTRACT_VERSIONS and supportedVersions (or is any), else returns false.
 * @param {Object} supportedVersions array of supported contract types & versions for a given test.
 * @param {Object} SUPPORTED_CONTRACT_VERSIONS array of supported contract types & versions for all tests within a test file.
 * @param {Object} currentTestIterationVersion object containing the current contract type & version for the current test.
 * @returns {bool} true of the current test iteration version is part of & supportedVersions & SUPPORTED_CONTRACT_VERSIONS
 * or any, false otherwise.
 */
function runTestForVersion(supportedVersions, SUPPORTED_CONTRACT_VERSIONS, currentTestIterationVersion) {
    // Validate that the array of supportedVersions provided is in the SUPPORTED_CONTRACT_VERSIONS OR is `any`.
    const supportedVersionOverlap = lodash_1.default.intersectionBy(supportedVersions, [...SUPPORTED_CONTRACT_VERSIONS, { contractType: "any", contractVersion: "any" }], (version) => [version.contractType, version.contractVersion].join(","));
    (0, assert_1.default)(supportedVersionOverlap.length > 0, `Contract version specified in the test is not supported. Specified version${JSON.stringify(supportedVersions)} is not part of ${JSON.stringify(SUPPORTED_CONTRACT_VERSIONS)}`);
    // Check if the current currentTestIterationVersion is part of the supportedVersions for the specific test.
    const testSupportedVersionOverlap = lodash_1.default.intersectionBy(supportedVersions, [currentTestIterationVersion, { contractType: "any", contractVersion: "any" }], (version) => [version.contractType, version.contractVersion].join(","));
    return testSupportedVersionOverlap.length > 0;
}
exports.runTestForVersion = runTestForVersion;
/**
 * Used in unit tests that test multiple smart contract versions at the same time, this method will create constructor
 * parameters in accordance with the contract version and execution context.
 * @param {Object} contractVersion object containing the contractVersion and Type to be used with the constructor params
 * @param {Object} contextObjects object containing nested objects which provide context on the creation of the constructor
 * params. Note each key type defined in the requiredContextObjects must be provided to correctly use this method.
 * @param {Object} overrideConstructorParams optional override for the constructor params generated.
 * @returns {Object} version compatible constructor parameters.
 */
async function createConstructorParamsForContractVersion(contractVersion, contextObjects, overrideConstructorParams = {}) {
    (0, assert_1.default)(contractVersion && contractVersion.contractVersion && contractVersion.contractType, "contractVersion must be provided, containing both a contract version and type");
    const requiredContextObjects = [
        "convertDecimals",
        "finder",
        "collateralToken",
        "syntheticToken",
        "identifier",
        "fundingRateIdentifier",
        "timer",
        "store",
        "configStore",
    ];
    // Check that each of the expected keys is present and not null.
    requiredContextObjects.forEach((expectedKey) => {
        (0, assert_1.default)(contextObjects[expectedKey] && Object.keys(contextObjects).includes(expectedKey), `Provided context object is missing type ${expectedKey} or is undefined`);
    });
    // Note: the ?s and ||s below allow this function to work with web3 or truffle object types.
    const currentTime = (await contextObjects.timer.getCurrentTime?.())?.toNumber() ||
        parseInt(await contextObjects.timer.methods.getCurrentTime().call());
    const constructorParams = {
        expirationTimestamp: currentTime + 100000,
        withdrawalLiveness: "1000",
        collateralAddress: contextObjects.collateralToken.address || contextObjects.collateralToken.options.address,
        tokenAddress: contextObjects.syntheticToken.address || contextObjects.syntheticToken.options.address,
        finderAddress: contextObjects.finder.address || contextObjects.finder.options.address,
        priceFeedIdentifier: padRight(utf8ToHex(contextObjects.identifier), 64),
        liquidationLiveness: "1000",
        collateralRequirement: { rawValue: toWei("1.2") },
        disputeBondPercentage: { rawValue: toWei("0.1") },
        sponsorDisputeRewardPercentage: { rawValue: toWei("0.1") },
        disputerDisputeRewardPercentage: { rawValue: toWei("0.1") },
        minSponsorTokens: { rawValue: contextObjects.convertDecimals("5") },
        timerAddress: contextObjects.timer.address || contextObjects.timer.options.address,
        excessTokenBeneficiary: contextObjects.store.address || contextObjects.store.options.address,
        financialProductLibraryAddress: Constants_1.ZERO_ADDRESS,
    };
    if (contractVersion.contractType == "Perpetual") {
        constructorParams.fundingRateIdentifier = padRight(utf8ToHex(contextObjects.fundingRateIdentifier), 64);
        constructorParams.configStoreAddress =
            contextObjects.configStore.address || contextObjects.configStore.options.address;
        constructorParams.tokenScaling = { rawValue: toWei("1") };
    }
    return { ...constructorParams, ...overrideConstructorParams };
}
exports.createConstructorParamsForContractVersion = createConstructorParamsForContractVersion;
