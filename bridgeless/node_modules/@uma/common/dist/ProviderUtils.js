"use strict";
// This client exports a web3 instance which mimics that created by the default Truffle config. It exclusively uses
// web3 providers to take advantage of the flexibility of providing custom configs to tailor the desired options. The network
// syntax mimics that of the main UMA Truffle implementation to make this backwards compatible.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWeb3 = exports.getRetryWeb3sByChainId = exports.getWeb3ByChainId = exports.getMnemonic = exports.createBasicProvider = exports.getNodeUrl = void 0;
const web3_1 = __importDefault(require("web3"));
const minimist_1 = __importDefault(require("minimist"));
const url_1 = __importDefault(require("url"));
const RetryProvider_1 = require("./RetryProvider");
const hdwallet_provider_1 = __importDefault(require("@truffle/hdwallet-provider"));
const ManagedSecretProvider_1 = require("./gckms/ManagedSecretProvider");
const GckmsConfig_1 = require("./gckms/GckmsConfig");
const PublicNetworks_1 = require("./PublicNetworks");
const assert_1 = __importDefault(require("assert"));
const argv = (0, minimist_1.default)(process.argv.slice(), { string: ["network"] });
// NODE_RETRY_CONFIG should be a JSON of the form (retries and delay are optional, they default to 1 and 0 respectively):
// [
//    {
//      retries: 3,
//      delay: 1
//      url: https://mainnet.infura.io/v3/ACCOUNT_ID,
//    },
//    {
//      retries: 5,
//      delay: 1,
//      url: ws://99.999.99.99
//    }
// ]
const { NODE_RETRY_CONFIG } = process.env;
// Set web3 to null
let web3 = null;
function getNodeUrl(networkName, useHttps = false, chainId = null) {
    if ((0, PublicNetworks_1.isPublicNetwork)(networkName) && !networkName.includes("fork")) {
        const infuraApiKey = process.env.INFURA_API_KEY || "e34138b2db5b496ab5cc52319d2f0299";
        const name = networkName.split("_")[0];
        const chainSpecificUrl = chainId !== null ? process.env[`NODE_URL_${chainId}`] : null;
        const overrideUrl = chainSpecificUrl || process.env.CUSTOM_NODE_URL;
        // Note: Neither Boba nor xDai currently has no infura support.
        if (name === "boba")
            return overrideUrl || "https://mainnet.boba.network/";
        if (name === "xdai")
            return overrideUrl || "https://rpc.xdaichain.com/";
        if (name === "sx")
            return overrideUrl || "https://rpc.sx.technology";
        if (name === "avalanche")
            return overrideUrl || "https://api.avax.network/ext/bc/C/rpc";
        if (name === "evmos")
            return overrideUrl || "https://evmos-json-rpc.stakely.io";
        if (name === "meter")
            return overrideUrl || "https://rpc.meter.io";
        if (name === "base-goerli")
            return overrideUrl || "https://goerli.base.org";
        return (overrideUrl ||
            (useHttps ? `https://${name}.infura.io/v3/${infuraApiKey}` : `wss://${name}.infura.io/ws/v3/${infuraApiKey}`));
    }
    const port = process.env.CUSTOM_LOCAL_NODE_PORT || "9545";
    return `http://127.0.0.1:${port}`;
}
exports.getNodeUrl = getNodeUrl;
function createBasicProvider(nodeRetryConfig) {
    return new RetryProvider_1.RetryProvider(nodeRetryConfig.map((configElement) => {
        const protocol = url_1.default.parse(configElement.url).protocol;
        if (protocol === null)
            throw new Error(`No protocol detected for url: ${configElement.url}`);
        let options = {
            timeout: 10000, // 10 second timeout
        };
        if (protocol.startsWith("ws")) {
            // Websocket
            options = {
                ...options,
                clientConfig: {
                    maxReceivedFrameSize: 100000000,
                    maxReceivedMessageSize: 100000000, // bytes - default: 8MiB
                },
                reconnect: {
                    auto: true,
                    delay: 5000,
                    maxAttempts: 10,
                    onTimeout: false,
                },
            };
        }
        return { ...configElement, options };
    }));
}
exports.createBasicProvider = createBasicProvider;
const KEY_TYPES = ["gckms", "mnemonic", "none"];
function isKeyType(input) {
    return KEY_TYPES.some((keyType) => keyType === input);
}
function getDefaultKeyType(network) {
    if (network) {
        const networkSplit = network.split("_");
        const keyType = networkSplit[networkSplit.length - 1];
        if (isKeyType(keyType)) {
            return keyType;
        }
    }
    return "none";
}
function getMnemonic() {
    return process.env.MNEMONIC || "candy maple cake sugar pudding cream honey rich smooth crumble sweet treat";
}
exports.getMnemonic = getMnemonic;
function addMnemonicToProvider(provider, mnemonic = getMnemonic(), numKeys = parseInt(process.env.NUM_KEYS || "2"), keyOffset = process.env.KEY_OFFSET ? parseInt(process.env.KEY_OFFSET) : 0) {
    return new hdwallet_provider_1.default(mnemonic, provider, keyOffset, numKeys);
}
function addGckmsToProvider(provider) {
    const gckmsConfig = (0, GckmsConfig_1.getGckmsConfig)();
    return new ManagedSecretProvider_1.ManagedSecretProvider(gckmsConfig, provider, 0, gckmsConfig.length);
}
function addDefaultKeysToProvider(provider, network = argv.network) {
    switch (getDefaultKeyType(network)) {
        case "gckms":
            return addGckmsToProvider(provider);
        case "mnemonic":
            return addMnemonicToProvider(provider);
        case "none":
        default:
            return provider;
    }
}
/**
 * @notice Creates a web3 instance for a particular chain.
 * @param chainId the chain id for the network the user wants to connect to.
 * @returns new Web3 instance.
 */
function getWeb3ByChainId(chainId) {
    const retryConfigJson = process.env[`RETRY_CONFIG_${chainId}`];
    const nodeUrl = process.env[`NODE_URL_${chainId}`];
    let retryConfig;
    if (retryConfigJson)
        retryConfig = JSON.parse(retryConfigJson);
    else {
        (0, assert_1.default)(nodeUrl, `NODE_URL_${chainId} or RETRY_CONFIG_${chainId} must be provided!`);
        // Special case: if the user supplies a node url of "test", just return the global web3 object.
        if (nodeUrl === "test")
            return global.web3;
        retryConfig = [{ url: nodeUrl, retries: 2, delay: 1 }];
    }
    const keylessProvider = createBasicProvider(retryConfig);
    const keyedProvider = addDefaultKeysToProvider(keylessProvider);
    return new web3_1.default(keyedProvider);
}
exports.getWeb3ByChainId = getWeb3ByChainId;
/**
 * @notice Creates array of web3 instances for a particular chain.
 * @dev Providers to use are described in RETRY_CONFIG_{chainId} dictionary under the "url" key.
 * @param chainId the chain id for the network the user wants to connect to.
 * @returns array of new readonly Web3 instances.
 */
function getRetryWeb3sByChainId(chainId) {
    const retryConfigJson = process.env[`RETRY_CONFIG_${chainId}`] || "[]";
    const retryConfig = JSON.parse(retryConfigJson);
    if (retryConfig.length === 0) {
        const providerUrl = process.env[`NODE_URL_${chainId}`];
        if (!providerUrl)
            throw new Error(`No providers found for chain id ${chainId}`);
        return [new web3_1.default(providerUrl)];
    }
    return retryConfig.map((config) => new web3_1.default(createBasicProvider([config])));
}
exports.getRetryWeb3sByChainId = getRetryWeb3sByChainId;
/**
 * @notice Gets a web3 instance based on the network argument using the truffle config in this package.
 * Use this for compatibility for running with or without truffle.
 * @example
 *  If a node app uses getWeb3() and you want to load network 1 with a default wallet For full list of potential network
 * names see common/src/TruffleConfig node app --network=mainnet_mnemonic
 *
 * @notice You can also specify environment variables INFURA_API_KEY, CUSTOM_NODE_URL and CUSTOM_LOCAL_NODE_PORT.
 * If not provided there are defaults which load a hardcoded infura key. Default port is 9545.
 *
 * @notice a parameterizedNetwork name can also be provided. This enables you to use the library without needing to define
 * a `--network` argument. Useful in serverless or when running node scripts.
 *
 */
function getWeb3(parameterizedNetwork = "test") {
    const castedGlobal = global;
    if (castedGlobal.web3)
        return castedGlobal.web3;
    // If a web3 instance has already been initialized, return it.
    if (web3)
        return web3;
    // Create basic web3 provider with no wallet connection based on the url alone.
    const network = argv.network || parameterizedNetwork; // Default to the test network (local network).
    const nodeRetryConfig = NODE_RETRY_CONFIG
        ? JSON.parse(NODE_RETRY_CONFIG)
        : [{ url: getNodeUrl(network), retries: 0 }];
    const basicProvider = createBasicProvider(nodeRetryConfig);
    const providerWithWallet = addDefaultKeysToProvider(basicProvider, network);
    // Lastly, create a web3 instance with the wallet-based provider. This can be used to query the chain via the
    // a basic web3 provider & has access to the users wallet based on the kind of connection they created.
    web3 = new web3_1.default(providerWithWallet);
    return web3;
}
exports.getWeb3 = getWeb3;
