import winston from "winston";
import type Web3 from "web3";
import type { TransactionReceipt, PromiEvent } from "web3-core";
import type { ContractSendMethod } from "web3-eth-contract";
type CallReturnValue = ReturnType<ContractSendMethod["call"]>;
export interface AugmentedSendOptions {
    from: string;
    gas?: number;
    value?: number | string;
    nonce?: number;
    chainId?: string;
    type?: string;
    usingOffSetDSProxyAccount?: boolean;
    gasPrice?: number | string;
    maxFeePerGas?: number | string;
    maxPriorityFeePerGas?: number | string;
}
export interface ExecutedTransaction {
    receipt: TransactionReceipt | PromiEvent<TransactionReceipt>;
    transactionHash: string;
    returnValue: CallReturnValue;
    transactionConfig: AugmentedSendOptions;
}
/**
 * Simulate transaction via .call() and then .send() and return receipt. If an error is thrown, return the error and add
 * a flag denoting whether it was sent on the .call() or the .send(). Enables multiple EOAs to be used when sending the
 * transaction, cycling if a lower EOA index has a pending transaction.
 * @notice Uses the ynatm package to retry the transaction with increasing gas price.
 * @param {*Object} web3.js object for making queries and accessing Ethereum related methods.
 * @param {*Object} transaction Transaction to call `.call()` and subsequently `.send()` on from `senderAccount`.
 * @param {*Object} transactionConfig config, e.g. { maxFeePerGas, maxPriorityFeePerGas, from } or { gasPrice, from}
 *     depending if this is a london or pre-london transaction, passed to transaction.
 * @param availableAccounts {number} defines how many EOAs the transaction runner has access too. If the 0th account
 * has a pending tx then the runner will automatically send the transaction from the next EOA.
 * @param waitForMine {Boolean} informs if the transaction runner should wait until the tx is mined or return early once
 * it has a transaction hash. Useful when sending many transactions in quick succession.
 * @return Error and type of error (originating from `.call()` or `.send()`) or transaction receipt, return value and
 * transaction config. Note that the transaction receipt will be a promise if waitForMine is false.
 */
export declare const runTransaction: ({ web3: _web3, transaction, transactionConfig, availableAccounts, waitForMine, }: {
    web3: Web3;
    transaction: ContractSendMethod;
    transactionConfig: AugmentedSendOptions;
    availableAccounts?: number | undefined;
    waitForMine?: boolean | undefined;
}) => Promise<ExecutedTransaction>;
/**
 * Checks if an account has a pending transaction.
 * @param {*Object} web3.js object for making queries and accessing Ethereum related methods.
 * @param {*string} account account to check.
 * @return Bool true if the account has pending transaction and false if no pending transaction.
 */
export declare const accountHasPendingTransactions: (web3: Web3, account: string) => Promise<boolean>;
/**
 * Returns the number of pending transaction an account has. This method uses `provider.send` syntax. This undocumented
 * web3 method lets you call direct jsonrpc methods on the provider. This method differs from the web3.js getTransactionCount
 * by including mempool transactions. see https://infura.io/docs/ethereum/json-rpc/eth-getTransactionCount
 * @param {*Object} web3.js object for making queries and accessing Ethereum related methods.
 * @param {*string} account account to check.
 * @returns number representing the number of transactions, including pending.
 */
export declare const getPendingTransactionCount: (web3: Web3, account: string) => Promise<number>;
/**
 * Blocking code until a specific block number is mined. Will re-fetch the current block number every 500ms. Useful when
 * using methods called on contracts directly after state changes. Max blocking time should be ~ 15 seconds.
 * @param {Object} web3 Provider from Truffle/node to connect to Ethereum network.
 * @param {number} blockerBlockNumber block execution until this block number is mined.
 */
export declare const blockUntilBlockMined: (web3: Web3, blockerBlockNumber: number, delay?: number) => Promise<void>;
/**
 * @notice Finds block closest to target timestamp. User can configure search based on error tolerance.
 * @param web3 Web3 network to search blocks on.
 * @param targetTimestamp Timestamp that we are finding a block for.
 * @param higherLimitMax Returned block must have timestamp less than targetTimestamp + higherLimitMax. Increasing this
 * increases error and reduces time to compute.
 * @param lowerLimitMax Returned block must have timestamp more than targetTimestamp - lowerLimitMax. Increasing this
 * increases error and reduces time to compute.
 * @param blockDelta Amount of blocks to hop when binary searching for block. Increasing this increases error
 * but significantly reduces time to compute.
 * @param averageBlockTime Decreasing average block size will decrease precision and also decrease the amount of
 * requests made in order to find the closest block. Increasing this reduces time to compute but increases requests.
 * @returns {number, number} Block height and difference between block timestamp and target timestamp
 */
export declare function findBlockNumberAtTimestamp(web3: Web3, targetTimestamp: number, higherLimitMax?: number, lowerLimitMax?: number, blockDelta?: number, averageBlockTime?: number): Promise<{
    blockNumber: number;
    error: number;
}>;
/**
 * @notice Consumes an array of transactions with embedded promises produced by iteratively calling runTransaction.
 * Waits on all transactions to settle within the batch (included in a block). If any transaction contains an error then
 * produce a log to that effect. This method is intended to be called at the end of a bot run cycle to ensure that all
 * transactions that were submitted were indeed included without error. Note that runTransaction will not submit a
 * transaction if the function can detect it will revert (i.e using the .call syntax). Therefore this function will only
 * catch reverts that could not be seen at submission time.
 */
export declare function processTransactionPromiseBatch(transactions: Array<ExecutedTransaction>, logger: winston.Logger): Promise<void>;
export {};
