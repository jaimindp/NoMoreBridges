"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManagedSecretProvider = void 0;
const hdwallet_provider_1 = __importDefault(require("@truffle/hdwallet-provider"));
const utils_1 = require("./utils");
// Wraps HDWalletProvider, deferring construction and allowing a Cloud KMS managed secret to be fetched asynchronously
// and used to initialize an HDWalletProvider.
class ManagedSecretProvider {
    constructor(cloudKmsSecretConfigs, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    providerOrUrl, // Mirrors the type that HDWalletProvider expects.
    ...remainingArgs) {
        this.cloudKmsSecretConfigs = cloudKmsSecretConfigs;
        this.providerOrUrl = providerOrUrl;
        if (!Array.isArray(cloudKmsSecretConfigs)) {
            cloudKmsSecretConfigs = [cloudKmsSecretConfigs];
        }
        this.remainingArgs = remainingArgs;
        this.wrappedProvider = null;
        this.wrappedProviderPromise = this.getOrConstructWrappedProvider();
    }
    // Passes the call through, by attaching a callback to the wrapper provider promise.
    sendAsync(...all) {
        this.wrappedProviderPromise.then((wrappedProvider) => {
            wrappedProvider.sendAsync(...all);
        });
    }
    // Passes the call through. Requires that the wrapped provider has been created via, e.g., `constructWrappedProvider`.
    send(...all) {
        this.wrappedProviderPromise.then((wrappedProvider) => {
            wrappedProvider.send(...all);
        });
    }
    // Passes the call through. Requires that the wrapped provider has been created via, e.g., `constructWrappedProvider`.
    getAddress(...all) {
        return this.getWrappedProviderOrThrow().getAddress(...all);
    }
    // Returns the underlying wrapped provider.
    getWrappedProviderOrThrow() {
        if (this.wrappedProvider) {
            return this.wrappedProvider;
        }
        else {
            throw new Error("Must init provider first, can't get value synchronously");
        }
    }
    // Returns a Promise that resolves to the wrapped provider.
    async getOrConstructWrappedProvider() {
        if (this.wrappedProvider) {
            return this.wrappedProvider;
        }
        const keys = await (0, utils_1.retrieveGckmsKeys)(this.cloudKmsSecretConfigs);
        this.wrappedProvider = new hdwallet_provider_1.default(keys, this.providerOrUrl, ...this.remainingArgs);
        return this.wrappedProvider;
    }
}
exports.ManagedSecretProvider = ManagedSecretProvider;
