"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceAddressCase = exports.ConvertDecimals = exports.addSign = exports.createEtherscanLinkMarkdown = exports.createShortHexString = exports.createEtherscanLinkFromtx = exports.createFormatFunction = exports.formatWithMaxDecimals = exports.formatWei = exports.formatHours = exports.formatDate = exports.formatDateShort = exports.parseFixed = exports.formatFixed = void 0;
const PublicNetworks_1 = require("./PublicNetworks");
const web3_1 = __importDefault(require("web3"));
const { toChecksumAddress, fromWei, toBN } = web3_1.default.utils;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const moment_1 = __importDefault(require("moment"));
const assert_1 = __importDefault(require("assert"));
var bignumber_1 = require("@ethersproject/bignumber");
Object.defineProperty(exports, "formatFixed", { enumerable: true, get: function () { return bignumber_1.formatFixed; } });
Object.defineProperty(exports, "parseFixed", { enumerable: true, get: function () { return bignumber_1.parseFixed; } });
// Apply settings to BigNumber.js library.
// Note: ROUNDING_MODE is set to round ceiling so we send at least enough collateral to create the requested tokens.
// Note: RANGE is set to 500 so values don't overflow to infinity until they hit +-1e500.
// Note: EXPONENTIAL_AT is set to 500 to keep BigNumber from using exponential notation until the numbers hit
// +-1e500.
bignumber_js_1.default.set({ ROUNDING_MODE: 2, RANGE: 500, EXPONENTIAL_AT: 500 });
// Given a timestamp in seconds, returns the date in the format: "MM/DD/YYYY"
const formatDateShort = (timestampInSeconds) => {
    const date = moment_1.default.unix(Math.floor(timestampInSeconds));
    return date.format("MM/DD/YYYY");
};
exports.formatDateShort = formatDateShort;
const formatDate = (timestampInSeconds) => {
    return new Date(Math.floor(timestampInSeconds * 1000)).toString();
};
exports.formatDate = formatDate;
const formatHours = (seconds, decimals = 2) => {
    // 3600 seconds in an hour.
    return (seconds / 3600).toFixed(decimals);
};
exports.formatHours = formatHours;
// formatWei converts a string or BN instance from Wei to Ether, e.g., 1e19 -> 10.
const formatWei = (num) => {
    // Web3's `fromWei` function doesn't work on BN objects in minified mode (e.g.,
    // `web3.utils.isBN(web3.utils.fromBN("5"))` is false), so we use a workaround where we always pass in strings.
    // See https://github.com/ethereum/web3.js/issues/1777.
    return fromWei(num.toString());
};
exports.formatWei = formatWei;
// Formats the input to round to decimalPlaces number of decimals if the number has a magnitude larger than 1 and fixes
// precision to minPrecision if the number has a magnitude less than 1.
const formatWithMaxDecimals = (num, decimalPlaces, minPrecision, roundUp, showSign) => {
    if (roundUp) {
        bignumber_js_1.default.set({ ROUNDING_MODE: bignumber_js_1.default.ROUND_UP });
    }
    else {
        bignumber_js_1.default.set({ ROUNDING_MODE: bignumber_js_1.default.ROUND_DOWN });
    }
    const fullPrecisionFloat = new bignumber_js_1.default(num);
    const positiveSign = showSign && fullPrecisionFloat.gt(0) ? "+" : "";
    let fixedPrecisionFloat;
    // Convert back to BN to truncate any trailing 0s that the toFixed() output would print. If the number is equal to or larger than
    // 1 then truncate to `decimalPlaces` number of decimal places. EG 999.999 -> 999.99 with decimalPlaces=2 If the number
    // is less than 1 then truncate to minPrecision precision. EG: 0.0022183471 -> 0.002218 with minPrecision=4
    if (fullPrecisionFloat.abs().gte(new bignumber_js_1.default(1))) {
        fixedPrecisionFloat = new bignumber_js_1.default(fullPrecisionFloat).toFixed(decimalPlaces).toString();
    }
    else {
        fixedPrecisionFloat = new bignumber_js_1.default(fullPrecisionFloat).toPrecision(minPrecision).toString();
    }
    // This puts commas in the thousands places, but only before the decimal point.
    const fixedPrecisionFloatParts = fixedPrecisionFloat.split(".");
    fixedPrecisionFloatParts[0] = fixedPrecisionFloatParts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    return positiveSign + fixedPrecisionFloatParts.join(".");
};
exports.formatWithMaxDecimals = formatWithMaxDecimals;
const createFormatFunction = (numDisplayedDecimals, minDisplayedPrecision, showSign = false, decimals = 18) => {
    return (valInWei) => (0, exports.formatWithMaxDecimals)((0, exports.formatWei)((0, exports.ConvertDecimals)(decimals, 18)(valInWei)), numDisplayedDecimals, minDisplayedPrecision, false, showSign);
};
exports.createFormatFunction = createFormatFunction;
// Generate an etherscan link prefix. If a networkId is provided then the URL will point to this network. Else, assume mainnet.
function createEtherscanLinkFromtx(networkId) {
    // Construct etherscan link based on network
    let url;
    if (PublicNetworks_1.PublicNetworks[networkId]) {
        url = `${PublicNetworks_1.PublicNetworks[networkId].etherscan}`;
    }
    else {
        // Default to mainnet, even though it won't work for ganache runs.
        url = "https://etherscan.io/";
    }
    return url;
}
exports.createEtherscanLinkFromtx = createEtherscanLinkFromtx;
// Convert either an address or transaction to a shorter version.
// 0x772871a444c6e4e9903d8533a5a13101b74037158123e6709470f0afbf6e7d94 -> 0x7787...7d94
function createShortHexString(hex) {
    return hex.substring(0, 5) + "..." + hex.substring(hex.length - 6, hex.length);
}
exports.createShortHexString = createShortHexString;
// Take in either a transaction or an account and generate an etherscan link for the corresponding
// network formatted in markdown.
function createEtherscanLinkMarkdown(hex, networkId = 1) {
    if (hex.substring(0, 2) != "0x")
        return null;
    const shortURLString = createShortHexString(hex);
    // Transaction hash
    if (hex.length == 66)
        return `<${createEtherscanLinkFromtx(networkId)}tx/${hex}|${shortURLString}>`;
    // Account
    else if (hex.length == 42)
        return `<${createEtherscanLinkFromtx(networkId)}address/${hex}|${shortURLString}>`;
    return null;
}
exports.createEtherscanLinkMarkdown = createEtherscanLinkMarkdown;
function addSign(number) {
    if (Number(number) > 0) {
        return `+${number}`;
    }
    else {
        // Number strings already print the '-' sign for negative numbers.
        return `${number}`;
    }
}
exports.addSign = addSign;
// Take an amount based on fromDecimals and convert it to an amount based on toDecimals. For example 100 usdt = 100e6,
// with 6 decimals. If you wanted to convert this to a base 18 decimals you would get:
// convertDecimals(6,18)(100000000)  => 100000000000000000000 = 100e18.
// Returns a BigNumber you will need to call toString on
// fromDecimals: number - decimal value of amount
// toDecimals: number - decimal value to convert to
// web3: web3 object to get a big number function.
// return => (amount:string)=>BN
const ConvertDecimals = (fromDecimals, toDecimals) => {
    (0, assert_1.default)(fromDecimals >= 0, "requires fromDecimals as an integer >= 0");
    (0, assert_1.default)(toDecimals >= 0, "requires toDecimals as an integer >= 0");
    // amount: string, BN, number - integer amount in fromDecimals smallest unit that want to convert toDecimals
    // returns: BN with toDecimals in smallest unit
    return (amountIn) => {
        const amount = toBN(amountIn.toString());
        if (amount.isZero())
            return amount;
        const diff = fromDecimals - toDecimals;
        if (diff == 0)
            return amount;
        if (diff > 0)
            return amount.div(toBN("10").pow(toBN(diff.toString())));
        return amount.mul(toBN("10").pow(toBN((-1 * diff).toString())));
    };
};
exports.ConvertDecimals = ConvertDecimals;
// Takes in an object of any structure and returns the exact same object with all addresses converted to check sum format.
const replaceAddressCase = (object) => {
    const stringifiedObject = JSON.stringify(object);
    const replacedStringifiedObject = stringifiedObject.replace(/0x[a-fA-F0-9]{40}/g, toChecksumAddress);
    return JSON.parse(replacedStringifiedObject);
};
exports.replaceAddressCase = replaceAddressCase;
